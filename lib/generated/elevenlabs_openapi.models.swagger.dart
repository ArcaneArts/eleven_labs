// ignore_for_file: type=lint

import 'package:json_annotation/json_annotation.dart';
import 'package:collection/collection.dart';
import 'dart:convert';

import 'elevenlabs_openapi.enums.swagger.dart' as enums;

part 'elevenlabs_openapi.models.swagger.g.dart';

@JsonSerializable(explicitToJson: true)
class ASRConversationalConfig {
  const ASRConversationalConfig({
    this.quality,
    this.provider,
    this.userInputAudioFormat,
    this.keywords,
  });

  factory ASRConversationalConfig.fromJson(Map<String, dynamic> json) =>
      _$ASRConversationalConfigFromJson(json);

  static const toJsonFactory = _$ASRConversationalConfigToJson;
  Map<String, dynamic> toJson() => _$ASRConversationalConfigToJson(this);

  @JsonKey(
    name: 'quality',
    toJson: aSRQualityNullableToJson,
    fromJson: aSRQualityQualityNullableFromJson,
  )
  final enums.ASRQuality? quality;
  static enums.ASRQuality? aSRQualityQualityNullableFromJson(Object? value) =>
      aSRQualityNullableFromJson(value, enums.ASRQuality.high);

  @JsonKey(
    name: 'provider',
    toJson: aSRProviderNullableToJson,
    fromJson: aSRProviderProviderNullableFromJson,
  )
  final enums.ASRProvider? provider;
  static enums.ASRProvider? aSRProviderProviderNullableFromJson(
          Object? value) =>
      aSRProviderNullableFromJson(value, enums.ASRProvider.elevenlabs);

  @JsonKey(
    name: 'user_input_audio_format',
    toJson: aSRInputFormatNullableToJson,
    fromJson: aSRInputFormatUserInputAudioFormatNullableFromJson,
  )
  final enums.ASRInputFormat? userInputAudioFormat;
  static enums.ASRInputFormat?
      aSRInputFormatUserInputAudioFormatNullableFromJson(Object? value) =>
          aSRInputFormatNullableFromJson(value, enums.ASRInputFormat.pcm16000);

  @JsonKey(name: 'keywords', defaultValue: <String>[])
  final List<String>? keywords;
  static const fromJsonFactory = _$ASRConversationalConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ASRConversationalConfig &&
            (identical(other.quality, quality) ||
                const DeepCollectionEquality()
                    .equals(other.quality, quality)) &&
            (identical(other.provider, provider) ||
                const DeepCollectionEquality()
                    .equals(other.provider, provider)) &&
            (identical(other.userInputAudioFormat, userInputAudioFormat) ||
                const DeepCollectionEquality().equals(
                    other.userInputAudioFormat, userInputAudioFormat)) &&
            (identical(other.keywords, keywords) ||
                const DeepCollectionEquality()
                    .equals(other.keywords, keywords)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(quality) ^
      const DeepCollectionEquality().hash(provider) ^
      const DeepCollectionEquality().hash(userInputAudioFormat) ^
      const DeepCollectionEquality().hash(keywords) ^
      runtimeType.hashCode;
}

extension $ASRConversationalConfigExtension on ASRConversationalConfig {
  ASRConversationalConfig copyWith(
      {enums.ASRQuality? quality,
      enums.ASRProvider? provider,
      enums.ASRInputFormat? userInputAudioFormat,
      List<String>? keywords}) {
    return ASRConversationalConfig(
        quality: quality ?? this.quality,
        provider: provider ?? this.provider,
        userInputAudioFormat: userInputAudioFormat ?? this.userInputAudioFormat,
        keywords: keywords ?? this.keywords);
  }

  ASRConversationalConfig copyWithWrapped(
      {Wrapped<enums.ASRQuality?>? quality,
      Wrapped<enums.ASRProvider?>? provider,
      Wrapped<enums.ASRInputFormat?>? userInputAudioFormat,
      Wrapped<List<String>?>? keywords}) {
    return ASRConversationalConfig(
        quality: (quality != null ? quality.value : this.quality),
        provider: (provider != null ? provider.value : this.provider),
        userInputAudioFormat: (userInputAudioFormat != null
            ? userInputAudioFormat.value
            : this.userInputAudioFormat),
        keywords: (keywords != null ? keywords.value : this.keywords));
  }
}

@JsonSerializable(explicitToJson: true)
class AddChapterResponseModel {
  const AddChapterResponseModel({
    required this.chapter,
  });

  factory AddChapterResponseModel.fromJson(Map<String, dynamic> json) =>
      _$AddChapterResponseModelFromJson(json);

  static const toJsonFactory = _$AddChapterResponseModelToJson;
  Map<String, dynamic> toJson() => _$AddChapterResponseModelToJson(this);

  @JsonKey(name: 'chapter')
  final ChapterWithContentResponseModel chapter;
  static const fromJsonFactory = _$AddChapterResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AddChapterResponseModel &&
            (identical(other.chapter, chapter) ||
                const DeepCollectionEquality().equals(other.chapter, chapter)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(chapter) ^ runtimeType.hashCode;
}

extension $AddChapterResponseModelExtension on AddChapterResponseModel {
  AddChapterResponseModel copyWith({ChapterWithContentResponseModel? chapter}) {
    return AddChapterResponseModel(chapter: chapter ?? this.chapter);
  }

  AddChapterResponseModel copyWithWrapped(
      {Wrapped<ChapterWithContentResponseModel>? chapter}) {
    return AddChapterResponseModel(
        chapter: (chapter != null ? chapter.value : this.chapter));
  }
}

@JsonSerializable(explicitToJson: true)
class AddKnowledgeBaseResponseModel {
  const AddKnowledgeBaseResponseModel({
    required this.id,
    required this.name,
    required this.promptInjectable,
  });

  factory AddKnowledgeBaseResponseModel.fromJson(Map<String, dynamic> json) =>
      _$AddKnowledgeBaseResponseModelFromJson(json);

  static const toJsonFactory = _$AddKnowledgeBaseResponseModelToJson;
  Map<String, dynamic> toJson() => _$AddKnowledgeBaseResponseModelToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'prompt_injectable')
  final bool promptInjectable;
  static const fromJsonFactory = _$AddKnowledgeBaseResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AddKnowledgeBaseResponseModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.promptInjectable, promptInjectable) ||
                const DeepCollectionEquality()
                    .equals(other.promptInjectable, promptInjectable)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(promptInjectable) ^
      runtimeType.hashCode;
}

extension $AddKnowledgeBaseResponseModelExtension
    on AddKnowledgeBaseResponseModel {
  AddKnowledgeBaseResponseModel copyWith(
      {String? id, String? name, bool? promptInjectable}) {
    return AddKnowledgeBaseResponseModel(
        id: id ?? this.id,
        name: name ?? this.name,
        promptInjectable: promptInjectable ?? this.promptInjectable);
  }

  AddKnowledgeBaseResponseModel copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? name,
      Wrapped<bool>? promptInjectable}) {
    return AddKnowledgeBaseResponseModel(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        promptInjectable: (promptInjectable != null
            ? promptInjectable.value
            : this.promptInjectable));
  }
}

@JsonSerializable(explicitToJson: true)
class AddProjectResponseModel {
  const AddProjectResponseModel({
    required this.project,
  });

  factory AddProjectResponseModel.fromJson(Map<String, dynamic> json) =>
      _$AddProjectResponseModelFromJson(json);

  static const toJsonFactory = _$AddProjectResponseModelToJson;
  Map<String, dynamic> toJson() => _$AddProjectResponseModelToJson(this);

  @JsonKey(name: 'project')
  final ProjectResponseModel project;
  static const fromJsonFactory = _$AddProjectResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AddProjectResponseModel &&
            (identical(other.project, project) ||
                const DeepCollectionEquality().equals(other.project, project)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(project) ^ runtimeType.hashCode;
}

extension $AddProjectResponseModelExtension on AddProjectResponseModel {
  AddProjectResponseModel copyWith({ProjectResponseModel? project}) {
    return AddProjectResponseModel(project: project ?? this.project);
  }

  AddProjectResponseModel copyWithWrapped(
      {Wrapped<ProjectResponseModel>? project}) {
    return AddProjectResponseModel(
        project: (project != null ? project.value : this.project));
  }
}

@JsonSerializable(explicitToJson: true)
class AddPronunciationDictionaryResponseModel {
  const AddPronunciationDictionaryResponseModel({
    required this.id,
    required this.name,
    required this.createdBy,
    required this.creationTimeUnix,
    required this.versionId,
    required this.versionRulesNum,
    this.description,
    required this.permissionOnResource,
  });

  factory AddPronunciationDictionaryResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$AddPronunciationDictionaryResponseModelFromJson(json);

  static const toJsonFactory = _$AddPronunciationDictionaryResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$AddPronunciationDictionaryResponseModelToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'created_by')
  final String createdBy;
  @JsonKey(name: 'creation_time_unix')
  final int creationTimeUnix;
  @JsonKey(name: 'version_id')
  final String versionId;
  @JsonKey(name: 'version_rules_num')
  final int versionRulesNum;
  @JsonKey(name: 'description')
  final dynamic description;
  @JsonKey(name: 'permission_on_resource')
  final dynamic permissionOnResource;
  static const fromJsonFactory =
      _$AddPronunciationDictionaryResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AddPronunciationDictionaryResponseModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.creationTimeUnix, creationTimeUnix) ||
                const DeepCollectionEquality()
                    .equals(other.creationTimeUnix, creationTimeUnix)) &&
            (identical(other.versionId, versionId) ||
                const DeepCollectionEquality()
                    .equals(other.versionId, versionId)) &&
            (identical(other.versionRulesNum, versionRulesNum) ||
                const DeepCollectionEquality()
                    .equals(other.versionRulesNum, versionRulesNum)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.permissionOnResource, permissionOnResource) ||
                const DeepCollectionEquality()
                    .equals(other.permissionOnResource, permissionOnResource)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(creationTimeUnix) ^
      const DeepCollectionEquality().hash(versionId) ^
      const DeepCollectionEquality().hash(versionRulesNum) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(permissionOnResource) ^
      runtimeType.hashCode;
}

extension $AddPronunciationDictionaryResponseModelExtension
    on AddPronunciationDictionaryResponseModel {
  AddPronunciationDictionaryResponseModel copyWith(
      {String? id,
      String? name,
      String? createdBy,
      int? creationTimeUnix,
      String? versionId,
      int? versionRulesNum,
      dynamic description,
      dynamic permissionOnResource}) {
    return AddPronunciationDictionaryResponseModel(
        id: id ?? this.id,
        name: name ?? this.name,
        createdBy: createdBy ?? this.createdBy,
        creationTimeUnix: creationTimeUnix ?? this.creationTimeUnix,
        versionId: versionId ?? this.versionId,
        versionRulesNum: versionRulesNum ?? this.versionRulesNum,
        description: description ?? this.description,
        permissionOnResource:
            permissionOnResource ?? this.permissionOnResource);
  }

  AddPronunciationDictionaryResponseModel copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? name,
      Wrapped<String>? createdBy,
      Wrapped<int>? creationTimeUnix,
      Wrapped<String>? versionId,
      Wrapped<int>? versionRulesNum,
      Wrapped<dynamic>? description,
      Wrapped<dynamic>? permissionOnResource}) {
    return AddPronunciationDictionaryResponseModel(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        creationTimeUnix: (creationTimeUnix != null
            ? creationTimeUnix.value
            : this.creationTimeUnix),
        versionId: (versionId != null ? versionId.value : this.versionId),
        versionRulesNum: (versionRulesNum != null
            ? versionRulesNum.value
            : this.versionRulesNum),
        description:
            (description != null ? description.value : this.description),
        permissionOnResource: (permissionOnResource != null
            ? permissionOnResource.value
            : this.permissionOnResource));
  }
}

@JsonSerializable(explicitToJson: true)
class AddVoiceIVCResponseModel {
  const AddVoiceIVCResponseModel({
    required this.voiceId,
    required this.requiresVerification,
  });

  factory AddVoiceIVCResponseModel.fromJson(Map<String, dynamic> json) =>
      _$AddVoiceIVCResponseModelFromJson(json);

  static const toJsonFactory = _$AddVoiceIVCResponseModelToJson;
  Map<String, dynamic> toJson() => _$AddVoiceIVCResponseModelToJson(this);

  @JsonKey(name: 'voice_id')
  final String voiceId;
  @JsonKey(name: 'requires_verification')
  final bool requiresVerification;
  static const fromJsonFactory = _$AddVoiceIVCResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AddVoiceIVCResponseModel &&
            (identical(other.voiceId, voiceId) ||
                const DeepCollectionEquality()
                    .equals(other.voiceId, voiceId)) &&
            (identical(other.requiresVerification, requiresVerification) ||
                const DeepCollectionEquality()
                    .equals(other.requiresVerification, requiresVerification)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(voiceId) ^
      const DeepCollectionEquality().hash(requiresVerification) ^
      runtimeType.hashCode;
}

extension $AddVoiceIVCResponseModelExtension on AddVoiceIVCResponseModel {
  AddVoiceIVCResponseModel copyWith(
      {String? voiceId, bool? requiresVerification}) {
    return AddVoiceIVCResponseModel(
        voiceId: voiceId ?? this.voiceId,
        requiresVerification:
            requiresVerification ?? this.requiresVerification);
  }

  AddVoiceIVCResponseModel copyWithWrapped(
      {Wrapped<String>? voiceId, Wrapped<bool>? requiresVerification}) {
    return AddVoiceIVCResponseModel(
        voiceId: (voiceId != null ? voiceId.value : this.voiceId),
        requiresVerification: (requiresVerification != null
            ? requiresVerification.value
            : this.requiresVerification));
  }
}

@JsonSerializable(explicitToJson: true)
class AddVoiceResponseModel {
  const AddVoiceResponseModel({
    required this.voiceId,
  });

  factory AddVoiceResponseModel.fromJson(Map<String, dynamic> json) =>
      _$AddVoiceResponseModelFromJson(json);

  static const toJsonFactory = _$AddVoiceResponseModelToJson;
  Map<String, dynamic> toJson() => _$AddVoiceResponseModelToJson(this);

  @JsonKey(name: 'voice_id')
  final String voiceId;
  static const fromJsonFactory = _$AddVoiceResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AddVoiceResponseModel &&
            (identical(other.voiceId, voiceId) ||
                const DeepCollectionEquality().equals(other.voiceId, voiceId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(voiceId) ^ runtimeType.hashCode;
}

extension $AddVoiceResponseModelExtension on AddVoiceResponseModel {
  AddVoiceResponseModel copyWith({String? voiceId}) {
    return AddVoiceResponseModel(voiceId: voiceId ?? this.voiceId);
  }

  AddVoiceResponseModel copyWithWrapped({Wrapped<String>? voiceId}) {
    return AddVoiceResponseModel(
        voiceId: (voiceId != null ? voiceId.value : this.voiceId));
  }
}

@JsonSerializable(explicitToJson: true)
class AddWorkspaceGroupMemberResponseModel {
  const AddWorkspaceGroupMemberResponseModel({
    required this.status,
  });

  factory AddWorkspaceGroupMemberResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$AddWorkspaceGroupMemberResponseModelFromJson(json);

  static const toJsonFactory = _$AddWorkspaceGroupMemberResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$AddWorkspaceGroupMemberResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$AddWorkspaceGroupMemberResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AddWorkspaceGroupMemberResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $AddWorkspaceGroupMemberResponseModelExtension
    on AddWorkspaceGroupMemberResponseModel {
  AddWorkspaceGroupMemberResponseModel copyWith({String? status}) {
    return AddWorkspaceGroupMemberResponseModel(status: status ?? this.status);
  }

  AddWorkspaceGroupMemberResponseModel copyWithWrapped(
      {Wrapped<String>? status}) {
    return AddWorkspaceGroupMemberResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class AddWorkspaceInviteResponseModel {
  const AddWorkspaceInviteResponseModel({
    required this.status,
  });

  factory AddWorkspaceInviteResponseModel.fromJson(Map<String, dynamic> json) =>
      _$AddWorkspaceInviteResponseModelFromJson(json);

  static const toJsonFactory = _$AddWorkspaceInviteResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$AddWorkspaceInviteResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$AddWorkspaceInviteResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AddWorkspaceInviteResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $AddWorkspaceInviteResponseModelExtension
    on AddWorkspaceInviteResponseModel {
  AddWorkspaceInviteResponseModel copyWith({String? status}) {
    return AddWorkspaceInviteResponseModel(status: status ?? this.status);
  }

  AddWorkspaceInviteResponseModel copyWithWrapped({Wrapped<String>? status}) {
    return AddWorkspaceInviteResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class AdditionalFormatResponseModel {
  const AdditionalFormatResponseModel({
    required this.requestedFormat,
    required this.fileExtension,
    required this.contentType,
    required this.isBase64Encoded,
    required this.content,
  });

  factory AdditionalFormatResponseModel.fromJson(Map<String, dynamic> json) =>
      _$AdditionalFormatResponseModelFromJson(json);

  static const toJsonFactory = _$AdditionalFormatResponseModelToJson;
  Map<String, dynamic> toJson() => _$AdditionalFormatResponseModelToJson(this);

  @JsonKey(name: 'requested_format')
  final String requestedFormat;
  @JsonKey(name: 'file_extension')
  final String fileExtension;
  @JsonKey(name: 'content_type')
  final String contentType;
  @JsonKey(name: 'is_base64_encoded')
  final bool isBase64Encoded;
  @JsonKey(name: 'content')
  final String content;
  static const fromJsonFactory = _$AdditionalFormatResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AdditionalFormatResponseModel &&
            (identical(other.requestedFormat, requestedFormat) ||
                const DeepCollectionEquality()
                    .equals(other.requestedFormat, requestedFormat)) &&
            (identical(other.fileExtension, fileExtension) ||
                const DeepCollectionEquality()
                    .equals(other.fileExtension, fileExtension)) &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality()
                    .equals(other.contentType, contentType)) &&
            (identical(other.isBase64Encoded, isBase64Encoded) ||
                const DeepCollectionEquality()
                    .equals(other.isBase64Encoded, isBase64Encoded)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requestedFormat) ^
      const DeepCollectionEquality().hash(fileExtension) ^
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(isBase64Encoded) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $AdditionalFormatResponseModelExtension
    on AdditionalFormatResponseModel {
  AdditionalFormatResponseModel copyWith(
      {String? requestedFormat,
      String? fileExtension,
      String? contentType,
      bool? isBase64Encoded,
      String? content}) {
    return AdditionalFormatResponseModel(
        requestedFormat: requestedFormat ?? this.requestedFormat,
        fileExtension: fileExtension ?? this.fileExtension,
        contentType: contentType ?? this.contentType,
        isBase64Encoded: isBase64Encoded ?? this.isBase64Encoded,
        content: content ?? this.content);
  }

  AdditionalFormatResponseModel copyWithWrapped(
      {Wrapped<String>? requestedFormat,
      Wrapped<String>? fileExtension,
      Wrapped<String>? contentType,
      Wrapped<bool>? isBase64Encoded,
      Wrapped<String>? content}) {
    return AdditionalFormatResponseModel(
        requestedFormat: (requestedFormat != null
            ? requestedFormat.value
            : this.requestedFormat),
        fileExtension:
            (fileExtension != null ? fileExtension.value : this.fileExtension),
        contentType:
            (contentType != null ? contentType.value : this.contentType),
        isBase64Encoded: (isBase64Encoded != null
            ? isBase64Encoded.value
            : this.isBase64Encoded),
        content: (content != null ? content.value : this.content));
  }
}

typedef AdditionalFormats = List<ExportOptions>;

@JsonSerializable(explicitToJson: true)
class AgentBan {
  const AgentBan({
    required this.atUnix,
    this.reason,
    required this.reasonType,
  });

  factory AgentBan.fromJson(Map<String, dynamic> json) =>
      _$AgentBanFromJson(json);

  static const toJsonFactory = _$AgentBanToJson;
  Map<String, dynamic> toJson() => _$AgentBanToJson(this);

  @JsonKey(name: 'at_unix')
  final int atUnix;
  @JsonKey(name: 'reason')
  final dynamic reason;
  @JsonKey(
    name: 'reason_type',
    toJson: banReasonTypeToJson,
    fromJson: banReasonTypeFromJson,
  )
  final enums.BanReasonType reasonType;
  static const fromJsonFactory = _$AgentBanFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AgentBan &&
            (identical(other.atUnix, atUnix) ||
                const DeepCollectionEquality().equals(other.atUnix, atUnix)) &&
            (identical(other.reason, reason) ||
                const DeepCollectionEquality().equals(other.reason, reason)) &&
            (identical(other.reasonType, reasonType) ||
                const DeepCollectionEquality()
                    .equals(other.reasonType, reasonType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(atUnix) ^
      const DeepCollectionEquality().hash(reason) ^
      const DeepCollectionEquality().hash(reasonType) ^
      runtimeType.hashCode;
}

extension $AgentBanExtension on AgentBan {
  AgentBan copyWith(
      {int? atUnix, dynamic reason, enums.BanReasonType? reasonType}) {
    return AgentBan(
        atUnix: atUnix ?? this.atUnix,
        reason: reason ?? this.reason,
        reasonType: reasonType ?? this.reasonType);
  }

  AgentBan copyWithWrapped(
      {Wrapped<int>? atUnix,
      Wrapped<dynamic>? reason,
      Wrapped<enums.BanReasonType>? reasonType}) {
    return AgentBan(
        atUnix: (atUnix != null ? atUnix.value : this.atUnix),
        reason: (reason != null ? reason.value : this.reason),
        reasonType: (reasonType != null ? reasonType.value : this.reasonType));
  }
}

@JsonSerializable(explicitToJson: true)
class AgentCallLimits {
  const AgentCallLimits({
    this.agentConcurrencyLimit,
    this.dailyLimit,
  });

  factory AgentCallLimits.fromJson(Map<String, dynamic> json) =>
      _$AgentCallLimitsFromJson(json);

  static const toJsonFactory = _$AgentCallLimitsToJson;
  Map<String, dynamic> toJson() => _$AgentCallLimitsToJson(this);

  @JsonKey(name: 'agent_concurrency_limit')
  final int? agentConcurrencyLimit;
  @JsonKey(name: 'daily_limit')
  final int? dailyLimit;
  static const fromJsonFactory = _$AgentCallLimitsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AgentCallLimits &&
            (identical(other.agentConcurrencyLimit, agentConcurrencyLimit) ||
                const DeepCollectionEquality().equals(
                    other.agentConcurrencyLimit, agentConcurrencyLimit)) &&
            (identical(other.dailyLimit, dailyLimit) ||
                const DeepCollectionEquality()
                    .equals(other.dailyLimit, dailyLimit)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(agentConcurrencyLimit) ^
      const DeepCollectionEquality().hash(dailyLimit) ^
      runtimeType.hashCode;
}

extension $AgentCallLimitsExtension on AgentCallLimits {
  AgentCallLimits copyWith({int? agentConcurrencyLimit, int? dailyLimit}) {
    return AgentCallLimits(
        agentConcurrencyLimit:
            agentConcurrencyLimit ?? this.agentConcurrencyLimit,
        dailyLimit: dailyLimit ?? this.dailyLimit);
  }

  AgentCallLimits copyWithWrapped(
      {Wrapped<int?>? agentConcurrencyLimit, Wrapped<int?>? dailyLimit}) {
    return AgentCallLimits(
        agentConcurrencyLimit: (agentConcurrencyLimit != null
            ? agentConcurrencyLimit.value
            : this.agentConcurrencyLimit),
        dailyLimit: (dailyLimit != null ? dailyLimit.value : this.dailyLimit));
  }
}

@JsonSerializable(explicitToJson: true)
class AgentConfigAPIModelInput {
  const AgentConfigAPIModelInput({
    this.firstMessage,
    this.language,
    this.dynamicVariables,
    this.prompt,
  });

  factory AgentConfigAPIModelInput.fromJson(Map<String, dynamic> json) =>
      _$AgentConfigAPIModelInputFromJson(json);

  static const toJsonFactory = _$AgentConfigAPIModelInputToJson;
  Map<String, dynamic> toJson() => _$AgentConfigAPIModelInputToJson(this);

  @JsonKey(name: 'first_message')
  final String? firstMessage;
  @JsonKey(name: 'language')
  final String? language;
  @JsonKey(name: 'dynamic_variables')
  final DynamicVariablesConfig? dynamicVariables;
  @JsonKey(name: 'prompt')
  final PromptAgentInput? prompt;
  static const fromJsonFactory = _$AgentConfigAPIModelInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AgentConfigAPIModelInput &&
            (identical(other.firstMessage, firstMessage) ||
                const DeepCollectionEquality()
                    .equals(other.firstMessage, firstMessage)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.dynamicVariables, dynamicVariables) ||
                const DeepCollectionEquality()
                    .equals(other.dynamicVariables, dynamicVariables)) &&
            (identical(other.prompt, prompt) ||
                const DeepCollectionEquality().equals(other.prompt, prompt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(firstMessage) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(dynamicVariables) ^
      const DeepCollectionEquality().hash(prompt) ^
      runtimeType.hashCode;
}

extension $AgentConfigAPIModelInputExtension on AgentConfigAPIModelInput {
  AgentConfigAPIModelInput copyWith(
      {String? firstMessage,
      String? language,
      DynamicVariablesConfig? dynamicVariables,
      PromptAgentInput? prompt}) {
    return AgentConfigAPIModelInput(
        firstMessage: firstMessage ?? this.firstMessage,
        language: language ?? this.language,
        dynamicVariables: dynamicVariables ?? this.dynamicVariables,
        prompt: prompt ?? this.prompt);
  }

  AgentConfigAPIModelInput copyWithWrapped(
      {Wrapped<String?>? firstMessage,
      Wrapped<String?>? language,
      Wrapped<DynamicVariablesConfig?>? dynamicVariables,
      Wrapped<PromptAgentInput?>? prompt}) {
    return AgentConfigAPIModelInput(
        firstMessage:
            (firstMessage != null ? firstMessage.value : this.firstMessage),
        language: (language != null ? language.value : this.language),
        dynamicVariables: (dynamicVariables != null
            ? dynamicVariables.value
            : this.dynamicVariables),
        prompt: (prompt != null ? prompt.value : this.prompt));
  }
}

@JsonSerializable(explicitToJson: true)
class AgentConfigAPIModelOutput {
  const AgentConfigAPIModelOutput({
    this.firstMessage,
    this.language,
    this.dynamicVariables,
    this.prompt,
  });

  factory AgentConfigAPIModelOutput.fromJson(Map<String, dynamic> json) =>
      _$AgentConfigAPIModelOutputFromJson(json);

  static const toJsonFactory = _$AgentConfigAPIModelOutputToJson;
  Map<String, dynamic> toJson() => _$AgentConfigAPIModelOutputToJson(this);

  @JsonKey(name: 'first_message')
  final String? firstMessage;
  @JsonKey(name: 'language')
  final String? language;
  @JsonKey(name: 'dynamic_variables')
  final DynamicVariablesConfig? dynamicVariables;
  @JsonKey(name: 'prompt')
  final PromptAgentOutput? prompt;
  static const fromJsonFactory = _$AgentConfigAPIModelOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AgentConfigAPIModelOutput &&
            (identical(other.firstMessage, firstMessage) ||
                const DeepCollectionEquality()
                    .equals(other.firstMessage, firstMessage)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.dynamicVariables, dynamicVariables) ||
                const DeepCollectionEquality()
                    .equals(other.dynamicVariables, dynamicVariables)) &&
            (identical(other.prompt, prompt) ||
                const DeepCollectionEquality().equals(other.prompt, prompt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(firstMessage) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(dynamicVariables) ^
      const DeepCollectionEquality().hash(prompt) ^
      runtimeType.hashCode;
}

extension $AgentConfigAPIModelOutputExtension on AgentConfigAPIModelOutput {
  AgentConfigAPIModelOutput copyWith(
      {String? firstMessage,
      String? language,
      DynamicVariablesConfig? dynamicVariables,
      PromptAgentOutput? prompt}) {
    return AgentConfigAPIModelOutput(
        firstMessage: firstMessage ?? this.firstMessage,
        language: language ?? this.language,
        dynamicVariables: dynamicVariables ?? this.dynamicVariables,
        prompt: prompt ?? this.prompt);
  }

  AgentConfigAPIModelOutput copyWithWrapped(
      {Wrapped<String?>? firstMessage,
      Wrapped<String?>? language,
      Wrapped<DynamicVariablesConfig?>? dynamicVariables,
      Wrapped<PromptAgentOutput?>? prompt}) {
    return AgentConfigAPIModelOutput(
        firstMessage:
            (firstMessage != null ? firstMessage.value : this.firstMessage),
        language: (language != null ? language.value : this.language),
        dynamicVariables: (dynamicVariables != null
            ? dynamicVariables.value
            : this.dynamicVariables),
        prompt: (prompt != null ? prompt.value : this.prompt));
  }
}

@JsonSerializable(explicitToJson: true)
class AgentConfigDBModel {
  const AgentConfigDBModel({
    this.firstMessage,
    this.language,
    this.dynamicVariables,
    this.prompt,
  });

  factory AgentConfigDBModel.fromJson(Map<String, dynamic> json) =>
      _$AgentConfigDBModelFromJson(json);

  static const toJsonFactory = _$AgentConfigDBModelToJson;
  Map<String, dynamic> toJson() => _$AgentConfigDBModelToJson(this);

  @JsonKey(name: 'first_message')
  final String? firstMessage;
  @JsonKey(name: 'language')
  final String? language;
  @JsonKey(name: 'dynamic_variables')
  final DynamicVariablesConfig? dynamicVariables;
  @JsonKey(name: 'prompt')
  final PromptAgentDBModel? prompt;
  static const fromJsonFactory = _$AgentConfigDBModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AgentConfigDBModel &&
            (identical(other.firstMessage, firstMessage) ||
                const DeepCollectionEquality()
                    .equals(other.firstMessage, firstMessage)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.dynamicVariables, dynamicVariables) ||
                const DeepCollectionEquality()
                    .equals(other.dynamicVariables, dynamicVariables)) &&
            (identical(other.prompt, prompt) ||
                const DeepCollectionEquality().equals(other.prompt, prompt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(firstMessage) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(dynamicVariables) ^
      const DeepCollectionEquality().hash(prompt) ^
      runtimeType.hashCode;
}

extension $AgentConfigDBModelExtension on AgentConfigDBModel {
  AgentConfigDBModel copyWith(
      {String? firstMessage,
      String? language,
      DynamicVariablesConfig? dynamicVariables,
      PromptAgentDBModel? prompt}) {
    return AgentConfigDBModel(
        firstMessage: firstMessage ?? this.firstMessage,
        language: language ?? this.language,
        dynamicVariables: dynamicVariables ?? this.dynamicVariables,
        prompt: prompt ?? this.prompt);
  }

  AgentConfigDBModel copyWithWrapped(
      {Wrapped<String?>? firstMessage,
      Wrapped<String?>? language,
      Wrapped<DynamicVariablesConfig?>? dynamicVariables,
      Wrapped<PromptAgentDBModel?>? prompt}) {
    return AgentConfigDBModel(
        firstMessage:
            (firstMessage != null ? firstMessage.value : this.firstMessage),
        language: (language != null ? language.value : this.language),
        dynamicVariables: (dynamicVariables != null
            ? dynamicVariables.value
            : this.dynamicVariables),
        prompt: (prompt != null ? prompt.value : this.prompt));
  }
}

@JsonSerializable(explicitToJson: true)
class AgentConfigOverride {
  const AgentConfigOverride({
    this.firstMessage,
    this.language,
    this.prompt,
  });

  factory AgentConfigOverride.fromJson(Map<String, dynamic> json) =>
      _$AgentConfigOverrideFromJson(json);

  static const toJsonFactory = _$AgentConfigOverrideToJson;
  Map<String, dynamic> toJson() => _$AgentConfigOverrideToJson(this);

  @JsonKey(name: 'first_message')
  final dynamic firstMessage;
  @JsonKey(name: 'language')
  final dynamic language;
  @JsonKey(name: 'prompt')
  final dynamic prompt;
  static const fromJsonFactory = _$AgentConfigOverrideFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AgentConfigOverride &&
            (identical(other.firstMessage, firstMessage) ||
                const DeepCollectionEquality()
                    .equals(other.firstMessage, firstMessage)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.prompt, prompt) ||
                const DeepCollectionEquality().equals(other.prompt, prompt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(firstMessage) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(prompt) ^
      runtimeType.hashCode;
}

extension $AgentConfigOverrideExtension on AgentConfigOverride {
  AgentConfigOverride copyWith(
      {dynamic firstMessage, dynamic language, dynamic prompt}) {
    return AgentConfigOverride(
        firstMessage: firstMessage ?? this.firstMessage,
        language: language ?? this.language,
        prompt: prompt ?? this.prompt);
  }

  AgentConfigOverride copyWithWrapped(
      {Wrapped<dynamic>? firstMessage,
      Wrapped<dynamic>? language,
      Wrapped<dynamic>? prompt}) {
    return AgentConfigOverride(
        firstMessage:
            (firstMessage != null ? firstMessage.value : this.firstMessage),
        language: (language != null ? language.value : this.language),
        prompt: (prompt != null ? prompt.value : this.prompt));
  }
}

@JsonSerializable(explicitToJson: true)
class AgentConfigOverrideConfig {
  const AgentConfigOverrideConfig({
    this.firstMessage,
    this.language,
    this.prompt,
  });

  factory AgentConfigOverrideConfig.fromJson(Map<String, dynamic> json) =>
      _$AgentConfigOverrideConfigFromJson(json);

  static const toJsonFactory = _$AgentConfigOverrideConfigToJson;
  Map<String, dynamic> toJson() => _$AgentConfigOverrideConfigToJson(this);

  @JsonKey(name: 'first_message', defaultValue: false)
  final bool? firstMessage;
  @JsonKey(name: 'language', defaultValue: false)
  final bool? language;
  @JsonKey(name: 'prompt')
  final PromptAgentOverrideConfig? prompt;
  static const fromJsonFactory = _$AgentConfigOverrideConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AgentConfigOverrideConfig &&
            (identical(other.firstMessage, firstMessage) ||
                const DeepCollectionEquality()
                    .equals(other.firstMessage, firstMessage)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.prompt, prompt) ||
                const DeepCollectionEquality().equals(other.prompt, prompt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(firstMessage) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(prompt) ^
      runtimeType.hashCode;
}

extension $AgentConfigOverrideConfigExtension on AgentConfigOverrideConfig {
  AgentConfigOverrideConfig copyWith(
      {bool? firstMessage, bool? language, PromptAgentOverrideConfig? prompt}) {
    return AgentConfigOverrideConfig(
        firstMessage: firstMessage ?? this.firstMessage,
        language: language ?? this.language,
        prompt: prompt ?? this.prompt);
  }

  AgentConfigOverrideConfig copyWithWrapped(
      {Wrapped<bool?>? firstMessage,
      Wrapped<bool?>? language,
      Wrapped<PromptAgentOverrideConfig?>? prompt}) {
    return AgentConfigOverrideConfig(
        firstMessage:
            (firstMessage != null ? firstMessage.value : this.firstMessage),
        language: (language != null ? language.value : this.language),
        prompt: (prompt != null ? prompt.value : this.prompt));
  }
}

@JsonSerializable(explicitToJson: true)
class AgentMetadataResponseModel {
  const AgentMetadataResponseModel({
    required this.createdAtUnixSecs,
  });

  factory AgentMetadataResponseModel.fromJson(Map<String, dynamic> json) =>
      _$AgentMetadataResponseModelFromJson(json);

  static const toJsonFactory = _$AgentMetadataResponseModelToJson;
  Map<String, dynamic> toJson() => _$AgentMetadataResponseModelToJson(this);

  @JsonKey(name: 'created_at_unix_secs')
  final int createdAtUnixSecs;
  static const fromJsonFactory = _$AgentMetadataResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AgentMetadataResponseModel &&
            (identical(other.createdAtUnixSecs, createdAtUnixSecs) ||
                const DeepCollectionEquality()
                    .equals(other.createdAtUnixSecs, createdAtUnixSecs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdAtUnixSecs) ^
      runtimeType.hashCode;
}

extension $AgentMetadataResponseModelExtension on AgentMetadataResponseModel {
  AgentMetadataResponseModel copyWith({int? createdAtUnixSecs}) {
    return AgentMetadataResponseModel(
        createdAtUnixSecs: createdAtUnixSecs ?? this.createdAtUnixSecs);
  }

  AgentMetadataResponseModel copyWithWrapped(
      {Wrapped<int>? createdAtUnixSecs}) {
    return AgentMetadataResponseModel(
        createdAtUnixSecs: (createdAtUnixSecs != null
            ? createdAtUnixSecs.value
            : this.createdAtUnixSecs));
  }
}

@JsonSerializable(explicitToJson: true)
class AgentPlatformSettingsRequestModel {
  const AgentPlatformSettingsRequestModel({
    this.auth,
    this.evaluation,
    this.widget,
    this.dataCollection,
    this.overrides,
    this.callLimits,
    this.privacy,
    this.workspaceOverrides,
  });

  factory AgentPlatformSettingsRequestModel.fromJson(
          Map<String, dynamic> json) =>
      _$AgentPlatformSettingsRequestModelFromJson(json);

  static const toJsonFactory = _$AgentPlatformSettingsRequestModelToJson;
  Map<String, dynamic> toJson() =>
      _$AgentPlatformSettingsRequestModelToJson(this);

  @JsonKey(name: 'auth')
  final AuthSettings? auth;
  @JsonKey(name: 'evaluation')
  final EvaluationSettings? evaluation;
  @JsonKey(name: 'widget')
  final WidgetConfigInput? widget;
  @JsonKey(name: 'data_collection')
  final Map<String, dynamic>? dataCollection;
  @JsonKey(name: 'overrides')
  final ConversationInitiationClientDataConfigInput? overrides;
  @JsonKey(name: 'call_limits')
  final AgentCallLimits? callLimits;
  @JsonKey(name: 'privacy')
  final PrivacyConfig? privacy;
  @JsonKey(name: 'workspace_overrides')
  final AgentWorkspaceOverridesInput? workspaceOverrides;
  static const fromJsonFactory = _$AgentPlatformSettingsRequestModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AgentPlatformSettingsRequestModel &&
            (identical(other.auth, auth) ||
                const DeepCollectionEquality().equals(other.auth, auth)) &&
            (identical(other.evaluation, evaluation) ||
                const DeepCollectionEquality()
                    .equals(other.evaluation, evaluation)) &&
            (identical(other.widget, widget) ||
                const DeepCollectionEquality().equals(other.widget, widget)) &&
            (identical(other.dataCollection, dataCollection) ||
                const DeepCollectionEquality()
                    .equals(other.dataCollection, dataCollection)) &&
            (identical(other.overrides, overrides) ||
                const DeepCollectionEquality()
                    .equals(other.overrides, overrides)) &&
            (identical(other.callLimits, callLimits) ||
                const DeepCollectionEquality()
                    .equals(other.callLimits, callLimits)) &&
            (identical(other.privacy, privacy) ||
                const DeepCollectionEquality()
                    .equals(other.privacy, privacy)) &&
            (identical(other.workspaceOverrides, workspaceOverrides) ||
                const DeepCollectionEquality()
                    .equals(other.workspaceOverrides, workspaceOverrides)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(auth) ^
      const DeepCollectionEquality().hash(evaluation) ^
      const DeepCollectionEquality().hash(widget) ^
      const DeepCollectionEquality().hash(dataCollection) ^
      const DeepCollectionEquality().hash(overrides) ^
      const DeepCollectionEquality().hash(callLimits) ^
      const DeepCollectionEquality().hash(privacy) ^
      const DeepCollectionEquality().hash(workspaceOverrides) ^
      runtimeType.hashCode;
}

extension $AgentPlatformSettingsRequestModelExtension
    on AgentPlatformSettingsRequestModel {
  AgentPlatformSettingsRequestModel copyWith(
      {AuthSettings? auth,
      EvaluationSettings? evaluation,
      WidgetConfigInput? widget,
      Map<String, dynamic>? dataCollection,
      ConversationInitiationClientDataConfigInput? overrides,
      AgentCallLimits? callLimits,
      PrivacyConfig? privacy,
      AgentWorkspaceOverridesInput? workspaceOverrides}) {
    return AgentPlatformSettingsRequestModel(
        auth: auth ?? this.auth,
        evaluation: evaluation ?? this.evaluation,
        widget: widget ?? this.widget,
        dataCollection: dataCollection ?? this.dataCollection,
        overrides: overrides ?? this.overrides,
        callLimits: callLimits ?? this.callLimits,
        privacy: privacy ?? this.privacy,
        workspaceOverrides: workspaceOverrides ?? this.workspaceOverrides);
  }

  AgentPlatformSettingsRequestModel copyWithWrapped(
      {Wrapped<AuthSettings?>? auth,
      Wrapped<EvaluationSettings?>? evaluation,
      Wrapped<WidgetConfigInput?>? widget,
      Wrapped<Map<String, dynamic>?>? dataCollection,
      Wrapped<ConversationInitiationClientDataConfigInput?>? overrides,
      Wrapped<AgentCallLimits?>? callLimits,
      Wrapped<PrivacyConfig?>? privacy,
      Wrapped<AgentWorkspaceOverridesInput?>? workspaceOverrides}) {
    return AgentPlatformSettingsRequestModel(
        auth: (auth != null ? auth.value : this.auth),
        evaluation: (evaluation != null ? evaluation.value : this.evaluation),
        widget: (widget != null ? widget.value : this.widget),
        dataCollection: (dataCollection != null
            ? dataCollection.value
            : this.dataCollection),
        overrides: (overrides != null ? overrides.value : this.overrides),
        callLimits: (callLimits != null ? callLimits.value : this.callLimits),
        privacy: (privacy != null ? privacy.value : this.privacy),
        workspaceOverrides: (workspaceOverrides != null
            ? workspaceOverrides.value
            : this.workspaceOverrides));
  }
}

@JsonSerializable(explicitToJson: true)
class AgentPlatformSettingsResponseModel {
  const AgentPlatformSettingsResponseModel({
    this.auth,
    this.evaluation,
    this.widget,
    this.dataCollection,
    this.overrides,
    this.callLimits,
    this.privacy,
    this.workspaceOverrides,
    this.safety,
  });

  factory AgentPlatformSettingsResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$AgentPlatformSettingsResponseModelFromJson(json);

  static const toJsonFactory = _$AgentPlatformSettingsResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$AgentPlatformSettingsResponseModelToJson(this);

  @JsonKey(name: 'auth')
  final AuthSettings? auth;
  @JsonKey(name: 'evaluation')
  final EvaluationSettings? evaluation;
  @JsonKey(name: 'widget')
  final WidgetConfigOutput? widget;
  @JsonKey(name: 'data_collection')
  final Map<String, dynamic>? dataCollection;
  @JsonKey(name: 'overrides')
  final ConversationInitiationClientDataConfigOutput? overrides;
  @JsonKey(name: 'call_limits')
  final AgentCallLimits? callLimits;
  @JsonKey(name: 'privacy')
  final PrivacyConfig? privacy;
  @JsonKey(name: 'workspace_overrides')
  final AgentWorkspaceOverridesOutput? workspaceOverrides;
  @JsonKey(name: 'safety')
  final SafetyResponseModel? safety;
  static const fromJsonFactory = _$AgentPlatformSettingsResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AgentPlatformSettingsResponseModel &&
            (identical(other.auth, auth) ||
                const DeepCollectionEquality().equals(other.auth, auth)) &&
            (identical(other.evaluation, evaluation) ||
                const DeepCollectionEquality()
                    .equals(other.evaluation, evaluation)) &&
            (identical(other.widget, widget) ||
                const DeepCollectionEquality().equals(other.widget, widget)) &&
            (identical(other.dataCollection, dataCollection) ||
                const DeepCollectionEquality()
                    .equals(other.dataCollection, dataCollection)) &&
            (identical(other.overrides, overrides) ||
                const DeepCollectionEquality()
                    .equals(other.overrides, overrides)) &&
            (identical(other.callLimits, callLimits) ||
                const DeepCollectionEquality()
                    .equals(other.callLimits, callLimits)) &&
            (identical(other.privacy, privacy) ||
                const DeepCollectionEquality()
                    .equals(other.privacy, privacy)) &&
            (identical(other.workspaceOverrides, workspaceOverrides) ||
                const DeepCollectionEquality()
                    .equals(other.workspaceOverrides, workspaceOverrides)) &&
            (identical(other.safety, safety) ||
                const DeepCollectionEquality().equals(other.safety, safety)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(auth) ^
      const DeepCollectionEquality().hash(evaluation) ^
      const DeepCollectionEquality().hash(widget) ^
      const DeepCollectionEquality().hash(dataCollection) ^
      const DeepCollectionEquality().hash(overrides) ^
      const DeepCollectionEquality().hash(callLimits) ^
      const DeepCollectionEquality().hash(privacy) ^
      const DeepCollectionEquality().hash(workspaceOverrides) ^
      const DeepCollectionEquality().hash(safety) ^
      runtimeType.hashCode;
}

extension $AgentPlatformSettingsResponseModelExtension
    on AgentPlatformSettingsResponseModel {
  AgentPlatformSettingsResponseModel copyWith(
      {AuthSettings? auth,
      EvaluationSettings? evaluation,
      WidgetConfigOutput? widget,
      Map<String, dynamic>? dataCollection,
      ConversationInitiationClientDataConfigOutput? overrides,
      AgentCallLimits? callLimits,
      PrivacyConfig? privacy,
      AgentWorkspaceOverridesOutput? workspaceOverrides,
      SafetyResponseModel? safety}) {
    return AgentPlatformSettingsResponseModel(
        auth: auth ?? this.auth,
        evaluation: evaluation ?? this.evaluation,
        widget: widget ?? this.widget,
        dataCollection: dataCollection ?? this.dataCollection,
        overrides: overrides ?? this.overrides,
        callLimits: callLimits ?? this.callLimits,
        privacy: privacy ?? this.privacy,
        workspaceOverrides: workspaceOverrides ?? this.workspaceOverrides,
        safety: safety ?? this.safety);
  }

  AgentPlatformSettingsResponseModel copyWithWrapped(
      {Wrapped<AuthSettings?>? auth,
      Wrapped<EvaluationSettings?>? evaluation,
      Wrapped<WidgetConfigOutput?>? widget,
      Wrapped<Map<String, dynamic>?>? dataCollection,
      Wrapped<ConversationInitiationClientDataConfigOutput?>? overrides,
      Wrapped<AgentCallLimits?>? callLimits,
      Wrapped<PrivacyConfig?>? privacy,
      Wrapped<AgentWorkspaceOverridesOutput?>? workspaceOverrides,
      Wrapped<SafetyResponseModel?>? safety}) {
    return AgentPlatformSettingsResponseModel(
        auth: (auth != null ? auth.value : this.auth),
        evaluation: (evaluation != null ? evaluation.value : this.evaluation),
        widget: (widget != null ? widget.value : this.widget),
        dataCollection: (dataCollection != null
            ? dataCollection.value
            : this.dataCollection),
        overrides: (overrides != null ? overrides.value : this.overrides),
        callLimits: (callLimits != null ? callLimits.value : this.callLimits),
        privacy: (privacy != null ? privacy.value : this.privacy),
        workspaceOverrides: (workspaceOverrides != null
            ? workspaceOverrides.value
            : this.workspaceOverrides),
        safety: (safety != null ? safety.value : this.safety));
  }
}

@JsonSerializable(explicitToJson: true)
class AgentSimulatedChatTestResponseModel {
  const AgentSimulatedChatTestResponseModel({
    required this.simulatedConversation,
    required this.analysis,
  });

  factory AgentSimulatedChatTestResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$AgentSimulatedChatTestResponseModelFromJson(json);

  static const toJsonFactory = _$AgentSimulatedChatTestResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$AgentSimulatedChatTestResponseModelToJson(this);

  @JsonKey(
      name: 'simulated_conversation',
      defaultValue: <ConversationHistoryTranscriptCommonModelOutput>[])
  final List<ConversationHistoryTranscriptCommonModelOutput>
      simulatedConversation;
  @JsonKey(name: 'analysis')
  final ConversationHistoryAnalysisCommonModel analysis;
  static const fromJsonFactory = _$AgentSimulatedChatTestResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AgentSimulatedChatTestResponseModel &&
            (identical(other.simulatedConversation, simulatedConversation) ||
                const DeepCollectionEquality().equals(
                    other.simulatedConversation, simulatedConversation)) &&
            (identical(other.analysis, analysis) ||
                const DeepCollectionEquality()
                    .equals(other.analysis, analysis)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(simulatedConversation) ^
      const DeepCollectionEquality().hash(analysis) ^
      runtimeType.hashCode;
}

extension $AgentSimulatedChatTestResponseModelExtension
    on AgentSimulatedChatTestResponseModel {
  AgentSimulatedChatTestResponseModel copyWith(
      {List<ConversationHistoryTranscriptCommonModelOutput>?
          simulatedConversation,
      ConversationHistoryAnalysisCommonModel? analysis}) {
    return AgentSimulatedChatTestResponseModel(
        simulatedConversation:
            simulatedConversation ?? this.simulatedConversation,
        analysis: analysis ?? this.analysis);
  }

  AgentSimulatedChatTestResponseModel copyWithWrapped(
      {Wrapped<List<ConversationHistoryTranscriptCommonModelOutput>>?
          simulatedConversation,
      Wrapped<ConversationHistoryAnalysisCommonModel>? analysis}) {
    return AgentSimulatedChatTestResponseModel(
        simulatedConversation: (simulatedConversation != null
            ? simulatedConversation.value
            : this.simulatedConversation),
        analysis: (analysis != null ? analysis.value : this.analysis));
  }
}

@JsonSerializable(explicitToJson: true)
class AgentSummaryResponseModel {
  const AgentSummaryResponseModel({
    required this.agentId,
    required this.name,
    required this.tags,
    required this.createdAtUnixSecs,
    required this.accessInfo,
  });

  factory AgentSummaryResponseModel.fromJson(Map<String, dynamic> json) =>
      _$AgentSummaryResponseModelFromJson(json);

  static const toJsonFactory = _$AgentSummaryResponseModelToJson;
  Map<String, dynamic> toJson() => _$AgentSummaryResponseModelToJson(this);

  @JsonKey(name: 'agent_id')
  final String agentId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'tags', defaultValue: <String>[])
  final List<String> tags;
  @JsonKey(name: 'created_at_unix_secs')
  final int createdAtUnixSecs;
  @JsonKey(name: 'access_info')
  final ResourceAccessInfo accessInfo;
  static const fromJsonFactory = _$AgentSummaryResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AgentSummaryResponseModel &&
            (identical(other.agentId, agentId) ||
                const DeepCollectionEquality()
                    .equals(other.agentId, agentId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)) &&
            (identical(other.createdAtUnixSecs, createdAtUnixSecs) ||
                const DeepCollectionEquality()
                    .equals(other.createdAtUnixSecs, createdAtUnixSecs)) &&
            (identical(other.accessInfo, accessInfo) ||
                const DeepCollectionEquality()
                    .equals(other.accessInfo, accessInfo)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(agentId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(tags) ^
      const DeepCollectionEquality().hash(createdAtUnixSecs) ^
      const DeepCollectionEquality().hash(accessInfo) ^
      runtimeType.hashCode;
}

extension $AgentSummaryResponseModelExtension on AgentSummaryResponseModel {
  AgentSummaryResponseModel copyWith(
      {String? agentId,
      String? name,
      List<String>? tags,
      int? createdAtUnixSecs,
      ResourceAccessInfo? accessInfo}) {
    return AgentSummaryResponseModel(
        agentId: agentId ?? this.agentId,
        name: name ?? this.name,
        tags: tags ?? this.tags,
        createdAtUnixSecs: createdAtUnixSecs ?? this.createdAtUnixSecs,
        accessInfo: accessInfo ?? this.accessInfo);
  }

  AgentSummaryResponseModel copyWithWrapped(
      {Wrapped<String>? agentId,
      Wrapped<String>? name,
      Wrapped<List<String>>? tags,
      Wrapped<int>? createdAtUnixSecs,
      Wrapped<ResourceAccessInfo>? accessInfo}) {
    return AgentSummaryResponseModel(
        agentId: (agentId != null ? agentId.value : this.agentId),
        name: (name != null ? name.value : this.name),
        tags: (tags != null ? tags.value : this.tags),
        createdAtUnixSecs: (createdAtUnixSecs != null
            ? createdAtUnixSecs.value
            : this.createdAtUnixSecs),
        accessInfo: (accessInfo != null ? accessInfo.value : this.accessInfo));
  }
}

@JsonSerializable(explicitToJson: true)
class AgentTransfer {
  const AgentTransfer({
    required this.agentId,
    required this.condition,
  });

  factory AgentTransfer.fromJson(Map<String, dynamic> json) =>
      _$AgentTransferFromJson(json);

  static const toJsonFactory = _$AgentTransferToJson;
  Map<String, dynamic> toJson() => _$AgentTransferToJson(this);

  @JsonKey(name: 'agent_id')
  final String agentId;
  @JsonKey(name: 'condition')
  final String condition;
  static const fromJsonFactory = _$AgentTransferFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AgentTransfer &&
            (identical(other.agentId, agentId) ||
                const DeepCollectionEquality()
                    .equals(other.agentId, agentId)) &&
            (identical(other.condition, condition) ||
                const DeepCollectionEquality()
                    .equals(other.condition, condition)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(agentId) ^
      const DeepCollectionEquality().hash(condition) ^
      runtimeType.hashCode;
}

extension $AgentTransferExtension on AgentTransfer {
  AgentTransfer copyWith({String? agentId, String? condition}) {
    return AgentTransfer(
        agentId: agentId ?? this.agentId,
        condition: condition ?? this.condition);
  }

  AgentTransfer copyWithWrapped(
      {Wrapped<String>? agentId, Wrapped<String>? condition}) {
    return AgentTransfer(
        agentId: (agentId != null ? agentId.value : this.agentId),
        condition: (condition != null ? condition.value : this.condition));
  }
}

@JsonSerializable(explicitToJson: true)
class AgentWorkspaceOverridesInput {
  const AgentWorkspaceOverridesInput({
    this.conversationInitiationClientDataWebhook,
    this.webhooks,
  });

  factory AgentWorkspaceOverridesInput.fromJson(Map<String, dynamic> json) =>
      _$AgentWorkspaceOverridesInputFromJson(json);

  static const toJsonFactory = _$AgentWorkspaceOverridesInputToJson;
  Map<String, dynamic> toJson() => _$AgentWorkspaceOverridesInputToJson(this);

  @JsonKey(name: 'conversation_initiation_client_data_webhook')
  final dynamic conversationInitiationClientDataWebhook;
  @JsonKey(name: 'webhooks')
  final ConvAIWebhooks? webhooks;
  static const fromJsonFactory = _$AgentWorkspaceOverridesInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AgentWorkspaceOverridesInput &&
            (identical(other.conversationInitiationClientDataWebhook,
                    conversationInitiationClientDataWebhook) ||
                const DeepCollectionEquality().equals(
                    other.conversationInitiationClientDataWebhook,
                    conversationInitiationClientDataWebhook)) &&
            (identical(other.webhooks, webhooks) ||
                const DeepCollectionEquality()
                    .equals(other.webhooks, webhooks)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality()
          .hash(conversationInitiationClientDataWebhook) ^
      const DeepCollectionEquality().hash(webhooks) ^
      runtimeType.hashCode;
}

extension $AgentWorkspaceOverridesInputExtension
    on AgentWorkspaceOverridesInput {
  AgentWorkspaceOverridesInput copyWith(
      {dynamic conversationInitiationClientDataWebhook,
      ConvAIWebhooks? webhooks}) {
    return AgentWorkspaceOverridesInput(
        conversationInitiationClientDataWebhook:
            conversationInitiationClientDataWebhook ??
                this.conversationInitiationClientDataWebhook,
        webhooks: webhooks ?? this.webhooks);
  }

  AgentWorkspaceOverridesInput copyWithWrapped(
      {Wrapped<dynamic>? conversationInitiationClientDataWebhook,
      Wrapped<ConvAIWebhooks?>? webhooks}) {
    return AgentWorkspaceOverridesInput(
        conversationInitiationClientDataWebhook:
            (conversationInitiationClientDataWebhook != null
                ? conversationInitiationClientDataWebhook.value
                : this.conversationInitiationClientDataWebhook),
        webhooks: (webhooks != null ? webhooks.value : this.webhooks));
  }
}

@JsonSerializable(explicitToJson: true)
class AgentWorkspaceOverridesOutput {
  const AgentWorkspaceOverridesOutput({
    this.conversationInitiationClientDataWebhook,
    this.webhooks,
  });

  factory AgentWorkspaceOverridesOutput.fromJson(Map<String, dynamic> json) =>
      _$AgentWorkspaceOverridesOutputFromJson(json);

  static const toJsonFactory = _$AgentWorkspaceOverridesOutputToJson;
  Map<String, dynamic> toJson() => _$AgentWorkspaceOverridesOutputToJson(this);

  @JsonKey(name: 'conversation_initiation_client_data_webhook')
  final dynamic conversationInitiationClientDataWebhook;
  @JsonKey(name: 'webhooks')
  final ConvAIWebhooks? webhooks;
  static const fromJsonFactory = _$AgentWorkspaceOverridesOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AgentWorkspaceOverridesOutput &&
            (identical(other.conversationInitiationClientDataWebhook,
                    conversationInitiationClientDataWebhook) ||
                const DeepCollectionEquality().equals(
                    other.conversationInitiationClientDataWebhook,
                    conversationInitiationClientDataWebhook)) &&
            (identical(other.webhooks, webhooks) ||
                const DeepCollectionEquality()
                    .equals(other.webhooks, webhooks)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality()
          .hash(conversationInitiationClientDataWebhook) ^
      const DeepCollectionEquality().hash(webhooks) ^
      runtimeType.hashCode;
}

extension $AgentWorkspaceOverridesOutputExtension
    on AgentWorkspaceOverridesOutput {
  AgentWorkspaceOverridesOutput copyWith(
      {dynamic conversationInitiationClientDataWebhook,
      ConvAIWebhooks? webhooks}) {
    return AgentWorkspaceOverridesOutput(
        conversationInitiationClientDataWebhook:
            conversationInitiationClientDataWebhook ??
                this.conversationInitiationClientDataWebhook,
        webhooks: webhooks ?? this.webhooks);
  }

  AgentWorkspaceOverridesOutput copyWithWrapped(
      {Wrapped<dynamic>? conversationInitiationClientDataWebhook,
      Wrapped<ConvAIWebhooks?>? webhooks}) {
    return AgentWorkspaceOverridesOutput(
        conversationInitiationClientDataWebhook:
            (conversationInitiationClientDataWebhook != null
                ? conversationInitiationClientDataWebhook.value
                : this.conversationInitiationClientDataWebhook),
        webhooks: (webhooks != null ? webhooks.value : this.webhooks));
  }
}

@JsonSerializable(explicitToJson: true)
class AllowlistItem {
  const AllowlistItem({
    required this.hostname,
  });

  factory AllowlistItem.fromJson(Map<String, dynamic> json) =>
      _$AllowlistItemFromJson(json);

  static const toJsonFactory = _$AllowlistItemToJson;
  Map<String, dynamic> toJson() => _$AllowlistItemToJson(this);

  @JsonKey(name: 'hostname')
  final String hostname;
  static const fromJsonFactory = _$AllowlistItemFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AllowlistItem &&
            (identical(other.hostname, hostname) ||
                const DeepCollectionEquality()
                    .equals(other.hostname, hostname)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(hostname) ^ runtimeType.hashCode;
}

extension $AllowlistItemExtension on AllowlistItem {
  AllowlistItem copyWith({String? hostname}) {
    return AllowlistItem(hostname: hostname ?? this.hostname);
  }

  AllowlistItem copyWithWrapped({Wrapped<String>? hostname}) {
    return AllowlistItem(
        hostname: (hostname != null ? hostname.value : this.hostname));
  }
}

@JsonSerializable(explicitToJson: true)
class ArrayJsonSchemaPropertyInput {
  const ArrayJsonSchemaPropertyInput({
    this.type,
    this.description,
    required this.items,
  });

  factory ArrayJsonSchemaPropertyInput.fromJson(Map<String, dynamic> json) =>
      _$ArrayJsonSchemaPropertyInputFromJson(json);

  static const toJsonFactory = _$ArrayJsonSchemaPropertyInputToJson;
  Map<String, dynamic> toJson() => _$ArrayJsonSchemaPropertyInputToJson(this);

  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'items')
  final dynamic items;
  static const fromJsonFactory = _$ArrayJsonSchemaPropertyInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ArrayJsonSchemaPropertyInput &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(items) ^
      runtimeType.hashCode;
}

extension $ArrayJsonSchemaPropertyInputExtension
    on ArrayJsonSchemaPropertyInput {
  ArrayJsonSchemaPropertyInput copyWith(
      {String? type, String? description, dynamic items}) {
    return ArrayJsonSchemaPropertyInput(
        type: type ?? this.type,
        description: description ?? this.description,
        items: items ?? this.items);
  }

  ArrayJsonSchemaPropertyInput copyWithWrapped(
      {Wrapped<String?>? type,
      Wrapped<String?>? description,
      Wrapped<dynamic>? items}) {
    return ArrayJsonSchemaPropertyInput(
        type: (type != null ? type.value : this.type),
        description:
            (description != null ? description.value : this.description),
        items: (items != null ? items.value : this.items));
  }
}

@JsonSerializable(explicitToJson: true)
class ArrayJsonSchemaPropertyOutput {
  const ArrayJsonSchemaPropertyOutput({
    this.type,
    this.description,
    required this.items,
  });

  factory ArrayJsonSchemaPropertyOutput.fromJson(Map<String, dynamic> json) =>
      _$ArrayJsonSchemaPropertyOutputFromJson(json);

  static const toJsonFactory = _$ArrayJsonSchemaPropertyOutputToJson;
  Map<String, dynamic> toJson() => _$ArrayJsonSchemaPropertyOutputToJson(this);

  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'items')
  final dynamic items;
  static const fromJsonFactory = _$ArrayJsonSchemaPropertyOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ArrayJsonSchemaPropertyOutput &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.items, items) ||
                const DeepCollectionEquality().equals(other.items, items)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(items) ^
      runtimeType.hashCode;
}

extension $ArrayJsonSchemaPropertyOutputExtension
    on ArrayJsonSchemaPropertyOutput {
  ArrayJsonSchemaPropertyOutput copyWith(
      {String? type, String? description, dynamic items}) {
    return ArrayJsonSchemaPropertyOutput(
        type: type ?? this.type,
        description: description ?? this.description,
        items: items ?? this.items);
  }

  ArrayJsonSchemaPropertyOutput copyWithWrapped(
      {Wrapped<String?>? type,
      Wrapped<String?>? description,
      Wrapped<dynamic>? items}) {
    return ArrayJsonSchemaPropertyOutput(
        type: (type != null ? type.value : this.type),
        description:
            (description != null ? description.value : this.description),
        items: (items != null ? items.value : this.items));
  }
}

@JsonSerializable(explicitToJson: true)
class AudioNativeCreateProjectResponseModel {
  const AudioNativeCreateProjectResponseModel({
    required this.projectId,
    required this.converting,
    required this.htmlSnippet,
  });

  factory AudioNativeCreateProjectResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$AudioNativeCreateProjectResponseModelFromJson(json);

  static const toJsonFactory = _$AudioNativeCreateProjectResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$AudioNativeCreateProjectResponseModelToJson(this);

  @JsonKey(name: 'project_id')
  final String projectId;
  @JsonKey(name: 'converting')
  final bool converting;
  @JsonKey(name: 'html_snippet')
  final String htmlSnippet;
  static const fromJsonFactory =
      _$AudioNativeCreateProjectResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AudioNativeCreateProjectResponseModel &&
            (identical(other.projectId, projectId) ||
                const DeepCollectionEquality()
                    .equals(other.projectId, projectId)) &&
            (identical(other.converting, converting) ||
                const DeepCollectionEquality()
                    .equals(other.converting, converting)) &&
            (identical(other.htmlSnippet, htmlSnippet) ||
                const DeepCollectionEquality()
                    .equals(other.htmlSnippet, htmlSnippet)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(projectId) ^
      const DeepCollectionEquality().hash(converting) ^
      const DeepCollectionEquality().hash(htmlSnippet) ^
      runtimeType.hashCode;
}

extension $AudioNativeCreateProjectResponseModelExtension
    on AudioNativeCreateProjectResponseModel {
  AudioNativeCreateProjectResponseModel copyWith(
      {String? projectId, bool? converting, String? htmlSnippet}) {
    return AudioNativeCreateProjectResponseModel(
        projectId: projectId ?? this.projectId,
        converting: converting ?? this.converting,
        htmlSnippet: htmlSnippet ?? this.htmlSnippet);
  }

  AudioNativeCreateProjectResponseModel copyWithWrapped(
      {Wrapped<String>? projectId,
      Wrapped<bool>? converting,
      Wrapped<String>? htmlSnippet}) {
    return AudioNativeCreateProjectResponseModel(
        projectId: (projectId != null ? projectId.value : this.projectId),
        converting: (converting != null ? converting.value : this.converting),
        htmlSnippet:
            (htmlSnippet != null ? htmlSnippet.value : this.htmlSnippet));
  }
}

@JsonSerializable(explicitToJson: true)
class AudioNativeEditContentResponseModel {
  const AudioNativeEditContentResponseModel({
    required this.projectId,
    required this.converting,
    required this.publishing,
    required this.htmlSnippet,
  });

  factory AudioNativeEditContentResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$AudioNativeEditContentResponseModelFromJson(json);

  static const toJsonFactory = _$AudioNativeEditContentResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$AudioNativeEditContentResponseModelToJson(this);

  @JsonKey(name: 'project_id')
  final String projectId;
  @JsonKey(name: 'converting')
  final bool converting;
  @JsonKey(name: 'publishing')
  final bool publishing;
  @JsonKey(name: 'html_snippet')
  final String htmlSnippet;
  static const fromJsonFactory = _$AudioNativeEditContentResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AudioNativeEditContentResponseModel &&
            (identical(other.projectId, projectId) ||
                const DeepCollectionEquality()
                    .equals(other.projectId, projectId)) &&
            (identical(other.converting, converting) ||
                const DeepCollectionEquality()
                    .equals(other.converting, converting)) &&
            (identical(other.publishing, publishing) ||
                const DeepCollectionEquality()
                    .equals(other.publishing, publishing)) &&
            (identical(other.htmlSnippet, htmlSnippet) ||
                const DeepCollectionEquality()
                    .equals(other.htmlSnippet, htmlSnippet)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(projectId) ^
      const DeepCollectionEquality().hash(converting) ^
      const DeepCollectionEquality().hash(publishing) ^
      const DeepCollectionEquality().hash(htmlSnippet) ^
      runtimeType.hashCode;
}

extension $AudioNativeEditContentResponseModelExtension
    on AudioNativeEditContentResponseModel {
  AudioNativeEditContentResponseModel copyWith(
      {String? projectId,
      bool? converting,
      bool? publishing,
      String? htmlSnippet}) {
    return AudioNativeEditContentResponseModel(
        projectId: projectId ?? this.projectId,
        converting: converting ?? this.converting,
        publishing: publishing ?? this.publishing,
        htmlSnippet: htmlSnippet ?? this.htmlSnippet);
  }

  AudioNativeEditContentResponseModel copyWithWrapped(
      {Wrapped<String>? projectId,
      Wrapped<bool>? converting,
      Wrapped<bool>? publishing,
      Wrapped<String>? htmlSnippet}) {
    return AudioNativeEditContentResponseModel(
        projectId: (projectId != null ? projectId.value : this.projectId),
        converting: (converting != null ? converting.value : this.converting),
        publishing: (publishing != null ? publishing.value : this.publishing),
        htmlSnippet:
            (htmlSnippet != null ? htmlSnippet.value : this.htmlSnippet));
  }
}

@JsonSerializable(explicitToJson: true)
class AudioNativeProjectSettingsResponseModel {
  const AudioNativeProjectSettingsResponseModel({
    required this.title,
    required this.image,
    required this.author,
    required this.small,
    required this.textColor,
    required this.backgroundColor,
    required this.sessionization,
    this.audioPath,
    this.audioUrl,
    this.status,
  });

  factory AudioNativeProjectSettingsResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$AudioNativeProjectSettingsResponseModelFromJson(json);

  static const toJsonFactory = _$AudioNativeProjectSettingsResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$AudioNativeProjectSettingsResponseModelToJson(this);

  @JsonKey(name: 'title')
  final String title;
  @JsonKey(name: 'image')
  final String image;
  @JsonKey(name: 'author')
  final String author;
  @JsonKey(name: 'small')
  final bool small;
  @JsonKey(name: 'text_color')
  final String textColor;
  @JsonKey(name: 'background_color')
  final String backgroundColor;
  @JsonKey(name: 'sessionization')
  final int sessionization;
  @JsonKey(name: 'audio_path')
  final dynamic audioPath;
  @JsonKey(name: 'audio_url')
  final dynamic audioUrl;
  @JsonKey(
    name: 'status',
    toJson: audioNativeProjectSettingsResponseModelStatusNullableToJson,
    fromJson:
        audioNativeProjectSettingsResponseModelStatusStatusNullableFromJson,
  )
  final enums.AudioNativeProjectSettingsResponseModelStatus? status;
  static enums.AudioNativeProjectSettingsResponseModelStatus?
      audioNativeProjectSettingsResponseModelStatusStatusNullableFromJson(
              Object? value) =>
          audioNativeProjectSettingsResponseModelStatusNullableFromJson(
              value, enums.AudioNativeProjectSettingsResponseModelStatus.ready);

  static const fromJsonFactory =
      _$AudioNativeProjectSettingsResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AudioNativeProjectSettingsResponseModel &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.image, image) ||
                const DeepCollectionEquality().equals(other.image, image)) &&
            (identical(other.author, author) ||
                const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.small, small) ||
                const DeepCollectionEquality().equals(other.small, small)) &&
            (identical(other.textColor, textColor) ||
                const DeepCollectionEquality()
                    .equals(other.textColor, textColor)) &&
            (identical(other.backgroundColor, backgroundColor) ||
                const DeepCollectionEquality()
                    .equals(other.backgroundColor, backgroundColor)) &&
            (identical(other.sessionization, sessionization) ||
                const DeepCollectionEquality()
                    .equals(other.sessionization, sessionization)) &&
            (identical(other.audioPath, audioPath) ||
                const DeepCollectionEquality()
                    .equals(other.audioPath, audioPath)) &&
            (identical(other.audioUrl, audioUrl) ||
                const DeepCollectionEquality()
                    .equals(other.audioUrl, audioUrl)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(image) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(small) ^
      const DeepCollectionEquality().hash(textColor) ^
      const DeepCollectionEquality().hash(backgroundColor) ^
      const DeepCollectionEquality().hash(sessionization) ^
      const DeepCollectionEquality().hash(audioPath) ^
      const DeepCollectionEquality().hash(audioUrl) ^
      const DeepCollectionEquality().hash(status) ^
      runtimeType.hashCode;
}

extension $AudioNativeProjectSettingsResponseModelExtension
    on AudioNativeProjectSettingsResponseModel {
  AudioNativeProjectSettingsResponseModel copyWith(
      {String? title,
      String? image,
      String? author,
      bool? small,
      String? textColor,
      String? backgroundColor,
      int? sessionization,
      dynamic audioPath,
      dynamic audioUrl,
      enums.AudioNativeProjectSettingsResponseModelStatus? status}) {
    return AudioNativeProjectSettingsResponseModel(
        title: title ?? this.title,
        image: image ?? this.image,
        author: author ?? this.author,
        small: small ?? this.small,
        textColor: textColor ?? this.textColor,
        backgroundColor: backgroundColor ?? this.backgroundColor,
        sessionization: sessionization ?? this.sessionization,
        audioPath: audioPath ?? this.audioPath,
        audioUrl: audioUrl ?? this.audioUrl,
        status: status ?? this.status);
  }

  AudioNativeProjectSettingsResponseModel copyWithWrapped(
      {Wrapped<String>? title,
      Wrapped<String>? image,
      Wrapped<String>? author,
      Wrapped<bool>? small,
      Wrapped<String>? textColor,
      Wrapped<String>? backgroundColor,
      Wrapped<int>? sessionization,
      Wrapped<dynamic>? audioPath,
      Wrapped<dynamic>? audioUrl,
      Wrapped<enums.AudioNativeProjectSettingsResponseModelStatus?>? status}) {
    return AudioNativeProjectSettingsResponseModel(
        title: (title != null ? title.value : this.title),
        image: (image != null ? image.value : this.image),
        author: (author != null ? author.value : this.author),
        small: (small != null ? small.value : this.small),
        textColor: (textColor != null ? textColor.value : this.textColor),
        backgroundColor: (backgroundColor != null
            ? backgroundColor.value
            : this.backgroundColor),
        sessionization: (sessionization != null
            ? sessionization.value
            : this.sessionization),
        audioPath: (audioPath != null ? audioPath.value : this.audioPath),
        audioUrl: (audioUrl != null ? audioUrl.value : this.audioUrl),
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class AudioWithTimestampsResponseModel {
  const AudioWithTimestampsResponseModel({
    required this.audioBase64,
    this.alignment,
    this.normalizedAlignment,
  });

  factory AudioWithTimestampsResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$AudioWithTimestampsResponseModelFromJson(json);

  static const toJsonFactory = _$AudioWithTimestampsResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$AudioWithTimestampsResponseModelToJson(this);

  @JsonKey(name: 'audio_base64')
  final String audioBase64;
  @JsonKey(name: 'alignment')
  final dynamic alignment;
  @JsonKey(name: 'normalized_alignment')
  final dynamic normalizedAlignment;
  static const fromJsonFactory = _$AudioWithTimestampsResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AudioWithTimestampsResponseModel &&
            (identical(other.audioBase64, audioBase64) ||
                const DeepCollectionEquality()
                    .equals(other.audioBase64, audioBase64)) &&
            (identical(other.alignment, alignment) ||
                const DeepCollectionEquality()
                    .equals(other.alignment, alignment)) &&
            (identical(other.normalizedAlignment, normalizedAlignment) ||
                const DeepCollectionEquality()
                    .equals(other.normalizedAlignment, normalizedAlignment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(audioBase64) ^
      const DeepCollectionEquality().hash(alignment) ^
      const DeepCollectionEquality().hash(normalizedAlignment) ^
      runtimeType.hashCode;
}

extension $AudioWithTimestampsResponseModelExtension
    on AudioWithTimestampsResponseModel {
  AudioWithTimestampsResponseModel copyWith(
      {String? audioBase64, dynamic alignment, dynamic normalizedAlignment}) {
    return AudioWithTimestampsResponseModel(
        audioBase64: audioBase64 ?? this.audioBase64,
        alignment: alignment ?? this.alignment,
        normalizedAlignment: normalizedAlignment ?? this.normalizedAlignment);
  }

  AudioWithTimestampsResponseModel copyWithWrapped(
      {Wrapped<String>? audioBase64,
      Wrapped<dynamic>? alignment,
      Wrapped<dynamic>? normalizedAlignment}) {
    return AudioWithTimestampsResponseModel(
        audioBase64:
            (audioBase64 != null ? audioBase64.value : this.audioBase64),
        alignment: (alignment != null ? alignment.value : this.alignment),
        normalizedAlignment: (normalizedAlignment != null
            ? normalizedAlignment.value
            : this.normalizedAlignment));
  }
}

@JsonSerializable(explicitToJson: true)
class AuthSettings {
  const AuthSettings({
    this.enableAuth,
    this.allowlist,
    this.shareableToken,
  });

  factory AuthSettings.fromJson(Map<String, dynamic> json) =>
      _$AuthSettingsFromJson(json);

  static const toJsonFactory = _$AuthSettingsToJson;
  Map<String, dynamic> toJson() => _$AuthSettingsToJson(this);

  @JsonKey(name: 'enable_auth', defaultValue: false)
  final bool? enableAuth;
  @JsonKey(name: 'allowlist', defaultValue: <AllowlistItem>[])
  final List<AllowlistItem>? allowlist;
  @JsonKey(name: 'shareable_token')
  final dynamic shareableToken;
  static const fromJsonFactory = _$AuthSettingsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is AuthSettings &&
            (identical(other.enableAuth, enableAuth) ||
                const DeepCollectionEquality()
                    .equals(other.enableAuth, enableAuth)) &&
            (identical(other.allowlist, allowlist) ||
                const DeepCollectionEquality()
                    .equals(other.allowlist, allowlist)) &&
            (identical(other.shareableToken, shareableToken) ||
                const DeepCollectionEquality()
                    .equals(other.shareableToken, shareableToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(enableAuth) ^
      const DeepCollectionEquality().hash(allowlist) ^
      const DeepCollectionEquality().hash(shareableToken) ^
      runtimeType.hashCode;
}

extension $AuthSettingsExtension on AuthSettings {
  AuthSettings copyWith(
      {bool? enableAuth,
      List<AllowlistItem>? allowlist,
      dynamic shareableToken}) {
    return AuthSettings(
        enableAuth: enableAuth ?? this.enableAuth,
        allowlist: allowlist ?? this.allowlist,
        shareableToken: shareableToken ?? this.shareableToken);
  }

  AuthSettings copyWithWrapped(
      {Wrapped<bool?>? enableAuth,
      Wrapped<List<AllowlistItem>?>? allowlist,
      Wrapped<dynamic>? shareableToken}) {
    return AuthSettings(
        enableAuth: (enableAuth != null ? enableAuth.value : this.enableAuth),
        allowlist: (allowlist != null ? allowlist.value : this.allowlist),
        shareableToken: (shareableToken != null
            ? shareableToken.value
            : this.shareableToken));
  }
}

@JsonSerializable(explicitToJson: true)
class BatchCallDetailedResponse {
  const BatchCallDetailedResponse({
    required this.id,
    required this.phoneNumberId,
    this.phoneProvider,
    required this.name,
    required this.agentId,
    required this.createdAtUnix,
    required this.scheduledTimeUnix,
    required this.totalCallsDispatched,
    required this.totalCallsScheduled,
    required this.lastUpdatedAtUnix,
    required this.status,
    required this.agentName,
    required this.recipients,
  });

  factory BatchCallDetailedResponse.fromJson(Map<String, dynamic> json) =>
      _$BatchCallDetailedResponseFromJson(json);

  static const toJsonFactory = _$BatchCallDetailedResponseToJson;
  Map<String, dynamic> toJson() => _$BatchCallDetailedResponseToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'phone_number_id')
  final String phoneNumberId;
  @JsonKey(
    name: 'phone_provider',
    toJson: telephonyProviderNullableToJson,
    fromJson: telephonyProviderPhoneProviderNullableFromJson,
  )
  final enums.TelephonyProvider? phoneProvider;
  static enums.TelephonyProvider?
      telephonyProviderPhoneProviderNullableFromJson(Object? value) =>
          telephonyProviderNullableFromJson(
              value, enums.TelephonyProvider.twilio);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'agent_id')
  final String agentId;
  @JsonKey(name: 'created_at_unix')
  final int createdAtUnix;
  @JsonKey(name: 'scheduled_time_unix')
  final int scheduledTimeUnix;
  @JsonKey(name: 'total_calls_dispatched')
  final int totalCallsDispatched;
  @JsonKey(name: 'total_calls_scheduled')
  final int totalCallsScheduled;
  @JsonKey(name: 'last_updated_at_unix')
  final int lastUpdatedAtUnix;
  @JsonKey(
    name: 'status',
    toJson: batchCallStatusToJson,
    fromJson: batchCallStatusFromJson,
  )
  final enums.BatchCallStatus status;
  @JsonKey(name: 'agent_name')
  final String agentName;
  @JsonKey(
      name: 'recipients', defaultValue: <OutboundCallRecipientResponseModel>[])
  final List<OutboundCallRecipientResponseModel> recipients;
  static const fromJsonFactory = _$BatchCallDetailedResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BatchCallDetailedResponse &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.phoneNumberId, phoneNumberId) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumberId, phoneNumberId)) &&
            (identical(other.phoneProvider, phoneProvider) ||
                const DeepCollectionEquality()
                    .equals(other.phoneProvider, phoneProvider)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.agentId, agentId) ||
                const DeepCollectionEquality()
                    .equals(other.agentId, agentId)) &&
            (identical(other.createdAtUnix, createdAtUnix) ||
                const DeepCollectionEquality()
                    .equals(other.createdAtUnix, createdAtUnix)) &&
            (identical(other.scheduledTimeUnix, scheduledTimeUnix) ||
                const DeepCollectionEquality()
                    .equals(other.scheduledTimeUnix, scheduledTimeUnix)) &&
            (identical(other.totalCallsDispatched, totalCallsDispatched) ||
                const DeepCollectionEquality().equals(
                    other.totalCallsDispatched, totalCallsDispatched)) &&
            (identical(other.totalCallsScheduled, totalCallsScheduled) ||
                const DeepCollectionEquality()
                    .equals(other.totalCallsScheduled, totalCallsScheduled)) &&
            (identical(other.lastUpdatedAtUnix, lastUpdatedAtUnix) ||
                const DeepCollectionEquality()
                    .equals(other.lastUpdatedAtUnix, lastUpdatedAtUnix)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.agentName, agentName) ||
                const DeepCollectionEquality()
                    .equals(other.agentName, agentName)) &&
            (identical(other.recipients, recipients) ||
                const DeepCollectionEquality()
                    .equals(other.recipients, recipients)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(phoneNumberId) ^
      const DeepCollectionEquality().hash(phoneProvider) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(agentId) ^
      const DeepCollectionEquality().hash(createdAtUnix) ^
      const DeepCollectionEquality().hash(scheduledTimeUnix) ^
      const DeepCollectionEquality().hash(totalCallsDispatched) ^
      const DeepCollectionEquality().hash(totalCallsScheduled) ^
      const DeepCollectionEquality().hash(lastUpdatedAtUnix) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(agentName) ^
      const DeepCollectionEquality().hash(recipients) ^
      runtimeType.hashCode;
}

extension $BatchCallDetailedResponseExtension on BatchCallDetailedResponse {
  BatchCallDetailedResponse copyWith(
      {String? id,
      String? phoneNumberId,
      enums.TelephonyProvider? phoneProvider,
      String? name,
      String? agentId,
      int? createdAtUnix,
      int? scheduledTimeUnix,
      int? totalCallsDispatched,
      int? totalCallsScheduled,
      int? lastUpdatedAtUnix,
      enums.BatchCallStatus? status,
      String? agentName,
      List<OutboundCallRecipientResponseModel>? recipients}) {
    return BatchCallDetailedResponse(
        id: id ?? this.id,
        phoneNumberId: phoneNumberId ?? this.phoneNumberId,
        phoneProvider: phoneProvider ?? this.phoneProvider,
        name: name ?? this.name,
        agentId: agentId ?? this.agentId,
        createdAtUnix: createdAtUnix ?? this.createdAtUnix,
        scheduledTimeUnix: scheduledTimeUnix ?? this.scheduledTimeUnix,
        totalCallsDispatched: totalCallsDispatched ?? this.totalCallsDispatched,
        totalCallsScheduled: totalCallsScheduled ?? this.totalCallsScheduled,
        lastUpdatedAtUnix: lastUpdatedAtUnix ?? this.lastUpdatedAtUnix,
        status: status ?? this.status,
        agentName: agentName ?? this.agentName,
        recipients: recipients ?? this.recipients);
  }

  BatchCallDetailedResponse copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? phoneNumberId,
      Wrapped<enums.TelephonyProvider?>? phoneProvider,
      Wrapped<String>? name,
      Wrapped<String>? agentId,
      Wrapped<int>? createdAtUnix,
      Wrapped<int>? scheduledTimeUnix,
      Wrapped<int>? totalCallsDispatched,
      Wrapped<int>? totalCallsScheduled,
      Wrapped<int>? lastUpdatedAtUnix,
      Wrapped<enums.BatchCallStatus>? status,
      Wrapped<String>? agentName,
      Wrapped<List<OutboundCallRecipientResponseModel>>? recipients}) {
    return BatchCallDetailedResponse(
        id: (id != null ? id.value : this.id),
        phoneNumberId:
            (phoneNumberId != null ? phoneNumberId.value : this.phoneNumberId),
        phoneProvider:
            (phoneProvider != null ? phoneProvider.value : this.phoneProvider),
        name: (name != null ? name.value : this.name),
        agentId: (agentId != null ? agentId.value : this.agentId),
        createdAtUnix:
            (createdAtUnix != null ? createdAtUnix.value : this.createdAtUnix),
        scheduledTimeUnix: (scheduledTimeUnix != null
            ? scheduledTimeUnix.value
            : this.scheduledTimeUnix),
        totalCallsDispatched: (totalCallsDispatched != null
            ? totalCallsDispatched.value
            : this.totalCallsDispatched),
        totalCallsScheduled: (totalCallsScheduled != null
            ? totalCallsScheduled.value
            : this.totalCallsScheduled),
        lastUpdatedAtUnix: (lastUpdatedAtUnix != null
            ? lastUpdatedAtUnix.value
            : this.lastUpdatedAtUnix),
        status: (status != null ? status.value : this.status),
        agentName: (agentName != null ? agentName.value : this.agentName),
        recipients: (recipients != null ? recipients.value : this.recipients));
  }
}

@JsonSerializable(explicitToJson: true)
class BatchCallResponse {
  const BatchCallResponse({
    required this.id,
    required this.phoneNumberId,
    this.phoneProvider,
    required this.name,
    required this.agentId,
    required this.createdAtUnix,
    required this.scheduledTimeUnix,
    required this.totalCallsDispatched,
    required this.totalCallsScheduled,
    required this.lastUpdatedAtUnix,
    required this.status,
    required this.agentName,
  });

  factory BatchCallResponse.fromJson(Map<String, dynamic> json) =>
      _$BatchCallResponseFromJson(json);

  static const toJsonFactory = _$BatchCallResponseToJson;
  Map<String, dynamic> toJson() => _$BatchCallResponseToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'phone_number_id')
  final String phoneNumberId;
  @JsonKey(
    name: 'phone_provider',
    toJson: telephonyProviderNullableToJson,
    fromJson: telephonyProviderPhoneProviderNullableFromJson,
  )
  final enums.TelephonyProvider? phoneProvider;
  static enums.TelephonyProvider?
      telephonyProviderPhoneProviderNullableFromJson(Object? value) =>
          telephonyProviderNullableFromJson(
              value, enums.TelephonyProvider.twilio);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'agent_id')
  final String agentId;
  @JsonKey(name: 'created_at_unix')
  final int createdAtUnix;
  @JsonKey(name: 'scheduled_time_unix')
  final int scheduledTimeUnix;
  @JsonKey(name: 'total_calls_dispatched')
  final int totalCallsDispatched;
  @JsonKey(name: 'total_calls_scheduled')
  final int totalCallsScheduled;
  @JsonKey(name: 'last_updated_at_unix')
  final int lastUpdatedAtUnix;
  @JsonKey(
    name: 'status',
    toJson: batchCallStatusToJson,
    fromJson: batchCallStatusFromJson,
  )
  final enums.BatchCallStatus status;
  @JsonKey(name: 'agent_name')
  final String agentName;
  static const fromJsonFactory = _$BatchCallResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BatchCallResponse &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.phoneNumberId, phoneNumberId) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumberId, phoneNumberId)) &&
            (identical(other.phoneProvider, phoneProvider) ||
                const DeepCollectionEquality()
                    .equals(other.phoneProvider, phoneProvider)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.agentId, agentId) ||
                const DeepCollectionEquality()
                    .equals(other.agentId, agentId)) &&
            (identical(other.createdAtUnix, createdAtUnix) ||
                const DeepCollectionEquality()
                    .equals(other.createdAtUnix, createdAtUnix)) &&
            (identical(other.scheduledTimeUnix, scheduledTimeUnix) ||
                const DeepCollectionEquality()
                    .equals(other.scheduledTimeUnix, scheduledTimeUnix)) &&
            (identical(other.totalCallsDispatched, totalCallsDispatched) ||
                const DeepCollectionEquality().equals(
                    other.totalCallsDispatched, totalCallsDispatched)) &&
            (identical(other.totalCallsScheduled, totalCallsScheduled) ||
                const DeepCollectionEquality()
                    .equals(other.totalCallsScheduled, totalCallsScheduled)) &&
            (identical(other.lastUpdatedAtUnix, lastUpdatedAtUnix) ||
                const DeepCollectionEquality()
                    .equals(other.lastUpdatedAtUnix, lastUpdatedAtUnix)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.agentName, agentName) ||
                const DeepCollectionEquality()
                    .equals(other.agentName, agentName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(phoneNumberId) ^
      const DeepCollectionEquality().hash(phoneProvider) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(agentId) ^
      const DeepCollectionEquality().hash(createdAtUnix) ^
      const DeepCollectionEquality().hash(scheduledTimeUnix) ^
      const DeepCollectionEquality().hash(totalCallsDispatched) ^
      const DeepCollectionEquality().hash(totalCallsScheduled) ^
      const DeepCollectionEquality().hash(lastUpdatedAtUnix) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(agentName) ^
      runtimeType.hashCode;
}

extension $BatchCallResponseExtension on BatchCallResponse {
  BatchCallResponse copyWith(
      {String? id,
      String? phoneNumberId,
      enums.TelephonyProvider? phoneProvider,
      String? name,
      String? agentId,
      int? createdAtUnix,
      int? scheduledTimeUnix,
      int? totalCallsDispatched,
      int? totalCallsScheduled,
      int? lastUpdatedAtUnix,
      enums.BatchCallStatus? status,
      String? agentName}) {
    return BatchCallResponse(
        id: id ?? this.id,
        phoneNumberId: phoneNumberId ?? this.phoneNumberId,
        phoneProvider: phoneProvider ?? this.phoneProvider,
        name: name ?? this.name,
        agentId: agentId ?? this.agentId,
        createdAtUnix: createdAtUnix ?? this.createdAtUnix,
        scheduledTimeUnix: scheduledTimeUnix ?? this.scheduledTimeUnix,
        totalCallsDispatched: totalCallsDispatched ?? this.totalCallsDispatched,
        totalCallsScheduled: totalCallsScheduled ?? this.totalCallsScheduled,
        lastUpdatedAtUnix: lastUpdatedAtUnix ?? this.lastUpdatedAtUnix,
        status: status ?? this.status,
        agentName: agentName ?? this.agentName);
  }

  BatchCallResponse copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? phoneNumberId,
      Wrapped<enums.TelephonyProvider?>? phoneProvider,
      Wrapped<String>? name,
      Wrapped<String>? agentId,
      Wrapped<int>? createdAtUnix,
      Wrapped<int>? scheduledTimeUnix,
      Wrapped<int>? totalCallsDispatched,
      Wrapped<int>? totalCallsScheduled,
      Wrapped<int>? lastUpdatedAtUnix,
      Wrapped<enums.BatchCallStatus>? status,
      Wrapped<String>? agentName}) {
    return BatchCallResponse(
        id: (id != null ? id.value : this.id),
        phoneNumberId:
            (phoneNumberId != null ? phoneNumberId.value : this.phoneNumberId),
        phoneProvider:
            (phoneProvider != null ? phoneProvider.value : this.phoneProvider),
        name: (name != null ? name.value : this.name),
        agentId: (agentId != null ? agentId.value : this.agentId),
        createdAtUnix:
            (createdAtUnix != null ? createdAtUnix.value : this.createdAtUnix),
        scheduledTimeUnix: (scheduledTimeUnix != null
            ? scheduledTimeUnix.value
            : this.scheduledTimeUnix),
        totalCallsDispatched: (totalCallsDispatched != null
            ? totalCallsDispatched.value
            : this.totalCallsDispatched),
        totalCallsScheduled: (totalCallsScheduled != null
            ? totalCallsScheduled.value
            : this.totalCallsScheduled),
        lastUpdatedAtUnix: (lastUpdatedAtUnix != null
            ? lastUpdatedAtUnix.value
            : this.lastUpdatedAtUnix),
        status: (status != null ? status.value : this.status),
        agentName: (agentName != null ? agentName.value : this.agentName));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyAddALanguageToTheResourceV1DubbingResourceDubbingIdLanguagePost {
  const BodyAddALanguageToTheResourceV1DubbingResourceDubbingIdLanguagePost({
    required this.language,
  });

  factory BodyAddALanguageToTheResourceV1DubbingResourceDubbingIdLanguagePost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyAddALanguageToTheResourceV1DubbingResourceDubbingIdLanguagePostFromJson(
          json);

  static const toJsonFactory =
      _$BodyAddALanguageToTheResourceV1DubbingResourceDubbingIdLanguagePostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyAddALanguageToTheResourceV1DubbingResourceDubbingIdLanguagePostToJson(
          this);

  @JsonKey(name: 'language')
  final dynamic language;
  static const fromJsonFactory =
      _$BodyAddALanguageToTheResourceV1DubbingResourceDubbingIdLanguagePostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyAddALanguageToTheResourceV1DubbingResourceDubbingIdLanguagePost &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(language) ^ runtimeType.hashCode;
}

extension $BodyAddALanguageToTheResourceV1DubbingResourceDubbingIdLanguagePostExtension
    on BodyAddALanguageToTheResourceV1DubbingResourceDubbingIdLanguagePost {
  BodyAddALanguageToTheResourceV1DubbingResourceDubbingIdLanguagePost copyWith(
      {dynamic language}) {
    return BodyAddALanguageToTheResourceV1DubbingResourceDubbingIdLanguagePost(
        language: language ?? this.language);
  }

  BodyAddALanguageToTheResourceV1DubbingResourceDubbingIdLanguagePost
      copyWithWrapped({Wrapped<dynamic>? language}) {
    return BodyAddALanguageToTheResourceV1DubbingResourceDubbingIdLanguagePost(
        language: (language != null ? language.value : this.language));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromFilePost {
  const BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromFilePost({
    required this.name,
    this.file,
    this.description,
    this.workspaceAccess,
  });

  factory BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromFilePost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromFilePostFromJson(
          json);

  static const toJsonFactory =
      _$BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromFilePostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromFilePostToJson(
          this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'file')
  final dynamic file;
  @JsonKey(name: 'description')
  final dynamic description;
  @JsonKey(name: 'workspace_access')
  final dynamic workspaceAccess;
  static const fromJsonFactory =
      _$BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromFilePostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromFilePost &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.workspaceAccess, workspaceAccess) ||
                const DeepCollectionEquality()
                    .equals(other.workspaceAccess, workspaceAccess)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(file) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(workspaceAccess) ^
      runtimeType.hashCode;
}

extension $BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromFilePostExtension
    on BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromFilePost {
  BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromFilePost
      copyWith(
          {String? name,
          dynamic file,
          dynamic description,
          dynamic workspaceAccess}) {
    return BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromFilePost(
        name: name ?? this.name,
        file: file ?? this.file,
        description: description ?? this.description,
        workspaceAccess: workspaceAccess ?? this.workspaceAccess);
  }

  BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromFilePost
      copyWithWrapped(
          {Wrapped<String>? name,
          Wrapped<dynamic>? file,
          Wrapped<dynamic>? description,
          Wrapped<dynamic>? workspaceAccess}) {
    return BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromFilePost(
        name: (name != null ? name.value : this.name),
        file: (file != null ? file.value : this.file),
        description:
            (description != null ? description.value : this.description),
        workspaceAccess: (workspaceAccess != null
            ? workspaceAccess.value
            : this.workspaceAccess));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromRulesPost {
  const BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromRulesPost({
    required this.rules,
    required this.name,
    this.description,
    this.workspaceAccess,
  });

  factory BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromRulesPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromRulesPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromRulesPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromRulesPostToJson(
          this);

  @JsonKey(name: 'rules', defaultValue: <Object>[])
  final List<Object> rules;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final dynamic description;
  @JsonKey(name: 'workspace_access')
  final dynamic workspaceAccess;
  static const fromJsonFactory =
      _$BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromRulesPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromRulesPost &&
            (identical(other.rules, rules) ||
                const DeepCollectionEquality().equals(other.rules, rules)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.workspaceAccess, workspaceAccess) ||
                const DeepCollectionEquality()
                    .equals(other.workspaceAccess, workspaceAccess)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(rules) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(workspaceAccess) ^
      runtimeType.hashCode;
}

extension $BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromRulesPostExtension
    on BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromRulesPost {
  BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromRulesPost
      copyWith(
          {List<Object>? rules,
          String? name,
          dynamic description,
          dynamic workspaceAccess}) {
    return BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromRulesPost(
        rules: rules ?? this.rules,
        name: name ?? this.name,
        description: description ?? this.description,
        workspaceAccess: workspaceAccess ?? this.workspaceAccess);
  }

  BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromRulesPost
      copyWithWrapped(
          {Wrapped<List<Object>>? rules,
          Wrapped<String>? name,
          Wrapped<dynamic>? description,
          Wrapped<dynamic>? workspaceAccess}) {
    return BodyAddAPronunciationDictionaryV1PronunciationDictionariesAddFromRulesPost(
        rules: (rules != null ? rules.value : this.rules),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        workspaceAccess: (workspaceAccess != null
            ? workspaceAccess.value
            : this.workspaceAccess));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyAddChapterToAProjectV1ProjectsProjectIdChaptersAddPost {
  const BodyAddChapterToAProjectV1ProjectsProjectIdChaptersAddPost({
    required this.name,
    this.fromUrl,
  });

  factory BodyAddChapterToAProjectV1ProjectsProjectIdChaptersAddPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyAddChapterToAProjectV1ProjectsProjectIdChaptersAddPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyAddChapterToAProjectV1ProjectsProjectIdChaptersAddPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyAddChapterToAProjectV1ProjectsProjectIdChaptersAddPostToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'from_url')
  final dynamic fromUrl;
  static const fromJsonFactory =
      _$BodyAddChapterToAProjectV1ProjectsProjectIdChaptersAddPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyAddChapterToAProjectV1ProjectsProjectIdChaptersAddPost &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.fromUrl, fromUrl) ||
                const DeepCollectionEquality().equals(other.fromUrl, fromUrl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(fromUrl) ^
      runtimeType.hashCode;
}

extension $BodyAddChapterToAProjectV1ProjectsProjectIdChaptersAddPostExtension
    on BodyAddChapterToAProjectV1ProjectsProjectIdChaptersAddPost {
  BodyAddChapterToAProjectV1ProjectsProjectIdChaptersAddPost copyWith(
      {String? name, dynamic fromUrl}) {
    return BodyAddChapterToAProjectV1ProjectsProjectIdChaptersAddPost(
        name: name ?? this.name, fromUrl: fromUrl ?? this.fromUrl);
  }

  BodyAddChapterToAProjectV1ProjectsProjectIdChaptersAddPost copyWithWrapped(
      {Wrapped<String>? name, Wrapped<dynamic>? fromUrl}) {
    return BodyAddChapterToAProjectV1ProjectsProjectIdChaptersAddPost(
        name: (name != null ? name.value : this.name),
        fromUrl: (fromUrl != null ? fromUrl.value : this.fromUrl));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIdMembersPost {
  const BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIdMembersPost({
    required this.email,
  });

  factory BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIdMembersPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIdMembersPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIdMembersPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIdMembersPostToJson(this);

  @JsonKey(name: 'email')
  final String email;
  static const fromJsonFactory =
      _$BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIdMembersPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIdMembersPost &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(email) ^ runtimeType.hashCode;
}

extension $BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIdMembersPostExtension
    on BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIdMembersPost {
  BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIdMembersPost copyWith(
      {String? email}) {
    return BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIdMembersPost(
        email: email ?? this.email);
  }

  BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIdMembersPost copyWithWrapped(
      {Wrapped<String>? email}) {
    return BodyAddMemberToUserGroupV1WorkspaceGroupsGroupIdMembersPost(
        email: (email != null ? email.value : this.email));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyAddProjectV1ProjectsAddPost {
  const BodyAddProjectV1ProjectsAddPost({
    required this.name,
    required this.defaultTitleVoiceId,
    required this.defaultParagraphVoiceId,
    required this.defaultModelId,
    this.fromUrl,
    this.fromDocument,
    this.qualityPreset,
    this.title,
    this.author,
    this.description,
    this.genres,
    this.targetAudience,
    this.language,
    this.contentType,
    this.originalPublicationDate,
    this.matureContent,
    this.isbnNumber,
    this.acxVolumeNormalization,
    this.volumeNormalization,
    this.pronunciationDictionaryLocators,
    this.callbackUrl,
    this.fiction,
    this.applyTextNormalization,
    this.autoConvert,
    this.autoAssignVoices,
    this.sourceType,
  });

  factory BodyAddProjectV1ProjectsAddPost.fromJson(Map<String, dynamic> json) =>
      _$BodyAddProjectV1ProjectsAddPostFromJson(json);

  static const toJsonFactory = _$BodyAddProjectV1ProjectsAddPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyAddProjectV1ProjectsAddPostToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'default_title_voice_id')
  final String defaultTitleVoiceId;
  @JsonKey(name: 'default_paragraph_voice_id')
  final String defaultParagraphVoiceId;
  @JsonKey(name: 'default_model_id')
  final String defaultModelId;
  @JsonKey(name: 'from_url')
  final dynamic fromUrl;
  @JsonKey(name: 'from_document')
  final dynamic fromDocument;
  @JsonKey(name: 'quality_preset')
  final String? qualityPreset;
  @JsonKey(name: 'title')
  final dynamic title;
  @JsonKey(name: 'author')
  final dynamic author;
  @JsonKey(name: 'description')
  final dynamic description;
  @JsonKey(name: 'genres', defaultValue: <String>[])
  final List<String>? genres;
  @JsonKey(name: 'target_audience')
  final dynamic targetAudience;
  @JsonKey(name: 'language')
  final dynamic language;
  @JsonKey(name: 'content_type')
  final dynamic contentType;
  @JsonKey(name: 'original_publication_date')
  final dynamic originalPublicationDate;
  @JsonKey(name: 'mature_content')
  final dynamic matureContent;
  @JsonKey(name: 'isbn_number')
  final dynamic isbnNumber;
  @JsonKey(name: 'acx_volume_normalization', defaultValue: false)
  final bool? acxVolumeNormalization;
  @JsonKey(name: 'volume_normalization', defaultValue: false)
  final bool? volumeNormalization;
  @JsonKey(name: 'pronunciation_dictionary_locators', defaultValue: <String>[])
  final List<String>? pronunciationDictionaryLocators;
  @JsonKey(name: 'callback_url')
  final dynamic callbackUrl;
  @JsonKey(name: 'fiction')
  final dynamic fiction;
  @JsonKey(name: 'apply_text_normalization')
  final dynamic applyTextNormalization;
  @JsonKey(name: 'auto_convert', defaultValue: false)
  final bool? autoConvert;
  @JsonKey(name: 'auto_assign_voices')
  final dynamic autoAssignVoices;
  @JsonKey(name: 'source_type')
  final dynamic sourceType;
  static const fromJsonFactory = _$BodyAddProjectV1ProjectsAddPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyAddProjectV1ProjectsAddPost &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.defaultTitleVoiceId, defaultTitleVoiceId) ||
                const DeepCollectionEquality()
                    .equals(other.defaultTitleVoiceId, defaultTitleVoiceId)) &&
            (identical(other.defaultParagraphVoiceId, defaultParagraphVoiceId) ||
                const DeepCollectionEquality().equals(
                    other.defaultParagraphVoiceId, defaultParagraphVoiceId)) &&
            (identical(other.defaultModelId, defaultModelId) ||
                const DeepCollectionEquality()
                    .equals(other.defaultModelId, defaultModelId)) &&
            (identical(other.fromUrl, fromUrl) ||
                const DeepCollectionEquality()
                    .equals(other.fromUrl, fromUrl)) &&
            (identical(other.fromDocument, fromDocument) ||
                const DeepCollectionEquality()
                    .equals(other.fromDocument, fromDocument)) &&
            (identical(other.qualityPreset, qualityPreset) ||
                const DeepCollectionEquality()
                    .equals(other.qualityPreset, qualityPreset)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.author, author) ||
                const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.genres, genres) ||
                const DeepCollectionEquality().equals(other.genres, genres)) &&
            (identical(other.targetAudience, targetAudience) ||
                const DeepCollectionEquality()
                    .equals(other.targetAudience, targetAudience)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality()
                    .equals(other.contentType, contentType)) &&
            (identical(other.originalPublicationDate, originalPublicationDate) ||
                const DeepCollectionEquality().equals(
                    other.originalPublicationDate, originalPublicationDate)) &&
            (identical(other.matureContent, matureContent) ||
                const DeepCollectionEquality()
                    .equals(other.matureContent, matureContent)) &&
            (identical(other.isbnNumber, isbnNumber) ||
                const DeepCollectionEquality()
                    .equals(other.isbnNumber, isbnNumber)) &&
            (identical(other.acxVolumeNormalization, acxVolumeNormalization) ||
                const DeepCollectionEquality().equals(other.acxVolumeNormalization, acxVolumeNormalization)) &&
            (identical(other.volumeNormalization, volumeNormalization) || const DeepCollectionEquality().equals(other.volumeNormalization, volumeNormalization)) &&
            (identical(other.pronunciationDictionaryLocators, pronunciationDictionaryLocators) || const DeepCollectionEquality().equals(other.pronunciationDictionaryLocators, pronunciationDictionaryLocators)) &&
            (identical(other.callbackUrl, callbackUrl) || const DeepCollectionEquality().equals(other.callbackUrl, callbackUrl)) &&
            (identical(other.fiction, fiction) || const DeepCollectionEquality().equals(other.fiction, fiction)) &&
            (identical(other.applyTextNormalization, applyTextNormalization) || const DeepCollectionEquality().equals(other.applyTextNormalization, applyTextNormalization)) &&
            (identical(other.autoConvert, autoConvert) || const DeepCollectionEquality().equals(other.autoConvert, autoConvert)) &&
            (identical(other.autoAssignVoices, autoAssignVoices) || const DeepCollectionEquality().equals(other.autoAssignVoices, autoAssignVoices)) &&
            (identical(other.sourceType, sourceType) || const DeepCollectionEquality().equals(other.sourceType, sourceType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(defaultTitleVoiceId) ^
      const DeepCollectionEquality().hash(defaultParagraphVoiceId) ^
      const DeepCollectionEquality().hash(defaultModelId) ^
      const DeepCollectionEquality().hash(fromUrl) ^
      const DeepCollectionEquality().hash(fromDocument) ^
      const DeepCollectionEquality().hash(qualityPreset) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(genres) ^
      const DeepCollectionEquality().hash(targetAudience) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(originalPublicationDate) ^
      const DeepCollectionEquality().hash(matureContent) ^
      const DeepCollectionEquality().hash(isbnNumber) ^
      const DeepCollectionEquality().hash(acxVolumeNormalization) ^
      const DeepCollectionEquality().hash(volumeNormalization) ^
      const DeepCollectionEquality().hash(pronunciationDictionaryLocators) ^
      const DeepCollectionEquality().hash(callbackUrl) ^
      const DeepCollectionEquality().hash(fiction) ^
      const DeepCollectionEquality().hash(applyTextNormalization) ^
      const DeepCollectionEquality().hash(autoConvert) ^
      const DeepCollectionEquality().hash(autoAssignVoices) ^
      const DeepCollectionEquality().hash(sourceType) ^
      runtimeType.hashCode;
}

extension $BodyAddProjectV1ProjectsAddPostExtension
    on BodyAddProjectV1ProjectsAddPost {
  BodyAddProjectV1ProjectsAddPost copyWith(
      {String? name,
      String? defaultTitleVoiceId,
      String? defaultParagraphVoiceId,
      String? defaultModelId,
      dynamic fromUrl,
      dynamic fromDocument,
      String? qualityPreset,
      dynamic title,
      dynamic author,
      dynamic description,
      List<String>? genres,
      dynamic targetAudience,
      dynamic language,
      dynamic contentType,
      dynamic originalPublicationDate,
      dynamic matureContent,
      dynamic isbnNumber,
      bool? acxVolumeNormalization,
      bool? volumeNormalization,
      List<String>? pronunciationDictionaryLocators,
      dynamic callbackUrl,
      dynamic fiction,
      dynamic applyTextNormalization,
      bool? autoConvert,
      dynamic autoAssignVoices,
      dynamic sourceType}) {
    return BodyAddProjectV1ProjectsAddPost(
        name: name ?? this.name,
        defaultTitleVoiceId: defaultTitleVoiceId ?? this.defaultTitleVoiceId,
        defaultParagraphVoiceId:
            defaultParagraphVoiceId ?? this.defaultParagraphVoiceId,
        defaultModelId: defaultModelId ?? this.defaultModelId,
        fromUrl: fromUrl ?? this.fromUrl,
        fromDocument: fromDocument ?? this.fromDocument,
        qualityPreset: qualityPreset ?? this.qualityPreset,
        title: title ?? this.title,
        author: author ?? this.author,
        description: description ?? this.description,
        genres: genres ?? this.genres,
        targetAudience: targetAudience ?? this.targetAudience,
        language: language ?? this.language,
        contentType: contentType ?? this.contentType,
        originalPublicationDate:
            originalPublicationDate ?? this.originalPublicationDate,
        matureContent: matureContent ?? this.matureContent,
        isbnNumber: isbnNumber ?? this.isbnNumber,
        acxVolumeNormalization:
            acxVolumeNormalization ?? this.acxVolumeNormalization,
        volumeNormalization: volumeNormalization ?? this.volumeNormalization,
        pronunciationDictionaryLocators: pronunciationDictionaryLocators ??
            this.pronunciationDictionaryLocators,
        callbackUrl: callbackUrl ?? this.callbackUrl,
        fiction: fiction ?? this.fiction,
        applyTextNormalization:
            applyTextNormalization ?? this.applyTextNormalization,
        autoConvert: autoConvert ?? this.autoConvert,
        autoAssignVoices: autoAssignVoices ?? this.autoAssignVoices,
        sourceType: sourceType ?? this.sourceType);
  }

  BodyAddProjectV1ProjectsAddPost copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String>? defaultTitleVoiceId,
      Wrapped<String>? defaultParagraphVoiceId,
      Wrapped<String>? defaultModelId,
      Wrapped<dynamic>? fromUrl,
      Wrapped<dynamic>? fromDocument,
      Wrapped<String?>? qualityPreset,
      Wrapped<dynamic>? title,
      Wrapped<dynamic>? author,
      Wrapped<dynamic>? description,
      Wrapped<List<String>?>? genres,
      Wrapped<dynamic>? targetAudience,
      Wrapped<dynamic>? language,
      Wrapped<dynamic>? contentType,
      Wrapped<dynamic>? originalPublicationDate,
      Wrapped<dynamic>? matureContent,
      Wrapped<dynamic>? isbnNumber,
      Wrapped<bool?>? acxVolumeNormalization,
      Wrapped<bool?>? volumeNormalization,
      Wrapped<List<String>?>? pronunciationDictionaryLocators,
      Wrapped<dynamic>? callbackUrl,
      Wrapped<dynamic>? fiction,
      Wrapped<dynamic>? applyTextNormalization,
      Wrapped<bool?>? autoConvert,
      Wrapped<dynamic>? autoAssignVoices,
      Wrapped<dynamic>? sourceType}) {
    return BodyAddProjectV1ProjectsAddPost(
        name: (name != null ? name.value : this.name),
        defaultTitleVoiceId: (defaultTitleVoiceId != null
            ? defaultTitleVoiceId.value
            : this.defaultTitleVoiceId),
        defaultParagraphVoiceId: (defaultParagraphVoiceId != null
            ? defaultParagraphVoiceId.value
            : this.defaultParagraphVoiceId),
        defaultModelId: (defaultModelId != null
            ? defaultModelId.value
            : this.defaultModelId),
        fromUrl: (fromUrl != null ? fromUrl.value : this.fromUrl),
        fromDocument:
            (fromDocument != null ? fromDocument.value : this.fromDocument),
        qualityPreset:
            (qualityPreset != null ? qualityPreset.value : this.qualityPreset),
        title: (title != null ? title.value : this.title),
        author: (author != null ? author.value : this.author),
        description:
            (description != null ? description.value : this.description),
        genres: (genres != null ? genres.value : this.genres),
        targetAudience: (targetAudience != null
            ? targetAudience.value
            : this.targetAudience),
        language: (language != null ? language.value : this.language),
        contentType:
            (contentType != null ? contentType.value : this.contentType),
        originalPublicationDate: (originalPublicationDate != null
            ? originalPublicationDate.value
            : this.originalPublicationDate),
        matureContent:
            (matureContent != null ? matureContent.value : this.matureContent),
        isbnNumber: (isbnNumber != null ? isbnNumber.value : this.isbnNumber),
        acxVolumeNormalization: (acxVolumeNormalization != null
            ? acxVolumeNormalization.value
            : this.acxVolumeNormalization),
        volumeNormalization: (volumeNormalization != null
            ? volumeNormalization.value
            : this.volumeNormalization),
        pronunciationDictionaryLocators:
            (pronunciationDictionaryLocators != null
                ? pronunciationDictionaryLocators.value
                : this.pronunciationDictionaryLocators),
        callbackUrl:
            (callbackUrl != null ? callbackUrl.value : this.callbackUrl),
        fiction: (fiction != null ? fiction.value : this.fiction),
        applyTextNormalization: (applyTextNormalization != null
            ? applyTextNormalization.value
            : this.applyTextNormalization),
        autoConvert:
            (autoConvert != null ? autoConvert.value : this.autoConvert),
        autoAssignVoices: (autoAssignVoices != null
            ? autoAssignVoices.value
            : this.autoAssignVoices),
        sourceType: (sourceType != null ? sourceType.value : this.sourceType));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyAddRulesToThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdAddRulesPost {
  const BodyAddRulesToThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdAddRulesPost({
    required this.rules,
  });

  factory BodyAddRulesToThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdAddRulesPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyAddRulesToThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdAddRulesPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyAddRulesToThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdAddRulesPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyAddRulesToThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdAddRulesPostToJson(
          this);

  @JsonKey(name: 'rules', defaultValue: <Object>[])
  final List<Object> rules;
  static const fromJsonFactory =
      _$BodyAddRulesToThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdAddRulesPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyAddRulesToThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdAddRulesPost &&
            (identical(other.rules, rules) ||
                const DeepCollectionEquality().equals(other.rules, rules)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(rules) ^ runtimeType.hashCode;
}

extension $BodyAddRulesToThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdAddRulesPostExtension
    on BodyAddRulesToThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdAddRulesPost {
  BodyAddRulesToThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdAddRulesPost
      copyWith({List<Object>? rules}) {
    return BodyAddRulesToThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdAddRulesPost(
        rules: rules ?? this.rules);
  }

  BodyAddRulesToThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdAddRulesPost
      copyWithWrapped({Wrapped<List<Object>>? rules}) {
    return BodyAddRulesToThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdAddRulesPost(
        rules: (rules != null ? rules.value : this.rules));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyAddSamplesToPVCVoiceV1VoicesPvcVoiceIdSamplesPost {
  const BodyAddSamplesToPVCVoiceV1VoicesPvcVoiceIdSamplesPost({
    required this.files,
    this.removeBackgroundNoise,
  });

  factory BodyAddSamplesToPVCVoiceV1VoicesPvcVoiceIdSamplesPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyAddSamplesToPVCVoiceV1VoicesPvcVoiceIdSamplesPostFromJson(json);

  static const toJsonFactory =
      _$BodyAddSamplesToPVCVoiceV1VoicesPvcVoiceIdSamplesPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyAddSamplesToPVCVoiceV1VoicesPvcVoiceIdSamplesPostToJson(this);

  @JsonKey(name: 'files', defaultValue: <String>[])
  final List<String> files;
  @JsonKey(name: 'remove_background_noise', defaultValue: false)
  final bool? removeBackgroundNoise;
  static const fromJsonFactory =
      _$BodyAddSamplesToPVCVoiceV1VoicesPvcVoiceIdSamplesPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyAddSamplesToPVCVoiceV1VoicesPvcVoiceIdSamplesPost &&
            (identical(other.files, files) ||
                const DeepCollectionEquality().equals(other.files, files)) &&
            (identical(other.removeBackgroundNoise, removeBackgroundNoise) ||
                const DeepCollectionEquality().equals(
                    other.removeBackgroundNoise, removeBackgroundNoise)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(files) ^
      const DeepCollectionEquality().hash(removeBackgroundNoise) ^
      runtimeType.hashCode;
}

extension $BodyAddSamplesToPVCVoiceV1VoicesPvcVoiceIdSamplesPostExtension
    on BodyAddSamplesToPVCVoiceV1VoicesPvcVoiceIdSamplesPost {
  BodyAddSamplesToPVCVoiceV1VoicesPvcVoiceIdSamplesPost copyWith(
      {List<String>? files, bool? removeBackgroundNoise}) {
    return BodyAddSamplesToPVCVoiceV1VoicesPvcVoiceIdSamplesPost(
        files: files ?? this.files,
        removeBackgroundNoise:
            removeBackgroundNoise ?? this.removeBackgroundNoise);
  }

  BodyAddSamplesToPVCVoiceV1VoicesPvcVoiceIdSamplesPost copyWithWrapped(
      {Wrapped<List<String>>? files, Wrapped<bool?>? removeBackgroundNoise}) {
    return BodyAddSamplesToPVCVoiceV1VoicesPvcVoiceIdSamplesPost(
        files: (files != null ? files.value : this.files),
        removeBackgroundNoise: (removeBackgroundNoise != null
            ? removeBackgroundNoise.value
            : this.removeBackgroundNoise));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyAddSharedVoiceV1VoicesAddPublicUserIdVoiceIdPost {
  const BodyAddSharedVoiceV1VoicesAddPublicUserIdVoiceIdPost({
    required this.newName,
  });

  factory BodyAddSharedVoiceV1VoicesAddPublicUserIdVoiceIdPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyAddSharedVoiceV1VoicesAddPublicUserIdVoiceIdPostFromJson(json);

  static const toJsonFactory =
      _$BodyAddSharedVoiceV1VoicesAddPublicUserIdVoiceIdPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyAddSharedVoiceV1VoicesAddPublicUserIdVoiceIdPostToJson(this);

  @JsonKey(name: 'new_name')
  final String newName;
  static const fromJsonFactory =
      _$BodyAddSharedVoiceV1VoicesAddPublicUserIdVoiceIdPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyAddSharedVoiceV1VoicesAddPublicUserIdVoiceIdPost &&
            (identical(other.newName, newName) ||
                const DeepCollectionEquality().equals(other.newName, newName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(newName) ^ runtimeType.hashCode;
}

extension $BodyAddSharedVoiceV1VoicesAddPublicUserIdVoiceIdPostExtension
    on BodyAddSharedVoiceV1VoicesAddPublicUserIdVoiceIdPost {
  BodyAddSharedVoiceV1VoicesAddPublicUserIdVoiceIdPost copyWith(
      {String? newName}) {
    return BodyAddSharedVoiceV1VoicesAddPublicUserIdVoiceIdPost(
        newName: newName ?? this.newName);
  }

  BodyAddSharedVoiceV1VoicesAddPublicUserIdVoiceIdPost copyWithWrapped(
      {Wrapped<String>? newName}) {
    return BodyAddSharedVoiceV1VoicesAddPublicUserIdVoiceIdPost(
        newName: (newName != null ? newName.value : this.newName));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyAddToKnowledgeBaseV1ConvaiAddToKnowledgeBasePost {
  const BodyAddToKnowledgeBaseV1ConvaiAddToKnowledgeBasePost({
    this.name,
    this.url,
    this.file,
  });

  factory BodyAddToKnowledgeBaseV1ConvaiAddToKnowledgeBasePost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyAddToKnowledgeBaseV1ConvaiAddToKnowledgeBasePostFromJson(json);

  static const toJsonFactory =
      _$BodyAddToKnowledgeBaseV1ConvaiAddToKnowledgeBasePostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyAddToKnowledgeBaseV1ConvaiAddToKnowledgeBasePostToJson(this);

  @JsonKey(name: 'name')
  final dynamic name;
  @JsonKey(name: 'url')
  final String? url;
  @JsonKey(name: 'file')
  final String? file;
  static const fromJsonFactory =
      _$BodyAddToKnowledgeBaseV1ConvaiAddToKnowledgeBasePostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyAddToKnowledgeBaseV1ConvaiAddToKnowledgeBasePost &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(file) ^
      runtimeType.hashCode;
}

extension $BodyAddToKnowledgeBaseV1ConvaiAddToKnowledgeBasePostExtension
    on BodyAddToKnowledgeBaseV1ConvaiAddToKnowledgeBasePost {
  BodyAddToKnowledgeBaseV1ConvaiAddToKnowledgeBasePost copyWith(
      {dynamic name, String? url, String? file}) {
    return BodyAddToKnowledgeBaseV1ConvaiAddToKnowledgeBasePost(
        name: name ?? this.name, url: url ?? this.url, file: file ?? this.file);
  }

  BodyAddToKnowledgeBaseV1ConvaiAddToKnowledgeBasePost copyWithWrapped(
      {Wrapped<dynamic>? name, Wrapped<String?>? url, Wrapped<String?>? file}) {
    return BodyAddToKnowledgeBaseV1ConvaiAddToKnowledgeBasePost(
        name: (name != null ? name.value : this.name),
        url: (url != null ? url.value : this.url),
        file: (file != null ? file.value : this.file));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyAddToKnowledgeBaseV1ConvaiAgentsAgentIdAddToKnowledgeBasePost {
  const BodyAddToKnowledgeBaseV1ConvaiAgentsAgentIdAddToKnowledgeBasePost({
    this.name,
    this.url,
    this.file,
  });

  factory BodyAddToKnowledgeBaseV1ConvaiAgentsAgentIdAddToKnowledgeBasePost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyAddToKnowledgeBaseV1ConvaiAgentsAgentIdAddToKnowledgeBasePostFromJson(
          json);

  static const toJsonFactory =
      _$BodyAddToKnowledgeBaseV1ConvaiAgentsAgentIdAddToKnowledgeBasePostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyAddToKnowledgeBaseV1ConvaiAgentsAgentIdAddToKnowledgeBasePostToJson(
          this);

  @JsonKey(name: 'name')
  final dynamic name;
  @JsonKey(name: 'url')
  final String? url;
  @JsonKey(name: 'file')
  final String? file;
  static const fromJsonFactory =
      _$BodyAddToKnowledgeBaseV1ConvaiAgentsAgentIdAddToKnowledgeBasePostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyAddToKnowledgeBaseV1ConvaiAgentsAgentIdAddToKnowledgeBasePost &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(file) ^
      runtimeType.hashCode;
}

extension $BodyAddToKnowledgeBaseV1ConvaiAgentsAgentIdAddToKnowledgeBasePostExtension
    on BodyAddToKnowledgeBaseV1ConvaiAgentsAgentIdAddToKnowledgeBasePost {
  BodyAddToKnowledgeBaseV1ConvaiAgentsAgentIdAddToKnowledgeBasePost copyWith(
      {dynamic name, String? url, String? file}) {
    return BodyAddToKnowledgeBaseV1ConvaiAgentsAgentIdAddToKnowledgeBasePost(
        name: name ?? this.name, url: url ?? this.url, file: file ?? this.file);
  }

  BodyAddToKnowledgeBaseV1ConvaiAgentsAgentIdAddToKnowledgeBasePost
      copyWithWrapped(
          {Wrapped<dynamic>? name,
          Wrapped<String?>? url,
          Wrapped<String?>? file}) {
    return BodyAddToKnowledgeBaseV1ConvaiAgentsAgentIdAddToKnowledgeBasePost(
        name: (name != null ? name.value : this.name),
        url: (url != null ? url.value : this.url),
        file: (file != null ? file.value : this.file));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyAddToKnowledgeBaseV1ConvaiKnowledgeBasePost {
  const BodyAddToKnowledgeBaseV1ConvaiKnowledgeBasePost({
    this.name,
    this.url,
    this.file,
  });

  factory BodyAddToKnowledgeBaseV1ConvaiKnowledgeBasePost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyAddToKnowledgeBaseV1ConvaiKnowledgeBasePostFromJson(json);

  static const toJsonFactory =
      _$BodyAddToKnowledgeBaseV1ConvaiKnowledgeBasePostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyAddToKnowledgeBaseV1ConvaiKnowledgeBasePostToJson(this);

  @JsonKey(name: 'name')
  final dynamic name;
  @JsonKey(name: 'url')
  final String? url;
  @JsonKey(name: 'file')
  final String? file;
  static const fromJsonFactory =
      _$BodyAddToKnowledgeBaseV1ConvaiKnowledgeBasePostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyAddToKnowledgeBaseV1ConvaiKnowledgeBasePost &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(file) ^
      runtimeType.hashCode;
}

extension $BodyAddToKnowledgeBaseV1ConvaiKnowledgeBasePostExtension
    on BodyAddToKnowledgeBaseV1ConvaiKnowledgeBasePost {
  BodyAddToKnowledgeBaseV1ConvaiKnowledgeBasePost copyWith(
      {dynamic name, String? url, String? file}) {
    return BodyAddToKnowledgeBaseV1ConvaiKnowledgeBasePost(
        name: name ?? this.name, url: url ?? this.url, file: file ?? this.file);
  }

  BodyAddToKnowledgeBaseV1ConvaiKnowledgeBasePost copyWithWrapped(
      {Wrapped<dynamic>? name, Wrapped<String?>? url, Wrapped<String?>? file}) {
    return BodyAddToKnowledgeBaseV1ConvaiKnowledgeBasePost(
        name: (name != null ? name.value : this.name),
        url: (url != null ? url.value : this.url),
        file: (file != null ? file.value : this.file));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyAddVoiceV1VoicesAddPost {
  const BodyAddVoiceV1VoicesAddPost({
    required this.name,
    required this.files,
    this.removeBackgroundNoise,
    this.description,
    this.labels,
  });

  factory BodyAddVoiceV1VoicesAddPost.fromJson(Map<String, dynamic> json) =>
      _$BodyAddVoiceV1VoicesAddPostFromJson(json);

  static const toJsonFactory = _$BodyAddVoiceV1VoicesAddPostToJson;
  Map<String, dynamic> toJson() => _$BodyAddVoiceV1VoicesAddPostToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'files', defaultValue: <String>[])
  final List<String> files;
  @JsonKey(name: 'remove_background_noise', defaultValue: false)
  final bool? removeBackgroundNoise;
  @JsonKey(name: 'description')
  final dynamic description;
  @JsonKey(name: 'labels')
  final dynamic labels;
  static const fromJsonFactory = _$BodyAddVoiceV1VoicesAddPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyAddVoiceV1VoicesAddPost &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.files, files) ||
                const DeepCollectionEquality().equals(other.files, files)) &&
            (identical(other.removeBackgroundNoise, removeBackgroundNoise) ||
                const DeepCollectionEquality().equals(
                    other.removeBackgroundNoise, removeBackgroundNoise)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.labels, labels) ||
                const DeepCollectionEquality().equals(other.labels, labels)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(files) ^
      const DeepCollectionEquality().hash(removeBackgroundNoise) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(labels) ^
      runtimeType.hashCode;
}

extension $BodyAddVoiceV1VoicesAddPostExtension on BodyAddVoiceV1VoicesAddPost {
  BodyAddVoiceV1VoicesAddPost copyWith(
      {String? name,
      List<String>? files,
      bool? removeBackgroundNoise,
      dynamic description,
      dynamic labels}) {
    return BodyAddVoiceV1VoicesAddPost(
        name: name ?? this.name,
        files: files ?? this.files,
        removeBackgroundNoise:
            removeBackgroundNoise ?? this.removeBackgroundNoise,
        description: description ?? this.description,
        labels: labels ?? this.labels);
  }

  BodyAddVoiceV1VoicesAddPost copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<List<String>>? files,
      Wrapped<bool?>? removeBackgroundNoise,
      Wrapped<dynamic>? description,
      Wrapped<dynamic>? labels}) {
    return BodyAddVoiceV1VoicesAddPost(
        name: (name != null ? name.value : this.name),
        files: (files != null ? files.value : this.files),
        removeBackgroundNoise: (removeBackgroundNoise != null
            ? removeBackgroundNoise.value
            : this.removeBackgroundNoise),
        description:
            (description != null ? description.value : this.description),
        labels: (labels != null ? labels.value : this.labels));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyAudioIsolationStreamV1AudioIsolationStreamPost {
  const BodyAudioIsolationStreamV1AudioIsolationStreamPost({
    required this.audio,
    this.fileFormat,
  });

  factory BodyAudioIsolationStreamV1AudioIsolationStreamPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyAudioIsolationStreamV1AudioIsolationStreamPostFromJson(json);

  static const toJsonFactory =
      _$BodyAudioIsolationStreamV1AudioIsolationStreamPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyAudioIsolationStreamV1AudioIsolationStreamPostToJson(this);

  @JsonKey(name: 'audio')
  final String audio;
  @JsonKey(name: 'file_format')
  final dynamic fileFormat;
  static const fromJsonFactory =
      _$BodyAudioIsolationStreamV1AudioIsolationStreamPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyAudioIsolationStreamV1AudioIsolationStreamPost &&
            (identical(other.audio, audio) ||
                const DeepCollectionEquality().equals(other.audio, audio)) &&
            (identical(other.fileFormat, fileFormat) ||
                const DeepCollectionEquality()
                    .equals(other.fileFormat, fileFormat)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(audio) ^
      const DeepCollectionEquality().hash(fileFormat) ^
      runtimeType.hashCode;
}

extension $BodyAudioIsolationStreamV1AudioIsolationStreamPostExtension
    on BodyAudioIsolationStreamV1AudioIsolationStreamPost {
  BodyAudioIsolationStreamV1AudioIsolationStreamPost copyWith(
      {String? audio, dynamic fileFormat}) {
    return BodyAudioIsolationStreamV1AudioIsolationStreamPost(
        audio: audio ?? this.audio, fileFormat: fileFormat ?? this.fileFormat);
  }

  BodyAudioIsolationStreamV1AudioIsolationStreamPost copyWithWrapped(
      {Wrapped<String>? audio, Wrapped<dynamic>? fileFormat}) {
    return BodyAudioIsolationStreamV1AudioIsolationStreamPost(
        audio: (audio != null ? audio.value : this.audio),
        fileFormat: (fileFormat != null ? fileFormat.value : this.fileFormat));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyAudioIsolationV1AudioIsolationPost {
  const BodyAudioIsolationV1AudioIsolationPost({
    required this.audio,
    this.fileFormat,
  });

  factory BodyAudioIsolationV1AudioIsolationPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyAudioIsolationV1AudioIsolationPostFromJson(json);

  static const toJsonFactory = _$BodyAudioIsolationV1AudioIsolationPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyAudioIsolationV1AudioIsolationPostToJson(this);

  @JsonKey(name: 'audio')
  final String audio;
  @JsonKey(name: 'file_format')
  final dynamic fileFormat;
  static const fromJsonFactory =
      _$BodyAudioIsolationV1AudioIsolationPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyAudioIsolationV1AudioIsolationPost &&
            (identical(other.audio, audio) ||
                const DeepCollectionEquality().equals(other.audio, audio)) &&
            (identical(other.fileFormat, fileFormat) ||
                const DeepCollectionEquality()
                    .equals(other.fileFormat, fileFormat)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(audio) ^
      const DeepCollectionEquality().hash(fileFormat) ^
      runtimeType.hashCode;
}

extension $BodyAudioIsolationV1AudioIsolationPostExtension
    on BodyAudioIsolationV1AudioIsolationPost {
  BodyAudioIsolationV1AudioIsolationPost copyWith(
      {String? audio, dynamic fileFormat}) {
    return BodyAudioIsolationV1AudioIsolationPost(
        audio: audio ?? this.audio, fileFormat: fileFormat ?? this.fileFormat);
  }

  BodyAudioIsolationV1AudioIsolationPost copyWithWrapped(
      {Wrapped<String>? audio, Wrapped<dynamic>? fileFormat}) {
    return BodyAudioIsolationV1AudioIsolationPost(
        audio: (audio != null ? audio.value : this.audio),
        fileFormat: (fileFormat != null ? fileFormat.value : this.fileFormat));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyCreateAgentV1ConvaiAgentsCreatePost {
  const BodyCreateAgentV1ConvaiAgentsCreatePost({
    required this.conversationConfig,
    this.platformSettings,
    this.name,
    this.tags,
  });

  factory BodyCreateAgentV1ConvaiAgentsCreatePost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyCreateAgentV1ConvaiAgentsCreatePostFromJson(json);

  static const toJsonFactory = _$BodyCreateAgentV1ConvaiAgentsCreatePostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyCreateAgentV1ConvaiAgentsCreatePostToJson(this);

  @JsonKey(name: 'conversation_config')
  final ConversationalConfigAPIModelInput conversationConfig;
  @JsonKey(name: 'platform_settings')
  final dynamic platformSettings;
  @JsonKey(name: 'name')
  final dynamic name;
  @JsonKey(name: 'tags')
  final dynamic tags;
  static const fromJsonFactory =
      _$BodyCreateAgentV1ConvaiAgentsCreatePostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyCreateAgentV1ConvaiAgentsCreatePost &&
            (identical(other.conversationConfig, conversationConfig) ||
                const DeepCollectionEquality()
                    .equals(other.conversationConfig, conversationConfig)) &&
            (identical(other.platformSettings, platformSettings) ||
                const DeepCollectionEquality()
                    .equals(other.platformSettings, platformSettings)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(conversationConfig) ^
      const DeepCollectionEquality().hash(platformSettings) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $BodyCreateAgentV1ConvaiAgentsCreatePostExtension
    on BodyCreateAgentV1ConvaiAgentsCreatePost {
  BodyCreateAgentV1ConvaiAgentsCreatePost copyWith(
      {ConversationalConfigAPIModelInput? conversationConfig,
      dynamic platformSettings,
      dynamic name,
      dynamic tags}) {
    return BodyCreateAgentV1ConvaiAgentsCreatePost(
        conversationConfig: conversationConfig ?? this.conversationConfig,
        platformSettings: platformSettings ?? this.platformSettings,
        name: name ?? this.name,
        tags: tags ?? this.tags);
  }

  BodyCreateAgentV1ConvaiAgentsCreatePost copyWithWrapped(
      {Wrapped<ConversationalConfigAPIModelInput>? conversationConfig,
      Wrapped<dynamic>? platformSettings,
      Wrapped<dynamic>? name,
      Wrapped<dynamic>? tags}) {
    return BodyCreateAgentV1ConvaiAgentsCreatePost(
        conversationConfig: (conversationConfig != null
            ? conversationConfig.value
            : this.conversationConfig),
        platformSettings: (platformSettings != null
            ? platformSettings.value
            : this.platformSettings),
        name: (name != null ? name.value : this.name),
        tags: (tags != null ? tags.value : this.tags));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyCreatePVCVoiceV1VoicesPvcPost {
  const BodyCreatePVCVoiceV1VoicesPvcPost({
    required this.name,
    required this.language,
    this.description,
    this.labels,
  });

  factory BodyCreatePVCVoiceV1VoicesPvcPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyCreatePVCVoiceV1VoicesPvcPostFromJson(json);

  static const toJsonFactory = _$BodyCreatePVCVoiceV1VoicesPvcPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyCreatePVCVoiceV1VoicesPvcPostToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'language')
  final String language;
  @JsonKey(name: 'description')
  final dynamic description;
  @JsonKey(name: 'labels')
  final dynamic labels;
  static const fromJsonFactory = _$BodyCreatePVCVoiceV1VoicesPvcPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyCreatePVCVoiceV1VoicesPvcPost &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.labels, labels) ||
                const DeepCollectionEquality().equals(other.labels, labels)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(labels) ^
      runtimeType.hashCode;
}

extension $BodyCreatePVCVoiceV1VoicesPvcPostExtension
    on BodyCreatePVCVoiceV1VoicesPvcPost {
  BodyCreatePVCVoiceV1VoicesPvcPost copyWith(
      {String? name, String? language, dynamic description, dynamic labels}) {
    return BodyCreatePVCVoiceV1VoicesPvcPost(
        name: name ?? this.name,
        language: language ?? this.language,
        description: description ?? this.description,
        labels: labels ?? this.labels);
  }

  BodyCreatePVCVoiceV1VoicesPvcPost copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String>? language,
      Wrapped<dynamic>? description,
      Wrapped<dynamic>? labels}) {
    return BodyCreatePVCVoiceV1VoicesPvcPost(
        name: (name != null ? name.value : this.name),
        language: (language != null ? language.value : this.language),
        description:
            (description != null ? description.value : this.description),
        labels: (labels != null ? labels.value : this.labels));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyCreatePronunciationDictionariesV1StudioProjectsProjectIdPronunciationDictionariesPost {
  const BodyCreatePronunciationDictionariesV1StudioProjectsProjectIdPronunciationDictionariesPost({
    required this.pronunciationDictionaryLocators,
    this.invalidateAffectedText,
  });

  factory BodyCreatePronunciationDictionariesV1StudioProjectsProjectIdPronunciationDictionariesPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyCreatePronunciationDictionariesV1StudioProjectsProjectIdPronunciationDictionariesPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyCreatePronunciationDictionariesV1StudioProjectsProjectIdPronunciationDictionariesPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyCreatePronunciationDictionariesV1StudioProjectsProjectIdPronunciationDictionariesPostToJson(
          this);

  @JsonKey(
      name: 'pronunciation_dictionary_locators',
      defaultValue: <PronunciationDictionaryVersionLocatorDBModel>[])
  final List<PronunciationDictionaryVersionLocatorDBModel>
      pronunciationDictionaryLocators;
  @JsonKey(name: 'invalidate_affected_text', defaultValue: true)
  final bool? invalidateAffectedText;
  static const fromJsonFactory =
      _$BodyCreatePronunciationDictionariesV1StudioProjectsProjectIdPronunciationDictionariesPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyCreatePronunciationDictionariesV1StudioProjectsProjectIdPronunciationDictionariesPost &&
            (identical(other.pronunciationDictionaryLocators,
                    pronunciationDictionaryLocators) ||
                const DeepCollectionEquality().equals(
                    other.pronunciationDictionaryLocators,
                    pronunciationDictionaryLocators)) &&
            (identical(other.invalidateAffectedText, invalidateAffectedText) ||
                const DeepCollectionEquality().equals(
                    other.invalidateAffectedText, invalidateAffectedText)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(pronunciationDictionaryLocators) ^
      const DeepCollectionEquality().hash(invalidateAffectedText) ^
      runtimeType.hashCode;
}

extension $BodyCreatePronunciationDictionariesV1StudioProjectsProjectIdPronunciationDictionariesPostExtension
    on BodyCreatePronunciationDictionariesV1StudioProjectsProjectIdPronunciationDictionariesPost {
  BodyCreatePronunciationDictionariesV1StudioProjectsProjectIdPronunciationDictionariesPost
      copyWith(
          {List<PronunciationDictionaryVersionLocatorDBModel>?
              pronunciationDictionaryLocators,
          bool? invalidateAffectedText}) {
    return BodyCreatePronunciationDictionariesV1StudioProjectsProjectIdPronunciationDictionariesPost(
        pronunciationDictionaryLocators: pronunciationDictionaryLocators ??
            this.pronunciationDictionaryLocators,
        invalidateAffectedText:
            invalidateAffectedText ?? this.invalidateAffectedText);
  }

  BodyCreatePronunciationDictionariesV1StudioProjectsProjectIdPronunciationDictionariesPost
      copyWithWrapped(
          {Wrapped<List<PronunciationDictionaryVersionLocatorDBModel>>?
              pronunciationDictionaryLocators,
          Wrapped<bool?>? invalidateAffectedText}) {
    return BodyCreatePronunciationDictionariesV1StudioProjectsProjectIdPronunciationDictionariesPost(
        pronunciationDictionaryLocators:
            (pronunciationDictionaryLocators != null
                ? pronunciationDictionaryLocators.value
                : this.pronunciationDictionaryLocators),
        invalidateAffectedText: (invalidateAffectedText != null
            ? invalidateAffectedText.value
            : this.invalidateAffectedText));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyCreateStudioProjectV1StudioProjectsPost {
  const BodyCreateStudioProjectV1StudioProjectsPost({
    required this.name,
    required this.defaultTitleVoiceId,
    required this.defaultParagraphVoiceId,
    required this.defaultModelId,
    this.fromUrl,
    this.fromDocument,
    this.qualityPreset,
    this.title,
    this.author,
    this.description,
    this.genres,
    this.targetAudience,
    this.language,
    this.contentType,
    this.originalPublicationDate,
    this.matureContent,
    this.isbnNumber,
    this.acxVolumeNormalization,
    this.volumeNormalization,
    this.pronunciationDictionaryLocators,
    this.callbackUrl,
    this.fiction,
    this.applyTextNormalization,
    this.autoConvert,
    this.autoAssignVoices,
    this.sourceType,
  });

  factory BodyCreateStudioProjectV1StudioProjectsPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyCreateStudioProjectV1StudioProjectsPostFromJson(json);

  static const toJsonFactory =
      _$BodyCreateStudioProjectV1StudioProjectsPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyCreateStudioProjectV1StudioProjectsPostToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'default_title_voice_id')
  final String defaultTitleVoiceId;
  @JsonKey(name: 'default_paragraph_voice_id')
  final String defaultParagraphVoiceId;
  @JsonKey(name: 'default_model_id')
  final String defaultModelId;
  @JsonKey(name: 'from_url')
  final dynamic fromUrl;
  @JsonKey(name: 'from_document')
  final dynamic fromDocument;
  @JsonKey(name: 'quality_preset')
  final String? qualityPreset;
  @JsonKey(name: 'title')
  final dynamic title;
  @JsonKey(name: 'author')
  final dynamic author;
  @JsonKey(name: 'description')
  final dynamic description;
  @JsonKey(name: 'genres', defaultValue: <String>[])
  final List<String>? genres;
  @JsonKey(name: 'target_audience')
  final dynamic targetAudience;
  @JsonKey(name: 'language')
  final dynamic language;
  @JsonKey(name: 'content_type')
  final dynamic contentType;
  @JsonKey(name: 'original_publication_date')
  final dynamic originalPublicationDate;
  @JsonKey(name: 'mature_content')
  final dynamic matureContent;
  @JsonKey(name: 'isbn_number')
  final dynamic isbnNumber;
  @JsonKey(name: 'acx_volume_normalization', defaultValue: false)
  final bool? acxVolumeNormalization;
  @JsonKey(name: 'volume_normalization', defaultValue: false)
  final bool? volumeNormalization;
  @JsonKey(name: 'pronunciation_dictionary_locators', defaultValue: <String>[])
  final List<String>? pronunciationDictionaryLocators;
  @JsonKey(name: 'callback_url')
  final dynamic callbackUrl;
  @JsonKey(name: 'fiction')
  final dynamic fiction;
  @JsonKey(name: 'apply_text_normalization')
  final dynamic applyTextNormalization;
  @JsonKey(name: 'auto_convert', defaultValue: false)
  final bool? autoConvert;
  @JsonKey(name: 'auto_assign_voices')
  final dynamic autoAssignVoices;
  @JsonKey(name: 'source_type')
  final dynamic sourceType;
  static const fromJsonFactory =
      _$BodyCreateStudioProjectV1StudioProjectsPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyCreateStudioProjectV1StudioProjectsPost &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.defaultTitleVoiceId, defaultTitleVoiceId) ||
                const DeepCollectionEquality()
                    .equals(other.defaultTitleVoiceId, defaultTitleVoiceId)) &&
            (identical(other.defaultParagraphVoiceId, defaultParagraphVoiceId) ||
                const DeepCollectionEquality().equals(
                    other.defaultParagraphVoiceId, defaultParagraphVoiceId)) &&
            (identical(other.defaultModelId, defaultModelId) ||
                const DeepCollectionEquality()
                    .equals(other.defaultModelId, defaultModelId)) &&
            (identical(other.fromUrl, fromUrl) ||
                const DeepCollectionEquality()
                    .equals(other.fromUrl, fromUrl)) &&
            (identical(other.fromDocument, fromDocument) ||
                const DeepCollectionEquality()
                    .equals(other.fromDocument, fromDocument)) &&
            (identical(other.qualityPreset, qualityPreset) ||
                const DeepCollectionEquality()
                    .equals(other.qualityPreset, qualityPreset)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.author, author) ||
                const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.genres, genres) ||
                const DeepCollectionEquality().equals(other.genres, genres)) &&
            (identical(other.targetAudience, targetAudience) ||
                const DeepCollectionEquality()
                    .equals(other.targetAudience, targetAudience)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality()
                    .equals(other.contentType, contentType)) &&
            (identical(other.originalPublicationDate, originalPublicationDate) ||
                const DeepCollectionEquality().equals(
                    other.originalPublicationDate, originalPublicationDate)) &&
            (identical(other.matureContent, matureContent) ||
                const DeepCollectionEquality()
                    .equals(other.matureContent, matureContent)) &&
            (identical(other.isbnNumber, isbnNumber) ||
                const DeepCollectionEquality()
                    .equals(other.isbnNumber, isbnNumber)) &&
            (identical(other.acxVolumeNormalization, acxVolumeNormalization) ||
                const DeepCollectionEquality().equals(other.acxVolumeNormalization, acxVolumeNormalization)) &&
            (identical(other.volumeNormalization, volumeNormalization) || const DeepCollectionEquality().equals(other.volumeNormalization, volumeNormalization)) &&
            (identical(other.pronunciationDictionaryLocators, pronunciationDictionaryLocators) || const DeepCollectionEquality().equals(other.pronunciationDictionaryLocators, pronunciationDictionaryLocators)) &&
            (identical(other.callbackUrl, callbackUrl) || const DeepCollectionEquality().equals(other.callbackUrl, callbackUrl)) &&
            (identical(other.fiction, fiction) || const DeepCollectionEquality().equals(other.fiction, fiction)) &&
            (identical(other.applyTextNormalization, applyTextNormalization) || const DeepCollectionEquality().equals(other.applyTextNormalization, applyTextNormalization)) &&
            (identical(other.autoConvert, autoConvert) || const DeepCollectionEquality().equals(other.autoConvert, autoConvert)) &&
            (identical(other.autoAssignVoices, autoAssignVoices) || const DeepCollectionEquality().equals(other.autoAssignVoices, autoAssignVoices)) &&
            (identical(other.sourceType, sourceType) || const DeepCollectionEquality().equals(other.sourceType, sourceType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(defaultTitleVoiceId) ^
      const DeepCollectionEquality().hash(defaultParagraphVoiceId) ^
      const DeepCollectionEquality().hash(defaultModelId) ^
      const DeepCollectionEquality().hash(fromUrl) ^
      const DeepCollectionEquality().hash(fromDocument) ^
      const DeepCollectionEquality().hash(qualityPreset) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(genres) ^
      const DeepCollectionEquality().hash(targetAudience) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(originalPublicationDate) ^
      const DeepCollectionEquality().hash(matureContent) ^
      const DeepCollectionEquality().hash(isbnNumber) ^
      const DeepCollectionEquality().hash(acxVolumeNormalization) ^
      const DeepCollectionEquality().hash(volumeNormalization) ^
      const DeepCollectionEquality().hash(pronunciationDictionaryLocators) ^
      const DeepCollectionEquality().hash(callbackUrl) ^
      const DeepCollectionEquality().hash(fiction) ^
      const DeepCollectionEquality().hash(applyTextNormalization) ^
      const DeepCollectionEquality().hash(autoConvert) ^
      const DeepCollectionEquality().hash(autoAssignVoices) ^
      const DeepCollectionEquality().hash(sourceType) ^
      runtimeType.hashCode;
}

extension $BodyCreateStudioProjectV1StudioProjectsPostExtension
    on BodyCreateStudioProjectV1StudioProjectsPost {
  BodyCreateStudioProjectV1StudioProjectsPost copyWith(
      {String? name,
      String? defaultTitleVoiceId,
      String? defaultParagraphVoiceId,
      String? defaultModelId,
      dynamic fromUrl,
      dynamic fromDocument,
      String? qualityPreset,
      dynamic title,
      dynamic author,
      dynamic description,
      List<String>? genres,
      dynamic targetAudience,
      dynamic language,
      dynamic contentType,
      dynamic originalPublicationDate,
      dynamic matureContent,
      dynamic isbnNumber,
      bool? acxVolumeNormalization,
      bool? volumeNormalization,
      List<String>? pronunciationDictionaryLocators,
      dynamic callbackUrl,
      dynamic fiction,
      dynamic applyTextNormalization,
      bool? autoConvert,
      dynamic autoAssignVoices,
      dynamic sourceType}) {
    return BodyCreateStudioProjectV1StudioProjectsPost(
        name: name ?? this.name,
        defaultTitleVoiceId: defaultTitleVoiceId ?? this.defaultTitleVoiceId,
        defaultParagraphVoiceId:
            defaultParagraphVoiceId ?? this.defaultParagraphVoiceId,
        defaultModelId: defaultModelId ?? this.defaultModelId,
        fromUrl: fromUrl ?? this.fromUrl,
        fromDocument: fromDocument ?? this.fromDocument,
        qualityPreset: qualityPreset ?? this.qualityPreset,
        title: title ?? this.title,
        author: author ?? this.author,
        description: description ?? this.description,
        genres: genres ?? this.genres,
        targetAudience: targetAudience ?? this.targetAudience,
        language: language ?? this.language,
        contentType: contentType ?? this.contentType,
        originalPublicationDate:
            originalPublicationDate ?? this.originalPublicationDate,
        matureContent: matureContent ?? this.matureContent,
        isbnNumber: isbnNumber ?? this.isbnNumber,
        acxVolumeNormalization:
            acxVolumeNormalization ?? this.acxVolumeNormalization,
        volumeNormalization: volumeNormalization ?? this.volumeNormalization,
        pronunciationDictionaryLocators: pronunciationDictionaryLocators ??
            this.pronunciationDictionaryLocators,
        callbackUrl: callbackUrl ?? this.callbackUrl,
        fiction: fiction ?? this.fiction,
        applyTextNormalization:
            applyTextNormalization ?? this.applyTextNormalization,
        autoConvert: autoConvert ?? this.autoConvert,
        autoAssignVoices: autoAssignVoices ?? this.autoAssignVoices,
        sourceType: sourceType ?? this.sourceType);
  }

  BodyCreateStudioProjectV1StudioProjectsPost copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String>? defaultTitleVoiceId,
      Wrapped<String>? defaultParagraphVoiceId,
      Wrapped<String>? defaultModelId,
      Wrapped<dynamic>? fromUrl,
      Wrapped<dynamic>? fromDocument,
      Wrapped<String?>? qualityPreset,
      Wrapped<dynamic>? title,
      Wrapped<dynamic>? author,
      Wrapped<dynamic>? description,
      Wrapped<List<String>?>? genres,
      Wrapped<dynamic>? targetAudience,
      Wrapped<dynamic>? language,
      Wrapped<dynamic>? contentType,
      Wrapped<dynamic>? originalPublicationDate,
      Wrapped<dynamic>? matureContent,
      Wrapped<dynamic>? isbnNumber,
      Wrapped<bool?>? acxVolumeNormalization,
      Wrapped<bool?>? volumeNormalization,
      Wrapped<List<String>?>? pronunciationDictionaryLocators,
      Wrapped<dynamic>? callbackUrl,
      Wrapped<dynamic>? fiction,
      Wrapped<dynamic>? applyTextNormalization,
      Wrapped<bool?>? autoConvert,
      Wrapped<dynamic>? autoAssignVoices,
      Wrapped<dynamic>? sourceType}) {
    return BodyCreateStudioProjectV1StudioProjectsPost(
        name: (name != null ? name.value : this.name),
        defaultTitleVoiceId: (defaultTitleVoiceId != null
            ? defaultTitleVoiceId.value
            : this.defaultTitleVoiceId),
        defaultParagraphVoiceId: (defaultParagraphVoiceId != null
            ? defaultParagraphVoiceId.value
            : this.defaultParagraphVoiceId),
        defaultModelId: (defaultModelId != null
            ? defaultModelId.value
            : this.defaultModelId),
        fromUrl: (fromUrl != null ? fromUrl.value : this.fromUrl),
        fromDocument:
            (fromDocument != null ? fromDocument.value : this.fromDocument),
        qualityPreset:
            (qualityPreset != null ? qualityPreset.value : this.qualityPreset),
        title: (title != null ? title.value : this.title),
        author: (author != null ? author.value : this.author),
        description:
            (description != null ? description.value : this.description),
        genres: (genres != null ? genres.value : this.genres),
        targetAudience: (targetAudience != null
            ? targetAudience.value
            : this.targetAudience),
        language: (language != null ? language.value : this.language),
        contentType:
            (contentType != null ? contentType.value : this.contentType),
        originalPublicationDate: (originalPublicationDate != null
            ? originalPublicationDate.value
            : this.originalPublicationDate),
        matureContent:
            (matureContent != null ? matureContent.value : this.matureContent),
        isbnNumber: (isbnNumber != null ? isbnNumber.value : this.isbnNumber),
        acxVolumeNormalization: (acxVolumeNormalization != null
            ? acxVolumeNormalization.value
            : this.acxVolumeNormalization),
        volumeNormalization: (volumeNormalization != null
            ? volumeNormalization.value
            : this.volumeNormalization),
        pronunciationDictionaryLocators:
            (pronunciationDictionaryLocators != null
                ? pronunciationDictionaryLocators.value
                : this.pronunciationDictionaryLocators),
        callbackUrl:
            (callbackUrl != null ? callbackUrl.value : this.callbackUrl),
        fiction: (fiction != null ? fiction.value : this.fiction),
        applyTextNormalization: (applyTextNormalization != null
            ? applyTextNormalization.value
            : this.applyTextNormalization),
        autoConvert:
            (autoConvert != null ? autoConvert.value : this.autoConvert),
        autoAssignVoices: (autoAssignVoices != null
            ? autoAssignVoices.value
            : this.autoAssignVoices),
        sourceType: (sourceType != null ? sourceType.value : this.sourceType));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyCreateURLDocumentV1ConvaiKnowledgeBaseUrlPost {
  const BodyCreateURLDocumentV1ConvaiKnowledgeBaseUrlPost({
    required this.url,
    this.name,
  });

  factory BodyCreateURLDocumentV1ConvaiKnowledgeBaseUrlPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyCreateURLDocumentV1ConvaiKnowledgeBaseUrlPostFromJson(json);

  static const toJsonFactory =
      _$BodyCreateURLDocumentV1ConvaiKnowledgeBaseUrlPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyCreateURLDocumentV1ConvaiKnowledgeBaseUrlPostToJson(this);

  @JsonKey(name: 'url')
  final String url;
  @JsonKey(name: 'name')
  final dynamic name;
  static const fromJsonFactory =
      _$BodyCreateURLDocumentV1ConvaiKnowledgeBaseUrlPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyCreateURLDocumentV1ConvaiKnowledgeBaseUrlPost &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(name) ^
      runtimeType.hashCode;
}

extension $BodyCreateURLDocumentV1ConvaiKnowledgeBaseUrlPostExtension
    on BodyCreateURLDocumentV1ConvaiKnowledgeBaseUrlPost {
  BodyCreateURLDocumentV1ConvaiKnowledgeBaseUrlPost copyWith(
      {String? url, dynamic name}) {
    return BodyCreateURLDocumentV1ConvaiKnowledgeBaseUrlPost(
        url: url ?? this.url, name: name ?? this.name);
  }

  BodyCreateURLDocumentV1ConvaiKnowledgeBaseUrlPost copyWithWrapped(
      {Wrapped<String>? url, Wrapped<dynamic>? name}) {
    return BodyCreateURLDocumentV1ConvaiKnowledgeBaseUrlPost(
        url: (url != null ? url.value : this.url),
        name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyCreateANewVoiceFromVoicePreviewV1TextToVoiceCreateVoiceFromPreviewPost {
  const BodyCreateANewVoiceFromVoicePreviewV1TextToVoiceCreateVoiceFromPreviewPost({
    required this.voiceName,
    required this.voiceDescription,
    required this.generatedVoiceId,
    this.labels,
    this.playedNotSelectedVoiceIds,
  });

  factory BodyCreateANewVoiceFromVoicePreviewV1TextToVoiceCreateVoiceFromPreviewPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyCreateANewVoiceFromVoicePreviewV1TextToVoiceCreateVoiceFromPreviewPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyCreateANewVoiceFromVoicePreviewV1TextToVoiceCreateVoiceFromPreviewPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyCreateANewVoiceFromVoicePreviewV1TextToVoiceCreateVoiceFromPreviewPostToJson(
          this);

  @JsonKey(name: 'voice_name')
  final String voiceName;
  @JsonKey(name: 'voice_description')
  final String voiceDescription;
  @JsonKey(name: 'generated_voice_id')
  final String generatedVoiceId;
  @JsonKey(name: 'labels')
  final dynamic labels;
  @JsonKey(name: 'played_not_selected_voice_ids')
  final dynamic playedNotSelectedVoiceIds;
  static const fromJsonFactory =
      _$BodyCreateANewVoiceFromVoicePreviewV1TextToVoiceCreateVoiceFromPreviewPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyCreateANewVoiceFromVoicePreviewV1TextToVoiceCreateVoiceFromPreviewPost &&
            (identical(other.voiceName, voiceName) ||
                const DeepCollectionEquality()
                    .equals(other.voiceName, voiceName)) &&
            (identical(other.voiceDescription, voiceDescription) ||
                const DeepCollectionEquality()
                    .equals(other.voiceDescription, voiceDescription)) &&
            (identical(other.generatedVoiceId, generatedVoiceId) ||
                const DeepCollectionEquality()
                    .equals(other.generatedVoiceId, generatedVoiceId)) &&
            (identical(other.labels, labels) ||
                const DeepCollectionEquality().equals(other.labels, labels)) &&
            (identical(other.playedNotSelectedVoiceIds,
                    playedNotSelectedVoiceIds) ||
                const DeepCollectionEquality().equals(
                    other.playedNotSelectedVoiceIds,
                    playedNotSelectedVoiceIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(voiceName) ^
      const DeepCollectionEquality().hash(voiceDescription) ^
      const DeepCollectionEquality().hash(generatedVoiceId) ^
      const DeepCollectionEquality().hash(labels) ^
      const DeepCollectionEquality().hash(playedNotSelectedVoiceIds) ^
      runtimeType.hashCode;
}

extension $BodyCreateANewVoiceFromVoicePreviewV1TextToVoiceCreateVoiceFromPreviewPostExtension
    on BodyCreateANewVoiceFromVoicePreviewV1TextToVoiceCreateVoiceFromPreviewPost {
  BodyCreateANewVoiceFromVoicePreviewV1TextToVoiceCreateVoiceFromPreviewPost
      copyWith(
          {String? voiceName,
          String? voiceDescription,
          String? generatedVoiceId,
          dynamic labels,
          dynamic playedNotSelectedVoiceIds}) {
    return BodyCreateANewVoiceFromVoicePreviewV1TextToVoiceCreateVoiceFromPreviewPost(
        voiceName: voiceName ?? this.voiceName,
        voiceDescription: voiceDescription ?? this.voiceDescription,
        generatedVoiceId: generatedVoiceId ?? this.generatedVoiceId,
        labels: labels ?? this.labels,
        playedNotSelectedVoiceIds:
            playedNotSelectedVoiceIds ?? this.playedNotSelectedVoiceIds);
  }

  BodyCreateANewVoiceFromVoicePreviewV1TextToVoiceCreateVoiceFromPreviewPost
      copyWithWrapped(
          {Wrapped<String>? voiceName,
          Wrapped<String>? voiceDescription,
          Wrapped<String>? generatedVoiceId,
          Wrapped<dynamic>? labels,
          Wrapped<dynamic>? playedNotSelectedVoiceIds}) {
    return BodyCreateANewVoiceFromVoicePreviewV1TextToVoiceCreateVoiceFromPreviewPost(
        voiceName: (voiceName != null ? voiceName.value : this.voiceName),
        voiceDescription: (voiceDescription != null
            ? voiceDescription.value
            : this.voiceDescription),
        generatedVoiceId: (generatedVoiceId != null
            ? generatedVoiceId.value
            : this.generatedVoiceId),
        labels: (labels != null ? labels.value : this.labels),
        playedNotSelectedVoiceIds: (playedNotSelectedVoiceIds != null
            ? playedNotSelectedVoiceIds.value
            : this.playedNotSelectedVoiceIds));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost {
  const BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost({
    required this.voiceName,
    required this.voiceDescription,
    required this.generatedVoiceId,
    this.playedNotSelectedVoiceIds,
    this.labels,
  });

  factory BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostFromJson(
          json);

  static const toJsonFactory =
      _$BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostToJson(
          this);

  @JsonKey(name: 'voice_name')
  final String voiceName;
  @JsonKey(name: 'voice_description')
  final String voiceDescription;
  @JsonKey(name: 'generated_voice_id')
  final String generatedVoiceId;
  @JsonKey(name: 'played_not_selected_voice_ids')
  final dynamic playedNotSelectedVoiceIds;
  @JsonKey(name: 'labels')
  final dynamic labels;
  static const fromJsonFactory =
      _$BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost &&
            (identical(other.voiceName, voiceName) ||
                const DeepCollectionEquality()
                    .equals(other.voiceName, voiceName)) &&
            (identical(other.voiceDescription, voiceDescription) ||
                const DeepCollectionEquality()
                    .equals(other.voiceDescription, voiceDescription)) &&
            (identical(other.generatedVoiceId, generatedVoiceId) ||
                const DeepCollectionEquality()
                    .equals(other.generatedVoiceId, generatedVoiceId)) &&
            (identical(other.playedNotSelectedVoiceIds,
                    playedNotSelectedVoiceIds) ||
                const DeepCollectionEquality().equals(
                    other.playedNotSelectedVoiceIds,
                    playedNotSelectedVoiceIds)) &&
            (identical(other.labels, labels) ||
                const DeepCollectionEquality().equals(other.labels, labels)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(voiceName) ^
      const DeepCollectionEquality().hash(voiceDescription) ^
      const DeepCollectionEquality().hash(generatedVoiceId) ^
      const DeepCollectionEquality().hash(playedNotSelectedVoiceIds) ^
      const DeepCollectionEquality().hash(labels) ^
      runtimeType.hashCode;
}

extension $BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePostExtension
    on BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost {
  BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost copyWith(
      {String? voiceName,
      String? voiceDescription,
      String? generatedVoiceId,
      dynamic playedNotSelectedVoiceIds,
      dynamic labels}) {
    return BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost(
        voiceName: voiceName ?? this.voiceName,
        voiceDescription: voiceDescription ?? this.voiceDescription,
        generatedVoiceId: generatedVoiceId ?? this.generatedVoiceId,
        playedNotSelectedVoiceIds:
            playedNotSelectedVoiceIds ?? this.playedNotSelectedVoiceIds,
        labels: labels ?? this.labels);
  }

  BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost
      copyWithWrapped(
          {Wrapped<String>? voiceName,
          Wrapped<String>? voiceDescription,
          Wrapped<String>? generatedVoiceId,
          Wrapped<dynamic>? playedNotSelectedVoiceIds,
          Wrapped<dynamic>? labels}) {
    return BodyCreateAPreviouslyGeneratedVoiceV1VoiceGenerationCreateVoicePost(
        voiceName: (voiceName != null ? voiceName.value : this.voiceName),
        voiceDescription: (voiceDescription != null
            ? voiceDescription.value
            : this.voiceDescription),
        generatedVoiceId: (generatedVoiceId != null
            ? generatedVoiceId.value
            : this.generatedVoiceId),
        playedNotSelectedVoiceIds: (playedNotSelectedVoiceIds != null
            ? playedNotSelectedVoiceIds.value
            : this.playedNotSelectedVoiceIds),
        labels: (labels != null ? labels.value : this.labels));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyCreateChapterV1StudioProjectsProjectIdChaptersPost {
  const BodyCreateChapterV1StudioProjectsProjectIdChaptersPost({
    required this.name,
    this.fromUrl,
  });

  factory BodyCreateChapterV1StudioProjectsProjectIdChaptersPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyCreateChapterV1StudioProjectsProjectIdChaptersPostFromJson(json);

  static const toJsonFactory =
      _$BodyCreateChapterV1StudioProjectsProjectIdChaptersPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyCreateChapterV1StudioProjectsProjectIdChaptersPostToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'from_url')
  final dynamic fromUrl;
  static const fromJsonFactory =
      _$BodyCreateChapterV1StudioProjectsProjectIdChaptersPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyCreateChapterV1StudioProjectsProjectIdChaptersPost &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.fromUrl, fromUrl) ||
                const DeepCollectionEquality().equals(other.fromUrl, fromUrl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(fromUrl) ^
      runtimeType.hashCode;
}

extension $BodyCreateChapterV1StudioProjectsProjectIdChaptersPostExtension
    on BodyCreateChapterV1StudioProjectsProjectIdChaptersPost {
  BodyCreateChapterV1StudioProjectsProjectIdChaptersPost copyWith(
      {String? name, dynamic fromUrl}) {
    return BodyCreateChapterV1StudioProjectsProjectIdChaptersPost(
        name: name ?? this.name, fromUrl: fromUrl ?? this.fromUrl);
  }

  BodyCreateChapterV1StudioProjectsProjectIdChaptersPost copyWithWrapped(
      {Wrapped<String>? name, Wrapped<dynamic>? fromUrl}) {
    return BodyCreateChapterV1StudioProjectsProjectIdChaptersPost(
        name: (name != null ? name.value : this.name),
        fromUrl: (fromUrl != null ? fromUrl.value : this.fromUrl));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyCreateFileDocumentV1ConvaiKnowledgeBaseFilePost {
  const BodyCreateFileDocumentV1ConvaiKnowledgeBaseFilePost({
    required this.file,
    this.name,
  });

  factory BodyCreateFileDocumentV1ConvaiKnowledgeBaseFilePost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyCreateFileDocumentV1ConvaiKnowledgeBaseFilePostFromJson(json);

  static const toJsonFactory =
      _$BodyCreateFileDocumentV1ConvaiKnowledgeBaseFilePostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyCreateFileDocumentV1ConvaiKnowledgeBaseFilePostToJson(this);

  @JsonKey(name: 'file')
  final String file;
  @JsonKey(name: 'name')
  final dynamic name;
  static const fromJsonFactory =
      _$BodyCreateFileDocumentV1ConvaiKnowledgeBaseFilePostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyCreateFileDocumentV1ConvaiKnowledgeBaseFilePost &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(file) ^
      const DeepCollectionEquality().hash(name) ^
      runtimeType.hashCode;
}

extension $BodyCreateFileDocumentV1ConvaiKnowledgeBaseFilePostExtension
    on BodyCreateFileDocumentV1ConvaiKnowledgeBaseFilePost {
  BodyCreateFileDocumentV1ConvaiKnowledgeBaseFilePost copyWith(
      {String? file, dynamic name}) {
    return BodyCreateFileDocumentV1ConvaiKnowledgeBaseFilePost(
        file: file ?? this.file, name: name ?? this.name);
  }

  BodyCreateFileDocumentV1ConvaiKnowledgeBaseFilePost copyWithWrapped(
      {Wrapped<String>? file, Wrapped<dynamic>? name}) {
    return BodyCreateFileDocumentV1ConvaiKnowledgeBaseFilePost(
        file: (file != null ? file.value : this.file),
        name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyCreateForcedAlignmentV1ForcedAlignmentPost {
  const BodyCreateForcedAlignmentV1ForcedAlignmentPost({
    required this.file,
    required this.text,
    this.enabledSpooledFile,
  });

  factory BodyCreateForcedAlignmentV1ForcedAlignmentPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyCreateForcedAlignmentV1ForcedAlignmentPostFromJson(json);

  static const toJsonFactory =
      _$BodyCreateForcedAlignmentV1ForcedAlignmentPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyCreateForcedAlignmentV1ForcedAlignmentPostToJson(this);

  @JsonKey(name: 'file')
  final String file;
  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'enabled_spooled_file', defaultValue: false)
  final bool? enabledSpooledFile;
  static const fromJsonFactory =
      _$BodyCreateForcedAlignmentV1ForcedAlignmentPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyCreateForcedAlignmentV1ForcedAlignmentPost &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.enabledSpooledFile, enabledSpooledFile) ||
                const DeepCollectionEquality()
                    .equals(other.enabledSpooledFile, enabledSpooledFile)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(file) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(enabledSpooledFile) ^
      runtimeType.hashCode;
}

extension $BodyCreateForcedAlignmentV1ForcedAlignmentPostExtension
    on BodyCreateForcedAlignmentV1ForcedAlignmentPost {
  BodyCreateForcedAlignmentV1ForcedAlignmentPost copyWith(
      {String? file, String? text, bool? enabledSpooledFile}) {
    return BodyCreateForcedAlignmentV1ForcedAlignmentPost(
        file: file ?? this.file,
        text: text ?? this.text,
        enabledSpooledFile: enabledSpooledFile ?? this.enabledSpooledFile);
  }

  BodyCreateForcedAlignmentV1ForcedAlignmentPost copyWithWrapped(
      {Wrapped<String>? file,
      Wrapped<String>? text,
      Wrapped<bool?>? enabledSpooledFile}) {
    return BodyCreateForcedAlignmentV1ForcedAlignmentPost(
        file: (file != null ? file.value : this.file),
        text: (text != null ? text.value : this.text),
        enabledSpooledFile: (enabledSpooledFile != null
            ? enabledSpooledFile.value
            : this.enabledSpooledFile));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyCreatePodcastV1ProjectsPodcastCreatePost {
  const BodyCreatePodcastV1ProjectsPodcastCreatePost({
    required this.modelId,
    required this.mode,
    required this.source,
    this.qualityPreset,
    this.durationScale,
    this.language,
    this.highlights,
    this.callbackUrl,
  });

  factory BodyCreatePodcastV1ProjectsPodcastCreatePost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyCreatePodcastV1ProjectsPodcastCreatePostFromJson(json);

  static const toJsonFactory =
      _$BodyCreatePodcastV1ProjectsPodcastCreatePostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyCreatePodcastV1ProjectsPodcastCreatePostToJson(this);

  @JsonKey(name: 'model_id')
  final String modelId;
  @JsonKey(name: 'mode')
  final dynamic mode;
  @JsonKey(name: 'source')
  final dynamic source;
  @JsonKey(
    name: 'quality_preset',
    toJson:
        bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPresetNullableToJson,
    fromJson:
        bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPresetQualityPresetNullableFromJson,
  )
  final enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset?
      qualityPreset;
  static enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset?
      bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPresetQualityPresetNullableFromJson(
              Object? value) =>
          bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPresetNullableFromJson(
              value,
              enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset
                  .standard);

  @JsonKey(
    name: 'duration_scale',
    toJson:
        bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScaleNullableToJson,
    fromJson:
        bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScaleDurationScaleNullableFromJson,
  )
  final enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale?
      durationScale;
  static enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale?
      bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScaleDurationScaleNullableFromJson(
              Object? value) =>
          bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScaleNullableFromJson(
              value,
              enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale
                  .$default);

  @JsonKey(name: 'language')
  final dynamic language;
  @JsonKey(name: 'highlights')
  final dynamic highlights;
  @JsonKey(name: 'callback_url')
  final dynamic callbackUrl;
  static const fromJsonFactory =
      _$BodyCreatePodcastV1ProjectsPodcastCreatePostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyCreatePodcastV1ProjectsPodcastCreatePost &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.mode, mode) ||
                const DeepCollectionEquality().equals(other.mode, mode)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)) &&
            (identical(other.qualityPreset, qualityPreset) ||
                const DeepCollectionEquality()
                    .equals(other.qualityPreset, qualityPreset)) &&
            (identical(other.durationScale, durationScale) ||
                const DeepCollectionEquality()
                    .equals(other.durationScale, durationScale)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.highlights, highlights) ||
                const DeepCollectionEquality()
                    .equals(other.highlights, highlights)) &&
            (identical(other.callbackUrl, callbackUrl) ||
                const DeepCollectionEquality()
                    .equals(other.callbackUrl, callbackUrl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(mode) ^
      const DeepCollectionEquality().hash(source) ^
      const DeepCollectionEquality().hash(qualityPreset) ^
      const DeepCollectionEquality().hash(durationScale) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(highlights) ^
      const DeepCollectionEquality().hash(callbackUrl) ^
      runtimeType.hashCode;
}

extension $BodyCreatePodcastV1ProjectsPodcastCreatePostExtension
    on BodyCreatePodcastV1ProjectsPodcastCreatePost {
  BodyCreatePodcastV1ProjectsPodcastCreatePost copyWith(
      {String? modelId,
      dynamic mode,
      dynamic source,
      enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset?
          qualityPreset,
      enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale?
          durationScale,
      dynamic language,
      dynamic highlights,
      dynamic callbackUrl}) {
    return BodyCreatePodcastV1ProjectsPodcastCreatePost(
        modelId: modelId ?? this.modelId,
        mode: mode ?? this.mode,
        source: source ?? this.source,
        qualityPreset: qualityPreset ?? this.qualityPreset,
        durationScale: durationScale ?? this.durationScale,
        language: language ?? this.language,
        highlights: highlights ?? this.highlights,
        callbackUrl: callbackUrl ?? this.callbackUrl);
  }

  BodyCreatePodcastV1ProjectsPodcastCreatePost copyWithWrapped(
      {Wrapped<String>? modelId,
      Wrapped<dynamic>? mode,
      Wrapped<dynamic>? source,
      Wrapped<enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset?>?
          qualityPreset,
      Wrapped<enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale?>?
          durationScale,
      Wrapped<dynamic>? language,
      Wrapped<dynamic>? highlights,
      Wrapped<dynamic>? callbackUrl}) {
    return BodyCreatePodcastV1ProjectsPodcastCreatePost(
        modelId: (modelId != null ? modelId.value : this.modelId),
        mode: (mode != null ? mode.value : this.mode),
        source: (source != null ? source.value : this.source),
        qualityPreset:
            (qualityPreset != null ? qualityPreset.value : this.qualityPreset),
        durationScale:
            (durationScale != null ? durationScale.value : this.durationScale),
        language: (language != null ? language.value : this.language),
        highlights: (highlights != null ? highlights.value : this.highlights),
        callbackUrl:
            (callbackUrl != null ? callbackUrl.value : this.callbackUrl));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyCreatePodcastV1StudioPodcastsPost {
  const BodyCreatePodcastV1StudioPodcastsPost({
    required this.modelId,
    required this.mode,
    required this.source,
    this.qualityPreset,
    this.durationScale,
    this.language,
    this.highlights,
    this.callbackUrl,
  });

  factory BodyCreatePodcastV1StudioPodcastsPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyCreatePodcastV1StudioPodcastsPostFromJson(json);

  static const toJsonFactory = _$BodyCreatePodcastV1StudioPodcastsPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyCreatePodcastV1StudioPodcastsPostToJson(this);

  @JsonKey(name: 'model_id')
  final String modelId;
  @JsonKey(name: 'mode')
  final dynamic mode;
  @JsonKey(name: 'source')
  final dynamic source;
  @JsonKey(
    name: 'quality_preset',
    toJson: bodyCreatePodcastV1StudioPodcastsPostQualityPresetNullableToJson,
    fromJson:
        bodyCreatePodcastV1StudioPodcastsPostQualityPresetQualityPresetNullableFromJson,
  )
  final enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset? qualityPreset;
  static enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset?
      bodyCreatePodcastV1StudioPodcastsPostQualityPresetQualityPresetNullableFromJson(
              Object? value) =>
          bodyCreatePodcastV1StudioPodcastsPostQualityPresetNullableFromJson(
              value,
              enums
                  .BodyCreatePodcastV1StudioPodcastsPostQualityPreset.standard);

  @JsonKey(
    name: 'duration_scale',
    toJson: bodyCreatePodcastV1StudioPodcastsPostDurationScaleNullableToJson,
    fromJson:
        bodyCreatePodcastV1StudioPodcastsPostDurationScaleDurationScaleNullableFromJson,
  )
  final enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale? durationScale;
  static enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale?
      bodyCreatePodcastV1StudioPodcastsPostDurationScaleDurationScaleNullableFromJson(
              Object? value) =>
          bodyCreatePodcastV1StudioPodcastsPostDurationScaleNullableFromJson(
              value,
              enums
                  .BodyCreatePodcastV1StudioPodcastsPostDurationScale.$default);

  @JsonKey(name: 'language')
  final dynamic language;
  @JsonKey(name: 'highlights')
  final dynamic highlights;
  @JsonKey(name: 'callback_url')
  final dynamic callbackUrl;
  static const fromJsonFactory =
      _$BodyCreatePodcastV1StudioPodcastsPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyCreatePodcastV1StudioPodcastsPost &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.mode, mode) ||
                const DeepCollectionEquality().equals(other.mode, mode)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)) &&
            (identical(other.qualityPreset, qualityPreset) ||
                const DeepCollectionEquality()
                    .equals(other.qualityPreset, qualityPreset)) &&
            (identical(other.durationScale, durationScale) ||
                const DeepCollectionEquality()
                    .equals(other.durationScale, durationScale)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.highlights, highlights) ||
                const DeepCollectionEquality()
                    .equals(other.highlights, highlights)) &&
            (identical(other.callbackUrl, callbackUrl) ||
                const DeepCollectionEquality()
                    .equals(other.callbackUrl, callbackUrl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(mode) ^
      const DeepCollectionEquality().hash(source) ^
      const DeepCollectionEquality().hash(qualityPreset) ^
      const DeepCollectionEquality().hash(durationScale) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(highlights) ^
      const DeepCollectionEquality().hash(callbackUrl) ^
      runtimeType.hashCode;
}

extension $BodyCreatePodcastV1StudioPodcastsPostExtension
    on BodyCreatePodcastV1StudioPodcastsPost {
  BodyCreatePodcastV1StudioPodcastsPost copyWith(
      {String? modelId,
      dynamic mode,
      dynamic source,
      enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset? qualityPreset,
      enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale? durationScale,
      dynamic language,
      dynamic highlights,
      dynamic callbackUrl}) {
    return BodyCreatePodcastV1StudioPodcastsPost(
        modelId: modelId ?? this.modelId,
        mode: mode ?? this.mode,
        source: source ?? this.source,
        qualityPreset: qualityPreset ?? this.qualityPreset,
        durationScale: durationScale ?? this.durationScale,
        language: language ?? this.language,
        highlights: highlights ?? this.highlights,
        callbackUrl: callbackUrl ?? this.callbackUrl);
  }

  BodyCreatePodcastV1StudioPodcastsPost copyWithWrapped(
      {Wrapped<String>? modelId,
      Wrapped<dynamic>? mode,
      Wrapped<dynamic>? source,
      Wrapped<enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset?>?
          qualityPreset,
      Wrapped<enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale?>?
          durationScale,
      Wrapped<dynamic>? language,
      Wrapped<dynamic>? highlights,
      Wrapped<dynamic>? callbackUrl}) {
    return BodyCreatePodcastV1StudioPodcastsPost(
        modelId: (modelId != null ? modelId.value : this.modelId),
        mode: (mode != null ? mode.value : this.mode),
        source: (source != null ? source.value : this.source),
        qualityPreset:
            (qualityPreset != null ? qualityPreset.value : this.qualityPreset),
        durationScale:
            (durationScale != null ? durationScale.value : this.durationScale),
        language: (language != null ? language.value : this.language),
        highlights: (highlights != null ? highlights.value : this.highlights),
        callbackUrl:
            (callbackUrl != null ? callbackUrl.value : this.callbackUrl));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost {
  const BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost({
    required this.text,
    this.name,
  });

  factory BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPostFromJson(json);

  static const toJsonFactory =
      _$BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPostToJson(this);

  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'name')
  final dynamic name;
  static const fromJsonFactory =
      _$BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(name) ^
      runtimeType.hashCode;
}

extension $BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPostExtension
    on BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost {
  BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost copyWith(
      {String? text, dynamic name}) {
    return BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost(
        text: text ?? this.text, name: name ?? this.name);
  }

  BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost copyWithWrapped(
      {Wrapped<String>? text, Wrapped<dynamic>? name}) {
    return BodyCreateTextDocumentV1ConvaiKnowledgeBaseTextPost(
        text: (text != null ? text.value : this.text),
        name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyCreatesAudioNativeEnabledProjectV1AudioNativePost {
  const BodyCreatesAudioNativeEnabledProjectV1AudioNativePost({
    required this.name,
    this.image,
    this.author,
    this.title,
    this.small,
    this.textColor,
    this.backgroundColor,
    this.sessionization,
    this.voiceId,
    this.modelId,
    this.file,
    this.autoConvert,
  });

  factory BodyCreatesAudioNativeEnabledProjectV1AudioNativePost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyCreatesAudioNativeEnabledProjectV1AudioNativePostFromJson(json);

  static const toJsonFactory =
      _$BodyCreatesAudioNativeEnabledProjectV1AudioNativePostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyCreatesAudioNativeEnabledProjectV1AudioNativePostToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'image')
  @deprecated
  final dynamic image;
  @JsonKey(name: 'author')
  final dynamic author;
  @JsonKey(name: 'title')
  final dynamic title;
  @JsonKey(name: 'small', defaultValue: false)
  @deprecated
  final bool? small;
  @JsonKey(name: 'text_color')
  final dynamic textColor;
  @JsonKey(name: 'background_color')
  final dynamic backgroundColor;
  @JsonKey(name: 'sessionization')
  @deprecated
  final int? sessionization;
  @JsonKey(name: 'voice_id')
  final dynamic voiceId;
  @JsonKey(name: 'model_id')
  final dynamic modelId;
  @JsonKey(name: 'file')
  final String? file;
  @JsonKey(name: 'auto_convert', defaultValue: false)
  final bool? autoConvert;
  static const fromJsonFactory =
      _$BodyCreatesAudioNativeEnabledProjectV1AudioNativePostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyCreatesAudioNativeEnabledProjectV1AudioNativePost &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.image, image) ||
                const DeepCollectionEquality().equals(other.image, image)) &&
            (identical(other.author, author) ||
                const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.small, small) ||
                const DeepCollectionEquality().equals(other.small, small)) &&
            (identical(other.textColor, textColor) ||
                const DeepCollectionEquality()
                    .equals(other.textColor, textColor)) &&
            (identical(other.backgroundColor, backgroundColor) ||
                const DeepCollectionEquality()
                    .equals(other.backgroundColor, backgroundColor)) &&
            (identical(other.sessionization, sessionization) ||
                const DeepCollectionEquality()
                    .equals(other.sessionization, sessionization)) &&
            (identical(other.voiceId, voiceId) ||
                const DeepCollectionEquality()
                    .equals(other.voiceId, voiceId)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)) &&
            (identical(other.autoConvert, autoConvert) ||
                const DeepCollectionEquality()
                    .equals(other.autoConvert, autoConvert)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(image) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(small) ^
      const DeepCollectionEquality().hash(textColor) ^
      const DeepCollectionEquality().hash(backgroundColor) ^
      const DeepCollectionEquality().hash(sessionization) ^
      const DeepCollectionEquality().hash(voiceId) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(file) ^
      const DeepCollectionEquality().hash(autoConvert) ^
      runtimeType.hashCode;
}

extension $BodyCreatesAudioNativeEnabledProjectV1AudioNativePostExtension
    on BodyCreatesAudioNativeEnabledProjectV1AudioNativePost {
  BodyCreatesAudioNativeEnabledProjectV1AudioNativePost copyWith(
      {String? name,
      dynamic image,
      dynamic author,
      dynamic title,
      bool? small,
      dynamic textColor,
      dynamic backgroundColor,
      int? sessionization,
      dynamic voiceId,
      dynamic modelId,
      String? file,
      bool? autoConvert}) {
    return BodyCreatesAudioNativeEnabledProjectV1AudioNativePost(
        name: name ?? this.name,
        image: image ?? this.image,
        author: author ?? this.author,
        title: title ?? this.title,
        small: small ?? this.small,
        textColor: textColor ?? this.textColor,
        backgroundColor: backgroundColor ?? this.backgroundColor,
        sessionization: sessionization ?? this.sessionization,
        voiceId: voiceId ?? this.voiceId,
        modelId: modelId ?? this.modelId,
        file: file ?? this.file,
        autoConvert: autoConvert ?? this.autoConvert);
  }

  BodyCreatesAudioNativeEnabledProjectV1AudioNativePost copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<dynamic>? image,
      Wrapped<dynamic>? author,
      Wrapped<dynamic>? title,
      Wrapped<bool?>? small,
      Wrapped<dynamic>? textColor,
      Wrapped<dynamic>? backgroundColor,
      Wrapped<int?>? sessionization,
      Wrapped<dynamic>? voiceId,
      Wrapped<dynamic>? modelId,
      Wrapped<String?>? file,
      Wrapped<bool?>? autoConvert}) {
    return BodyCreatesAudioNativeEnabledProjectV1AudioNativePost(
        name: (name != null ? name.value : this.name),
        image: (image != null ? image.value : this.image),
        author: (author != null ? author.value : this.author),
        title: (title != null ? title.value : this.title),
        small: (small != null ? small.value : this.small),
        textColor: (textColor != null ? textColor.value : this.textColor),
        backgroundColor: (backgroundColor != null
            ? backgroundColor.value
            : this.backgroundColor),
        sessionization: (sessionization != null
            ? sessionization.value
            : this.sessionization),
        voiceId: (voiceId != null ? voiceId.value : this.voiceId),
        modelId: (modelId != null ? modelId.value : this.modelId),
        file: (file != null ? file.value : this.file),
        autoConvert:
            (autoConvert != null ? autoConvert.value : this.autoConvert));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyDeleteExistingInvitationV1WorkspaceInvitesDelete {
  const BodyDeleteExistingInvitationV1WorkspaceInvitesDelete({
    required this.email,
  });

  factory BodyDeleteExistingInvitationV1WorkspaceInvitesDelete.fromJson(
          Map<String, dynamic> json) =>
      _$BodyDeleteExistingInvitationV1WorkspaceInvitesDeleteFromJson(json);

  static const toJsonFactory =
      _$BodyDeleteExistingInvitationV1WorkspaceInvitesDeleteToJson;
  Map<String, dynamic> toJson() =>
      _$BodyDeleteExistingInvitationV1WorkspaceInvitesDeleteToJson(this);

  @JsonKey(name: 'email')
  final String email;
  static const fromJsonFactory =
      _$BodyDeleteExistingInvitationV1WorkspaceInvitesDeleteFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyDeleteExistingInvitationV1WorkspaceInvitesDelete &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(email) ^ runtimeType.hashCode;
}

extension $BodyDeleteExistingInvitationV1WorkspaceInvitesDeleteExtension
    on BodyDeleteExistingInvitationV1WorkspaceInvitesDelete {
  BodyDeleteExistingInvitationV1WorkspaceInvitesDelete copyWith(
      {String? email}) {
    return BodyDeleteExistingInvitationV1WorkspaceInvitesDelete(
        email: email ?? this.email);
  }

  BodyDeleteExistingInvitationV1WorkspaceInvitesDelete copyWithWrapped(
      {Wrapped<String>? email}) {
    return BodyDeleteExistingInvitationV1WorkspaceInvitesDelete(
        email: (email != null ? email.value : this.email));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIdMembersRemovePost {
  const BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIdMembersRemovePost({
    required this.email,
  });

  factory BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIdMembersRemovePost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIdMembersRemovePostFromJson(
          json);

  static const toJsonFactory =
      _$BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIdMembersRemovePostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIdMembersRemovePostToJson(
          this);

  @JsonKey(name: 'email')
  final String email;
  static const fromJsonFactory =
      _$BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIdMembersRemovePostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIdMembersRemovePost &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(email) ^ runtimeType.hashCode;
}

extension $BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIdMembersRemovePostExtension
    on BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIdMembersRemovePost {
  BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIdMembersRemovePost
      copyWith({String? email}) {
    return BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIdMembersRemovePost(
        email: email ?? this.email);
  }

  BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIdMembersRemovePost
      copyWithWrapped({Wrapped<String>? email}) {
    return BodyDeleteMemberFromUserGroupV1WorkspaceGroupsGroupIdMembersRemovePost(
        email: (email != null ? email.value : this.email));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyDeleteMemberV1WorkspaceMembersDelete {
  const BodyDeleteMemberV1WorkspaceMembersDelete({
    required this.email,
  });

  factory BodyDeleteMemberV1WorkspaceMembersDelete.fromJson(
          Map<String, dynamic> json) =>
      _$BodyDeleteMemberV1WorkspaceMembersDeleteFromJson(json);

  static const toJsonFactory = _$BodyDeleteMemberV1WorkspaceMembersDeleteToJson;
  Map<String, dynamic> toJson() =>
      _$BodyDeleteMemberV1WorkspaceMembersDeleteToJson(this);

  @JsonKey(name: 'email')
  final String email;
  static const fromJsonFactory =
      _$BodyDeleteMemberV1WorkspaceMembersDeleteFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyDeleteMemberV1WorkspaceMembersDelete &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(email) ^ runtimeType.hashCode;
}

extension $BodyDeleteMemberV1WorkspaceMembersDeleteExtension
    on BodyDeleteMemberV1WorkspaceMembersDelete {
  BodyDeleteMemberV1WorkspaceMembersDelete copyWith({String? email}) {
    return BodyDeleteMemberV1WorkspaceMembersDelete(email: email ?? this.email);
  }

  BodyDeleteMemberV1WorkspaceMembersDelete copyWithWrapped(
      {Wrapped<String>? email}) {
    return BodyDeleteMemberV1WorkspaceMembersDelete(
        email: (email != null ? email.value : this.email));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyDownloadHistoryItemsV1HistoryDownloadPost {
  const BodyDownloadHistoryItemsV1HistoryDownloadPost({
    required this.historyItemIds,
    this.outputFormat,
  });

  factory BodyDownloadHistoryItemsV1HistoryDownloadPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyDownloadHistoryItemsV1HistoryDownloadPostFromJson(json);

  static const toJsonFactory =
      _$BodyDownloadHistoryItemsV1HistoryDownloadPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyDownloadHistoryItemsV1HistoryDownloadPostToJson(this);

  @JsonKey(name: 'history_item_ids', defaultValue: <String>[])
  final List<String> historyItemIds;
  @JsonKey(name: 'output_format')
  final dynamic outputFormat;
  static const fromJsonFactory =
      _$BodyDownloadHistoryItemsV1HistoryDownloadPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyDownloadHistoryItemsV1HistoryDownloadPost &&
            (identical(other.historyItemIds, historyItemIds) ||
                const DeepCollectionEquality()
                    .equals(other.historyItemIds, historyItemIds)) &&
            (identical(other.outputFormat, outputFormat) ||
                const DeepCollectionEquality()
                    .equals(other.outputFormat, outputFormat)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(historyItemIds) ^
      const DeepCollectionEquality().hash(outputFormat) ^
      runtimeType.hashCode;
}

extension $BodyDownloadHistoryItemsV1HistoryDownloadPostExtension
    on BodyDownloadHistoryItemsV1HistoryDownloadPost {
  BodyDownloadHistoryItemsV1HistoryDownloadPost copyWith(
      {List<String>? historyItemIds, dynamic outputFormat}) {
    return BodyDownloadHistoryItemsV1HistoryDownloadPost(
        historyItemIds: historyItemIds ?? this.historyItemIds,
        outputFormat: outputFormat ?? this.outputFormat);
  }

  BodyDownloadHistoryItemsV1HistoryDownloadPost copyWithWrapped(
      {Wrapped<List<String>>? historyItemIds, Wrapped<dynamic>? outputFormat}) {
    return BodyDownloadHistoryItemsV1HistoryDownloadPost(
        historyItemIds: (historyItemIds != null
            ? historyItemIds.value
            : this.historyItemIds),
        outputFormat:
            (outputFormat != null ? outputFormat.value : this.outputFormat));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyDubAVideoOrAnAudioFileV1DubbingPost {
  const BodyDubAVideoOrAnAudioFileV1DubbingPost({
    this.file,
    this.csvFile,
    this.foregroundAudioFile,
    this.backgroundAudioFile,
    this.name,
    this.sourceUrl,
    this.sourceLang,
    this.targetLang,
    this.numSpeakers,
    this.watermark,
    this.startTime,
    this.endTime,
    this.highestResolution,
    this.dropBackgroundAudio,
    this.useProfanityFilter,
    this.dubbingStudio,
    this.disableVoiceCloning,
    this.mode,
  });

  factory BodyDubAVideoOrAnAudioFileV1DubbingPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyDubAVideoOrAnAudioFileV1DubbingPostFromJson(json);

  static const toJsonFactory = _$BodyDubAVideoOrAnAudioFileV1DubbingPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyDubAVideoOrAnAudioFileV1DubbingPostToJson(this);

  @JsonKey(name: 'file')
  final dynamic file;
  @JsonKey(name: 'csv_file')
  final dynamic csvFile;
  @JsonKey(name: 'foreground_audio_file')
  final dynamic foregroundAudioFile;
  @JsonKey(name: 'background_audio_file')
  final dynamic backgroundAudioFile;
  @JsonKey(name: 'name')
  final dynamic name;
  @JsonKey(name: 'source_url')
  final dynamic sourceUrl;
  @JsonKey(name: 'source_lang')
  final String? sourceLang;
  @JsonKey(name: 'target_lang')
  final dynamic targetLang;
  @JsonKey(name: 'num_speakers')
  final int? numSpeakers;
  @JsonKey(name: 'watermark', defaultValue: false)
  final bool? watermark;
  @JsonKey(name: 'start_time')
  final dynamic startTime;
  @JsonKey(name: 'end_time')
  final dynamic endTime;
  @JsonKey(name: 'highest_resolution', defaultValue: false)
  final bool? highestResolution;
  @JsonKey(name: 'drop_background_audio', defaultValue: false)
  final bool? dropBackgroundAudio;
  @JsonKey(name: 'use_profanity_filter')
  final dynamic useProfanityFilter;
  @JsonKey(name: 'dubbing_studio', defaultValue: false)
  final bool? dubbingStudio;
  @JsonKey(name: 'disable_voice_cloning', defaultValue: false)
  final bool? disableVoiceCloning;
  @JsonKey(name: 'mode')
  final dynamic mode;
  static const fromJsonFactory =
      _$BodyDubAVideoOrAnAudioFileV1DubbingPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyDubAVideoOrAnAudioFileV1DubbingPost &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)) &&
            (identical(other.csvFile, csvFile) ||
                const DeepCollectionEquality()
                    .equals(other.csvFile, csvFile)) &&
            (identical(other.foregroundAudioFile, foregroundAudioFile) ||
                const DeepCollectionEquality()
                    .equals(other.foregroundAudioFile, foregroundAudioFile)) &&
            (identical(other.backgroundAudioFile, backgroundAudioFile) ||
                const DeepCollectionEquality()
                    .equals(other.backgroundAudioFile, backgroundAudioFile)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.sourceUrl, sourceUrl) ||
                const DeepCollectionEquality()
                    .equals(other.sourceUrl, sourceUrl)) &&
            (identical(other.sourceLang, sourceLang) ||
                const DeepCollectionEquality()
                    .equals(other.sourceLang, sourceLang)) &&
            (identical(other.targetLang, targetLang) ||
                const DeepCollectionEquality()
                    .equals(other.targetLang, targetLang)) &&
            (identical(other.numSpeakers, numSpeakers) ||
                const DeepCollectionEquality()
                    .equals(other.numSpeakers, numSpeakers)) &&
            (identical(other.watermark, watermark) ||
                const DeepCollectionEquality()
                    .equals(other.watermark, watermark)) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality()
                    .equals(other.startTime, startTime)) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality()
                    .equals(other.endTime, endTime)) &&
            (identical(other.highestResolution, highestResolution) ||
                const DeepCollectionEquality()
                    .equals(other.highestResolution, highestResolution)) &&
            (identical(other.dropBackgroundAudio, dropBackgroundAudio) ||
                const DeepCollectionEquality()
                    .equals(other.dropBackgroundAudio, dropBackgroundAudio)) &&
            (identical(other.useProfanityFilter, useProfanityFilter) ||
                const DeepCollectionEquality()
                    .equals(other.useProfanityFilter, useProfanityFilter)) &&
            (identical(other.dubbingStudio, dubbingStudio) ||
                const DeepCollectionEquality()
                    .equals(other.dubbingStudio, dubbingStudio)) &&
            (identical(other.disableVoiceCloning, disableVoiceCloning) ||
                const DeepCollectionEquality()
                    .equals(other.disableVoiceCloning, disableVoiceCloning)) &&
            (identical(other.mode, mode) ||
                const DeepCollectionEquality().equals(other.mode, mode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(file) ^
      const DeepCollectionEquality().hash(csvFile) ^
      const DeepCollectionEquality().hash(foregroundAudioFile) ^
      const DeepCollectionEquality().hash(backgroundAudioFile) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(sourceUrl) ^
      const DeepCollectionEquality().hash(sourceLang) ^
      const DeepCollectionEquality().hash(targetLang) ^
      const DeepCollectionEquality().hash(numSpeakers) ^
      const DeepCollectionEquality().hash(watermark) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(highestResolution) ^
      const DeepCollectionEquality().hash(dropBackgroundAudio) ^
      const DeepCollectionEquality().hash(useProfanityFilter) ^
      const DeepCollectionEquality().hash(dubbingStudio) ^
      const DeepCollectionEquality().hash(disableVoiceCloning) ^
      const DeepCollectionEquality().hash(mode) ^
      runtimeType.hashCode;
}

extension $BodyDubAVideoOrAnAudioFileV1DubbingPostExtension
    on BodyDubAVideoOrAnAudioFileV1DubbingPost {
  BodyDubAVideoOrAnAudioFileV1DubbingPost copyWith(
      {dynamic file,
      dynamic csvFile,
      dynamic foregroundAudioFile,
      dynamic backgroundAudioFile,
      dynamic name,
      dynamic sourceUrl,
      String? sourceLang,
      dynamic targetLang,
      int? numSpeakers,
      bool? watermark,
      dynamic startTime,
      dynamic endTime,
      bool? highestResolution,
      bool? dropBackgroundAudio,
      dynamic useProfanityFilter,
      bool? dubbingStudio,
      bool? disableVoiceCloning,
      dynamic mode}) {
    return BodyDubAVideoOrAnAudioFileV1DubbingPost(
        file: file ?? this.file,
        csvFile: csvFile ?? this.csvFile,
        foregroundAudioFile: foregroundAudioFile ?? this.foregroundAudioFile,
        backgroundAudioFile: backgroundAudioFile ?? this.backgroundAudioFile,
        name: name ?? this.name,
        sourceUrl: sourceUrl ?? this.sourceUrl,
        sourceLang: sourceLang ?? this.sourceLang,
        targetLang: targetLang ?? this.targetLang,
        numSpeakers: numSpeakers ?? this.numSpeakers,
        watermark: watermark ?? this.watermark,
        startTime: startTime ?? this.startTime,
        endTime: endTime ?? this.endTime,
        highestResolution: highestResolution ?? this.highestResolution,
        dropBackgroundAudio: dropBackgroundAudio ?? this.dropBackgroundAudio,
        useProfanityFilter: useProfanityFilter ?? this.useProfanityFilter,
        dubbingStudio: dubbingStudio ?? this.dubbingStudio,
        disableVoiceCloning: disableVoiceCloning ?? this.disableVoiceCloning,
        mode: mode ?? this.mode);
  }

  BodyDubAVideoOrAnAudioFileV1DubbingPost copyWithWrapped(
      {Wrapped<dynamic>? file,
      Wrapped<dynamic>? csvFile,
      Wrapped<dynamic>? foregroundAudioFile,
      Wrapped<dynamic>? backgroundAudioFile,
      Wrapped<dynamic>? name,
      Wrapped<dynamic>? sourceUrl,
      Wrapped<String?>? sourceLang,
      Wrapped<dynamic>? targetLang,
      Wrapped<int?>? numSpeakers,
      Wrapped<bool?>? watermark,
      Wrapped<dynamic>? startTime,
      Wrapped<dynamic>? endTime,
      Wrapped<bool?>? highestResolution,
      Wrapped<bool?>? dropBackgroundAudio,
      Wrapped<dynamic>? useProfanityFilter,
      Wrapped<bool?>? dubbingStudio,
      Wrapped<bool?>? disableVoiceCloning,
      Wrapped<dynamic>? mode}) {
    return BodyDubAVideoOrAnAudioFileV1DubbingPost(
        file: (file != null ? file.value : this.file),
        csvFile: (csvFile != null ? csvFile.value : this.csvFile),
        foregroundAudioFile: (foregroundAudioFile != null
            ? foregroundAudioFile.value
            : this.foregroundAudioFile),
        backgroundAudioFile: (backgroundAudioFile != null
            ? backgroundAudioFile.value
            : this.backgroundAudioFile),
        name: (name != null ? name.value : this.name),
        sourceUrl: (sourceUrl != null ? sourceUrl.value : this.sourceUrl),
        sourceLang: (sourceLang != null ? sourceLang.value : this.sourceLang),
        targetLang: (targetLang != null ? targetLang.value : this.targetLang),
        numSpeakers:
            (numSpeakers != null ? numSpeakers.value : this.numSpeakers),
        watermark: (watermark != null ? watermark.value : this.watermark),
        startTime: (startTime != null ? startTime.value : this.startTime),
        endTime: (endTime != null ? endTime.value : this.endTime),
        highestResolution: (highestResolution != null
            ? highestResolution.value
            : this.highestResolution),
        dropBackgroundAudio: (dropBackgroundAudio != null
            ? dropBackgroundAudio.value
            : this.dropBackgroundAudio),
        useProfanityFilter: (useProfanityFilter != null
            ? useProfanityFilter.value
            : this.useProfanityFilter),
        dubbingStudio:
            (dubbingStudio != null ? dubbingStudio.value : this.dubbingStudio),
        disableVoiceCloning: (disableVoiceCloning != null
            ? disableVoiceCloning.value
            : this.disableVoiceCloning),
        mode: (mode != null ? mode.value : this.mode));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdDubPost {
  const BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdDubPost({
    required this.segments,
    required this.languages,
  });

  factory BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdDubPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdDubPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdDubPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdDubPostToJson(
          this);

  @JsonKey(name: 'segments', defaultValue: <String>[])
  final List<String> segments;
  @JsonKey(name: 'languages')
  final dynamic languages;
  static const fromJsonFactory =
      _$BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdDubPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdDubPost &&
            (identical(other.segments, segments) ||
                const DeepCollectionEquality()
                    .equals(other.segments, segments)) &&
            (identical(other.languages, languages) ||
                const DeepCollectionEquality()
                    .equals(other.languages, languages)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(segments) ^
      const DeepCollectionEquality().hash(languages) ^
      runtimeType.hashCode;
}

extension $BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdDubPostExtension
    on BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdDubPost {
  BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdDubPost
      copyWith({List<String>? segments, dynamic languages}) {
    return BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdDubPost(
        segments: segments ?? this.segments,
        languages: languages ?? this.languages);
  }

  BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdDubPost
      copyWithWrapped(
          {Wrapped<List<String>>? segments, Wrapped<dynamic>? languages}) {
    return BodyDubsAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdDubPost(
        segments: (segments != null ? segments.value : this.segments),
        languages: (languages != null ? languages.value : this.languages));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyEditPVCVoiceV1VoicesPvcVoiceIdPost {
  const BodyEditPVCVoiceV1VoicesPvcVoiceIdPost({
    this.name,
    this.language,
    this.description,
    this.labels,
  });

  factory BodyEditPVCVoiceV1VoicesPvcVoiceIdPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyEditPVCVoiceV1VoicesPvcVoiceIdPostFromJson(json);

  static const toJsonFactory = _$BodyEditPVCVoiceV1VoicesPvcVoiceIdPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyEditPVCVoiceV1VoicesPvcVoiceIdPostToJson(this);

  @JsonKey(name: 'name')
  final String? name;
  @JsonKey(name: 'language')
  final String? language;
  @JsonKey(name: 'description')
  final dynamic description;
  @JsonKey(name: 'labels')
  final dynamic labels;
  static const fromJsonFactory =
      _$BodyEditPVCVoiceV1VoicesPvcVoiceIdPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyEditPVCVoiceV1VoicesPvcVoiceIdPost &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.labels, labels) ||
                const DeepCollectionEquality().equals(other.labels, labels)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(labels) ^
      runtimeType.hashCode;
}

extension $BodyEditPVCVoiceV1VoicesPvcVoiceIdPostExtension
    on BodyEditPVCVoiceV1VoicesPvcVoiceIdPost {
  BodyEditPVCVoiceV1VoicesPvcVoiceIdPost copyWith(
      {String? name, String? language, dynamic description, dynamic labels}) {
    return BodyEditPVCVoiceV1VoicesPvcVoiceIdPost(
        name: name ?? this.name,
        language: language ?? this.language,
        description: description ?? this.description,
        labels: labels ?? this.labels);
  }

  BodyEditPVCVoiceV1VoicesPvcVoiceIdPost copyWithWrapped(
      {Wrapped<String?>? name,
      Wrapped<String?>? language,
      Wrapped<dynamic>? description,
      Wrapped<dynamic>? labels}) {
    return BodyEditPVCVoiceV1VoicesPvcVoiceIdPost(
        name: (name != null ? name.value : this.name),
        language: (language != null ? language.value : this.language),
        description:
            (description != null ? description.value : this.description),
        labels: (labels != null ? labels.value : this.labels));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyEditBasicProjectInfoV1ProjectsProjectIdPost {
  const BodyEditBasicProjectInfoV1ProjectsProjectIdPost({
    required this.name,
    required this.defaultTitleVoiceId,
    required this.defaultParagraphVoiceId,
    this.title,
    this.author,
    this.isbnNumber,
    this.volumeNormalization,
  });

  factory BodyEditBasicProjectInfoV1ProjectsProjectIdPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyEditBasicProjectInfoV1ProjectsProjectIdPostFromJson(json);

  static const toJsonFactory =
      _$BodyEditBasicProjectInfoV1ProjectsProjectIdPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyEditBasicProjectInfoV1ProjectsProjectIdPostToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'default_title_voice_id')
  final String defaultTitleVoiceId;
  @JsonKey(name: 'default_paragraph_voice_id')
  final String defaultParagraphVoiceId;
  @JsonKey(name: 'title')
  final dynamic title;
  @JsonKey(name: 'author')
  final dynamic author;
  @JsonKey(name: 'isbn_number')
  final dynamic isbnNumber;
  @JsonKey(name: 'volume_normalization', defaultValue: false)
  final bool? volumeNormalization;
  static const fromJsonFactory =
      _$BodyEditBasicProjectInfoV1ProjectsProjectIdPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyEditBasicProjectInfoV1ProjectsProjectIdPost &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.defaultTitleVoiceId, defaultTitleVoiceId) ||
                const DeepCollectionEquality()
                    .equals(other.defaultTitleVoiceId, defaultTitleVoiceId)) &&
            (identical(
                    other.defaultParagraphVoiceId, defaultParagraphVoiceId) ||
                const DeepCollectionEquality().equals(
                    other.defaultParagraphVoiceId, defaultParagraphVoiceId)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.author, author) ||
                const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.isbnNumber, isbnNumber) ||
                const DeepCollectionEquality()
                    .equals(other.isbnNumber, isbnNumber)) &&
            (identical(other.volumeNormalization, volumeNormalization) ||
                const DeepCollectionEquality()
                    .equals(other.volumeNormalization, volumeNormalization)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(defaultTitleVoiceId) ^
      const DeepCollectionEquality().hash(defaultParagraphVoiceId) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(isbnNumber) ^
      const DeepCollectionEquality().hash(volumeNormalization) ^
      runtimeType.hashCode;
}

extension $BodyEditBasicProjectInfoV1ProjectsProjectIdPostExtension
    on BodyEditBasicProjectInfoV1ProjectsProjectIdPost {
  BodyEditBasicProjectInfoV1ProjectsProjectIdPost copyWith(
      {String? name,
      String? defaultTitleVoiceId,
      String? defaultParagraphVoiceId,
      dynamic title,
      dynamic author,
      dynamic isbnNumber,
      bool? volumeNormalization}) {
    return BodyEditBasicProjectInfoV1ProjectsProjectIdPost(
        name: name ?? this.name,
        defaultTitleVoiceId: defaultTitleVoiceId ?? this.defaultTitleVoiceId,
        defaultParagraphVoiceId:
            defaultParagraphVoiceId ?? this.defaultParagraphVoiceId,
        title: title ?? this.title,
        author: author ?? this.author,
        isbnNumber: isbnNumber ?? this.isbnNumber,
        volumeNormalization: volumeNormalization ?? this.volumeNormalization);
  }

  BodyEditBasicProjectInfoV1ProjectsProjectIdPost copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String>? defaultTitleVoiceId,
      Wrapped<String>? defaultParagraphVoiceId,
      Wrapped<dynamic>? title,
      Wrapped<dynamic>? author,
      Wrapped<dynamic>? isbnNumber,
      Wrapped<bool?>? volumeNormalization}) {
    return BodyEditBasicProjectInfoV1ProjectsProjectIdPost(
        name: (name != null ? name.value : this.name),
        defaultTitleVoiceId: (defaultTitleVoiceId != null
            ? defaultTitleVoiceId.value
            : this.defaultTitleVoiceId),
        defaultParagraphVoiceId: (defaultParagraphVoiceId != null
            ? defaultParagraphVoiceId.value
            : this.defaultParagraphVoiceId),
        title: (title != null ? title.value : this.title),
        author: (author != null ? author.value : this.author),
        isbnNumber: (isbnNumber != null ? isbnNumber.value : this.isbnNumber),
        volumeNormalization: (volumeNormalization != null
            ? volumeNormalization.value
            : this.volumeNormalization));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyEditChapterV1ProjectsProjectIdChaptersChapterIdPatch {
  const BodyEditChapterV1ProjectsProjectIdChaptersChapterIdPatch({
    this.name,
    this.content,
  });

  factory BodyEditChapterV1ProjectsProjectIdChaptersChapterIdPatch.fromJson(
          Map<String, dynamic> json) =>
      _$BodyEditChapterV1ProjectsProjectIdChaptersChapterIdPatchFromJson(json);

  static const toJsonFactory =
      _$BodyEditChapterV1ProjectsProjectIdChaptersChapterIdPatchToJson;
  Map<String, dynamic> toJson() =>
      _$BodyEditChapterV1ProjectsProjectIdChaptersChapterIdPatchToJson(this);

  @JsonKey(name: 'name')
  final dynamic name;
  @JsonKey(name: 'content')
  final dynamic content;
  static const fromJsonFactory =
      _$BodyEditChapterV1ProjectsProjectIdChaptersChapterIdPatchFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyEditChapterV1ProjectsProjectIdChaptersChapterIdPatch &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $BodyEditChapterV1ProjectsProjectIdChaptersChapterIdPatchExtension
    on BodyEditChapterV1ProjectsProjectIdChaptersChapterIdPatch {
  BodyEditChapterV1ProjectsProjectIdChaptersChapterIdPatch copyWith(
      {dynamic name, dynamic content}) {
    return BodyEditChapterV1ProjectsProjectIdChaptersChapterIdPatch(
        name: name ?? this.name, content: content ?? this.content);
  }

  BodyEditChapterV1ProjectsProjectIdChaptersChapterIdPatch copyWithWrapped(
      {Wrapped<dynamic>? name, Wrapped<dynamic>? content}) {
    return BodyEditChapterV1ProjectsProjectIdChaptersChapterIdPatch(
        name: (name != null ? name.value : this.name),
        content: (content != null ? content.value : this.content));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyEditProjectContentV1ProjectsProjectIdContentPost {
  const BodyEditProjectContentV1ProjectsProjectIdContentPost({
    this.fromUrl,
    this.fromDocument,
    this.autoConvert,
  });

  factory BodyEditProjectContentV1ProjectsProjectIdContentPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyEditProjectContentV1ProjectsProjectIdContentPostFromJson(json);

  static const toJsonFactory =
      _$BodyEditProjectContentV1ProjectsProjectIdContentPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyEditProjectContentV1ProjectsProjectIdContentPostToJson(this);

  @JsonKey(name: 'from_url')
  final dynamic fromUrl;
  @JsonKey(name: 'from_document')
  final dynamic fromDocument;
  @JsonKey(name: 'auto_convert', defaultValue: false)
  final bool? autoConvert;
  static const fromJsonFactory =
      _$BodyEditProjectContentV1ProjectsProjectIdContentPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyEditProjectContentV1ProjectsProjectIdContentPost &&
            (identical(other.fromUrl, fromUrl) ||
                const DeepCollectionEquality()
                    .equals(other.fromUrl, fromUrl)) &&
            (identical(other.fromDocument, fromDocument) ||
                const DeepCollectionEquality()
                    .equals(other.fromDocument, fromDocument)) &&
            (identical(other.autoConvert, autoConvert) ||
                const DeepCollectionEquality()
                    .equals(other.autoConvert, autoConvert)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fromUrl) ^
      const DeepCollectionEquality().hash(fromDocument) ^
      const DeepCollectionEquality().hash(autoConvert) ^
      runtimeType.hashCode;
}

extension $BodyEditProjectContentV1ProjectsProjectIdContentPostExtension
    on BodyEditProjectContentV1ProjectsProjectIdContentPost {
  BodyEditProjectContentV1ProjectsProjectIdContentPost copyWith(
      {dynamic fromUrl, dynamic fromDocument, bool? autoConvert}) {
    return BodyEditProjectContentV1ProjectsProjectIdContentPost(
        fromUrl: fromUrl ?? this.fromUrl,
        fromDocument: fromDocument ?? this.fromDocument,
        autoConvert: autoConvert ?? this.autoConvert);
  }

  BodyEditProjectContentV1ProjectsProjectIdContentPost copyWithWrapped(
      {Wrapped<dynamic>? fromUrl,
      Wrapped<dynamic>? fromDocument,
      Wrapped<bool?>? autoConvert}) {
    return BodyEditProjectContentV1ProjectsProjectIdContentPost(
        fromUrl: (fromUrl != null ? fromUrl.value : this.fromUrl),
        fromDocument:
            (fromDocument != null ? fromDocument.value : this.fromDocument),
        autoConvert:
            (autoConvert != null ? autoConvert.value : this.autoConvert));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyEditVoiceV1VoicesVoiceIdEditPost {
  const BodyEditVoiceV1VoicesVoiceIdEditPost({
    required this.name,
    this.files,
    this.removeBackgroundNoise,
    this.description,
    this.labels,
  });

  factory BodyEditVoiceV1VoicesVoiceIdEditPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyEditVoiceV1VoicesVoiceIdEditPostFromJson(json);

  static const toJsonFactory = _$BodyEditVoiceV1VoicesVoiceIdEditPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyEditVoiceV1VoicesVoiceIdEditPostToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'files', defaultValue: <String>[])
  final List<String>? files;
  @JsonKey(name: 'remove_background_noise', defaultValue: false)
  final bool? removeBackgroundNoise;
  @JsonKey(name: 'description')
  final dynamic description;
  @JsonKey(name: 'labels')
  final dynamic labels;
  static const fromJsonFactory = _$BodyEditVoiceV1VoicesVoiceIdEditPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyEditVoiceV1VoicesVoiceIdEditPost &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.files, files) ||
                const DeepCollectionEquality().equals(other.files, files)) &&
            (identical(other.removeBackgroundNoise, removeBackgroundNoise) ||
                const DeepCollectionEquality().equals(
                    other.removeBackgroundNoise, removeBackgroundNoise)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.labels, labels) ||
                const DeepCollectionEquality().equals(other.labels, labels)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(files) ^
      const DeepCollectionEquality().hash(removeBackgroundNoise) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(labels) ^
      runtimeType.hashCode;
}

extension $BodyEditVoiceV1VoicesVoiceIdEditPostExtension
    on BodyEditVoiceV1VoicesVoiceIdEditPost {
  BodyEditVoiceV1VoicesVoiceIdEditPost copyWith(
      {String? name,
      List<String>? files,
      bool? removeBackgroundNoise,
      dynamic description,
      dynamic labels}) {
    return BodyEditVoiceV1VoicesVoiceIdEditPost(
        name: name ?? this.name,
        files: files ?? this.files,
        removeBackgroundNoise:
            removeBackgroundNoise ?? this.removeBackgroundNoise,
        description: description ?? this.description,
        labels: labels ?? this.labels);
  }

  BodyEditVoiceV1VoicesVoiceIdEditPost copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<List<String>?>? files,
      Wrapped<bool?>? removeBackgroundNoise,
      Wrapped<dynamic>? description,
      Wrapped<dynamic>? labels}) {
    return BodyEditVoiceV1VoicesVoiceIdEditPost(
        name: (name != null ? name.value : this.name),
        files: (files != null ? files.value : this.files),
        removeBackgroundNoise: (removeBackgroundNoise != null
            ? removeBackgroundNoise.value
            : this.removeBackgroundNoise),
        description:
            (description != null ? description.value : this.description),
        labels: (labels != null ? labels.value : this.labels));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost {
  const BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost({
    required this.gender,
    required this.accent,
    required this.age,
    required this.accentStrength,
    required this.text,
  });

  factory BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostFromJson(
          json);

  static const toJsonFactory =
      _$BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostToJson(this);

  @JsonKey(
    name: 'gender',
    toJson:
        bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGenderToJson,
    fromJson:
        bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGenderFromJson,
  )
  final enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender
      gender;
  @JsonKey(name: 'accent')
  final String accent;
  @JsonKey(
    name: 'age',
    toJson: bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAgeToJson,
    fromJson:
        bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAgeFromJson,
  )
  final enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge age;
  @JsonKey(name: 'accent_strength')
  final double accentStrength;
  @JsonKey(name: 'text')
  final String text;
  static const fromJsonFactory =
      _$BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost &&
            (identical(other.gender, gender) ||
                const DeepCollectionEquality().equals(other.gender, gender)) &&
            (identical(other.accent, accent) ||
                const DeepCollectionEquality().equals(other.accent, accent)) &&
            (identical(other.age, age) ||
                const DeepCollectionEquality().equals(other.age, age)) &&
            (identical(other.accentStrength, accentStrength) ||
                const DeepCollectionEquality()
                    .equals(other.accentStrength, accentStrength)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(gender) ^
      const DeepCollectionEquality().hash(accent) ^
      const DeepCollectionEquality().hash(age) ^
      const DeepCollectionEquality().hash(accentStrength) ^
      const DeepCollectionEquality().hash(text) ^
      runtimeType.hashCode;
}

extension $BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostExtension
    on BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost {
  BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost copyWith(
      {enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender?
          gender,
      String? accent,
      enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge? age,
      double? accentStrength,
      String? text}) {
    return BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost(
        gender: gender ?? this.gender,
        accent: accent ?? this.accent,
        age: age ?? this.age,
        accentStrength: accentStrength ?? this.accentStrength,
        text: text ?? this.text);
  }

  BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost copyWithWrapped(
      {Wrapped<
              enums
              .BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender>?
          gender,
      Wrapped<String>? accent,
      Wrapped<
              enums
              .BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge>?
          age,
      Wrapped<double>? accentStrength,
      Wrapped<String>? text}) {
    return BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePost(
        gender: (gender != null ? gender.value : this.gender),
        accent: (accent != null ? accent.value : this.accent),
        age: (age != null ? age.value : this.age),
        accentStrength: (accentStrength != null
            ? accentStrength.value
            : this.accentStrength),
        text: (text != null ? text.value : this.text));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyGetSimilarLibraryVoicesV1SimilarVoicesPost {
  const BodyGetSimilarLibraryVoicesV1SimilarVoicesPost({
    this.audioFile,
    this.similarityThreshold,
    this.topK,
  });

  factory BodyGetSimilarLibraryVoicesV1SimilarVoicesPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyGetSimilarLibraryVoicesV1SimilarVoicesPostFromJson(json);

  static const toJsonFactory =
      _$BodyGetSimilarLibraryVoicesV1SimilarVoicesPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyGetSimilarLibraryVoicesV1SimilarVoicesPostToJson(this);

  @JsonKey(name: 'audio_file')
  final String? audioFile;
  @JsonKey(name: 'similarity_threshold')
  final dynamic similarityThreshold;
  @JsonKey(name: 'top_k')
  final dynamic topK;
  static const fromJsonFactory =
      _$BodyGetSimilarLibraryVoicesV1SimilarVoicesPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyGetSimilarLibraryVoicesV1SimilarVoicesPost &&
            (identical(other.audioFile, audioFile) ||
                const DeepCollectionEquality()
                    .equals(other.audioFile, audioFile)) &&
            (identical(other.similarityThreshold, similarityThreshold) ||
                const DeepCollectionEquality()
                    .equals(other.similarityThreshold, similarityThreshold)) &&
            (identical(other.topK, topK) ||
                const DeepCollectionEquality().equals(other.topK, topK)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(audioFile) ^
      const DeepCollectionEquality().hash(similarityThreshold) ^
      const DeepCollectionEquality().hash(topK) ^
      runtimeType.hashCode;
}

extension $BodyGetSimilarLibraryVoicesV1SimilarVoicesPostExtension
    on BodyGetSimilarLibraryVoicesV1SimilarVoicesPost {
  BodyGetSimilarLibraryVoicesV1SimilarVoicesPost copyWith(
      {String? audioFile, dynamic similarityThreshold, dynamic topK}) {
    return BodyGetSimilarLibraryVoicesV1SimilarVoicesPost(
        audioFile: audioFile ?? this.audioFile,
        similarityThreshold: similarityThreshold ?? this.similarityThreshold,
        topK: topK ?? this.topK);
  }

  BodyGetSimilarLibraryVoicesV1SimilarVoicesPost copyWithWrapped(
      {Wrapped<String?>? audioFile,
      Wrapped<dynamic>? similarityThreshold,
      Wrapped<dynamic>? topK}) {
    return BodyGetSimilarLibraryVoicesV1SimilarVoicesPost(
        audioFile: (audioFile != null ? audioFile.value : this.audioFile),
        similarityThreshold: (similarityThreshold != null
            ? similarityThreshold.value
            : this.similarityThreshold),
        topK: (topK != null ? topK.value : this.topK));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost {
  const BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost({
    required this.agentId,
    required this.agentPhoneNumberId,
    required this.toNumber,
    this.conversationInitiationClientData,
  });

  factory BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPostToJson(
          this);

  @JsonKey(name: 'agent_id')
  final String agentId;
  @JsonKey(name: 'agent_phone_number_id')
  final String agentPhoneNumberId;
  @JsonKey(name: 'to_number')
  final String toNumber;
  @JsonKey(name: 'conversation_initiation_client_data')
  final dynamic conversationInitiationClientData;
  static const fromJsonFactory =
      _$BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost &&
            (identical(other.agentId, agentId) ||
                const DeepCollectionEquality()
                    .equals(other.agentId, agentId)) &&
            (identical(other.agentPhoneNumberId, agentPhoneNumberId) ||
                const DeepCollectionEquality()
                    .equals(other.agentPhoneNumberId, agentPhoneNumberId)) &&
            (identical(other.toNumber, toNumber) ||
                const DeepCollectionEquality()
                    .equals(other.toNumber, toNumber)) &&
            (identical(other.conversationInitiationClientData,
                    conversationInitiationClientData) ||
                const DeepCollectionEquality().equals(
                    other.conversationInitiationClientData,
                    conversationInitiationClientData)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(agentId) ^
      const DeepCollectionEquality().hash(agentPhoneNumberId) ^
      const DeepCollectionEquality().hash(toNumber) ^
      const DeepCollectionEquality().hash(conversationInitiationClientData) ^
      runtimeType.hashCode;
}

extension $BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPostExtension
    on BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost {
  BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost copyWith(
      {String? agentId,
      String? agentPhoneNumberId,
      String? toNumber,
      dynamic conversationInitiationClientData}) {
    return BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost(
        agentId: agentId ?? this.agentId,
        agentPhoneNumberId: agentPhoneNumberId ?? this.agentPhoneNumberId,
        toNumber: toNumber ?? this.toNumber,
        conversationInitiationClientData: conversationInitiationClientData ??
            this.conversationInitiationClientData);
  }

  BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost
      copyWithWrapped(
          {Wrapped<String>? agentId,
          Wrapped<String>? agentPhoneNumberId,
          Wrapped<String>? toNumber,
          Wrapped<dynamic>? conversationInitiationClientData}) {
    return BodyHandleAnOutboundCallViaSIPTrunkV1ConvaiSipTrunkOutboundCallPost(
        agentId: (agentId != null ? agentId.value : this.agentId),
        agentPhoneNumberId: (agentPhoneNumberId != null
            ? agentPhoneNumberId.value
            : this.agentPhoneNumberId),
        toNumber: (toNumber != null ? toNumber.value : this.toNumber),
        conversationInitiationClientData:
            (conversationInitiationClientData != null
                ? conversationInitiationClientData.value
                : this.conversationInitiationClientData));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost {
  const BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost({
    required this.agentId,
    required this.agentPhoneNumberId,
    required this.toNumber,
    this.conversationInitiationClientData,
  });

  factory BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPostToJson(
          this);

  @JsonKey(name: 'agent_id')
  final String agentId;
  @JsonKey(name: 'agent_phone_number_id')
  final String agentPhoneNumberId;
  @JsonKey(name: 'to_number')
  final String toNumber;
  @JsonKey(name: 'conversation_initiation_client_data')
  final dynamic conversationInitiationClientData;
  static const fromJsonFactory =
      _$BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost &&
            (identical(other.agentId, agentId) ||
                const DeepCollectionEquality()
                    .equals(other.agentId, agentId)) &&
            (identical(other.agentPhoneNumberId, agentPhoneNumberId) ||
                const DeepCollectionEquality()
                    .equals(other.agentPhoneNumberId, agentPhoneNumberId)) &&
            (identical(other.toNumber, toNumber) ||
                const DeepCollectionEquality()
                    .equals(other.toNumber, toNumber)) &&
            (identical(other.conversationInitiationClientData,
                    conversationInitiationClientData) ||
                const DeepCollectionEquality().equals(
                    other.conversationInitiationClientData,
                    conversationInitiationClientData)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(agentId) ^
      const DeepCollectionEquality().hash(agentPhoneNumberId) ^
      const DeepCollectionEquality().hash(toNumber) ^
      const DeepCollectionEquality().hash(conversationInitiationClientData) ^
      runtimeType.hashCode;
}

extension $BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPostExtension
    on BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost {
  BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost copyWith(
      {String? agentId,
      String? agentPhoneNumberId,
      String? toNumber,
      dynamic conversationInitiationClientData}) {
    return BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost(
        agentId: agentId ?? this.agentId,
        agentPhoneNumberId: agentPhoneNumberId ?? this.agentPhoneNumberId,
        toNumber: toNumber ?? this.toNumber,
        conversationInitiationClientData: conversationInitiationClientData ??
            this.conversationInitiationClientData);
  }

  BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost
      copyWithWrapped(
          {Wrapped<String>? agentId,
          Wrapped<String>? agentPhoneNumberId,
          Wrapped<String>? toNumber,
          Wrapped<dynamic>? conversationInitiationClientData}) {
    return BodyHandleAnOutboundCallViaTwilioV1ConvaiTwilioOutboundCallPost(
        agentId: (agentId != null ? agentId.value : this.agentId),
        agentPhoneNumberId: (agentPhoneNumberId != null
            ? agentPhoneNumberId.value
            : this.agentPhoneNumberId),
        toNumber: (toNumber != null ? toNumber.value : this.toNumber),
        conversationInitiationClientData:
            (conversationInitiationClientData != null
                ? conversationInitiationClientData.value
                : this.conversationInitiationClientData));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost {
  const BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost({
    required this.emails,
    this.groupIds,
  });

  factory BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPostFromJson(json);

  static const toJsonFactory =
      _$BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPostToJson(this);

  @JsonKey(name: 'emails', defaultValue: <String>[])
  final List<String> emails;
  @JsonKey(name: 'group_ids')
  final dynamic groupIds;
  static const fromJsonFactory =
      _$BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost &&
            (identical(other.emails, emails) ||
                const DeepCollectionEquality().equals(other.emails, emails)) &&
            (identical(other.groupIds, groupIds) ||
                const DeepCollectionEquality()
                    .equals(other.groupIds, groupIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(emails) ^
      const DeepCollectionEquality().hash(groupIds) ^
      runtimeType.hashCode;
}

extension $BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPostExtension
    on BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost {
  BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost copyWith(
      {List<String>? emails, dynamic groupIds}) {
    return BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost(
        emails: emails ?? this.emails, groupIds: groupIds ?? this.groupIds);
  }

  BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost copyWithWrapped(
      {Wrapped<List<String>>? emails, Wrapped<dynamic>? groupIds}) {
    return BodyInviteMultipleUsersV1WorkspaceInvitesAddBulkPost(
        emails: (emails != null ? emails.value : this.emails),
        groupIds: (groupIds != null ? groupIds.value : this.groupIds));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyInviteUserV1WorkspaceInvitesAddPost {
  const BodyInviteUserV1WorkspaceInvitesAddPost({
    required this.email,
    this.groupIds,
    this.workspacePermission,
  });

  factory BodyInviteUserV1WorkspaceInvitesAddPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyInviteUserV1WorkspaceInvitesAddPostFromJson(json);

  static const toJsonFactory = _$BodyInviteUserV1WorkspaceInvitesAddPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyInviteUserV1WorkspaceInvitesAddPostToJson(this);

  @JsonKey(name: 'email')
  final String email;
  @JsonKey(name: 'group_ids')
  final dynamic groupIds;
  @JsonKey(name: 'workspace_permission')
  final dynamic workspacePermission;
  static const fromJsonFactory =
      _$BodyInviteUserV1WorkspaceInvitesAddPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyInviteUserV1WorkspaceInvitesAddPost &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.groupIds, groupIds) ||
                const DeepCollectionEquality()
                    .equals(other.groupIds, groupIds)) &&
            (identical(other.workspacePermission, workspacePermission) ||
                const DeepCollectionEquality()
                    .equals(other.workspacePermission, workspacePermission)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(groupIds) ^
      const DeepCollectionEquality().hash(workspacePermission) ^
      runtimeType.hashCode;
}

extension $BodyInviteUserV1WorkspaceInvitesAddPostExtension
    on BodyInviteUserV1WorkspaceInvitesAddPost {
  BodyInviteUserV1WorkspaceInvitesAddPost copyWith(
      {String? email, dynamic groupIds, dynamic workspacePermission}) {
    return BodyInviteUserV1WorkspaceInvitesAddPost(
        email: email ?? this.email,
        groupIds: groupIds ?? this.groupIds,
        workspacePermission: workspacePermission ?? this.workspacePermission);
  }

  BodyInviteUserV1WorkspaceInvitesAddPost copyWithWrapped(
      {Wrapped<String>? email,
      Wrapped<dynamic>? groupIds,
      Wrapped<dynamic>? workspacePermission}) {
    return BodyInviteUserV1WorkspaceInvitesAddPost(
        email: (email != null ? email.value : this.email),
        groupIds: (groupIds != null ? groupIds.value : this.groupIds),
        workspacePermission: (workspacePermission != null
            ? workspacePermission.value
            : this.workspacePermission));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyPatchesAnAgentSettingsV1ConvaiAgentsAgentIdPatch {
  const BodyPatchesAnAgentSettingsV1ConvaiAgentsAgentIdPatch({
    this.conversationConfig,
    this.platformSettings,
    this.name,
    this.tags,
  });

  factory BodyPatchesAnAgentSettingsV1ConvaiAgentsAgentIdPatch.fromJson(
          Map<String, dynamic> json) =>
      _$BodyPatchesAnAgentSettingsV1ConvaiAgentsAgentIdPatchFromJson(json);

  static const toJsonFactory =
      _$BodyPatchesAnAgentSettingsV1ConvaiAgentsAgentIdPatchToJson;
  Map<String, dynamic> toJson() =>
      _$BodyPatchesAnAgentSettingsV1ConvaiAgentsAgentIdPatchToJson(this);

  @JsonKey(name: 'conversation_config')
  final dynamic conversationConfig;
  @JsonKey(name: 'platform_settings')
  final dynamic platformSettings;
  @JsonKey(name: 'name')
  final dynamic name;
  @JsonKey(name: 'tags')
  final dynamic tags;
  static const fromJsonFactory =
      _$BodyPatchesAnAgentSettingsV1ConvaiAgentsAgentIdPatchFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyPatchesAnAgentSettingsV1ConvaiAgentsAgentIdPatch &&
            (identical(other.conversationConfig, conversationConfig) ||
                const DeepCollectionEquality()
                    .equals(other.conversationConfig, conversationConfig)) &&
            (identical(other.platformSettings, platformSettings) ||
                const DeepCollectionEquality()
                    .equals(other.platformSettings, platformSettings)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(conversationConfig) ^
      const DeepCollectionEquality().hash(platformSettings) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $BodyPatchesAnAgentSettingsV1ConvaiAgentsAgentIdPatchExtension
    on BodyPatchesAnAgentSettingsV1ConvaiAgentsAgentIdPatch {
  BodyPatchesAnAgentSettingsV1ConvaiAgentsAgentIdPatch copyWith(
      {dynamic conversationConfig,
      dynamic platformSettings,
      dynamic name,
      dynamic tags}) {
    return BodyPatchesAnAgentSettingsV1ConvaiAgentsAgentIdPatch(
        conversationConfig: conversationConfig ?? this.conversationConfig,
        platformSettings: platformSettings ?? this.platformSettings,
        name: name ?? this.name,
        tags: tags ?? this.tags);
  }

  BodyPatchesAnAgentSettingsV1ConvaiAgentsAgentIdPatch copyWithWrapped(
      {Wrapped<dynamic>? conversationConfig,
      Wrapped<dynamic>? platformSettings,
      Wrapped<dynamic>? name,
      Wrapped<dynamic>? tags}) {
    return BodyPatchesAnAgentSettingsV1ConvaiAgentsAgentIdPatch(
        conversationConfig: (conversationConfig != null
            ? conversationConfig.value
            : this.conversationConfig),
        platformSettings: (platformSettings != null
            ? platformSettings.value
            : this.platformSettings),
        name: (name != null ? name.value : this.name),
        tags: (tags != null ? tags.value : this.tags));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyPostAgentAvatarV1ConvaiAgentsAgentIdAvatarPost {
  const BodyPostAgentAvatarV1ConvaiAgentsAgentIdAvatarPost({
    required this.avatarFile,
  });

  factory BodyPostAgentAvatarV1ConvaiAgentsAgentIdAvatarPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyPostAgentAvatarV1ConvaiAgentsAgentIdAvatarPostFromJson(json);

  static const toJsonFactory =
      _$BodyPostAgentAvatarV1ConvaiAgentsAgentIdAvatarPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyPostAgentAvatarV1ConvaiAgentsAgentIdAvatarPostToJson(this);

  @JsonKey(name: 'avatar_file')
  final String avatarFile;
  static const fromJsonFactory =
      _$BodyPostAgentAvatarV1ConvaiAgentsAgentIdAvatarPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyPostAgentAvatarV1ConvaiAgentsAgentIdAvatarPost &&
            (identical(other.avatarFile, avatarFile) ||
                const DeepCollectionEquality()
                    .equals(other.avatarFile, avatarFile)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(avatarFile) ^ runtimeType.hashCode;
}

extension $BodyPostAgentAvatarV1ConvaiAgentsAgentIdAvatarPostExtension
    on BodyPostAgentAvatarV1ConvaiAgentsAgentIdAvatarPost {
  BodyPostAgentAvatarV1ConvaiAgentsAgentIdAvatarPost copyWith(
      {String? avatarFile}) {
    return BodyPostAgentAvatarV1ConvaiAgentsAgentIdAvatarPost(
        avatarFile: avatarFile ?? this.avatarFile);
  }

  BodyPostAgentAvatarV1ConvaiAgentsAgentIdAvatarPost copyWithWrapped(
      {Wrapped<String>? avatarFile}) {
    return BodyPostAgentAvatarV1ConvaiAgentsAgentIdAvatarPost(
        avatarFile: (avatarFile != null ? avatarFile.value : this.avatarFile));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdRemoveRulesPost {
  const BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdRemoveRulesPost({
    required this.ruleStrings,
  });

  factory BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdRemoveRulesPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdRemoveRulesPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdRemoveRulesPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdRemoveRulesPostToJson(
          this);

  @JsonKey(name: 'rule_strings', defaultValue: <String>[])
  final List<String> ruleStrings;
  static const fromJsonFactory =
      _$BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdRemoveRulesPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdRemoveRulesPost &&
            (identical(other.ruleStrings, ruleStrings) ||
                const DeepCollectionEquality()
                    .equals(other.ruleStrings, ruleStrings)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ruleStrings) ^ runtimeType.hashCode;
}

extension $BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdRemoveRulesPostExtension
    on BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdRemoveRulesPost {
  BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdRemoveRulesPost
      copyWith({List<String>? ruleStrings}) {
    return BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdRemoveRulesPost(
        ruleStrings: ruleStrings ?? this.ruleStrings);
  }

  BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdRemoveRulesPost
      copyWithWrapped({Wrapped<List<String>>? ruleStrings}) {
    return BodyRemoveRulesFromThePronunciationDictionaryV1PronunciationDictionariesPronunciationDictionaryIdRemoveRulesPost(
        ruleStrings:
            (ruleStrings != null ? ruleStrings.value : this.ruleStrings));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyRenderAudioOrVideoForTheGivenLanguageV1DubbingResourceDubbingIdRenderLanguagePost {
  const BodyRenderAudioOrVideoForTheGivenLanguageV1DubbingResourceDubbingIdRenderLanguagePost({
    required this.renderType,
  });

  factory BodyRenderAudioOrVideoForTheGivenLanguageV1DubbingResourceDubbingIdRenderLanguagePost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyRenderAudioOrVideoForTheGivenLanguageV1DubbingResourceDubbingIdRenderLanguagePostFromJson(
          json);

  static const toJsonFactory =
      _$BodyRenderAudioOrVideoForTheGivenLanguageV1DubbingResourceDubbingIdRenderLanguagePostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyRenderAudioOrVideoForTheGivenLanguageV1DubbingResourceDubbingIdRenderLanguagePostToJson(
          this);

  @JsonKey(
    name: 'render_type',
    toJson: renderTypeToJson,
    fromJson: renderTypeFromJson,
  )
  final enums.RenderType renderType;
  static const fromJsonFactory =
      _$BodyRenderAudioOrVideoForTheGivenLanguageV1DubbingResourceDubbingIdRenderLanguagePostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyRenderAudioOrVideoForTheGivenLanguageV1DubbingResourceDubbingIdRenderLanguagePost &&
            (identical(other.renderType, renderType) ||
                const DeepCollectionEquality()
                    .equals(other.renderType, renderType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(renderType) ^ runtimeType.hashCode;
}

extension $BodyRenderAudioOrVideoForTheGivenLanguageV1DubbingResourceDubbingIdRenderLanguagePostExtension
    on BodyRenderAudioOrVideoForTheGivenLanguageV1DubbingResourceDubbingIdRenderLanguagePost {
  BodyRenderAudioOrVideoForTheGivenLanguageV1DubbingResourceDubbingIdRenderLanguagePost
      copyWith({enums.RenderType? renderType}) {
    return BodyRenderAudioOrVideoForTheGivenLanguageV1DubbingResourceDubbingIdRenderLanguagePost(
        renderType: renderType ?? this.renderType);
  }

  BodyRenderAudioOrVideoForTheGivenLanguageV1DubbingResourceDubbingIdRenderLanguagePost
      copyWithWrapped({Wrapped<enums.RenderType>? renderType}) {
    return BodyRenderAudioOrVideoForTheGivenLanguageV1DubbingResourceDubbingIdRenderLanguagePost(
        renderType: (renderType != null ? renderType.value : this.renderType));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyRequestManualVerificationV1VoicesPvcVoiceIdVerificationPost {
  const BodyRequestManualVerificationV1VoicesPvcVoiceIdVerificationPost({
    required this.files,
    this.extraText,
  });

  factory BodyRequestManualVerificationV1VoicesPvcVoiceIdVerificationPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyRequestManualVerificationV1VoicesPvcVoiceIdVerificationPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyRequestManualVerificationV1VoicesPvcVoiceIdVerificationPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyRequestManualVerificationV1VoicesPvcVoiceIdVerificationPostToJson(
          this);

  @JsonKey(name: 'files', defaultValue: <String>[])
  final List<String> files;
  @JsonKey(name: 'extra_text')
  final dynamic extraText;
  static const fromJsonFactory =
      _$BodyRequestManualVerificationV1VoicesPvcVoiceIdVerificationPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyRequestManualVerificationV1VoicesPvcVoiceIdVerificationPost &&
            (identical(other.files, files) ||
                const DeepCollectionEquality().equals(other.files, files)) &&
            (identical(other.extraText, extraText) ||
                const DeepCollectionEquality()
                    .equals(other.extraText, extraText)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(files) ^
      const DeepCollectionEquality().hash(extraText) ^
      runtimeType.hashCode;
}

extension $BodyRequestManualVerificationV1VoicesPvcVoiceIdVerificationPostExtension
    on BodyRequestManualVerificationV1VoicesPvcVoiceIdVerificationPost {
  BodyRequestManualVerificationV1VoicesPvcVoiceIdVerificationPost copyWith(
      {List<String>? files, dynamic extraText}) {
    return BodyRequestManualVerificationV1VoicesPvcVoiceIdVerificationPost(
        files: files ?? this.files, extraText: extraText ?? this.extraText);
  }

  BodyRequestManualVerificationV1VoicesPvcVoiceIdVerificationPost
      copyWithWrapped(
          {Wrapped<List<String>>? files, Wrapped<dynamic>? extraText}) {
    return BodyRequestManualVerificationV1VoicesPvcVoiceIdVerificationPost(
        files: (files != null ? files.value : this.files),
        extraText: (extraText != null ? extraText.value : this.extraText));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyRetrieveVoiceSampleAudioV1VoicesPvcVoiceIdSamplesSampleIdAudioGet {
  const BodyRetrieveVoiceSampleAudioV1VoicesPvcVoiceIdSamplesSampleIdAudioGet({
    this.removeBackgroundNoise,
  });

  factory BodyRetrieveVoiceSampleAudioV1VoicesPvcVoiceIdSamplesSampleIdAudioGet.fromJson(
          Map<String, dynamic> json) =>
      _$BodyRetrieveVoiceSampleAudioV1VoicesPvcVoiceIdSamplesSampleIdAudioGetFromJson(
          json);

  static const toJsonFactory =
      _$BodyRetrieveVoiceSampleAudioV1VoicesPvcVoiceIdSamplesSampleIdAudioGetToJson;
  Map<String, dynamic> toJson() =>
      _$BodyRetrieveVoiceSampleAudioV1VoicesPvcVoiceIdSamplesSampleIdAudioGetToJson(
          this);

  @JsonKey(name: 'remove_background_noise', defaultValue: false)
  final bool? removeBackgroundNoise;
  static const fromJsonFactory =
      _$BodyRetrieveVoiceSampleAudioV1VoicesPvcVoiceIdSamplesSampleIdAudioGetFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyRetrieveVoiceSampleAudioV1VoicesPvcVoiceIdSamplesSampleIdAudioGet &&
            (identical(other.removeBackgroundNoise, removeBackgroundNoise) ||
                const DeepCollectionEquality().equals(
                    other.removeBackgroundNoise, removeBackgroundNoise)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(removeBackgroundNoise) ^
      runtimeType.hashCode;
}

extension $BodyRetrieveVoiceSampleAudioV1VoicesPvcVoiceIdSamplesSampleIdAudioGetExtension
    on BodyRetrieveVoiceSampleAudioV1VoicesPvcVoiceIdSamplesSampleIdAudioGet {
  BodyRetrieveVoiceSampleAudioV1VoicesPvcVoiceIdSamplesSampleIdAudioGet
      copyWith({bool? removeBackgroundNoise}) {
    return BodyRetrieveVoiceSampleAudioV1VoicesPvcVoiceIdSamplesSampleIdAudioGet(
        removeBackgroundNoise:
            removeBackgroundNoise ?? this.removeBackgroundNoise);
  }

  BodyRetrieveVoiceSampleAudioV1VoicesPvcVoiceIdSamplesSampleIdAudioGet
      copyWithWrapped({Wrapped<bool?>? removeBackgroundNoise}) {
    return BodyRetrieveVoiceSampleAudioV1VoicesPvcVoiceIdSamplesSampleIdAudioGet(
        removeBackgroundNoise: (removeBackgroundNoise != null
            ? removeBackgroundNoise.value
            : this.removeBackgroundNoise));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyRunPVCTrainingV1VoicesPvcVoiceIdTrainPost {
  const BodyRunPVCTrainingV1VoicesPvcVoiceIdTrainPost({
    this.modelId,
  });

  factory BodyRunPVCTrainingV1VoicesPvcVoiceIdTrainPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyRunPVCTrainingV1VoicesPvcVoiceIdTrainPostFromJson(json);

  static const toJsonFactory =
      _$BodyRunPVCTrainingV1VoicesPvcVoiceIdTrainPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyRunPVCTrainingV1VoicesPvcVoiceIdTrainPostToJson(this);

  @JsonKey(name: 'model_id')
  final dynamic modelId;
  static const fromJsonFactory =
      _$BodyRunPVCTrainingV1VoicesPvcVoiceIdTrainPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyRunPVCTrainingV1VoicesPvcVoiceIdTrainPost &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality().equals(other.modelId, modelId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelId) ^ runtimeType.hashCode;
}

extension $BodyRunPVCTrainingV1VoicesPvcVoiceIdTrainPostExtension
    on BodyRunPVCTrainingV1VoicesPvcVoiceIdTrainPost {
  BodyRunPVCTrainingV1VoicesPvcVoiceIdTrainPost copyWith({dynamic modelId}) {
    return BodyRunPVCTrainingV1VoicesPvcVoiceIdTrainPost(
        modelId: modelId ?? this.modelId);
  }

  BodyRunPVCTrainingV1VoicesPvcVoiceIdTrainPost copyWithWrapped(
      {Wrapped<dynamic>? modelId}) {
    return BodyRunPVCTrainingV1VoicesPvcVoiceIdTrainPost(
        modelId: (modelId != null ? modelId.value : this.modelId));
  }
}

@JsonSerializable(explicitToJson: true)
class BodySendConversationFeedbackV1ConvaiConversationsConversationIdFeedbackPost {
  const BodySendConversationFeedbackV1ConvaiConversationsConversationIdFeedbackPost({
    required this.feedback,
  });

  factory BodySendConversationFeedbackV1ConvaiConversationsConversationIdFeedbackPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodySendConversationFeedbackV1ConvaiConversationsConversationIdFeedbackPostFromJson(
          json);

  static const toJsonFactory =
      _$BodySendConversationFeedbackV1ConvaiConversationsConversationIdFeedbackPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodySendConversationFeedbackV1ConvaiConversationsConversationIdFeedbackPostToJson(
          this);

  @JsonKey(
    name: 'feedback',
    toJson: userFeedbackScoreToJson,
    fromJson: userFeedbackScoreFromJson,
  )
  final enums.UserFeedbackScore feedback;
  static const fromJsonFactory =
      _$BodySendConversationFeedbackV1ConvaiConversationsConversationIdFeedbackPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodySendConversationFeedbackV1ConvaiConversationsConversationIdFeedbackPost &&
            (identical(other.feedback, feedback) ||
                const DeepCollectionEquality()
                    .equals(other.feedback, feedback)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(feedback) ^ runtimeType.hashCode;
}

extension $BodySendConversationFeedbackV1ConvaiConversationsConversationIdFeedbackPostExtension
    on BodySendConversationFeedbackV1ConvaiConversationsConversationIdFeedbackPost {
  BodySendConversationFeedbackV1ConvaiConversationsConversationIdFeedbackPost
      copyWith({enums.UserFeedbackScore? feedback}) {
    return BodySendConversationFeedbackV1ConvaiConversationsConversationIdFeedbackPost(
        feedback: feedback ?? this.feedback);
  }

  BodySendConversationFeedbackV1ConvaiConversationsConversationIdFeedbackPost
      copyWithWrapped({Wrapped<enums.UserFeedbackScore>? feedback}) {
    return BodySendConversationFeedbackV1ConvaiConversationsConversationIdFeedbackPost(
        feedback: (feedback != null ? feedback.value : this.feedback));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePost {
  const BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePost({
    required this.role,
    required this.resourceType,
    this.userEmail,
    this.groupId,
    this.workspaceApiKeyId,
  });

  factory BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostFromJson(
          json);

  static const toJsonFactory =
      _$BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostToJson(
          this);

  @JsonKey(
    name: 'role',
    toJson:
        bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRoleToJson,
    fromJson:
        bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRoleFromJson,
  )
  final enums
      .BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole
      role;
  @JsonKey(
    name: 'resource_type',
    toJson: workspaceResourceTypeToJson,
    fromJson: workspaceResourceTypeFromJson,
  )
  final enums.WorkspaceResourceType resourceType;
  @JsonKey(name: 'user_email')
  final dynamic userEmail;
  @JsonKey(name: 'group_id')
  final dynamic groupId;
  @JsonKey(name: 'workspace_api_key_id')
  final dynamic workspaceApiKeyId;
  static const fromJsonFactory =
      _$BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePost &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)) &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.userEmail, userEmail) ||
                const DeepCollectionEquality()
                    .equals(other.userEmail, userEmail)) &&
            (identical(other.groupId, groupId) ||
                const DeepCollectionEquality()
                    .equals(other.groupId, groupId)) &&
            (identical(other.workspaceApiKeyId, workspaceApiKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.workspaceApiKeyId, workspaceApiKeyId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(role) ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(userEmail) ^
      const DeepCollectionEquality().hash(groupId) ^
      const DeepCollectionEquality().hash(workspaceApiKeyId) ^
      runtimeType.hashCode;
}

extension $BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostExtension
    on BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePost {
  BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePost copyWith(
      {enums
          .BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole?
          role,
      enums.WorkspaceResourceType? resourceType,
      dynamic userEmail,
      dynamic groupId,
      dynamic workspaceApiKeyId}) {
    return BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePost(
        role: role ?? this.role,
        resourceType: resourceType ?? this.resourceType,
        userEmail: userEmail ?? this.userEmail,
        groupId: groupId ?? this.groupId,
        workspaceApiKeyId: workspaceApiKeyId ?? this.workspaceApiKeyId);
  }

  BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePost copyWithWrapped(
      {Wrapped<
              enums
              .BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole>?
          role,
      Wrapped<enums.WorkspaceResourceType>? resourceType,
      Wrapped<dynamic>? userEmail,
      Wrapped<dynamic>? groupId,
      Wrapped<dynamic>? workspaceApiKeyId}) {
    return BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePost(
        role: (role != null ? role.value : this.role),
        resourceType:
            (resourceType != null ? resourceType.value : this.resourceType),
        userEmail: (userEmail != null ? userEmail.value : this.userEmail),
        groupId: (groupId != null ? groupId.value : this.groupId),
        workspaceApiKeyId: (workspaceApiKeyId != null
            ? workspaceApiKeyId.value
            : this.workspaceApiKeyId));
  }
}

@JsonSerializable(explicitToJson: true)
class BodySimulatesAConversationStreamV1ConvaiAgentsAgentIdSimulateConversationStreamPost {
  const BodySimulatesAConversationStreamV1ConvaiAgentsAgentIdSimulateConversationStreamPost({
    required this.simulationSpecification,
    this.extraEvaluationCriteria,
  });

  factory BodySimulatesAConversationStreamV1ConvaiAgentsAgentIdSimulateConversationStreamPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodySimulatesAConversationStreamV1ConvaiAgentsAgentIdSimulateConversationStreamPostFromJson(
          json);

  static const toJsonFactory =
      _$BodySimulatesAConversationStreamV1ConvaiAgentsAgentIdSimulateConversationStreamPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodySimulatesAConversationStreamV1ConvaiAgentsAgentIdSimulateConversationStreamPostToJson(
          this);

  @JsonKey(name: 'simulation_specification')
  final ConversationSimulationSpecification simulationSpecification;
  @JsonKey(name: 'extra_evaluation_criteria')
  final dynamic extraEvaluationCriteria;
  static const fromJsonFactory =
      _$BodySimulatesAConversationStreamV1ConvaiAgentsAgentIdSimulateConversationStreamPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodySimulatesAConversationStreamV1ConvaiAgentsAgentIdSimulateConversationStreamPost &&
            (identical(
                    other.simulationSpecification, simulationSpecification) ||
                const DeepCollectionEquality().equals(
                    other.simulationSpecification, simulationSpecification)) &&
            (identical(
                    other.extraEvaluationCriteria, extraEvaluationCriteria) ||
                const DeepCollectionEquality().equals(
                    other.extraEvaluationCriteria, extraEvaluationCriteria)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(simulationSpecification) ^
      const DeepCollectionEquality().hash(extraEvaluationCriteria) ^
      runtimeType.hashCode;
}

extension $BodySimulatesAConversationStreamV1ConvaiAgentsAgentIdSimulateConversationStreamPostExtension
    on BodySimulatesAConversationStreamV1ConvaiAgentsAgentIdSimulateConversationStreamPost {
  BodySimulatesAConversationStreamV1ConvaiAgentsAgentIdSimulateConversationStreamPost
      copyWith(
          {ConversationSimulationSpecification? simulationSpecification,
          dynamic extraEvaluationCriteria}) {
    return BodySimulatesAConversationStreamV1ConvaiAgentsAgentIdSimulateConversationStreamPost(
        simulationSpecification:
            simulationSpecification ?? this.simulationSpecification,
        extraEvaluationCriteria:
            extraEvaluationCriteria ?? this.extraEvaluationCriteria);
  }

  BodySimulatesAConversationStreamV1ConvaiAgentsAgentIdSimulateConversationStreamPost
      copyWithWrapped(
          {Wrapped<ConversationSimulationSpecification>?
              simulationSpecification,
          Wrapped<dynamic>? extraEvaluationCriteria}) {
    return BodySimulatesAConversationStreamV1ConvaiAgentsAgentIdSimulateConversationStreamPost(
        simulationSpecification: (simulationSpecification != null
            ? simulationSpecification.value
            : this.simulationSpecification),
        extraEvaluationCriteria: (extraEvaluationCriteria != null
            ? extraEvaluationCriteria.value
            : this.extraEvaluationCriteria));
  }
}

@JsonSerializable(explicitToJson: true)
class BodySimulatesAConversationV1ConvaiAgentsAgentIdSimulateConversationPost {
  const BodySimulatesAConversationV1ConvaiAgentsAgentIdSimulateConversationPost({
    required this.simulationSpecification,
    this.extraEvaluationCriteria,
  });

  factory BodySimulatesAConversationV1ConvaiAgentsAgentIdSimulateConversationPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodySimulatesAConversationV1ConvaiAgentsAgentIdSimulateConversationPostFromJson(
          json);

  static const toJsonFactory =
      _$BodySimulatesAConversationV1ConvaiAgentsAgentIdSimulateConversationPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodySimulatesAConversationV1ConvaiAgentsAgentIdSimulateConversationPostToJson(
          this);

  @JsonKey(name: 'simulation_specification')
  final ConversationSimulationSpecification simulationSpecification;
  @JsonKey(name: 'extra_evaluation_criteria')
  final dynamic extraEvaluationCriteria;
  static const fromJsonFactory =
      _$BodySimulatesAConversationV1ConvaiAgentsAgentIdSimulateConversationPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodySimulatesAConversationV1ConvaiAgentsAgentIdSimulateConversationPost &&
            (identical(
                    other.simulationSpecification, simulationSpecification) ||
                const DeepCollectionEquality().equals(
                    other.simulationSpecification, simulationSpecification)) &&
            (identical(
                    other.extraEvaluationCriteria, extraEvaluationCriteria) ||
                const DeepCollectionEquality().equals(
                    other.extraEvaluationCriteria, extraEvaluationCriteria)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(simulationSpecification) ^
      const DeepCollectionEquality().hash(extraEvaluationCriteria) ^
      runtimeType.hashCode;
}

extension $BodySimulatesAConversationV1ConvaiAgentsAgentIdSimulateConversationPostExtension
    on BodySimulatesAConversationV1ConvaiAgentsAgentIdSimulateConversationPost {
  BodySimulatesAConversationV1ConvaiAgentsAgentIdSimulateConversationPost
      copyWith(
          {ConversationSimulationSpecification? simulationSpecification,
          dynamic extraEvaluationCriteria}) {
    return BodySimulatesAConversationV1ConvaiAgentsAgentIdSimulateConversationPost(
        simulationSpecification:
            simulationSpecification ?? this.simulationSpecification,
        extraEvaluationCriteria:
            extraEvaluationCriteria ?? this.extraEvaluationCriteria);
  }

  BodySimulatesAConversationV1ConvaiAgentsAgentIdSimulateConversationPost
      copyWithWrapped(
          {Wrapped<ConversationSimulationSpecification>?
              simulationSpecification,
          Wrapped<dynamic>? extraEvaluationCriteria}) {
    return BodySimulatesAConversationV1ConvaiAgentsAgentIdSimulateConversationPost(
        simulationSpecification: (simulationSpecification != null
            ? simulationSpecification.value
            : this.simulationSpecification),
        extraEvaluationCriteria: (extraEvaluationCriteria != null
            ? extraEvaluationCriteria.value
            : this.extraEvaluationCriteria));
  }
}

@JsonSerializable(explicitToJson: true)
class BodySoundGenerationV1SoundGenerationPost {
  const BodySoundGenerationV1SoundGenerationPost({
    required this.text,
    this.durationSeconds,
    this.promptInfluence,
  });

  factory BodySoundGenerationV1SoundGenerationPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodySoundGenerationV1SoundGenerationPostFromJson(json);

  static const toJsonFactory = _$BodySoundGenerationV1SoundGenerationPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodySoundGenerationV1SoundGenerationPostToJson(this);

  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'duration_seconds')
  final dynamic durationSeconds;
  @JsonKey(name: 'prompt_influence')
  final dynamic promptInfluence;
  static const fromJsonFactory =
      _$BodySoundGenerationV1SoundGenerationPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodySoundGenerationV1SoundGenerationPost &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.durationSeconds, durationSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.durationSeconds, durationSeconds)) &&
            (identical(other.promptInfluence, promptInfluence) ||
                const DeepCollectionEquality()
                    .equals(other.promptInfluence, promptInfluence)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(durationSeconds) ^
      const DeepCollectionEquality().hash(promptInfluence) ^
      runtimeType.hashCode;
}

extension $BodySoundGenerationV1SoundGenerationPostExtension
    on BodySoundGenerationV1SoundGenerationPost {
  BodySoundGenerationV1SoundGenerationPost copyWith(
      {String? text, dynamic durationSeconds, dynamic promptInfluence}) {
    return BodySoundGenerationV1SoundGenerationPost(
        text: text ?? this.text,
        durationSeconds: durationSeconds ?? this.durationSeconds,
        promptInfluence: promptInfluence ?? this.promptInfluence);
  }

  BodySoundGenerationV1SoundGenerationPost copyWithWrapped(
      {Wrapped<String>? text,
      Wrapped<dynamic>? durationSeconds,
      Wrapped<dynamic>? promptInfluence}) {
    return BodySoundGenerationV1SoundGenerationPost(
        text: (text != null ? text.value : this.text),
        durationSeconds: (durationSeconds != null
            ? durationSeconds.value
            : this.durationSeconds),
        promptInfluence: (promptInfluence != null
            ? promptInfluence.value
            : this.promptInfluence));
  }
}

@JsonSerializable(explicitToJson: true)
class BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost {
  const BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost({
    required this.audio,
    this.modelId,
    this.voiceSettings,
    this.seed,
    this.removeBackgroundNoise,
    this.fileFormat,
  });

  factory BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPostFromJson(
          json);

  static const toJsonFactory =
      _$BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPostToJson(
          this);

  @JsonKey(name: 'audio')
  final String audio;
  @JsonKey(name: 'model_id')
  final String? modelId;
  @JsonKey(name: 'voice_settings')
  final dynamic voiceSettings;
  @JsonKey(name: 'seed')
  final dynamic seed;
  @JsonKey(name: 'remove_background_noise', defaultValue: false)
  final bool? removeBackgroundNoise;
  @JsonKey(name: 'file_format')
  final dynamic fileFormat;
  static const fromJsonFactory =
      _$BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost &&
            (identical(other.audio, audio) ||
                const DeepCollectionEquality().equals(other.audio, audio)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.voiceSettings, voiceSettings) ||
                const DeepCollectionEquality()
                    .equals(other.voiceSettings, voiceSettings)) &&
            (identical(other.seed, seed) ||
                const DeepCollectionEquality().equals(other.seed, seed)) &&
            (identical(other.removeBackgroundNoise, removeBackgroundNoise) ||
                const DeepCollectionEquality().equals(
                    other.removeBackgroundNoise, removeBackgroundNoise)) &&
            (identical(other.fileFormat, fileFormat) ||
                const DeepCollectionEquality()
                    .equals(other.fileFormat, fileFormat)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(audio) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(voiceSettings) ^
      const DeepCollectionEquality().hash(seed) ^
      const DeepCollectionEquality().hash(removeBackgroundNoise) ^
      const DeepCollectionEquality().hash(fileFormat) ^
      runtimeType.hashCode;
}

extension $BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPostExtension
    on BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost {
  BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost copyWith(
      {String? audio,
      String? modelId,
      dynamic voiceSettings,
      dynamic seed,
      bool? removeBackgroundNoise,
      dynamic fileFormat}) {
    return BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost(
        audio: audio ?? this.audio,
        modelId: modelId ?? this.modelId,
        voiceSettings: voiceSettings ?? this.voiceSettings,
        seed: seed ?? this.seed,
        removeBackgroundNoise:
            removeBackgroundNoise ?? this.removeBackgroundNoise,
        fileFormat: fileFormat ?? this.fileFormat);
  }

  BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost copyWithWrapped(
      {Wrapped<String>? audio,
      Wrapped<String?>? modelId,
      Wrapped<dynamic>? voiceSettings,
      Wrapped<dynamic>? seed,
      Wrapped<bool?>? removeBackgroundNoise,
      Wrapped<dynamic>? fileFormat}) {
    return BodySpeechToSpeechStreamingV1SpeechToSpeechVoiceIdStreamPost(
        audio: (audio != null ? audio.value : this.audio),
        modelId: (modelId != null ? modelId.value : this.modelId),
        voiceSettings:
            (voiceSettings != null ? voiceSettings.value : this.voiceSettings),
        seed: (seed != null ? seed.value : this.seed),
        removeBackgroundNoise: (removeBackgroundNoise != null
            ? removeBackgroundNoise.value
            : this.removeBackgroundNoise),
        fileFormat: (fileFormat != null ? fileFormat.value : this.fileFormat));
  }
}

@JsonSerializable(explicitToJson: true)
class BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost {
  const BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost({
    required this.audio,
    this.modelId,
    this.voiceSettings,
    this.seed,
    this.removeBackgroundNoise,
    this.fileFormat,
  });

  factory BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodySpeechToSpeechV1SpeechToSpeechVoiceIdPostFromJson(json);

  static const toJsonFactory =
      _$BodySpeechToSpeechV1SpeechToSpeechVoiceIdPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodySpeechToSpeechV1SpeechToSpeechVoiceIdPostToJson(this);

  @JsonKey(name: 'audio')
  final String audio;
  @JsonKey(name: 'model_id')
  final String? modelId;
  @JsonKey(name: 'voice_settings')
  final dynamic voiceSettings;
  @JsonKey(name: 'seed')
  final dynamic seed;
  @JsonKey(name: 'remove_background_noise', defaultValue: false)
  final bool? removeBackgroundNoise;
  @JsonKey(name: 'file_format')
  final dynamic fileFormat;
  static const fromJsonFactory =
      _$BodySpeechToSpeechV1SpeechToSpeechVoiceIdPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost &&
            (identical(other.audio, audio) ||
                const DeepCollectionEquality().equals(other.audio, audio)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.voiceSettings, voiceSettings) ||
                const DeepCollectionEquality()
                    .equals(other.voiceSettings, voiceSettings)) &&
            (identical(other.seed, seed) ||
                const DeepCollectionEquality().equals(other.seed, seed)) &&
            (identical(other.removeBackgroundNoise, removeBackgroundNoise) ||
                const DeepCollectionEquality().equals(
                    other.removeBackgroundNoise, removeBackgroundNoise)) &&
            (identical(other.fileFormat, fileFormat) ||
                const DeepCollectionEquality()
                    .equals(other.fileFormat, fileFormat)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(audio) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(voiceSettings) ^
      const DeepCollectionEquality().hash(seed) ^
      const DeepCollectionEquality().hash(removeBackgroundNoise) ^
      const DeepCollectionEquality().hash(fileFormat) ^
      runtimeType.hashCode;
}

extension $BodySpeechToSpeechV1SpeechToSpeechVoiceIdPostExtension
    on BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost {
  BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost copyWith(
      {String? audio,
      String? modelId,
      dynamic voiceSettings,
      dynamic seed,
      bool? removeBackgroundNoise,
      dynamic fileFormat}) {
    return BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost(
        audio: audio ?? this.audio,
        modelId: modelId ?? this.modelId,
        voiceSettings: voiceSettings ?? this.voiceSettings,
        seed: seed ?? this.seed,
        removeBackgroundNoise:
            removeBackgroundNoise ?? this.removeBackgroundNoise,
        fileFormat: fileFormat ?? this.fileFormat);
  }

  BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost copyWithWrapped(
      {Wrapped<String>? audio,
      Wrapped<String?>? modelId,
      Wrapped<dynamic>? voiceSettings,
      Wrapped<dynamic>? seed,
      Wrapped<bool?>? removeBackgroundNoise,
      Wrapped<dynamic>? fileFormat}) {
    return BodySpeechToSpeechV1SpeechToSpeechVoiceIdPost(
        audio: (audio != null ? audio.value : this.audio),
        modelId: (modelId != null ? modelId.value : this.modelId),
        voiceSettings:
            (voiceSettings != null ? voiceSettings.value : this.voiceSettings),
        seed: (seed != null ? seed.value : this.seed),
        removeBackgroundNoise: (removeBackgroundNoise != null
            ? removeBackgroundNoise.value
            : this.removeBackgroundNoise),
        fileFormat: (fileFormat != null ? fileFormat.value : this.fileFormat));
  }
}

@JsonSerializable(explicitToJson: true)
class BodySpeechToTextV1SpeechToTextPost {
  const BodySpeechToTextV1SpeechToTextPost({
    required this.modelId,
    this.file,
    this.languageCode,
    this.tagAudioEvents,
    this.numSpeakers,
    this.timestampsGranularity,
    this.diarize,
    this.additionalFormats,
    this.fileFormat,
    this.cloudStorageUrl,
    this.webhook,
  });

  factory BodySpeechToTextV1SpeechToTextPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodySpeechToTextV1SpeechToTextPostFromJson(json);

  static const toJsonFactory = _$BodySpeechToTextV1SpeechToTextPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodySpeechToTextV1SpeechToTextPostToJson(this);

  @JsonKey(name: 'model_id')
  final String modelId;
  @JsonKey(name: 'file')
  final dynamic file;
  @JsonKey(name: 'language_code')
  final dynamic languageCode;
  @JsonKey(name: 'tag_audio_events', defaultValue: true)
  final bool? tagAudioEvents;
  @JsonKey(name: 'num_speakers')
  final dynamic numSpeakers;
  @JsonKey(
    name: 'timestamps_granularity',
    toJson:
        bodySpeechToTextV1SpeechToTextPostTimestampsGranularityNullableToJson,
    fromJson:
        bodySpeechToTextV1SpeechToTextPostTimestampsGranularityTimestampsGranularityNullableFromJson,
  )
  final enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity?
      timestampsGranularity;
  static enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity?
      bodySpeechToTextV1SpeechToTextPostTimestampsGranularityTimestampsGranularityNullableFromJson(
              Object? value) =>
          bodySpeechToTextV1SpeechToTextPostTimestampsGranularityNullableFromJson(
              value,
              enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity
                  .word);

  @JsonKey(name: 'diarize', defaultValue: false)
  final bool? diarize;
  @JsonKey(name: 'additional_formats')
  final List<ExportOptions>? additionalFormats;
  @JsonKey(
    name: 'file_format',
    toJson: bodySpeechToTextV1SpeechToTextPostFileFormatNullableToJson,
    fromJson:
        bodySpeechToTextV1SpeechToTextPostFileFormatFileFormatNullableFromJson,
  )
  final enums.BodySpeechToTextV1SpeechToTextPostFileFormat? fileFormat;
  static enums.BodySpeechToTextV1SpeechToTextPostFileFormat?
      bodySpeechToTextV1SpeechToTextPostFileFormatFileFormatNullableFromJson(
              Object? value) =>
          bodySpeechToTextV1SpeechToTextPostFileFormatNullableFromJson(
              value, enums.BodySpeechToTextV1SpeechToTextPostFileFormat.other);

  @JsonKey(name: 'cloud_storage_url')
  final dynamic cloudStorageUrl;
  @JsonKey(name: 'webhook', defaultValue: false)
  final bool? webhook;
  static const fromJsonFactory = _$BodySpeechToTextV1SpeechToTextPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodySpeechToTextV1SpeechToTextPost &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)) &&
            (identical(other.languageCode, languageCode) ||
                const DeepCollectionEquality()
                    .equals(other.languageCode, languageCode)) &&
            (identical(other.tagAudioEvents, tagAudioEvents) ||
                const DeepCollectionEquality()
                    .equals(other.tagAudioEvents, tagAudioEvents)) &&
            (identical(other.numSpeakers, numSpeakers) ||
                const DeepCollectionEquality()
                    .equals(other.numSpeakers, numSpeakers)) &&
            (identical(other.timestampsGranularity, timestampsGranularity) ||
                const DeepCollectionEquality().equals(
                    other.timestampsGranularity, timestampsGranularity)) &&
            (identical(other.diarize, diarize) ||
                const DeepCollectionEquality()
                    .equals(other.diarize, diarize)) &&
            (identical(other.additionalFormats, additionalFormats) ||
                const DeepCollectionEquality()
                    .equals(other.additionalFormats, additionalFormats)) &&
            (identical(other.fileFormat, fileFormat) ||
                const DeepCollectionEquality()
                    .equals(other.fileFormat, fileFormat)) &&
            (identical(other.cloudStorageUrl, cloudStorageUrl) ||
                const DeepCollectionEquality()
                    .equals(other.cloudStorageUrl, cloudStorageUrl)) &&
            (identical(other.webhook, webhook) ||
                const DeepCollectionEquality().equals(other.webhook, webhook)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(file) ^
      const DeepCollectionEquality().hash(languageCode) ^
      const DeepCollectionEquality().hash(tagAudioEvents) ^
      const DeepCollectionEquality().hash(numSpeakers) ^
      const DeepCollectionEquality().hash(timestampsGranularity) ^
      const DeepCollectionEquality().hash(diarize) ^
      const DeepCollectionEquality().hash(additionalFormats) ^
      const DeepCollectionEquality().hash(fileFormat) ^
      const DeepCollectionEquality().hash(cloudStorageUrl) ^
      const DeepCollectionEquality().hash(webhook) ^
      runtimeType.hashCode;
}

extension $BodySpeechToTextV1SpeechToTextPostExtension
    on BodySpeechToTextV1SpeechToTextPost {
  BodySpeechToTextV1SpeechToTextPost copyWith(
      {String? modelId,
      dynamic file,
      dynamic languageCode,
      bool? tagAudioEvents,
      dynamic numSpeakers,
      enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity?
          timestampsGranularity,
      bool? diarize,
      List<ExportOptions>? additionalFormats,
      enums.BodySpeechToTextV1SpeechToTextPostFileFormat? fileFormat,
      dynamic cloudStorageUrl,
      bool? webhook}) {
    return BodySpeechToTextV1SpeechToTextPost(
        modelId: modelId ?? this.modelId,
        file: file ?? this.file,
        languageCode: languageCode ?? this.languageCode,
        tagAudioEvents: tagAudioEvents ?? this.tagAudioEvents,
        numSpeakers: numSpeakers ?? this.numSpeakers,
        timestampsGranularity:
            timestampsGranularity ?? this.timestampsGranularity,
        diarize: diarize ?? this.diarize,
        additionalFormats: additionalFormats ?? this.additionalFormats,
        fileFormat: fileFormat ?? this.fileFormat,
        cloudStorageUrl: cloudStorageUrl ?? this.cloudStorageUrl,
        webhook: webhook ?? this.webhook);
  }

  BodySpeechToTextV1SpeechToTextPost copyWithWrapped(
      {Wrapped<String>? modelId,
      Wrapped<dynamic>? file,
      Wrapped<dynamic>? languageCode,
      Wrapped<bool?>? tagAudioEvents,
      Wrapped<dynamic>? numSpeakers,
      Wrapped<enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity?>?
          timestampsGranularity,
      Wrapped<bool?>? diarize,
      Wrapped<List<ExportOptions>?>? additionalFormats,
      Wrapped<enums.BodySpeechToTextV1SpeechToTextPostFileFormat?>? fileFormat,
      Wrapped<dynamic>? cloudStorageUrl,
      Wrapped<bool?>? webhook}) {
    return BodySpeechToTextV1SpeechToTextPost(
        modelId: (modelId != null ? modelId.value : this.modelId),
        file: (file != null ? file.value : this.file),
        languageCode:
            (languageCode != null ? languageCode.value : this.languageCode),
        tagAudioEvents: (tagAudioEvents != null
            ? tagAudioEvents.value
            : this.tagAudioEvents),
        numSpeakers:
            (numSpeakers != null ? numSpeakers.value : this.numSpeakers),
        timestampsGranularity: (timestampsGranularity != null
            ? timestampsGranularity.value
            : this.timestampsGranularity),
        diarize: (diarize != null ? diarize.value : this.diarize),
        additionalFormats: (additionalFormats != null
            ? additionalFormats.value
            : this.additionalFormats),
        fileFormat: (fileFormat != null ? fileFormat.value : this.fileFormat),
        cloudStorageUrl: (cloudStorageUrl != null
            ? cloudStorageUrl.value
            : this.cloudStorageUrl),
        webhook: (webhook != null ? webhook.value : this.webhook));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyStreamStudioProjectAudioV1StudioProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost {
  const BodyStreamStudioProjectAudioV1StudioProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost({
    this.convertToMpeg,
  });

  factory BodyStreamStudioProjectAudioV1StudioProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyStreamStudioProjectAudioV1StudioProjectsProjectIdSnapshotsProjectSnapshotIdStreamPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyStreamStudioProjectAudioV1StudioProjectsProjectIdSnapshotsProjectSnapshotIdStreamPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyStreamStudioProjectAudioV1StudioProjectsProjectIdSnapshotsProjectSnapshotIdStreamPostToJson(
          this);

  @JsonKey(name: 'convert_to_mpeg', defaultValue: false)
  final bool? convertToMpeg;
  static const fromJsonFactory =
      _$BodyStreamStudioProjectAudioV1StudioProjectsProjectIdSnapshotsProjectSnapshotIdStreamPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyStreamStudioProjectAudioV1StudioProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost &&
            (identical(other.convertToMpeg, convertToMpeg) ||
                const DeepCollectionEquality()
                    .equals(other.convertToMpeg, convertToMpeg)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(convertToMpeg) ^ runtimeType.hashCode;
}

extension $BodyStreamStudioProjectAudioV1StudioProjectsProjectIdSnapshotsProjectSnapshotIdStreamPostExtension
    on BodyStreamStudioProjectAudioV1StudioProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost {
  BodyStreamStudioProjectAudioV1StudioProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost
      copyWith({bool? convertToMpeg}) {
    return BodyStreamStudioProjectAudioV1StudioProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost(
        convertToMpeg: convertToMpeg ?? this.convertToMpeg);
  }

  BodyStreamStudioProjectAudioV1StudioProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost
      copyWithWrapped({Wrapped<bool?>? convertToMpeg}) {
    return BodyStreamStudioProjectAudioV1StudioProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost(
        convertToMpeg:
            (convertToMpeg != null ? convertToMpeg.value : this.convertToMpeg));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyStreamChapterAudioV1ProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPost {
  const BodyStreamChapterAudioV1ProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPost({
    this.convertToMpeg,
  });

  factory BodyStreamChapterAudioV1ProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyStreamChapterAudioV1ProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyStreamChapterAudioV1ProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyStreamChapterAudioV1ProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPostToJson(
          this);

  @JsonKey(name: 'convert_to_mpeg', defaultValue: false)
  final bool? convertToMpeg;
  static const fromJsonFactory =
      _$BodyStreamChapterAudioV1ProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyStreamChapterAudioV1ProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPost &&
            (identical(other.convertToMpeg, convertToMpeg) ||
                const DeepCollectionEquality()
                    .equals(other.convertToMpeg, convertToMpeg)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(convertToMpeg) ^ runtimeType.hashCode;
}

extension $BodyStreamChapterAudioV1ProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPostExtension
    on BodyStreamChapterAudioV1ProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPost {
  BodyStreamChapterAudioV1ProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPost
      copyWith({bool? convertToMpeg}) {
    return BodyStreamChapterAudioV1ProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPost(
        convertToMpeg: convertToMpeg ?? this.convertToMpeg);
  }

  BodyStreamChapterAudioV1ProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPost
      copyWithWrapped({Wrapped<bool?>? convertToMpeg}) {
    return BodyStreamChapterAudioV1ProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPost(
        convertToMpeg:
            (convertToMpeg != null ? convertToMpeg.value : this.convertToMpeg));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyStreamChapterAudioV1StudioProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPost {
  const BodyStreamChapterAudioV1StudioProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPost({
    this.convertToMpeg,
  });

  factory BodyStreamChapterAudioV1StudioProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyStreamChapterAudioV1StudioProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyStreamChapterAudioV1StudioProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyStreamChapterAudioV1StudioProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPostToJson(
          this);

  @JsonKey(name: 'convert_to_mpeg', defaultValue: false)
  final bool? convertToMpeg;
  static const fromJsonFactory =
      _$BodyStreamChapterAudioV1StudioProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyStreamChapterAudioV1StudioProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPost &&
            (identical(other.convertToMpeg, convertToMpeg) ||
                const DeepCollectionEquality()
                    .equals(other.convertToMpeg, convertToMpeg)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(convertToMpeg) ^ runtimeType.hashCode;
}

extension $BodyStreamChapterAudioV1StudioProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPostExtension
    on BodyStreamChapterAudioV1StudioProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPost {
  BodyStreamChapterAudioV1StudioProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPost
      copyWith({bool? convertToMpeg}) {
    return BodyStreamChapterAudioV1StudioProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPost(
        convertToMpeg: convertToMpeg ?? this.convertToMpeg);
  }

  BodyStreamChapterAudioV1StudioProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPost
      copyWithWrapped({Wrapped<bool?>? convertToMpeg}) {
    return BodyStreamChapterAudioV1StudioProjectsProjectIdChaptersChapterIdSnapshotsChapterSnapshotIdStreamPost(
        convertToMpeg:
            (convertToMpeg != null ? convertToMpeg.value : this.convertToMpeg));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyStreamProjectAudioV1ProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost {
  const BodyStreamProjectAudioV1ProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost({
    this.convertToMpeg,
  });

  factory BodyStreamProjectAudioV1ProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyStreamProjectAudioV1ProjectsProjectIdSnapshotsProjectSnapshotIdStreamPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyStreamProjectAudioV1ProjectsProjectIdSnapshotsProjectSnapshotIdStreamPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyStreamProjectAudioV1ProjectsProjectIdSnapshotsProjectSnapshotIdStreamPostToJson(
          this);

  @JsonKey(name: 'convert_to_mpeg', defaultValue: false)
  final bool? convertToMpeg;
  static const fromJsonFactory =
      _$BodyStreamProjectAudioV1ProjectsProjectIdSnapshotsProjectSnapshotIdStreamPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyStreamProjectAudioV1ProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost &&
            (identical(other.convertToMpeg, convertToMpeg) ||
                const DeepCollectionEquality()
                    .equals(other.convertToMpeg, convertToMpeg)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(convertToMpeg) ^ runtimeType.hashCode;
}

extension $BodyStreamProjectAudioV1ProjectsProjectIdSnapshotsProjectSnapshotIdStreamPostExtension
    on BodyStreamProjectAudioV1ProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost {
  BodyStreamProjectAudioV1ProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost
      copyWith({bool? convertToMpeg}) {
    return BodyStreamProjectAudioV1ProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost(
        convertToMpeg: convertToMpeg ?? this.convertToMpeg);
  }

  BodyStreamProjectAudioV1ProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost
      copyWithWrapped({Wrapped<bool?>? convertToMpeg}) {
    return BodyStreamProjectAudioV1ProjectsProjectIdSnapshotsProjectSnapshotIdStreamPost(
        convertToMpeg:
            (convertToMpeg != null ? convertToMpeg.value : this.convertToMpeg));
  }
}

@JsonSerializable(explicitToJson: true)
class BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost {
  const BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost({
    required this.callName,
    required this.agentId,
    required this.agentPhoneNumberId,
    required this.scheduledTimeUnix,
    required this.recipients,
  });

  factory BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPostFromJson(json);

  static const toJsonFactory =
      _$BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPostToJson(this);

  @JsonKey(name: 'call_name')
  final String callName;
  @JsonKey(name: 'agent_id')
  final String agentId;
  @JsonKey(name: 'agent_phone_number_id')
  final String agentPhoneNumberId;
  @JsonKey(name: 'scheduled_time_unix')
  final dynamic scheduledTimeUnix;
  @JsonKey(name: 'recipients', defaultValue: <OutboundCallRecipient>[])
  final List<OutboundCallRecipient> recipients;
  static const fromJsonFactory =
      _$BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost &&
            (identical(other.callName, callName) ||
                const DeepCollectionEquality()
                    .equals(other.callName, callName)) &&
            (identical(other.agentId, agentId) ||
                const DeepCollectionEquality()
                    .equals(other.agentId, agentId)) &&
            (identical(other.agentPhoneNumberId, agentPhoneNumberId) ||
                const DeepCollectionEquality()
                    .equals(other.agentPhoneNumberId, agentPhoneNumberId)) &&
            (identical(other.scheduledTimeUnix, scheduledTimeUnix) ||
                const DeepCollectionEquality()
                    .equals(other.scheduledTimeUnix, scheduledTimeUnix)) &&
            (identical(other.recipients, recipients) ||
                const DeepCollectionEquality()
                    .equals(other.recipients, recipients)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(callName) ^
      const DeepCollectionEquality().hash(agentId) ^
      const DeepCollectionEquality().hash(agentPhoneNumberId) ^
      const DeepCollectionEquality().hash(scheduledTimeUnix) ^
      const DeepCollectionEquality().hash(recipients) ^
      runtimeType.hashCode;
}

extension $BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPostExtension
    on BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost {
  BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost copyWith(
      {String? callName,
      String? agentId,
      String? agentPhoneNumberId,
      dynamic scheduledTimeUnix,
      List<OutboundCallRecipient>? recipients}) {
    return BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost(
        callName: callName ?? this.callName,
        agentId: agentId ?? this.agentId,
        agentPhoneNumberId: agentPhoneNumberId ?? this.agentPhoneNumberId,
        scheduledTimeUnix: scheduledTimeUnix ?? this.scheduledTimeUnix,
        recipients: recipients ?? this.recipients);
  }

  BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost copyWithWrapped(
      {Wrapped<String>? callName,
      Wrapped<String>? agentId,
      Wrapped<String>? agentPhoneNumberId,
      Wrapped<dynamic>? scheduledTimeUnix,
      Wrapped<List<OutboundCallRecipient>>? recipients}) {
    return BodySubmitABatchCallRequestV1ConvaiBatchCallingSubmitPost(
        callName: (callName != null ? callName.value : this.callName),
        agentId: (agentId != null ? agentId.value : this.agentId),
        agentPhoneNumberId: (agentPhoneNumberId != null
            ? agentPhoneNumberId.value
            : this.agentPhoneNumberId),
        scheduledTimeUnix: (scheduledTimeUnix != null
            ? scheduledTimeUnix.value
            : this.scheduledTimeUnix),
        recipients: (recipients != null ? recipients.value : this.recipients));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost {
  const BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost({
    required this.inputs,
    this.modelId,
    this.settings,
    this.pronunciationDictionaryLocators,
    this.seed,
  });

  factory BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostToJson(
          this);

  @JsonKey(name: 'inputs', defaultValue: <DialogueInput>[])
  final List<DialogueInput> inputs;
  @JsonKey(name: 'model_id')
  final String? modelId;
  @JsonKey(name: 'settings')
  final dynamic settings;
  @JsonKey(name: 'pronunciation_dictionary_locators')
  final dynamic pronunciationDictionaryLocators;
  @JsonKey(name: 'seed')
  final dynamic seed;
  static const fromJsonFactory =
      _$BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost &&
            (identical(other.inputs, inputs) ||
                const DeepCollectionEquality().equals(other.inputs, inputs)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.settings, settings) ||
                const DeepCollectionEquality()
                    .equals(other.settings, settings)) &&
            (identical(other.pronunciationDictionaryLocators,
                    pronunciationDictionaryLocators) ||
                const DeepCollectionEquality().equals(
                    other.pronunciationDictionaryLocators,
                    pronunciationDictionaryLocators)) &&
            (identical(other.seed, seed) ||
                const DeepCollectionEquality().equals(other.seed, seed)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(inputs) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(settings) ^
      const DeepCollectionEquality().hash(pronunciationDictionaryLocators) ^
      const DeepCollectionEquality().hash(seed) ^
      runtimeType.hashCode;
}

extension $BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPostExtension
    on BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost {
  BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost copyWith(
      {List<DialogueInput>? inputs,
      String? modelId,
      dynamic settings,
      dynamic pronunciationDictionaryLocators,
      dynamic seed}) {
    return BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost(
        inputs: inputs ?? this.inputs,
        modelId: modelId ?? this.modelId,
        settings: settings ?? this.settings,
        pronunciationDictionaryLocators: pronunciationDictionaryLocators ??
            this.pronunciationDictionaryLocators,
        seed: seed ?? this.seed);
  }

  BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost
      copyWithWrapped(
          {Wrapped<List<DialogueInput>>? inputs,
          Wrapped<String?>? modelId,
          Wrapped<dynamic>? settings,
          Wrapped<dynamic>? pronunciationDictionaryLocators,
          Wrapped<dynamic>? seed}) {
    return BodyTextToDialogueMultiVoiceStreamingV1TextToDialogueStreamPost(
        inputs: (inputs != null ? inputs.value : this.inputs),
        modelId: (modelId != null ? modelId.value : this.modelId),
        settings: (settings != null ? settings.value : this.settings),
        pronunciationDictionaryLocators:
            (pronunciationDictionaryLocators != null
                ? pronunciationDictionaryLocators.value
                : this.pronunciationDictionaryLocators),
        seed: (seed != null ? seed.value : this.seed));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyTextToDialogueMultiVoiceV1TextToDialoguePost {
  const BodyTextToDialogueMultiVoiceV1TextToDialoguePost({
    required this.inputs,
    this.modelId,
    this.settings,
    this.pronunciationDictionaryLocators,
    this.seed,
  });

  factory BodyTextToDialogueMultiVoiceV1TextToDialoguePost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyTextToDialogueMultiVoiceV1TextToDialoguePostFromJson(json);

  static const toJsonFactory =
      _$BodyTextToDialogueMultiVoiceV1TextToDialoguePostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyTextToDialogueMultiVoiceV1TextToDialoguePostToJson(this);

  @JsonKey(name: 'inputs', defaultValue: <DialogueInput>[])
  final List<DialogueInput> inputs;
  @JsonKey(name: 'model_id')
  final String? modelId;
  @JsonKey(name: 'settings')
  final dynamic settings;
  @JsonKey(name: 'pronunciation_dictionary_locators')
  final dynamic pronunciationDictionaryLocators;
  @JsonKey(name: 'seed')
  final dynamic seed;
  static const fromJsonFactory =
      _$BodyTextToDialogueMultiVoiceV1TextToDialoguePostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyTextToDialogueMultiVoiceV1TextToDialoguePost &&
            (identical(other.inputs, inputs) ||
                const DeepCollectionEquality().equals(other.inputs, inputs)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.settings, settings) ||
                const DeepCollectionEquality()
                    .equals(other.settings, settings)) &&
            (identical(other.pronunciationDictionaryLocators,
                    pronunciationDictionaryLocators) ||
                const DeepCollectionEquality().equals(
                    other.pronunciationDictionaryLocators,
                    pronunciationDictionaryLocators)) &&
            (identical(other.seed, seed) ||
                const DeepCollectionEquality().equals(other.seed, seed)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(inputs) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(settings) ^
      const DeepCollectionEquality().hash(pronunciationDictionaryLocators) ^
      const DeepCollectionEquality().hash(seed) ^
      runtimeType.hashCode;
}

extension $BodyTextToDialogueMultiVoiceV1TextToDialoguePostExtension
    on BodyTextToDialogueMultiVoiceV1TextToDialoguePost {
  BodyTextToDialogueMultiVoiceV1TextToDialoguePost copyWith(
      {List<DialogueInput>? inputs,
      String? modelId,
      dynamic settings,
      dynamic pronunciationDictionaryLocators,
      dynamic seed}) {
    return BodyTextToDialogueMultiVoiceV1TextToDialoguePost(
        inputs: inputs ?? this.inputs,
        modelId: modelId ?? this.modelId,
        settings: settings ?? this.settings,
        pronunciationDictionaryLocators: pronunciationDictionaryLocators ??
            this.pronunciationDictionaryLocators,
        seed: seed ?? this.seed);
  }

  BodyTextToDialogueMultiVoiceV1TextToDialoguePost copyWithWrapped(
      {Wrapped<List<DialogueInput>>? inputs,
      Wrapped<String?>? modelId,
      Wrapped<dynamic>? settings,
      Wrapped<dynamic>? pronunciationDictionaryLocators,
      Wrapped<dynamic>? seed}) {
    return BodyTextToDialogueMultiVoiceV1TextToDialoguePost(
        inputs: (inputs != null ? inputs.value : this.inputs),
        modelId: (modelId != null ? modelId.value : this.modelId),
        settings: (settings != null ? settings.value : this.settings),
        pronunciationDictionaryLocators:
            (pronunciationDictionaryLocators != null
                ? pronunciationDictionaryLocators.value
                : this.pronunciationDictionaryLocators),
        seed: (seed != null ? seed.value : this.seed));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPost {
  const BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPost({
    required this.text,
    this.modelId,
    this.languageCode,
    this.voiceSettings,
    this.pronunciationDictionaryLocators,
    this.seed,
    this.previousText,
    this.nextText,
    this.previousRequestIds,
    this.nextRequestIds,
    this.usePvcAsIvc,
    this.applyTextNormalization,
    this.applyLanguageTextNormalization,
  });

  factory BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostFromJson(json);

  static const toJsonFactory =
      _$BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostToJson(this);

  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'model_id')
  final String? modelId;
  @JsonKey(name: 'language_code')
  final dynamic languageCode;
  @JsonKey(name: 'voice_settings')
  final dynamic voiceSettings;
  @JsonKey(name: 'pronunciation_dictionary_locators')
  final dynamic pronunciationDictionaryLocators;
  @JsonKey(name: 'seed')
  final dynamic seed;
  @JsonKey(name: 'previous_text')
  final dynamic previousText;
  @JsonKey(name: 'next_text')
  final dynamic nextText;
  @JsonKey(name: 'previous_request_ids')
  final dynamic previousRequestIds;
  @JsonKey(name: 'next_request_ids')
  final dynamic nextRequestIds;
  @JsonKey(name: 'use_pvc_as_ivc', defaultValue: false)
  @deprecated
  final bool? usePvcAsIvc;
  @JsonKey(
    name: 'apply_text_normalization',
    toJson:
        bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalizationNullableToJson,
    fromJson:
        bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalizationApplyTextNormalizationNullableFromJson,
  )
  final enums
      .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization?
      applyTextNormalization;
  static enums
      .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization?
      bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalizationApplyTextNormalizationNullableFromJson(
              Object? value) =>
          bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalizationNullableFromJson(
              value,
              enums
                  .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization
                  .auto);

  @JsonKey(name: 'apply_language_text_normalization', defaultValue: false)
  final bool? applyLanguageTextNormalization;
  static const fromJsonFactory =
      _$BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPost &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.languageCode, languageCode) ||
                const DeepCollectionEquality()
                    .equals(other.languageCode, languageCode)) &&
            (identical(other.voiceSettings, voiceSettings) ||
                const DeepCollectionEquality()
                    .equals(other.voiceSettings, voiceSettings)) &&
            (identical(other.pronunciationDictionaryLocators,
                    pronunciationDictionaryLocators) ||
                const DeepCollectionEquality().equals(
                    other.pronunciationDictionaryLocators,
                    pronunciationDictionaryLocators)) &&
            (identical(other.seed, seed) ||
                const DeepCollectionEquality().equals(other.seed, seed)) &&
            (identical(other.previousText, previousText) ||
                const DeepCollectionEquality()
                    .equals(other.previousText, previousText)) &&
            (identical(other.nextText, nextText) ||
                const DeepCollectionEquality()
                    .equals(other.nextText, nextText)) &&
            (identical(other.previousRequestIds, previousRequestIds) ||
                const DeepCollectionEquality()
                    .equals(other.previousRequestIds, previousRequestIds)) &&
            (identical(other.nextRequestIds, nextRequestIds) ||
                const DeepCollectionEquality()
                    .equals(other.nextRequestIds, nextRequestIds)) &&
            (identical(other.usePvcAsIvc, usePvcAsIvc) ||
                const DeepCollectionEquality()
                    .equals(other.usePvcAsIvc, usePvcAsIvc)) &&
            (identical(other.applyTextNormalization, applyTextNormalization) ||
                const DeepCollectionEquality().equals(
                    other.applyTextNormalization, applyTextNormalization)) &&
            (identical(other.applyLanguageTextNormalization,
                    applyLanguageTextNormalization) ||
                const DeepCollectionEquality().equals(
                    other.applyLanguageTextNormalization,
                    applyLanguageTextNormalization)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(languageCode) ^
      const DeepCollectionEquality().hash(voiceSettings) ^
      const DeepCollectionEquality().hash(pronunciationDictionaryLocators) ^
      const DeepCollectionEquality().hash(seed) ^
      const DeepCollectionEquality().hash(previousText) ^
      const DeepCollectionEquality().hash(nextText) ^
      const DeepCollectionEquality().hash(previousRequestIds) ^
      const DeepCollectionEquality().hash(nextRequestIds) ^
      const DeepCollectionEquality().hash(usePvcAsIvc) ^
      const DeepCollectionEquality().hash(applyTextNormalization) ^
      const DeepCollectionEquality().hash(applyLanguageTextNormalization) ^
      runtimeType.hashCode;
}

extension $BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostExtension
    on BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPost {
  BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPost copyWith(
      {String? text,
      String? modelId,
      dynamic languageCode,
      dynamic voiceSettings,
      dynamic pronunciationDictionaryLocators,
      dynamic seed,
      dynamic previousText,
      dynamic nextText,
      dynamic previousRequestIds,
      dynamic nextRequestIds,
      bool? usePvcAsIvc,
      enums
          .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization?
          applyTextNormalization,
      bool? applyLanguageTextNormalization}) {
    return BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPost(
        text: text ?? this.text,
        modelId: modelId ?? this.modelId,
        languageCode: languageCode ?? this.languageCode,
        voiceSettings: voiceSettings ?? this.voiceSettings,
        pronunciationDictionaryLocators: pronunciationDictionaryLocators ??
            this.pronunciationDictionaryLocators,
        seed: seed ?? this.seed,
        previousText: previousText ?? this.previousText,
        nextText: nextText ?? this.nextText,
        previousRequestIds: previousRequestIds ?? this.previousRequestIds,
        nextRequestIds: nextRequestIds ?? this.nextRequestIds,
        usePvcAsIvc: usePvcAsIvc ?? this.usePvcAsIvc,
        applyTextNormalization:
            applyTextNormalization ?? this.applyTextNormalization,
        applyLanguageTextNormalization: applyLanguageTextNormalization ??
            this.applyLanguageTextNormalization);
  }

  BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPost copyWithWrapped(
      {Wrapped<String>? text,
      Wrapped<String?>? modelId,
      Wrapped<dynamic>? languageCode,
      Wrapped<dynamic>? voiceSettings,
      Wrapped<dynamic>? pronunciationDictionaryLocators,
      Wrapped<dynamic>? seed,
      Wrapped<dynamic>? previousText,
      Wrapped<dynamic>? nextText,
      Wrapped<dynamic>? previousRequestIds,
      Wrapped<dynamic>? nextRequestIds,
      Wrapped<bool?>? usePvcAsIvc,
      Wrapped<
              enums
              .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization?>?
          applyTextNormalization,
      Wrapped<bool?>? applyLanguageTextNormalization}) {
    return BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPost(
        text: (text != null ? text.value : this.text),
        modelId: (modelId != null ? modelId.value : this.modelId),
        languageCode:
            (languageCode != null ? languageCode.value : this.languageCode),
        voiceSettings:
            (voiceSettings != null ? voiceSettings.value : this.voiceSettings),
        pronunciationDictionaryLocators:
            (pronunciationDictionaryLocators != null
                ? pronunciationDictionaryLocators.value
                : this.pronunciationDictionaryLocators),
        seed: (seed != null ? seed.value : this.seed),
        previousText:
            (previousText != null ? previousText.value : this.previousText),
        nextText: (nextText != null ? nextText.value : this.nextText),
        previousRequestIds: (previousRequestIds != null
            ? previousRequestIds.value
            : this.previousRequestIds),
        nextRequestIds: (nextRequestIds != null
            ? nextRequestIds.value
            : this.nextRequestIds),
        usePvcAsIvc:
            (usePvcAsIvc != null ? usePvcAsIvc.value : this.usePvcAsIvc),
        applyTextNormalization: (applyTextNormalization != null
            ? applyTextNormalization.value
            : this.applyTextNormalization),
        applyLanguageTextNormalization: (applyLanguageTextNormalization != null
            ? applyLanguageTextNormalization.value
            : this.applyLanguageTextNormalization));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPost {
  const BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPost({
    required this.text,
    this.modelId,
    this.languageCode,
    this.voiceSettings,
    this.pronunciationDictionaryLocators,
    this.seed,
    this.previousText,
    this.nextText,
    this.previousRequestIds,
    this.nextRequestIds,
    this.usePvcAsIvc,
    this.applyTextNormalization,
    this.applyLanguageTextNormalization,
  });

  factory BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostToJson(
          this);

  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'model_id')
  final String? modelId;
  @JsonKey(name: 'language_code')
  final dynamic languageCode;
  @JsonKey(name: 'voice_settings')
  final dynamic voiceSettings;
  @JsonKey(name: 'pronunciation_dictionary_locators')
  final dynamic pronunciationDictionaryLocators;
  @JsonKey(name: 'seed')
  final dynamic seed;
  @JsonKey(name: 'previous_text')
  final dynamic previousText;
  @JsonKey(name: 'next_text')
  final dynamic nextText;
  @JsonKey(name: 'previous_request_ids')
  final dynamic previousRequestIds;
  @JsonKey(name: 'next_request_ids')
  final dynamic nextRequestIds;
  @JsonKey(name: 'use_pvc_as_ivc', defaultValue: false)
  @deprecated
  final bool? usePvcAsIvc;
  @JsonKey(
    name: 'apply_text_normalization',
    toJson:
        bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalizationNullableToJson,
    fromJson:
        bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalizationApplyTextNormalizationNullableFromJson,
  )
  final enums
      .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization?
      applyTextNormalization;
  static enums
      .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization?
      bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalizationApplyTextNormalizationNullableFromJson(
              Object? value) =>
          bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalizationNullableFromJson(
              value,
              enums
                  .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization
                  .auto);

  @JsonKey(name: 'apply_language_text_normalization', defaultValue: false)
  final bool? applyLanguageTextNormalization;
  static const fromJsonFactory =
      _$BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPost &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.languageCode, languageCode) ||
                const DeepCollectionEquality()
                    .equals(other.languageCode, languageCode)) &&
            (identical(other.voiceSettings, voiceSettings) ||
                const DeepCollectionEquality()
                    .equals(other.voiceSettings, voiceSettings)) &&
            (identical(other.pronunciationDictionaryLocators, pronunciationDictionaryLocators) ||
                const DeepCollectionEquality().equals(
                    other.pronunciationDictionaryLocators,
                    pronunciationDictionaryLocators)) &&
            (identical(other.seed, seed) ||
                const DeepCollectionEquality().equals(other.seed, seed)) &&
            (identical(other.previousText, previousText) ||
                const DeepCollectionEquality()
                    .equals(other.previousText, previousText)) &&
            (identical(other.nextText, nextText) ||
                const DeepCollectionEquality()
                    .equals(other.nextText, nextText)) &&
            (identical(other.previousRequestIds, previousRequestIds) ||
                const DeepCollectionEquality()
                    .equals(other.previousRequestIds, previousRequestIds)) &&
            (identical(other.nextRequestIds, nextRequestIds) ||
                const DeepCollectionEquality()
                    .equals(other.nextRequestIds, nextRequestIds)) &&
            (identical(other.usePvcAsIvc, usePvcAsIvc) ||
                const DeepCollectionEquality()
                    .equals(other.usePvcAsIvc, usePvcAsIvc)) &&
            (identical(other.applyTextNormalization, applyTextNormalization) ||
                const DeepCollectionEquality().equals(
                    other.applyTextNormalization, applyTextNormalization)) &&
            (identical(other.applyLanguageTextNormalization, applyLanguageTextNormalization) ||
                const DeepCollectionEquality().equals(
                    other.applyLanguageTextNormalization,
                    applyLanguageTextNormalization)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(languageCode) ^
      const DeepCollectionEquality().hash(voiceSettings) ^
      const DeepCollectionEquality().hash(pronunciationDictionaryLocators) ^
      const DeepCollectionEquality().hash(seed) ^
      const DeepCollectionEquality().hash(previousText) ^
      const DeepCollectionEquality().hash(nextText) ^
      const DeepCollectionEquality().hash(previousRequestIds) ^
      const DeepCollectionEquality().hash(nextRequestIds) ^
      const DeepCollectionEquality().hash(usePvcAsIvc) ^
      const DeepCollectionEquality().hash(applyTextNormalization) ^
      const DeepCollectionEquality().hash(applyLanguageTextNormalization) ^
      runtimeType.hashCode;
}

extension $BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostExtension
    on BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPost {
  BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPost
      copyWith(
          {String? text,
          String? modelId,
          dynamic languageCode,
          dynamic voiceSettings,
          dynamic pronunciationDictionaryLocators,
          dynamic seed,
          dynamic previousText,
          dynamic nextText,
          dynamic previousRequestIds,
          dynamic nextRequestIds,
          bool? usePvcAsIvc,
          enums
              .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization?
              applyTextNormalization,
          bool? applyLanguageTextNormalization}) {
    return BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPost(
        text: text ?? this.text,
        modelId: modelId ?? this.modelId,
        languageCode: languageCode ?? this.languageCode,
        voiceSettings: voiceSettings ?? this.voiceSettings,
        pronunciationDictionaryLocators: pronunciationDictionaryLocators ??
            this.pronunciationDictionaryLocators,
        seed: seed ?? this.seed,
        previousText: previousText ?? this.previousText,
        nextText: nextText ?? this.nextText,
        previousRequestIds: previousRequestIds ?? this.previousRequestIds,
        nextRequestIds: nextRequestIds ?? this.nextRequestIds,
        usePvcAsIvc: usePvcAsIvc ?? this.usePvcAsIvc,
        applyTextNormalization:
            applyTextNormalization ?? this.applyTextNormalization,
        applyLanguageTextNormalization: applyLanguageTextNormalization ??
            this.applyLanguageTextNormalization);
  }

  BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPost
      copyWithWrapped(
          {Wrapped<String>? text,
          Wrapped<String?>? modelId,
          Wrapped<dynamic>? languageCode,
          Wrapped<dynamic>? voiceSettings,
          Wrapped<dynamic>? pronunciationDictionaryLocators,
          Wrapped<dynamic>? seed,
          Wrapped<dynamic>? previousText,
          Wrapped<dynamic>? nextText,
          Wrapped<dynamic>? previousRequestIds,
          Wrapped<dynamic>? nextRequestIds,
          Wrapped<bool?>? usePvcAsIvc,
          Wrapped<
                  enums
                  .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization?>?
              applyTextNormalization,
          Wrapped<bool?>? applyLanguageTextNormalization}) {
    return BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPost(
        text: (text != null ? text.value : this.text),
        modelId: (modelId != null ? modelId.value : this.modelId),
        languageCode:
            (languageCode != null ? languageCode.value : this.languageCode),
        voiceSettings:
            (voiceSettings != null ? voiceSettings.value : this.voiceSettings),
        pronunciationDictionaryLocators:
            (pronunciationDictionaryLocators != null
                ? pronunciationDictionaryLocators.value
                : this.pronunciationDictionaryLocators),
        seed: (seed != null ? seed.value : this.seed),
        previousText:
            (previousText != null ? previousText.value : this.previousText),
        nextText: (nextText != null ? nextText.value : this.nextText),
        previousRequestIds: (previousRequestIds != null
            ? previousRequestIds.value
            : this.previousRequestIds),
        nextRequestIds: (nextRequestIds != null
            ? nextRequestIds.value
            : this.nextRequestIds),
        usePvcAsIvc:
            (usePvcAsIvc != null ? usePvcAsIvc.value : this.usePvcAsIvc),
        applyTextNormalization: (applyTextNormalization != null
            ? applyTextNormalization.value
            : this.applyTextNormalization),
        applyLanguageTextNormalization: (applyLanguageTextNormalization != null
            ? applyLanguageTextNormalization.value
            : this.applyLanguageTextNormalization));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyTextToSpeechV1TextToSpeechVoiceIdPost {
  const BodyTextToSpeechV1TextToSpeechVoiceIdPost({
    required this.text,
    this.modelId,
    this.languageCode,
    this.voiceSettings,
    this.pronunciationDictionaryLocators,
    this.seed,
    this.previousText,
    this.nextText,
    this.previousRequestIds,
    this.nextRequestIds,
    this.usePvcAsIvc,
    this.applyTextNormalization,
    this.applyLanguageTextNormalization,
  });

  factory BodyTextToSpeechV1TextToSpeechVoiceIdPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyTextToSpeechV1TextToSpeechVoiceIdPostFromJson(json);

  static const toJsonFactory =
      _$BodyTextToSpeechV1TextToSpeechVoiceIdPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyTextToSpeechV1TextToSpeechVoiceIdPostToJson(this);

  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'model_id')
  final String? modelId;
  @JsonKey(name: 'language_code')
  final dynamic languageCode;
  @JsonKey(name: 'voice_settings')
  final dynamic voiceSettings;
  @JsonKey(name: 'pronunciation_dictionary_locators')
  final dynamic pronunciationDictionaryLocators;
  @JsonKey(name: 'seed')
  final dynamic seed;
  @JsonKey(name: 'previous_text')
  final dynamic previousText;
  @JsonKey(name: 'next_text')
  final dynamic nextText;
  @JsonKey(name: 'previous_request_ids')
  final dynamic previousRequestIds;
  @JsonKey(name: 'next_request_ids')
  final dynamic nextRequestIds;
  @JsonKey(name: 'use_pvc_as_ivc', defaultValue: false)
  @deprecated
  final bool? usePvcAsIvc;
  @JsonKey(
    name: 'apply_text_normalization',
    toJson:
        bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalizationNullableToJson,
    fromJson:
        bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalizationApplyTextNormalizationNullableFromJson,
  )
  final enums.BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization?
      applyTextNormalization;
  static enums.BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization?
      bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalizationApplyTextNormalizationNullableFromJson(
              Object? value) =>
          bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalizationNullableFromJson(
              value,
              enums
                  .BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization
                  .auto);

  @JsonKey(name: 'apply_language_text_normalization', defaultValue: false)
  final bool? applyLanguageTextNormalization;
  static const fromJsonFactory =
      _$BodyTextToSpeechV1TextToSpeechVoiceIdPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyTextToSpeechV1TextToSpeechVoiceIdPost &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.languageCode, languageCode) ||
                const DeepCollectionEquality()
                    .equals(other.languageCode, languageCode)) &&
            (identical(other.voiceSettings, voiceSettings) ||
                const DeepCollectionEquality()
                    .equals(other.voiceSettings, voiceSettings)) &&
            (identical(other.pronunciationDictionaryLocators,
                    pronunciationDictionaryLocators) ||
                const DeepCollectionEquality().equals(
                    other.pronunciationDictionaryLocators,
                    pronunciationDictionaryLocators)) &&
            (identical(other.seed, seed) ||
                const DeepCollectionEquality().equals(other.seed, seed)) &&
            (identical(other.previousText, previousText) ||
                const DeepCollectionEquality()
                    .equals(other.previousText, previousText)) &&
            (identical(other.nextText, nextText) ||
                const DeepCollectionEquality()
                    .equals(other.nextText, nextText)) &&
            (identical(other.previousRequestIds, previousRequestIds) ||
                const DeepCollectionEquality()
                    .equals(other.previousRequestIds, previousRequestIds)) &&
            (identical(other.nextRequestIds, nextRequestIds) ||
                const DeepCollectionEquality()
                    .equals(other.nextRequestIds, nextRequestIds)) &&
            (identical(other.usePvcAsIvc, usePvcAsIvc) ||
                const DeepCollectionEquality()
                    .equals(other.usePvcAsIvc, usePvcAsIvc)) &&
            (identical(other.applyTextNormalization, applyTextNormalization) ||
                const DeepCollectionEquality().equals(
                    other.applyTextNormalization, applyTextNormalization)) &&
            (identical(other.applyLanguageTextNormalization,
                    applyLanguageTextNormalization) ||
                const DeepCollectionEquality().equals(
                    other.applyLanguageTextNormalization,
                    applyLanguageTextNormalization)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(languageCode) ^
      const DeepCollectionEquality().hash(voiceSettings) ^
      const DeepCollectionEquality().hash(pronunciationDictionaryLocators) ^
      const DeepCollectionEquality().hash(seed) ^
      const DeepCollectionEquality().hash(previousText) ^
      const DeepCollectionEquality().hash(nextText) ^
      const DeepCollectionEquality().hash(previousRequestIds) ^
      const DeepCollectionEquality().hash(nextRequestIds) ^
      const DeepCollectionEquality().hash(usePvcAsIvc) ^
      const DeepCollectionEquality().hash(applyTextNormalization) ^
      const DeepCollectionEquality().hash(applyLanguageTextNormalization) ^
      runtimeType.hashCode;
}

extension $BodyTextToSpeechV1TextToSpeechVoiceIdPostExtension
    on BodyTextToSpeechV1TextToSpeechVoiceIdPost {
  BodyTextToSpeechV1TextToSpeechVoiceIdPost copyWith(
      {String? text,
      String? modelId,
      dynamic languageCode,
      dynamic voiceSettings,
      dynamic pronunciationDictionaryLocators,
      dynamic seed,
      dynamic previousText,
      dynamic nextText,
      dynamic previousRequestIds,
      dynamic nextRequestIds,
      bool? usePvcAsIvc,
      enums.BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization?
          applyTextNormalization,
      bool? applyLanguageTextNormalization}) {
    return BodyTextToSpeechV1TextToSpeechVoiceIdPost(
        text: text ?? this.text,
        modelId: modelId ?? this.modelId,
        languageCode: languageCode ?? this.languageCode,
        voiceSettings: voiceSettings ?? this.voiceSettings,
        pronunciationDictionaryLocators: pronunciationDictionaryLocators ??
            this.pronunciationDictionaryLocators,
        seed: seed ?? this.seed,
        previousText: previousText ?? this.previousText,
        nextText: nextText ?? this.nextText,
        previousRequestIds: previousRequestIds ?? this.previousRequestIds,
        nextRequestIds: nextRequestIds ?? this.nextRequestIds,
        usePvcAsIvc: usePvcAsIvc ?? this.usePvcAsIvc,
        applyTextNormalization:
            applyTextNormalization ?? this.applyTextNormalization,
        applyLanguageTextNormalization: applyLanguageTextNormalization ??
            this.applyLanguageTextNormalization);
  }

  BodyTextToSpeechV1TextToSpeechVoiceIdPost copyWithWrapped(
      {Wrapped<String>? text,
      Wrapped<String?>? modelId,
      Wrapped<dynamic>? languageCode,
      Wrapped<dynamic>? voiceSettings,
      Wrapped<dynamic>? pronunciationDictionaryLocators,
      Wrapped<dynamic>? seed,
      Wrapped<dynamic>? previousText,
      Wrapped<dynamic>? nextText,
      Wrapped<dynamic>? previousRequestIds,
      Wrapped<dynamic>? nextRequestIds,
      Wrapped<bool?>? usePvcAsIvc,
      Wrapped<
              enums
              .BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization?>?
          applyTextNormalization,
      Wrapped<bool?>? applyLanguageTextNormalization}) {
    return BodyTextToSpeechV1TextToSpeechVoiceIdPost(
        text: (text != null ? text.value : this.text),
        modelId: (modelId != null ? modelId.value : this.modelId),
        languageCode:
            (languageCode != null ? languageCode.value : this.languageCode),
        voiceSettings:
            (voiceSettings != null ? voiceSettings.value : this.voiceSettings),
        pronunciationDictionaryLocators:
            (pronunciationDictionaryLocators != null
                ? pronunciationDictionaryLocators.value
                : this.pronunciationDictionaryLocators),
        seed: (seed != null ? seed.value : this.seed),
        previousText:
            (previousText != null ? previousText.value : this.previousText),
        nextText: (nextText != null ? nextText.value : this.nextText),
        previousRequestIds: (previousRequestIds != null
            ? previousRequestIds.value
            : this.previousRequestIds),
        nextRequestIds: (nextRequestIds != null
            ? nextRequestIds.value
            : this.nextRequestIds),
        usePvcAsIvc:
            (usePvcAsIvc != null ? usePvcAsIvc.value : this.usePvcAsIvc),
        applyTextNormalization: (applyTextNormalization != null
            ? applyTextNormalization.value
            : this.applyTextNormalization),
        applyLanguageTextNormalization: (applyLanguageTextNormalization != null
            ? applyLanguageTextNormalization.value
            : this.applyLanguageTextNormalization));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPost {
  const BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPost({
    required this.text,
    this.modelId,
    this.languageCode,
    this.voiceSettings,
    this.pronunciationDictionaryLocators,
    this.seed,
    this.previousText,
    this.nextText,
    this.previousRequestIds,
    this.nextRequestIds,
    this.usePvcAsIvc,
    this.applyTextNormalization,
    this.applyLanguageTextNormalization,
  });

  factory BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostToJson(
          this);

  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'model_id')
  final String? modelId;
  @JsonKey(name: 'language_code')
  final dynamic languageCode;
  @JsonKey(name: 'voice_settings')
  final dynamic voiceSettings;
  @JsonKey(
      name: 'pronunciation_dictionary_locators',
      defaultValue: <PronunciationDictionaryVersionLocatorRequestModel>[])
  final List<PronunciationDictionaryVersionLocatorRequestModel>?
      pronunciationDictionaryLocators;
  @JsonKey(name: 'seed')
  final dynamic seed;
  @JsonKey(name: 'previous_text')
  final dynamic previousText;
  @JsonKey(name: 'next_text')
  final dynamic nextText;
  @JsonKey(name: 'previous_request_ids', defaultValue: <String>[])
  final List<String>? previousRequestIds;
  @JsonKey(name: 'next_request_ids', defaultValue: <String>[])
  final List<String>? nextRequestIds;
  @JsonKey(name: 'use_pvc_as_ivc', defaultValue: false)
  @deprecated
  final bool? usePvcAsIvc;
  @JsonKey(
    name: 'apply_text_normalization',
    toJson:
        bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalizationNullableToJson,
    fromJson:
        bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalizationApplyTextNormalizationNullableFromJson,
  )
  final enums
      .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization?
      applyTextNormalization;
  static enums
      .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization?
      bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalizationApplyTextNormalizationNullableFromJson(
              Object? value) =>
          bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalizationNullableFromJson(
              value,
              enums
                  .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization
                  .auto);

  @JsonKey(name: 'apply_language_text_normalization', defaultValue: false)
  final bool? applyLanguageTextNormalization;
  static const fromJsonFactory =
      _$BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPost &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.languageCode, languageCode) ||
                const DeepCollectionEquality()
                    .equals(other.languageCode, languageCode)) &&
            (identical(other.voiceSettings, voiceSettings) ||
                const DeepCollectionEquality()
                    .equals(other.voiceSettings, voiceSettings)) &&
            (identical(other.pronunciationDictionaryLocators, pronunciationDictionaryLocators) ||
                const DeepCollectionEquality().equals(
                    other.pronunciationDictionaryLocators,
                    pronunciationDictionaryLocators)) &&
            (identical(other.seed, seed) ||
                const DeepCollectionEquality().equals(other.seed, seed)) &&
            (identical(other.previousText, previousText) ||
                const DeepCollectionEquality()
                    .equals(other.previousText, previousText)) &&
            (identical(other.nextText, nextText) ||
                const DeepCollectionEquality()
                    .equals(other.nextText, nextText)) &&
            (identical(other.previousRequestIds, previousRequestIds) ||
                const DeepCollectionEquality()
                    .equals(other.previousRequestIds, previousRequestIds)) &&
            (identical(other.nextRequestIds, nextRequestIds) ||
                const DeepCollectionEquality()
                    .equals(other.nextRequestIds, nextRequestIds)) &&
            (identical(other.usePvcAsIvc, usePvcAsIvc) ||
                const DeepCollectionEquality()
                    .equals(other.usePvcAsIvc, usePvcAsIvc)) &&
            (identical(other.applyTextNormalization, applyTextNormalization) ||
                const DeepCollectionEquality().equals(
                    other.applyTextNormalization, applyTextNormalization)) &&
            (identical(other.applyLanguageTextNormalization, applyLanguageTextNormalization) ||
                const DeepCollectionEquality().equals(
                    other.applyLanguageTextNormalization,
                    applyLanguageTextNormalization)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(languageCode) ^
      const DeepCollectionEquality().hash(voiceSettings) ^
      const DeepCollectionEquality().hash(pronunciationDictionaryLocators) ^
      const DeepCollectionEquality().hash(seed) ^
      const DeepCollectionEquality().hash(previousText) ^
      const DeepCollectionEquality().hash(nextText) ^
      const DeepCollectionEquality().hash(previousRequestIds) ^
      const DeepCollectionEquality().hash(nextRequestIds) ^
      const DeepCollectionEquality().hash(usePvcAsIvc) ^
      const DeepCollectionEquality().hash(applyTextNormalization) ^
      const DeepCollectionEquality().hash(applyLanguageTextNormalization) ^
      runtimeType.hashCode;
}

extension $BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostExtension
    on BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPost {
  BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPost copyWith(
      {String? text,
      String? modelId,
      dynamic languageCode,
      dynamic voiceSettings,
      List<PronunciationDictionaryVersionLocatorRequestModel>?
          pronunciationDictionaryLocators,
      dynamic seed,
      dynamic previousText,
      dynamic nextText,
      List<String>? previousRequestIds,
      List<String>? nextRequestIds,
      bool? usePvcAsIvc,
      enums
          .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization?
          applyTextNormalization,
      bool? applyLanguageTextNormalization}) {
    return BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPost(
        text: text ?? this.text,
        modelId: modelId ?? this.modelId,
        languageCode: languageCode ?? this.languageCode,
        voiceSettings: voiceSettings ?? this.voiceSettings,
        pronunciationDictionaryLocators: pronunciationDictionaryLocators ??
            this.pronunciationDictionaryLocators,
        seed: seed ?? this.seed,
        previousText: previousText ?? this.previousText,
        nextText: nextText ?? this.nextText,
        previousRequestIds: previousRequestIds ?? this.previousRequestIds,
        nextRequestIds: nextRequestIds ?? this.nextRequestIds,
        usePvcAsIvc: usePvcAsIvc ?? this.usePvcAsIvc,
        applyTextNormalization:
            applyTextNormalization ?? this.applyTextNormalization,
        applyLanguageTextNormalization: applyLanguageTextNormalization ??
            this.applyLanguageTextNormalization);
  }

  BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPost
      copyWithWrapped(
          {Wrapped<String>? text,
          Wrapped<String?>? modelId,
          Wrapped<dynamic>? languageCode,
          Wrapped<dynamic>? voiceSettings,
          Wrapped<List<PronunciationDictionaryVersionLocatorRequestModel>?>?
              pronunciationDictionaryLocators,
          Wrapped<dynamic>? seed,
          Wrapped<dynamic>? previousText,
          Wrapped<dynamic>? nextText,
          Wrapped<List<String>?>? previousRequestIds,
          Wrapped<List<String>?>? nextRequestIds,
          Wrapped<bool?>? usePvcAsIvc,
          Wrapped<
                  enums
                  .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization?>?
              applyTextNormalization,
          Wrapped<bool?>? applyLanguageTextNormalization}) {
    return BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPost(
        text: (text != null ? text.value : this.text),
        modelId: (modelId != null ? modelId.value : this.modelId),
        languageCode:
            (languageCode != null ? languageCode.value : this.languageCode),
        voiceSettings:
            (voiceSettings != null ? voiceSettings.value : this.voiceSettings),
        pronunciationDictionaryLocators:
            (pronunciationDictionaryLocators != null
                ? pronunciationDictionaryLocators.value
                : this.pronunciationDictionaryLocators),
        seed: (seed != null ? seed.value : this.seed),
        previousText:
            (previousText != null ? previousText.value : this.previousText),
        nextText: (nextText != null ? nextText.value : this.nextText),
        previousRequestIds: (previousRequestIds != null
            ? previousRequestIds.value
            : this.previousRequestIds),
        nextRequestIds: (nextRequestIds != null
            ? nextRequestIds.value
            : this.nextRequestIds),
        usePvcAsIvc:
            (usePvcAsIvc != null ? usePvcAsIvc.value : this.usePvcAsIvc),
        applyTextNormalization: (applyTextNormalization != null
            ? applyTextNormalization.value
            : this.applyTextNormalization),
        applyLanguageTextNormalization: (applyLanguageTextNormalization != null
            ? applyLanguageTextNormalization.value
            : this.applyLanguageTextNormalization));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyTranscribesSegmentsV1DubbingResourceDubbingIdTranscribePost {
  const BodyTranscribesSegmentsV1DubbingResourceDubbingIdTranscribePost({
    required this.segments,
  });

  factory BodyTranscribesSegmentsV1DubbingResourceDubbingIdTranscribePost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyTranscribesSegmentsV1DubbingResourceDubbingIdTranscribePostFromJson(
          json);

  static const toJsonFactory =
      _$BodyTranscribesSegmentsV1DubbingResourceDubbingIdTranscribePostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyTranscribesSegmentsV1DubbingResourceDubbingIdTranscribePostToJson(
          this);

  @JsonKey(name: 'segments', defaultValue: <String>[])
  final List<String> segments;
  static const fromJsonFactory =
      _$BodyTranscribesSegmentsV1DubbingResourceDubbingIdTranscribePostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyTranscribesSegmentsV1DubbingResourceDubbingIdTranscribePost &&
            (identical(other.segments, segments) ||
                const DeepCollectionEquality()
                    .equals(other.segments, segments)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(segments) ^ runtimeType.hashCode;
}

extension $BodyTranscribesSegmentsV1DubbingResourceDubbingIdTranscribePostExtension
    on BodyTranscribesSegmentsV1DubbingResourceDubbingIdTranscribePost {
  BodyTranscribesSegmentsV1DubbingResourceDubbingIdTranscribePost copyWith(
      {List<String>? segments}) {
    return BodyTranscribesSegmentsV1DubbingResourceDubbingIdTranscribePost(
        segments: segments ?? this.segments);
  }

  BodyTranscribesSegmentsV1DubbingResourceDubbingIdTranscribePost
      copyWithWrapped({Wrapped<List<String>>? segments}) {
    return BodyTranscribesSegmentsV1DubbingResourceDubbingIdTranscribePost(
        segments: (segments != null ? segments.value : this.segments));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdTranslatePost {
  const BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdTranslatePost({
    required this.segments,
    required this.languages,
  });

  factory BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdTranslatePost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdTranslatePostFromJson(
          json);

  static const toJsonFactory =
      _$BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdTranslatePostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdTranslatePostToJson(
          this);

  @JsonKey(name: 'segments', defaultValue: <String>[])
  final List<String> segments;
  @JsonKey(name: 'languages')
  final dynamic languages;
  static const fromJsonFactory =
      _$BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdTranslatePostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdTranslatePost &&
            (identical(other.segments, segments) ||
                const DeepCollectionEquality()
                    .equals(other.segments, segments)) &&
            (identical(other.languages, languages) ||
                const DeepCollectionEquality()
                    .equals(other.languages, languages)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(segments) ^
      const DeepCollectionEquality().hash(languages) ^
      runtimeType.hashCode;
}

extension $BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdTranslatePostExtension
    on BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdTranslatePost {
  BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdTranslatePost
      copyWith({List<String>? segments, dynamic languages}) {
    return BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdTranslatePost(
        segments: segments ?? this.segments,
        languages: languages ?? this.languages);
  }

  BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdTranslatePost
      copyWithWrapped(
          {Wrapped<List<String>>? segments, Wrapped<dynamic>? languages}) {
    return BodyTranslatesAllOrSomeSegmentsAndLanguagesV1DubbingResourceDubbingIdTranslatePost(
        segments: (segments != null ? segments.value : this.segments),
        languages: (languages != null ? languages.value : this.languages));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIdUnsharePost {
  const BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIdUnsharePost({
    required this.resourceType,
    this.userEmail,
    this.groupId,
    this.workspaceApiKeyId,
  });

  factory BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIdUnsharePost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIdUnsharePostFromJson(
          json);

  static const toJsonFactory =
      _$BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIdUnsharePostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIdUnsharePostToJson(
          this);

  @JsonKey(
    name: 'resource_type',
    toJson: workspaceResourceTypeToJson,
    fromJson: workspaceResourceTypeFromJson,
  )
  final enums.WorkspaceResourceType resourceType;
  @JsonKey(name: 'user_email')
  final dynamic userEmail;
  @JsonKey(name: 'group_id')
  final dynamic groupId;
  @JsonKey(name: 'workspace_api_key_id')
  final dynamic workspaceApiKeyId;
  static const fromJsonFactory =
      _$BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIdUnsharePostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIdUnsharePost &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.userEmail, userEmail) ||
                const DeepCollectionEquality()
                    .equals(other.userEmail, userEmail)) &&
            (identical(other.groupId, groupId) ||
                const DeepCollectionEquality()
                    .equals(other.groupId, groupId)) &&
            (identical(other.workspaceApiKeyId, workspaceApiKeyId) ||
                const DeepCollectionEquality()
                    .equals(other.workspaceApiKeyId, workspaceApiKeyId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(userEmail) ^
      const DeepCollectionEquality().hash(groupId) ^
      const DeepCollectionEquality().hash(workspaceApiKeyId) ^
      runtimeType.hashCode;
}

extension $BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIdUnsharePostExtension
    on BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIdUnsharePost {
  BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIdUnsharePost
      copyWith(
          {enums.WorkspaceResourceType? resourceType,
          dynamic userEmail,
          dynamic groupId,
          dynamic workspaceApiKeyId}) {
    return BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIdUnsharePost(
        resourceType: resourceType ?? this.resourceType,
        userEmail: userEmail ?? this.userEmail,
        groupId: groupId ?? this.groupId,
        workspaceApiKeyId: workspaceApiKeyId ?? this.workspaceApiKeyId);
  }

  BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIdUnsharePost
      copyWithWrapped(
          {Wrapped<enums.WorkspaceResourceType>? resourceType,
          Wrapped<dynamic>? userEmail,
          Wrapped<dynamic>? groupId,
          Wrapped<dynamic>? workspaceApiKeyId}) {
    return BodyUnshareWorkspaceResourceV1WorkspaceResourcesResourceIdUnsharePost(
        resourceType:
            (resourceType != null ? resourceType.value : this.resourceType),
        userEmail: (userEmail != null ? userEmail.value : this.userEmail),
        groupId: (groupId != null ? groupId.value : this.groupId),
        workspaceApiKeyId: (workspaceApiKeyId != null
            ? workspaceApiKeyId.value
            : this.workspaceApiKeyId));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIdSamplesSampleIdPost {
  const BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIdSamplesSampleIdPost({
    this.removeBackgroundNoise,
    this.selectedSpeakerIds,
    this.trimStartTime,
    this.trimEndTime,
  });

  factory BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIdSamplesSampleIdPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIdSamplesSampleIdPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIdSamplesSampleIdPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIdSamplesSampleIdPostToJson(
          this);

  @JsonKey(name: 'remove_background_noise', defaultValue: false)
  final bool? removeBackgroundNoise;
  @JsonKey(name: 'selected_speaker_ids')
  final dynamic selectedSpeakerIds;
  @JsonKey(name: 'trim_start_time')
  final dynamic trimStartTime;
  @JsonKey(name: 'trim_end_time')
  final dynamic trimEndTime;
  static const fromJsonFactory =
      _$BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIdSamplesSampleIdPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIdSamplesSampleIdPost &&
            (identical(other.removeBackgroundNoise, removeBackgroundNoise) ||
                const DeepCollectionEquality().equals(
                    other.removeBackgroundNoise, removeBackgroundNoise)) &&
            (identical(other.selectedSpeakerIds, selectedSpeakerIds) ||
                const DeepCollectionEquality()
                    .equals(other.selectedSpeakerIds, selectedSpeakerIds)) &&
            (identical(other.trimStartTime, trimStartTime) ||
                const DeepCollectionEquality()
                    .equals(other.trimStartTime, trimStartTime)) &&
            (identical(other.trimEndTime, trimEndTime) ||
                const DeepCollectionEquality()
                    .equals(other.trimEndTime, trimEndTime)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(removeBackgroundNoise) ^
      const DeepCollectionEquality().hash(selectedSpeakerIds) ^
      const DeepCollectionEquality().hash(trimStartTime) ^
      const DeepCollectionEquality().hash(trimEndTime) ^
      runtimeType.hashCode;
}

extension $BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIdSamplesSampleIdPostExtension
    on BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIdSamplesSampleIdPost {
  BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIdSamplesSampleIdPost copyWith(
      {bool? removeBackgroundNoise,
      dynamic selectedSpeakerIds,
      dynamic trimStartTime,
      dynamic trimEndTime}) {
    return BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIdSamplesSampleIdPost(
        removeBackgroundNoise:
            removeBackgroundNoise ?? this.removeBackgroundNoise,
        selectedSpeakerIds: selectedSpeakerIds ?? this.selectedSpeakerIds,
        trimStartTime: trimStartTime ?? this.trimStartTime,
        trimEndTime: trimEndTime ?? this.trimEndTime);
  }

  BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIdSamplesSampleIdPost copyWithWrapped(
      {Wrapped<bool?>? removeBackgroundNoise,
      Wrapped<dynamic>? selectedSpeakerIds,
      Wrapped<dynamic>? trimStartTime,
      Wrapped<dynamic>? trimEndTime}) {
    return BodyUpdatePVCVoiceSampleV1VoicesPvcVoiceIdSamplesSampleIdPost(
        removeBackgroundNoise: (removeBackgroundNoise != null
            ? removeBackgroundNoise.value
            : this.removeBackgroundNoise),
        selectedSpeakerIds: (selectedSpeakerIds != null
            ? selectedSpeakerIds.value
            : this.selectedSpeakerIds),
        trimStartTime:
            (trimStartTime != null ? trimStartTime.value : this.trimStartTime),
        trimEndTime:
            (trimEndTime != null ? trimEndTime.value : this.trimEndTime));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyUpdatePronunciationDictionariesV1ProjectsProjectIdUpdatePronunciationDictionariesPost {
  const BodyUpdatePronunciationDictionariesV1ProjectsProjectIdUpdatePronunciationDictionariesPost({
    required this.pronunciationDictionaryLocators,
    this.invalidateAffectedText,
  });

  factory BodyUpdatePronunciationDictionariesV1ProjectsProjectIdUpdatePronunciationDictionariesPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyUpdatePronunciationDictionariesV1ProjectsProjectIdUpdatePronunciationDictionariesPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyUpdatePronunciationDictionariesV1ProjectsProjectIdUpdatePronunciationDictionariesPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyUpdatePronunciationDictionariesV1ProjectsProjectIdUpdatePronunciationDictionariesPostToJson(
          this);

  @JsonKey(
      name: 'pronunciation_dictionary_locators',
      defaultValue: <PronunciationDictionaryVersionLocatorDBModel>[])
  final List<PronunciationDictionaryVersionLocatorDBModel>
      pronunciationDictionaryLocators;
  @JsonKey(name: 'invalidate_affected_text', defaultValue: true)
  final bool? invalidateAffectedText;
  static const fromJsonFactory =
      _$BodyUpdatePronunciationDictionariesV1ProjectsProjectIdUpdatePronunciationDictionariesPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyUpdatePronunciationDictionariesV1ProjectsProjectIdUpdatePronunciationDictionariesPost &&
            (identical(other.pronunciationDictionaryLocators,
                    pronunciationDictionaryLocators) ||
                const DeepCollectionEquality().equals(
                    other.pronunciationDictionaryLocators,
                    pronunciationDictionaryLocators)) &&
            (identical(other.invalidateAffectedText, invalidateAffectedText) ||
                const DeepCollectionEquality().equals(
                    other.invalidateAffectedText, invalidateAffectedText)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(pronunciationDictionaryLocators) ^
      const DeepCollectionEquality().hash(invalidateAffectedText) ^
      runtimeType.hashCode;
}

extension $BodyUpdatePronunciationDictionariesV1ProjectsProjectIdUpdatePronunciationDictionariesPostExtension
    on BodyUpdatePronunciationDictionariesV1ProjectsProjectIdUpdatePronunciationDictionariesPost {
  BodyUpdatePronunciationDictionariesV1ProjectsProjectIdUpdatePronunciationDictionariesPost
      copyWith(
          {List<PronunciationDictionaryVersionLocatorDBModel>?
              pronunciationDictionaryLocators,
          bool? invalidateAffectedText}) {
    return BodyUpdatePronunciationDictionariesV1ProjectsProjectIdUpdatePronunciationDictionariesPost(
        pronunciationDictionaryLocators: pronunciationDictionaryLocators ??
            this.pronunciationDictionaryLocators,
        invalidateAffectedText:
            invalidateAffectedText ?? this.invalidateAffectedText);
  }

  BodyUpdatePronunciationDictionariesV1ProjectsProjectIdUpdatePronunciationDictionariesPost
      copyWithWrapped(
          {Wrapped<List<PronunciationDictionaryVersionLocatorDBModel>>?
              pronunciationDictionaryLocators,
          Wrapped<bool?>? invalidateAffectedText}) {
    return BodyUpdatePronunciationDictionariesV1ProjectsProjectIdUpdatePronunciationDictionariesPost(
        pronunciationDictionaryLocators:
            (pronunciationDictionaryLocators != null
                ? pronunciationDictionaryLocators.value
                : this.pronunciationDictionaryLocators),
        invalidateAffectedText: (invalidateAffectedText != null
            ? invalidateAffectedText.value
            : this.invalidateAffectedText));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyUpdateStudioProjectContentV1StudioProjectsProjectIdContentPost {
  const BodyUpdateStudioProjectContentV1StudioProjectsProjectIdContentPost({
    this.fromUrl,
    this.fromDocument,
    this.autoConvert,
  });

  factory BodyUpdateStudioProjectContentV1StudioProjectsProjectIdContentPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyUpdateStudioProjectContentV1StudioProjectsProjectIdContentPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyUpdateStudioProjectContentV1StudioProjectsProjectIdContentPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyUpdateStudioProjectContentV1StudioProjectsProjectIdContentPostToJson(
          this);

  @JsonKey(name: 'from_url')
  final dynamic fromUrl;
  @JsonKey(name: 'from_document')
  final dynamic fromDocument;
  @JsonKey(name: 'auto_convert', defaultValue: false)
  final bool? autoConvert;
  static const fromJsonFactory =
      _$BodyUpdateStudioProjectContentV1StudioProjectsProjectIdContentPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyUpdateStudioProjectContentV1StudioProjectsProjectIdContentPost &&
            (identical(other.fromUrl, fromUrl) ||
                const DeepCollectionEquality()
                    .equals(other.fromUrl, fromUrl)) &&
            (identical(other.fromDocument, fromDocument) ||
                const DeepCollectionEquality()
                    .equals(other.fromDocument, fromDocument)) &&
            (identical(other.autoConvert, autoConvert) ||
                const DeepCollectionEquality()
                    .equals(other.autoConvert, autoConvert)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fromUrl) ^
      const DeepCollectionEquality().hash(fromDocument) ^
      const DeepCollectionEquality().hash(autoConvert) ^
      runtimeType.hashCode;
}

extension $BodyUpdateStudioProjectContentV1StudioProjectsProjectIdContentPostExtension
    on BodyUpdateStudioProjectContentV1StudioProjectsProjectIdContentPost {
  BodyUpdateStudioProjectContentV1StudioProjectsProjectIdContentPost copyWith(
      {dynamic fromUrl, dynamic fromDocument, bool? autoConvert}) {
    return BodyUpdateStudioProjectContentV1StudioProjectsProjectIdContentPost(
        fromUrl: fromUrl ?? this.fromUrl,
        fromDocument: fromDocument ?? this.fromDocument,
        autoConvert: autoConvert ?? this.autoConvert);
  }

  BodyUpdateStudioProjectContentV1StudioProjectsProjectIdContentPost
      copyWithWrapped(
          {Wrapped<dynamic>? fromUrl,
          Wrapped<dynamic>? fromDocument,
          Wrapped<bool?>? autoConvert}) {
    return BodyUpdateStudioProjectContentV1StudioProjectsProjectIdContentPost(
        fromUrl: (fromUrl != null ? fromUrl.value : this.fromUrl),
        fromDocument:
            (fromDocument != null ? fromDocument.value : this.fromDocument),
        autoConvert:
            (autoConvert != null ? autoConvert.value : this.autoConvert));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyUpdateStudioProjectV1StudioProjectsProjectIdPost {
  const BodyUpdateStudioProjectV1StudioProjectsProjectIdPost({
    required this.name,
    required this.defaultTitleVoiceId,
    required this.defaultParagraphVoiceId,
    this.title,
    this.author,
    this.isbnNumber,
    this.volumeNormalization,
  });

  factory BodyUpdateStudioProjectV1StudioProjectsProjectIdPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyUpdateStudioProjectV1StudioProjectsProjectIdPostFromJson(json);

  static const toJsonFactory =
      _$BodyUpdateStudioProjectV1StudioProjectsProjectIdPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyUpdateStudioProjectV1StudioProjectsProjectIdPostToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'default_title_voice_id')
  final String defaultTitleVoiceId;
  @JsonKey(name: 'default_paragraph_voice_id')
  final String defaultParagraphVoiceId;
  @JsonKey(name: 'title')
  final dynamic title;
  @JsonKey(name: 'author')
  final dynamic author;
  @JsonKey(name: 'isbn_number')
  final dynamic isbnNumber;
  @JsonKey(name: 'volume_normalization', defaultValue: false)
  final bool? volumeNormalization;
  static const fromJsonFactory =
      _$BodyUpdateStudioProjectV1StudioProjectsProjectIdPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyUpdateStudioProjectV1StudioProjectsProjectIdPost &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.defaultTitleVoiceId, defaultTitleVoiceId) ||
                const DeepCollectionEquality()
                    .equals(other.defaultTitleVoiceId, defaultTitleVoiceId)) &&
            (identical(
                    other.defaultParagraphVoiceId, defaultParagraphVoiceId) ||
                const DeepCollectionEquality().equals(
                    other.defaultParagraphVoiceId, defaultParagraphVoiceId)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.author, author) ||
                const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.isbnNumber, isbnNumber) ||
                const DeepCollectionEquality()
                    .equals(other.isbnNumber, isbnNumber)) &&
            (identical(other.volumeNormalization, volumeNormalization) ||
                const DeepCollectionEquality()
                    .equals(other.volumeNormalization, volumeNormalization)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(defaultTitleVoiceId) ^
      const DeepCollectionEquality().hash(defaultParagraphVoiceId) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(isbnNumber) ^
      const DeepCollectionEquality().hash(volumeNormalization) ^
      runtimeType.hashCode;
}

extension $BodyUpdateStudioProjectV1StudioProjectsProjectIdPostExtension
    on BodyUpdateStudioProjectV1StudioProjectsProjectIdPost {
  BodyUpdateStudioProjectV1StudioProjectsProjectIdPost copyWith(
      {String? name,
      String? defaultTitleVoiceId,
      String? defaultParagraphVoiceId,
      dynamic title,
      dynamic author,
      dynamic isbnNumber,
      bool? volumeNormalization}) {
    return BodyUpdateStudioProjectV1StudioProjectsProjectIdPost(
        name: name ?? this.name,
        defaultTitleVoiceId: defaultTitleVoiceId ?? this.defaultTitleVoiceId,
        defaultParagraphVoiceId:
            defaultParagraphVoiceId ?? this.defaultParagraphVoiceId,
        title: title ?? this.title,
        author: author ?? this.author,
        isbnNumber: isbnNumber ?? this.isbnNumber,
        volumeNormalization: volumeNormalization ?? this.volumeNormalization);
  }

  BodyUpdateStudioProjectV1StudioProjectsProjectIdPost copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String>? defaultTitleVoiceId,
      Wrapped<String>? defaultParagraphVoiceId,
      Wrapped<dynamic>? title,
      Wrapped<dynamic>? author,
      Wrapped<dynamic>? isbnNumber,
      Wrapped<bool?>? volumeNormalization}) {
    return BodyUpdateStudioProjectV1StudioProjectsProjectIdPost(
        name: (name != null ? name.value : this.name),
        defaultTitleVoiceId: (defaultTitleVoiceId != null
            ? defaultTitleVoiceId.value
            : this.defaultTitleVoiceId),
        defaultParagraphVoiceId: (defaultParagraphVoiceId != null
            ? defaultParagraphVoiceId.value
            : this.defaultParagraphVoiceId),
        title: (title != null ? title.value : this.title),
        author: (author != null ? author.value : this.author),
        isbnNumber: (isbnNumber != null ? isbnNumber.value : this.isbnNumber),
        volumeNormalization: (volumeNormalization != null
            ? volumeNormalization.value
            : this.volumeNormalization));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyUpdateAudioNativeProjectContentV1AudioNativeProjectIdContentPost {
  const BodyUpdateAudioNativeProjectContentV1AudioNativeProjectIdContentPost({
    this.file,
    this.autoConvert,
    this.autoPublish,
  });

  factory BodyUpdateAudioNativeProjectContentV1AudioNativeProjectIdContentPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyUpdateAudioNativeProjectContentV1AudioNativeProjectIdContentPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyUpdateAudioNativeProjectContentV1AudioNativeProjectIdContentPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyUpdateAudioNativeProjectContentV1AudioNativeProjectIdContentPostToJson(
          this);

  @JsonKey(name: 'file')
  final String? file;
  @JsonKey(name: 'auto_convert', defaultValue: false)
  final bool? autoConvert;
  @JsonKey(name: 'auto_publish', defaultValue: false)
  final bool? autoPublish;
  static const fromJsonFactory =
      _$BodyUpdateAudioNativeProjectContentV1AudioNativeProjectIdContentPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyUpdateAudioNativeProjectContentV1AudioNativeProjectIdContentPost &&
            (identical(other.file, file) ||
                const DeepCollectionEquality().equals(other.file, file)) &&
            (identical(other.autoConvert, autoConvert) ||
                const DeepCollectionEquality()
                    .equals(other.autoConvert, autoConvert)) &&
            (identical(other.autoPublish, autoPublish) ||
                const DeepCollectionEquality()
                    .equals(other.autoPublish, autoPublish)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(file) ^
      const DeepCollectionEquality().hash(autoConvert) ^
      const DeepCollectionEquality().hash(autoPublish) ^
      runtimeType.hashCode;
}

extension $BodyUpdateAudioNativeProjectContentV1AudioNativeProjectIdContentPostExtension
    on BodyUpdateAudioNativeProjectContentV1AudioNativeProjectIdContentPost {
  BodyUpdateAudioNativeProjectContentV1AudioNativeProjectIdContentPost copyWith(
      {String? file, bool? autoConvert, bool? autoPublish}) {
    return BodyUpdateAudioNativeProjectContentV1AudioNativeProjectIdContentPost(
        file: file ?? this.file,
        autoConvert: autoConvert ?? this.autoConvert,
        autoPublish: autoPublish ?? this.autoPublish);
  }

  BodyUpdateAudioNativeProjectContentV1AudioNativeProjectIdContentPost
      copyWithWrapped(
          {Wrapped<String?>? file,
          Wrapped<bool?>? autoConvert,
          Wrapped<bool?>? autoPublish}) {
    return BodyUpdateAudioNativeProjectContentV1AudioNativeProjectIdContentPost(
        file: (file != null ? file.value : this.file),
        autoConvert:
            (autoConvert != null ? autoConvert.value : this.autoConvert),
        autoPublish:
            (autoPublish != null ? autoPublish.value : this.autoPublish));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyUpdateChapterV1StudioProjectsProjectIdChaptersChapterIdPost {
  const BodyUpdateChapterV1StudioProjectsProjectIdChaptersChapterIdPost({
    this.name,
    this.content,
  });

  factory BodyUpdateChapterV1StudioProjectsProjectIdChaptersChapterIdPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyUpdateChapterV1StudioProjectsProjectIdChaptersChapterIdPostFromJson(
          json);

  static const toJsonFactory =
      _$BodyUpdateChapterV1StudioProjectsProjectIdChaptersChapterIdPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyUpdateChapterV1StudioProjectsProjectIdChaptersChapterIdPostToJson(
          this);

  @JsonKey(name: 'name')
  final dynamic name;
  @JsonKey(name: 'content')
  final dynamic content;
  static const fromJsonFactory =
      _$BodyUpdateChapterV1StudioProjectsProjectIdChaptersChapterIdPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyUpdateChapterV1StudioProjectsProjectIdChaptersChapterIdPost &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $BodyUpdateChapterV1StudioProjectsProjectIdChaptersChapterIdPostExtension
    on BodyUpdateChapterV1StudioProjectsProjectIdChaptersChapterIdPost {
  BodyUpdateChapterV1StudioProjectsProjectIdChaptersChapterIdPost copyWith(
      {dynamic name, dynamic content}) {
    return BodyUpdateChapterV1StudioProjectsProjectIdChaptersChapterIdPost(
        name: name ?? this.name, content: content ?? this.content);
  }

  BodyUpdateChapterV1StudioProjectsProjectIdChaptersChapterIdPost
      copyWithWrapped({Wrapped<dynamic>? name, Wrapped<dynamic>? content}) {
    return BodyUpdateChapterV1StudioProjectsProjectIdChaptersChapterIdPost(
        name: (name != null ? name.value : this.name),
        content: (content != null ? content.value : this.content));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIdPatch {
  const BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIdPatch({
    required this.name,
  });

  factory BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIdPatch.fromJson(
          Map<String, dynamic> json) =>
      _$BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIdPatchFromJson(
          json);

  static const toJsonFactory =
      _$BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIdPatchToJson;
  Map<String, dynamic> toJson() =>
      _$BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIdPatchToJson(this);

  @JsonKey(name: 'name')
  final String name;
  static const fromJsonFactory =
      _$BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIdPatchFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIdPatch &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^ runtimeType.hashCode;
}

extension $BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIdPatchExtension
    on BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIdPatch {
  BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIdPatch copyWith(
      {String? name}) {
    return BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIdPatch(
        name: name ?? this.name);
  }

  BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIdPatch copyWithWrapped(
      {Wrapped<String>? name}) {
    return BodyUpdateDocumentV1ConvaiKnowledgeBaseDocumentationIdPatch(
        name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyUpdateMemberV1WorkspaceMembersPost {
  const BodyUpdateMemberV1WorkspaceMembersPost({
    required this.email,
    this.isLocked,
    this.workspaceRole,
  });

  factory BodyUpdateMemberV1WorkspaceMembersPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyUpdateMemberV1WorkspaceMembersPostFromJson(json);

  static const toJsonFactory = _$BodyUpdateMemberV1WorkspaceMembersPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyUpdateMemberV1WorkspaceMembersPostToJson(this);

  @JsonKey(name: 'email')
  final String email;
  @JsonKey(name: 'is_locked')
  final dynamic isLocked;
  @JsonKey(name: 'workspace_role')
  final dynamic workspaceRole;
  static const fromJsonFactory =
      _$BodyUpdateMemberV1WorkspaceMembersPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyUpdateMemberV1WorkspaceMembersPost &&
            (identical(other.email, email) ||
                const DeepCollectionEquality().equals(other.email, email)) &&
            (identical(other.isLocked, isLocked) ||
                const DeepCollectionEquality()
                    .equals(other.isLocked, isLocked)) &&
            (identical(other.workspaceRole, workspaceRole) ||
                const DeepCollectionEquality()
                    .equals(other.workspaceRole, workspaceRole)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(email) ^
      const DeepCollectionEquality().hash(isLocked) ^
      const DeepCollectionEquality().hash(workspaceRole) ^
      runtimeType.hashCode;
}

extension $BodyUpdateMemberV1WorkspaceMembersPostExtension
    on BodyUpdateMemberV1WorkspaceMembersPost {
  BodyUpdateMemberV1WorkspaceMembersPost copyWith(
      {String? email, dynamic isLocked, dynamic workspaceRole}) {
    return BodyUpdateMemberV1WorkspaceMembersPost(
        email: email ?? this.email,
        isLocked: isLocked ?? this.isLocked,
        workspaceRole: workspaceRole ?? this.workspaceRole);
  }

  BodyUpdateMemberV1WorkspaceMembersPost copyWithWrapped(
      {Wrapped<String>? email,
      Wrapped<dynamic>? isLocked,
      Wrapped<dynamic>? workspaceRole}) {
    return BodyUpdateMemberV1WorkspaceMembersPost(
        email: (email != null ? email.value : this.email),
        isLocked: (isLocked != null ? isLocked.value : this.isLocked),
        workspaceRole:
            (workspaceRole != null ? workspaceRole.value : this.workspaceRole));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIdSpeakerSpeakerIdPatch {
  const BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIdSpeakerSpeakerIdPatch({
    this.voiceId,
    this.languages,
  });

  factory BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIdSpeakerSpeakerIdPatch.fromJson(
          Map<String, dynamic> json) =>
      _$BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIdSpeakerSpeakerIdPatchFromJson(
          json);

  static const toJsonFactory =
      _$BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIdSpeakerSpeakerIdPatchToJson;
  Map<String, dynamic> toJson() =>
      _$BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIdSpeakerSpeakerIdPatchToJson(
          this);

  @JsonKey(name: 'voice_id')
  final dynamic voiceId;
  @JsonKey(name: 'languages')
  final dynamic languages;
  static const fromJsonFactory =
      _$BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIdSpeakerSpeakerIdPatchFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIdSpeakerSpeakerIdPatch &&
            (identical(other.voiceId, voiceId) ||
                const DeepCollectionEquality()
                    .equals(other.voiceId, voiceId)) &&
            (identical(other.languages, languages) ||
                const DeepCollectionEquality()
                    .equals(other.languages, languages)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(voiceId) ^
      const DeepCollectionEquality().hash(languages) ^
      runtimeType.hashCode;
}

extension $BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIdSpeakerSpeakerIdPatchExtension
    on BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIdSpeakerSpeakerIdPatch {
  BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIdSpeakerSpeakerIdPatch
      copyWith({dynamic voiceId, dynamic languages}) {
    return BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIdSpeakerSpeakerIdPatch(
        voiceId: voiceId ?? this.voiceId,
        languages: languages ?? this.languages);
  }

  BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIdSpeakerSpeakerIdPatch
      copyWithWrapped(
          {Wrapped<dynamic>? voiceId, Wrapped<dynamic>? languages}) {
    return BodyUpdateMetadataForASpeakerV1DubbingResourceDubbingIdSpeakerSpeakerIdPatch(
        voiceId: (voiceId != null ? voiceId.value : this.voiceId),
        languages: (languages != null ? languages.value : this.languages));
  }
}

@JsonSerializable(explicitToJson: true)
class BodyVerifyPVCVoiceCaptchaV1VoicesPvcVoiceIdCaptchaPost {
  const BodyVerifyPVCVoiceCaptchaV1VoicesPvcVoiceIdCaptchaPost({
    required this.recording,
  });

  factory BodyVerifyPVCVoiceCaptchaV1VoicesPvcVoiceIdCaptchaPost.fromJson(
          Map<String, dynamic> json) =>
      _$BodyVerifyPVCVoiceCaptchaV1VoicesPvcVoiceIdCaptchaPostFromJson(json);

  static const toJsonFactory =
      _$BodyVerifyPVCVoiceCaptchaV1VoicesPvcVoiceIdCaptchaPostToJson;
  Map<String, dynamic> toJson() =>
      _$BodyVerifyPVCVoiceCaptchaV1VoicesPvcVoiceIdCaptchaPostToJson(this);

  @JsonKey(name: 'recording')
  final String recording;
  static const fromJsonFactory =
      _$BodyVerifyPVCVoiceCaptchaV1VoicesPvcVoiceIdCaptchaPostFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is BodyVerifyPVCVoiceCaptchaV1VoicesPvcVoiceIdCaptchaPost &&
            (identical(other.recording, recording) ||
                const DeepCollectionEquality()
                    .equals(other.recording, recording)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(recording) ^ runtimeType.hashCode;
}

extension $BodyVerifyPVCVoiceCaptchaV1VoicesPvcVoiceIdCaptchaPostExtension
    on BodyVerifyPVCVoiceCaptchaV1VoicesPvcVoiceIdCaptchaPost {
  BodyVerifyPVCVoiceCaptchaV1VoicesPvcVoiceIdCaptchaPost copyWith(
      {String? recording}) {
    return BodyVerifyPVCVoiceCaptchaV1VoicesPvcVoiceIdCaptchaPost(
        recording: recording ?? this.recording);
  }

  BodyVerifyPVCVoiceCaptchaV1VoicesPvcVoiceIdCaptchaPost copyWithWrapped(
      {Wrapped<String>? recording}) {
    return BodyVerifyPVCVoiceCaptchaV1VoicesPvcVoiceIdCaptchaPost(
        recording: (recording != null ? recording.value : this.recording));
  }
}

@JsonSerializable(explicitToJson: true)
class ChapterContentBlockExtendableNodeResponseModel {
  const ChapterContentBlockExtendableNodeResponseModel({
    required this.type,
  });

  factory ChapterContentBlockExtendableNodeResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$ChapterContentBlockExtendableNodeResponseModelFromJson(json);

  static const toJsonFactory =
      _$ChapterContentBlockExtendableNodeResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$ChapterContentBlockExtendableNodeResponseModelToJson(this);

  @JsonKey(name: 'type')
  final String type;
  static const fromJsonFactory =
      _$ChapterContentBlockExtendableNodeResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChapterContentBlockExtendableNodeResponseModel &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^ runtimeType.hashCode;
}

extension $ChapterContentBlockExtendableNodeResponseModelExtension
    on ChapterContentBlockExtendableNodeResponseModel {
  ChapterContentBlockExtendableNodeResponseModel copyWith({String? type}) {
    return ChapterContentBlockExtendableNodeResponseModel(
        type: type ?? this.type);
  }

  ChapterContentBlockExtendableNodeResponseModel copyWithWrapped(
      {Wrapped<String>? type}) {
    return ChapterContentBlockExtendableNodeResponseModel(
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class ChapterContentBlockInputModel {
  const ChapterContentBlockInputModel({
    this.subType,
    this.blockId,
    required this.nodes,
  });

  factory ChapterContentBlockInputModel.fromJson(Map<String, dynamic> json) =>
      _$ChapterContentBlockInputModelFromJson(json);

  static const toJsonFactory = _$ChapterContentBlockInputModelToJson;
  Map<String, dynamic> toJson() => _$ChapterContentBlockInputModelToJson(this);

  @JsonKey(name: 'sub_type')
  final dynamic subType;
  @JsonKey(name: 'block_id')
  final dynamic blockId;
  @JsonKey(
      name: 'nodes', defaultValue: <ChapterContentParagraphTtsNodeInputModel>[])
  final List<ChapterContentParagraphTtsNodeInputModel> nodes;
  static const fromJsonFactory = _$ChapterContentBlockInputModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChapterContentBlockInputModel &&
            (identical(other.subType, subType) ||
                const DeepCollectionEquality()
                    .equals(other.subType, subType)) &&
            (identical(other.blockId, blockId) ||
                const DeepCollectionEquality()
                    .equals(other.blockId, blockId)) &&
            (identical(other.nodes, nodes) ||
                const DeepCollectionEquality().equals(other.nodes, nodes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(subType) ^
      const DeepCollectionEquality().hash(blockId) ^
      const DeepCollectionEquality().hash(nodes) ^
      runtimeType.hashCode;
}

extension $ChapterContentBlockInputModelExtension
    on ChapterContentBlockInputModel {
  ChapterContentBlockInputModel copyWith(
      {dynamic subType,
      dynamic blockId,
      List<ChapterContentParagraphTtsNodeInputModel>? nodes}) {
    return ChapterContentBlockInputModel(
        subType: subType ?? this.subType,
        blockId: blockId ?? this.blockId,
        nodes: nodes ?? this.nodes);
  }

  ChapterContentBlockInputModel copyWithWrapped(
      {Wrapped<dynamic>? subType,
      Wrapped<dynamic>? blockId,
      Wrapped<List<ChapterContentParagraphTtsNodeInputModel>>? nodes}) {
    return ChapterContentBlockInputModel(
        subType: (subType != null ? subType.value : this.subType),
        blockId: (blockId != null ? blockId.value : this.blockId),
        nodes: (nodes != null ? nodes.value : this.nodes));
  }
}

@JsonSerializable(explicitToJson: true)
class ChapterContentBlockResponseModel {
  const ChapterContentBlockResponseModel({
    required this.blockId,
    required this.nodes,
  });

  factory ChapterContentBlockResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$ChapterContentBlockResponseModelFromJson(json);

  static const toJsonFactory = _$ChapterContentBlockResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$ChapterContentBlockResponseModelToJson(this);

  @JsonKey(name: 'block_id')
  final String blockId;
  @JsonKey(name: 'nodes', defaultValue: <Object>[])
  final List<Object> nodes;
  static const fromJsonFactory = _$ChapterContentBlockResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChapterContentBlockResponseModel &&
            (identical(other.blockId, blockId) ||
                const DeepCollectionEquality()
                    .equals(other.blockId, blockId)) &&
            (identical(other.nodes, nodes) ||
                const DeepCollectionEquality().equals(other.nodes, nodes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(blockId) ^
      const DeepCollectionEquality().hash(nodes) ^
      runtimeType.hashCode;
}

extension $ChapterContentBlockResponseModelExtension
    on ChapterContentBlockResponseModel {
  ChapterContentBlockResponseModel copyWith(
      {String? blockId, List<Object>? nodes}) {
    return ChapterContentBlockResponseModel(
        blockId: blockId ?? this.blockId, nodes: nodes ?? this.nodes);
  }

  ChapterContentBlockResponseModel copyWithWrapped(
      {Wrapped<String>? blockId, Wrapped<List<Object>>? nodes}) {
    return ChapterContentBlockResponseModel(
        blockId: (blockId != null ? blockId.value : this.blockId),
        nodes: (nodes != null ? nodes.value : this.nodes));
  }
}

@JsonSerializable(explicitToJson: true)
class ChapterContentBlockTtsNodeResponseModel {
  const ChapterContentBlockTtsNodeResponseModel({
    required this.type,
    required this.voiceId,
    required this.text,
  });

  factory ChapterContentBlockTtsNodeResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$ChapterContentBlockTtsNodeResponseModelFromJson(json);

  static const toJsonFactory = _$ChapterContentBlockTtsNodeResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$ChapterContentBlockTtsNodeResponseModelToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'voice_id')
  final String voiceId;
  @JsonKey(name: 'text')
  final String text;
  static const fromJsonFactory =
      _$ChapterContentBlockTtsNodeResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChapterContentBlockTtsNodeResponseModel &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.voiceId, voiceId) ||
                const DeepCollectionEquality()
                    .equals(other.voiceId, voiceId)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(voiceId) ^
      const DeepCollectionEquality().hash(text) ^
      runtimeType.hashCode;
}

extension $ChapterContentBlockTtsNodeResponseModelExtension
    on ChapterContentBlockTtsNodeResponseModel {
  ChapterContentBlockTtsNodeResponseModel copyWith(
      {String? type, String? voiceId, String? text}) {
    return ChapterContentBlockTtsNodeResponseModel(
        type: type ?? this.type,
        voiceId: voiceId ?? this.voiceId,
        text: text ?? this.text);
  }

  ChapterContentBlockTtsNodeResponseModel copyWithWrapped(
      {Wrapped<String>? type,
      Wrapped<String>? voiceId,
      Wrapped<String>? text}) {
    return ChapterContentBlockTtsNodeResponseModel(
        type: (type != null ? type.value : this.type),
        voiceId: (voiceId != null ? voiceId.value : this.voiceId),
        text: (text != null ? text.value : this.text));
  }
}

@JsonSerializable(explicitToJson: true)
class ChapterContentInputModel {
  const ChapterContentInputModel({
    required this.blocks,
  });

  factory ChapterContentInputModel.fromJson(Map<String, dynamic> json) =>
      _$ChapterContentInputModelFromJson(json);

  static const toJsonFactory = _$ChapterContentInputModelToJson;
  Map<String, dynamic> toJson() => _$ChapterContentInputModelToJson(this);

  @JsonKey(name: 'blocks', defaultValue: <ChapterContentBlockInputModel>[])
  final List<ChapterContentBlockInputModel> blocks;
  static const fromJsonFactory = _$ChapterContentInputModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChapterContentInputModel &&
            (identical(other.blocks, blocks) ||
                const DeepCollectionEquality().equals(other.blocks, blocks)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(blocks) ^ runtimeType.hashCode;
}

extension $ChapterContentInputModelExtension on ChapterContentInputModel {
  ChapterContentInputModel copyWith(
      {List<ChapterContentBlockInputModel>? blocks}) {
    return ChapterContentInputModel(blocks: blocks ?? this.blocks);
  }

  ChapterContentInputModel copyWithWrapped(
      {Wrapped<List<ChapterContentBlockInputModel>>? blocks}) {
    return ChapterContentInputModel(
        blocks: (blocks != null ? blocks.value : this.blocks));
  }
}

@JsonSerializable(explicitToJson: true)
class ChapterContentParagraphTtsNodeInputModel {
  const ChapterContentParagraphTtsNodeInputModel({
    required this.type,
    required this.text,
    required this.voiceId,
  });

  factory ChapterContentParagraphTtsNodeInputModel.fromJson(
          Map<String, dynamic> json) =>
      _$ChapterContentParagraphTtsNodeInputModelFromJson(json);

  static const toJsonFactory = _$ChapterContentParagraphTtsNodeInputModelToJson;
  Map<String, dynamic> toJson() =>
      _$ChapterContentParagraphTtsNodeInputModelToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'voice_id')
  final String voiceId;
  static const fromJsonFactory =
      _$ChapterContentParagraphTtsNodeInputModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChapterContentParagraphTtsNodeInputModel &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.voiceId, voiceId) ||
                const DeepCollectionEquality().equals(other.voiceId, voiceId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(voiceId) ^
      runtimeType.hashCode;
}

extension $ChapterContentParagraphTtsNodeInputModelExtension
    on ChapterContentParagraphTtsNodeInputModel {
  ChapterContentParagraphTtsNodeInputModel copyWith(
      {String? type, String? text, String? voiceId}) {
    return ChapterContentParagraphTtsNodeInputModel(
        type: type ?? this.type,
        text: text ?? this.text,
        voiceId: voiceId ?? this.voiceId);
  }

  ChapterContentParagraphTtsNodeInputModel copyWithWrapped(
      {Wrapped<String>? type,
      Wrapped<String>? text,
      Wrapped<String>? voiceId}) {
    return ChapterContentParagraphTtsNodeInputModel(
        type: (type != null ? type.value : this.type),
        text: (text != null ? text.value : this.text),
        voiceId: (voiceId != null ? voiceId.value : this.voiceId));
  }
}

@JsonSerializable(explicitToJson: true)
class ChapterContentResponseModel {
  const ChapterContentResponseModel({
    required this.blocks,
  });

  factory ChapterContentResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ChapterContentResponseModelFromJson(json);

  static const toJsonFactory = _$ChapterContentResponseModelToJson;
  Map<String, dynamic> toJson() => _$ChapterContentResponseModelToJson(this);

  @JsonKey(name: 'blocks', defaultValue: <ChapterContentBlockResponseModel>[])
  final List<ChapterContentBlockResponseModel> blocks;
  static const fromJsonFactory = _$ChapterContentResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChapterContentResponseModel &&
            (identical(other.blocks, blocks) ||
                const DeepCollectionEquality().equals(other.blocks, blocks)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(blocks) ^ runtimeType.hashCode;
}

extension $ChapterContentResponseModelExtension on ChapterContentResponseModel {
  ChapterContentResponseModel copyWith(
      {List<ChapterContentBlockResponseModel>? blocks}) {
    return ChapterContentResponseModel(blocks: blocks ?? this.blocks);
  }

  ChapterContentResponseModel copyWithWrapped(
      {Wrapped<List<ChapterContentBlockResponseModel>>? blocks}) {
    return ChapterContentResponseModel(
        blocks: (blocks != null ? blocks.value : this.blocks));
  }
}

@JsonSerializable(explicitToJson: true)
class ChapterResponseModel {
  const ChapterResponseModel({
    required this.chapterId,
    required this.name,
    this.lastConversionDateUnix,
    this.conversionProgress,
    required this.canBeDownloaded,
    required this.state,
    this.statistics,
    this.lastConversionError,
  });

  factory ChapterResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ChapterResponseModelFromJson(json);

  static const toJsonFactory = _$ChapterResponseModelToJson;
  Map<String, dynamic> toJson() => _$ChapterResponseModelToJson(this);

  @JsonKey(name: 'chapter_id')
  final String chapterId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'last_conversion_date_unix')
  final dynamic lastConversionDateUnix;
  @JsonKey(name: 'conversion_progress')
  final dynamic conversionProgress;
  @JsonKey(name: 'can_be_downloaded')
  final bool canBeDownloaded;
  @JsonKey(
    name: 'state',
    toJson: chapterResponseModelStateToJson,
    fromJson: chapterResponseModelStateFromJson,
  )
  final enums.ChapterResponseModelState state;
  @JsonKey(name: 'statistics')
  final dynamic statistics;
  @JsonKey(name: 'last_conversion_error')
  final dynamic lastConversionError;
  static const fromJsonFactory = _$ChapterResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChapterResponseModel &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.lastConversionDateUnix, lastConversionDateUnix) ||
                const DeepCollectionEquality().equals(
                    other.lastConversionDateUnix, lastConversionDateUnix)) &&
            (identical(other.conversionProgress, conversionProgress) ||
                const DeepCollectionEquality()
                    .equals(other.conversionProgress, conversionProgress)) &&
            (identical(other.canBeDownloaded, canBeDownloaded) ||
                const DeepCollectionEquality()
                    .equals(other.canBeDownloaded, canBeDownloaded)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.statistics, statistics) ||
                const DeepCollectionEquality()
                    .equals(other.statistics, statistics)) &&
            (identical(other.lastConversionError, lastConversionError) ||
                const DeepCollectionEquality()
                    .equals(other.lastConversionError, lastConversionError)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(lastConversionDateUnix) ^
      const DeepCollectionEquality().hash(conversionProgress) ^
      const DeepCollectionEquality().hash(canBeDownloaded) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(statistics) ^
      const DeepCollectionEquality().hash(lastConversionError) ^
      runtimeType.hashCode;
}

extension $ChapterResponseModelExtension on ChapterResponseModel {
  ChapterResponseModel copyWith(
      {String? chapterId,
      String? name,
      dynamic lastConversionDateUnix,
      dynamic conversionProgress,
      bool? canBeDownloaded,
      enums.ChapterResponseModelState? state,
      dynamic statistics,
      dynamic lastConversionError}) {
    return ChapterResponseModel(
        chapterId: chapterId ?? this.chapterId,
        name: name ?? this.name,
        lastConversionDateUnix:
            lastConversionDateUnix ?? this.lastConversionDateUnix,
        conversionProgress: conversionProgress ?? this.conversionProgress,
        canBeDownloaded: canBeDownloaded ?? this.canBeDownloaded,
        state: state ?? this.state,
        statistics: statistics ?? this.statistics,
        lastConversionError: lastConversionError ?? this.lastConversionError);
  }

  ChapterResponseModel copyWithWrapped(
      {Wrapped<String>? chapterId,
      Wrapped<String>? name,
      Wrapped<dynamic>? lastConversionDateUnix,
      Wrapped<dynamic>? conversionProgress,
      Wrapped<bool>? canBeDownloaded,
      Wrapped<enums.ChapterResponseModelState>? state,
      Wrapped<dynamic>? statistics,
      Wrapped<dynamic>? lastConversionError}) {
    return ChapterResponseModel(
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        name: (name != null ? name.value : this.name),
        lastConversionDateUnix: (lastConversionDateUnix != null
            ? lastConversionDateUnix.value
            : this.lastConversionDateUnix),
        conversionProgress: (conversionProgress != null
            ? conversionProgress.value
            : this.conversionProgress),
        canBeDownloaded: (canBeDownloaded != null
            ? canBeDownloaded.value
            : this.canBeDownloaded),
        state: (state != null ? state.value : this.state),
        statistics: (statistics != null ? statistics.value : this.statistics),
        lastConversionError: (lastConversionError != null
            ? lastConversionError.value
            : this.lastConversionError));
  }
}

@JsonSerializable(explicitToJson: true)
class ChapterSnapshotExtendedResponseModel {
  const ChapterSnapshotExtendedResponseModel({
    required this.chapterSnapshotId,
    required this.projectId,
    required this.chapterId,
    required this.createdAtUnix,
    required this.name,
    required this.characterAlignments,
  });

  factory ChapterSnapshotExtendedResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$ChapterSnapshotExtendedResponseModelFromJson(json);

  static const toJsonFactory = _$ChapterSnapshotExtendedResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$ChapterSnapshotExtendedResponseModelToJson(this);

  @JsonKey(name: 'chapter_snapshot_id')
  final String chapterSnapshotId;
  @JsonKey(name: 'project_id')
  final String projectId;
  @JsonKey(name: 'chapter_id')
  final String chapterId;
  @JsonKey(name: 'created_at_unix')
  final int createdAtUnix;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(
      name: 'character_alignments', defaultValue: <CharacterAlignmentModel>[])
  final List<CharacterAlignmentModel> characterAlignments;
  static const fromJsonFactory = _$ChapterSnapshotExtendedResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChapterSnapshotExtendedResponseModel &&
            (identical(other.chapterSnapshotId, chapterSnapshotId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterSnapshotId, chapterSnapshotId)) &&
            (identical(other.projectId, projectId) ||
                const DeepCollectionEquality()
                    .equals(other.projectId, projectId)) &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.createdAtUnix, createdAtUnix) ||
                const DeepCollectionEquality()
                    .equals(other.createdAtUnix, createdAtUnix)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.characterAlignments, characterAlignments) ||
                const DeepCollectionEquality()
                    .equals(other.characterAlignments, characterAlignments)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(chapterSnapshotId) ^
      const DeepCollectionEquality().hash(projectId) ^
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(createdAtUnix) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(characterAlignments) ^
      runtimeType.hashCode;
}

extension $ChapterSnapshotExtendedResponseModelExtension
    on ChapterSnapshotExtendedResponseModel {
  ChapterSnapshotExtendedResponseModel copyWith(
      {String? chapterSnapshotId,
      String? projectId,
      String? chapterId,
      int? createdAtUnix,
      String? name,
      List<CharacterAlignmentModel>? characterAlignments}) {
    return ChapterSnapshotExtendedResponseModel(
        chapterSnapshotId: chapterSnapshotId ?? this.chapterSnapshotId,
        projectId: projectId ?? this.projectId,
        chapterId: chapterId ?? this.chapterId,
        createdAtUnix: createdAtUnix ?? this.createdAtUnix,
        name: name ?? this.name,
        characterAlignments: characterAlignments ?? this.characterAlignments);
  }

  ChapterSnapshotExtendedResponseModel copyWithWrapped(
      {Wrapped<String>? chapterSnapshotId,
      Wrapped<String>? projectId,
      Wrapped<String>? chapterId,
      Wrapped<int>? createdAtUnix,
      Wrapped<String>? name,
      Wrapped<List<CharacterAlignmentModel>>? characterAlignments}) {
    return ChapterSnapshotExtendedResponseModel(
        chapterSnapshotId: (chapterSnapshotId != null
            ? chapterSnapshotId.value
            : this.chapterSnapshotId),
        projectId: (projectId != null ? projectId.value : this.projectId),
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        createdAtUnix:
            (createdAtUnix != null ? createdAtUnix.value : this.createdAtUnix),
        name: (name != null ? name.value : this.name),
        characterAlignments: (characterAlignments != null
            ? characterAlignments.value
            : this.characterAlignments));
  }
}

@JsonSerializable(explicitToJson: true)
class ChapterSnapshotResponseModel {
  const ChapterSnapshotResponseModel({
    required this.chapterSnapshotId,
    required this.projectId,
    required this.chapterId,
    required this.createdAtUnix,
    required this.name,
  });

  factory ChapterSnapshotResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ChapterSnapshotResponseModelFromJson(json);

  static const toJsonFactory = _$ChapterSnapshotResponseModelToJson;
  Map<String, dynamic> toJson() => _$ChapterSnapshotResponseModelToJson(this);

  @JsonKey(name: 'chapter_snapshot_id')
  final String chapterSnapshotId;
  @JsonKey(name: 'project_id')
  final String projectId;
  @JsonKey(name: 'chapter_id')
  final String chapterId;
  @JsonKey(name: 'created_at_unix')
  final int createdAtUnix;
  @JsonKey(name: 'name')
  final String name;
  static const fromJsonFactory = _$ChapterSnapshotResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChapterSnapshotResponseModel &&
            (identical(other.chapterSnapshotId, chapterSnapshotId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterSnapshotId, chapterSnapshotId)) &&
            (identical(other.projectId, projectId) ||
                const DeepCollectionEquality()
                    .equals(other.projectId, projectId)) &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.createdAtUnix, createdAtUnix) ||
                const DeepCollectionEquality()
                    .equals(other.createdAtUnix, createdAtUnix)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(chapterSnapshotId) ^
      const DeepCollectionEquality().hash(projectId) ^
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(createdAtUnix) ^
      const DeepCollectionEquality().hash(name) ^
      runtimeType.hashCode;
}

extension $ChapterSnapshotResponseModelExtension
    on ChapterSnapshotResponseModel {
  ChapterSnapshotResponseModel copyWith(
      {String? chapterSnapshotId,
      String? projectId,
      String? chapterId,
      int? createdAtUnix,
      String? name}) {
    return ChapterSnapshotResponseModel(
        chapterSnapshotId: chapterSnapshotId ?? this.chapterSnapshotId,
        projectId: projectId ?? this.projectId,
        chapterId: chapterId ?? this.chapterId,
        createdAtUnix: createdAtUnix ?? this.createdAtUnix,
        name: name ?? this.name);
  }

  ChapterSnapshotResponseModel copyWithWrapped(
      {Wrapped<String>? chapterSnapshotId,
      Wrapped<String>? projectId,
      Wrapped<String>? chapterId,
      Wrapped<int>? createdAtUnix,
      Wrapped<String>? name}) {
    return ChapterSnapshotResponseModel(
        chapterSnapshotId: (chapterSnapshotId != null
            ? chapterSnapshotId.value
            : this.chapterSnapshotId),
        projectId: (projectId != null ? projectId.value : this.projectId),
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        createdAtUnix:
            (createdAtUnix != null ? createdAtUnix.value : this.createdAtUnix),
        name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class ChapterSnapshotsResponseModel {
  const ChapterSnapshotsResponseModel({
    required this.snapshots,
  });

  factory ChapterSnapshotsResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ChapterSnapshotsResponseModelFromJson(json);

  static const toJsonFactory = _$ChapterSnapshotsResponseModelToJson;
  Map<String, dynamic> toJson() => _$ChapterSnapshotsResponseModelToJson(this);

  @JsonKey(name: 'snapshots', defaultValue: <ChapterSnapshotResponseModel>[])
  final List<ChapterSnapshotResponseModel> snapshots;
  static const fromJsonFactory = _$ChapterSnapshotsResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChapterSnapshotsResponseModel &&
            (identical(other.snapshots, snapshots) ||
                const DeepCollectionEquality()
                    .equals(other.snapshots, snapshots)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(snapshots) ^ runtimeType.hashCode;
}

extension $ChapterSnapshotsResponseModelExtension
    on ChapterSnapshotsResponseModel {
  ChapterSnapshotsResponseModel copyWith(
      {List<ChapterSnapshotResponseModel>? snapshots}) {
    return ChapterSnapshotsResponseModel(
        snapshots: snapshots ?? this.snapshots);
  }

  ChapterSnapshotsResponseModel copyWithWrapped(
      {Wrapped<List<ChapterSnapshotResponseModel>>? snapshots}) {
    return ChapterSnapshotsResponseModel(
        snapshots: (snapshots != null ? snapshots.value : this.snapshots));
  }
}

@JsonSerializable(explicitToJson: true)
class ChapterStatisticsResponseModel {
  const ChapterStatisticsResponseModel({
    required this.charactersUnconverted,
    required this.charactersConverted,
    required this.paragraphsConverted,
    required this.paragraphsUnconverted,
  });

  factory ChapterStatisticsResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ChapterStatisticsResponseModelFromJson(json);

  static const toJsonFactory = _$ChapterStatisticsResponseModelToJson;
  Map<String, dynamic> toJson() => _$ChapterStatisticsResponseModelToJson(this);

  @JsonKey(name: 'characters_unconverted')
  final int charactersUnconverted;
  @JsonKey(name: 'characters_converted')
  final int charactersConverted;
  @JsonKey(name: 'paragraphs_converted')
  final int paragraphsConverted;
  @JsonKey(name: 'paragraphs_unconverted')
  final int paragraphsUnconverted;
  static const fromJsonFactory = _$ChapterStatisticsResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChapterStatisticsResponseModel &&
            (identical(other.charactersUnconverted, charactersUnconverted) ||
                const DeepCollectionEquality().equals(
                    other.charactersUnconverted, charactersUnconverted)) &&
            (identical(other.charactersConverted, charactersConverted) ||
                const DeepCollectionEquality()
                    .equals(other.charactersConverted, charactersConverted)) &&
            (identical(other.paragraphsConverted, paragraphsConverted) ||
                const DeepCollectionEquality()
                    .equals(other.paragraphsConverted, paragraphsConverted)) &&
            (identical(other.paragraphsUnconverted, paragraphsUnconverted) ||
                const DeepCollectionEquality().equals(
                    other.paragraphsUnconverted, paragraphsUnconverted)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(charactersUnconverted) ^
      const DeepCollectionEquality().hash(charactersConverted) ^
      const DeepCollectionEquality().hash(paragraphsConverted) ^
      const DeepCollectionEquality().hash(paragraphsUnconverted) ^
      runtimeType.hashCode;
}

extension $ChapterStatisticsResponseModelExtension
    on ChapterStatisticsResponseModel {
  ChapterStatisticsResponseModel copyWith(
      {int? charactersUnconverted,
      int? charactersConverted,
      int? paragraphsConverted,
      int? paragraphsUnconverted}) {
    return ChapterStatisticsResponseModel(
        charactersUnconverted:
            charactersUnconverted ?? this.charactersUnconverted,
        charactersConverted: charactersConverted ?? this.charactersConverted,
        paragraphsConverted: paragraphsConverted ?? this.paragraphsConverted,
        paragraphsUnconverted:
            paragraphsUnconverted ?? this.paragraphsUnconverted);
  }

  ChapterStatisticsResponseModel copyWithWrapped(
      {Wrapped<int>? charactersUnconverted,
      Wrapped<int>? charactersConverted,
      Wrapped<int>? paragraphsConverted,
      Wrapped<int>? paragraphsUnconverted}) {
    return ChapterStatisticsResponseModel(
        charactersUnconverted: (charactersUnconverted != null
            ? charactersUnconverted.value
            : this.charactersUnconverted),
        charactersConverted: (charactersConverted != null
            ? charactersConverted.value
            : this.charactersConverted),
        paragraphsConverted: (paragraphsConverted != null
            ? paragraphsConverted.value
            : this.paragraphsConverted),
        paragraphsUnconverted: (paragraphsUnconverted != null
            ? paragraphsUnconverted.value
            : this.paragraphsUnconverted));
  }
}

@JsonSerializable(explicitToJson: true)
class ChapterWithContentResponseModel {
  const ChapterWithContentResponseModel({
    required this.chapterId,
    required this.name,
    this.lastConversionDateUnix,
    this.conversionProgress,
    required this.canBeDownloaded,
    required this.state,
    this.statistics,
    this.lastConversionError,
    required this.content,
  });

  factory ChapterWithContentResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ChapterWithContentResponseModelFromJson(json);

  static const toJsonFactory = _$ChapterWithContentResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$ChapterWithContentResponseModelToJson(this);

  @JsonKey(name: 'chapter_id')
  final String chapterId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'last_conversion_date_unix')
  final dynamic lastConversionDateUnix;
  @JsonKey(name: 'conversion_progress')
  final dynamic conversionProgress;
  @JsonKey(name: 'can_be_downloaded')
  final bool canBeDownloaded;
  @JsonKey(
    name: 'state',
    toJson: chapterWithContentResponseModelStateToJson,
    fromJson: chapterWithContentResponseModelStateFromJson,
  )
  final enums.ChapterWithContentResponseModelState state;
  @JsonKey(name: 'statistics')
  final dynamic statistics;
  @JsonKey(name: 'last_conversion_error')
  final dynamic lastConversionError;
  @JsonKey(name: 'content')
  final ChapterContentResponseModel content;
  static const fromJsonFactory = _$ChapterWithContentResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ChapterWithContentResponseModel &&
            (identical(other.chapterId, chapterId) ||
                const DeepCollectionEquality()
                    .equals(other.chapterId, chapterId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.lastConversionDateUnix, lastConversionDateUnix) ||
                const DeepCollectionEquality().equals(
                    other.lastConversionDateUnix, lastConversionDateUnix)) &&
            (identical(other.conversionProgress, conversionProgress) ||
                const DeepCollectionEquality()
                    .equals(other.conversionProgress, conversionProgress)) &&
            (identical(other.canBeDownloaded, canBeDownloaded) ||
                const DeepCollectionEquality()
                    .equals(other.canBeDownloaded, canBeDownloaded)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.statistics, statistics) ||
                const DeepCollectionEquality()
                    .equals(other.statistics, statistics)) &&
            (identical(other.lastConversionError, lastConversionError) ||
                const DeepCollectionEquality()
                    .equals(other.lastConversionError, lastConversionError)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(chapterId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(lastConversionDateUnix) ^
      const DeepCollectionEquality().hash(conversionProgress) ^
      const DeepCollectionEquality().hash(canBeDownloaded) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(statistics) ^
      const DeepCollectionEquality().hash(lastConversionError) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $ChapterWithContentResponseModelExtension
    on ChapterWithContentResponseModel {
  ChapterWithContentResponseModel copyWith(
      {String? chapterId,
      String? name,
      dynamic lastConversionDateUnix,
      dynamic conversionProgress,
      bool? canBeDownloaded,
      enums.ChapterWithContentResponseModelState? state,
      dynamic statistics,
      dynamic lastConversionError,
      ChapterContentResponseModel? content}) {
    return ChapterWithContentResponseModel(
        chapterId: chapterId ?? this.chapterId,
        name: name ?? this.name,
        lastConversionDateUnix:
            lastConversionDateUnix ?? this.lastConversionDateUnix,
        conversionProgress: conversionProgress ?? this.conversionProgress,
        canBeDownloaded: canBeDownloaded ?? this.canBeDownloaded,
        state: state ?? this.state,
        statistics: statistics ?? this.statistics,
        lastConversionError: lastConversionError ?? this.lastConversionError,
        content: content ?? this.content);
  }

  ChapterWithContentResponseModel copyWithWrapped(
      {Wrapped<String>? chapterId,
      Wrapped<String>? name,
      Wrapped<dynamic>? lastConversionDateUnix,
      Wrapped<dynamic>? conversionProgress,
      Wrapped<bool>? canBeDownloaded,
      Wrapped<enums.ChapterWithContentResponseModelState>? state,
      Wrapped<dynamic>? statistics,
      Wrapped<dynamic>? lastConversionError,
      Wrapped<ChapterContentResponseModel>? content}) {
    return ChapterWithContentResponseModel(
        chapterId: (chapterId != null ? chapterId.value : this.chapterId),
        name: (name != null ? name.value : this.name),
        lastConversionDateUnix: (lastConversionDateUnix != null
            ? lastConversionDateUnix.value
            : this.lastConversionDateUnix),
        conversionProgress: (conversionProgress != null
            ? conversionProgress.value
            : this.conversionProgress),
        canBeDownloaded: (canBeDownloaded != null
            ? canBeDownloaded.value
            : this.canBeDownloaded),
        state: (state != null ? state.value : this.state),
        statistics: (statistics != null ? statistics.value : this.statistics),
        lastConversionError: (lastConversionError != null
            ? lastConversionError.value
            : this.lastConversionError),
        content: (content != null ? content.value : this.content));
  }
}

@JsonSerializable(explicitToJson: true)
class CharacterAlignmentModel {
  const CharacterAlignmentModel({
    required this.characters,
    required this.characterStartTimesSeconds,
    required this.characterEndTimesSeconds,
  });

  factory CharacterAlignmentModel.fromJson(Map<String, dynamic> json) =>
      _$CharacterAlignmentModelFromJson(json);

  static const toJsonFactory = _$CharacterAlignmentModelToJson;
  Map<String, dynamic> toJson() => _$CharacterAlignmentModelToJson(this);

  @JsonKey(name: 'characters', defaultValue: <String>[])
  final List<String> characters;
  @JsonKey(name: 'character_start_times_seconds', defaultValue: <double>[])
  final List<double> characterStartTimesSeconds;
  @JsonKey(name: 'character_end_times_seconds', defaultValue: <double>[])
  final List<double> characterEndTimesSeconds;
  static const fromJsonFactory = _$CharacterAlignmentModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CharacterAlignmentModel &&
            (identical(other.characters, characters) ||
                const DeepCollectionEquality()
                    .equals(other.characters, characters)) &&
            (identical(other.characterStartTimesSeconds,
                    characterStartTimesSeconds) ||
                const DeepCollectionEquality().equals(
                    other.characterStartTimesSeconds,
                    characterStartTimesSeconds)) &&
            (identical(
                    other.characterEndTimesSeconds, characterEndTimesSeconds) ||
                const DeepCollectionEquality().equals(
                    other.characterEndTimesSeconds, characterEndTimesSeconds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(characters) ^
      const DeepCollectionEquality().hash(characterStartTimesSeconds) ^
      const DeepCollectionEquality().hash(characterEndTimesSeconds) ^
      runtimeType.hashCode;
}

extension $CharacterAlignmentModelExtension on CharacterAlignmentModel {
  CharacterAlignmentModel copyWith(
      {List<String>? characters,
      List<double>? characterStartTimesSeconds,
      List<double>? characterEndTimesSeconds}) {
    return CharacterAlignmentModel(
        characters: characters ?? this.characters,
        characterStartTimesSeconds:
            characterStartTimesSeconds ?? this.characterStartTimesSeconds,
        characterEndTimesSeconds:
            characterEndTimesSeconds ?? this.characterEndTimesSeconds);
  }

  CharacterAlignmentModel copyWithWrapped(
      {Wrapped<List<String>>? characters,
      Wrapped<List<double>>? characterStartTimesSeconds,
      Wrapped<List<double>>? characterEndTimesSeconds}) {
    return CharacterAlignmentModel(
        characters: (characters != null ? characters.value : this.characters),
        characterStartTimesSeconds: (characterStartTimesSeconds != null
            ? characterStartTimesSeconds.value
            : this.characterStartTimesSeconds),
        characterEndTimesSeconds: (characterEndTimesSeconds != null
            ? characterEndTimesSeconds.value
            : this.characterEndTimesSeconds));
  }
}

@JsonSerializable(explicitToJson: true)
class CharacterAlignmentResponseModel {
  const CharacterAlignmentResponseModel({
    required this.characters,
    required this.characterStartTimesSeconds,
    required this.characterEndTimesSeconds,
  });

  factory CharacterAlignmentResponseModel.fromJson(Map<String, dynamic> json) =>
      _$CharacterAlignmentResponseModelFromJson(json);

  static const toJsonFactory = _$CharacterAlignmentResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$CharacterAlignmentResponseModelToJson(this);

  @JsonKey(name: 'characters', defaultValue: <String>[])
  final List<String> characters;
  @JsonKey(name: 'character_start_times_seconds', defaultValue: <double>[])
  final List<double> characterStartTimesSeconds;
  @JsonKey(name: 'character_end_times_seconds', defaultValue: <double>[])
  final List<double> characterEndTimesSeconds;
  static const fromJsonFactory = _$CharacterAlignmentResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CharacterAlignmentResponseModel &&
            (identical(other.characters, characters) ||
                const DeepCollectionEquality()
                    .equals(other.characters, characters)) &&
            (identical(other.characterStartTimesSeconds,
                    characterStartTimesSeconds) ||
                const DeepCollectionEquality().equals(
                    other.characterStartTimesSeconds,
                    characterStartTimesSeconds)) &&
            (identical(
                    other.characterEndTimesSeconds, characterEndTimesSeconds) ||
                const DeepCollectionEquality().equals(
                    other.characterEndTimesSeconds, characterEndTimesSeconds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(characters) ^
      const DeepCollectionEquality().hash(characterStartTimesSeconds) ^
      const DeepCollectionEquality().hash(characterEndTimesSeconds) ^
      runtimeType.hashCode;
}

extension $CharacterAlignmentResponseModelExtension
    on CharacterAlignmentResponseModel {
  CharacterAlignmentResponseModel copyWith(
      {List<String>? characters,
      List<double>? characterStartTimesSeconds,
      List<double>? characterEndTimesSeconds}) {
    return CharacterAlignmentResponseModel(
        characters: characters ?? this.characters,
        characterStartTimesSeconds:
            characterStartTimesSeconds ?? this.characterStartTimesSeconds,
        characterEndTimesSeconds:
            characterEndTimesSeconds ?? this.characterEndTimesSeconds);
  }

  CharacterAlignmentResponseModel copyWithWrapped(
      {Wrapped<List<String>>? characters,
      Wrapped<List<double>>? characterStartTimesSeconds,
      Wrapped<List<double>>? characterEndTimesSeconds}) {
    return CharacterAlignmentResponseModel(
        characters: (characters != null ? characters.value : this.characters),
        characterStartTimesSeconds: (characterStartTimesSeconds != null
            ? characterStartTimesSeconds.value
            : this.characterStartTimesSeconds),
        characterEndTimesSeconds: (characterEndTimesSeconds != null
            ? characterEndTimesSeconds.value
            : this.characterEndTimesSeconds));
  }
}

@JsonSerializable(explicitToJson: true)
class ClientToolConfigInput {
  const ClientToolConfigInput({
    this.id,
    required this.name,
    required this.description,
    this.responseTimeoutSecs,
    this.type,
    this.parameters,
    this.expectsResponse,
    this.dynamicVariables,
  });

  factory ClientToolConfigInput.fromJson(Map<String, dynamic> json) =>
      _$ClientToolConfigInputFromJson(json);

  static const toJsonFactory = _$ClientToolConfigInputToJson;
  Map<String, dynamic> toJson() => _$ClientToolConfigInputToJson(this);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'response_timeout_secs')
  final int? responseTimeoutSecs;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'parameters')
  final dynamic parameters;
  @JsonKey(name: 'expects_response', defaultValue: false)
  final bool? expectsResponse;
  @JsonKey(name: 'dynamic_variables')
  final DynamicVariablesConfig? dynamicVariables;
  static const fromJsonFactory = _$ClientToolConfigInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ClientToolConfigInput &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.responseTimeoutSecs, responseTimeoutSecs) ||
                const DeepCollectionEquality()
                    .equals(other.responseTimeoutSecs, responseTimeoutSecs)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)) &&
            (identical(other.expectsResponse, expectsResponse) ||
                const DeepCollectionEquality()
                    .equals(other.expectsResponse, expectsResponse)) &&
            (identical(other.dynamicVariables, dynamicVariables) ||
                const DeepCollectionEquality()
                    .equals(other.dynamicVariables, dynamicVariables)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(responseTimeoutSecs) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(parameters) ^
      const DeepCollectionEquality().hash(expectsResponse) ^
      const DeepCollectionEquality().hash(dynamicVariables) ^
      runtimeType.hashCode;
}

extension $ClientToolConfigInputExtension on ClientToolConfigInput {
  ClientToolConfigInput copyWith(
      {String? id,
      String? name,
      String? description,
      int? responseTimeoutSecs,
      String? type,
      dynamic parameters,
      bool? expectsResponse,
      DynamicVariablesConfig? dynamicVariables}) {
    return ClientToolConfigInput(
        id: id ?? this.id,
        name: name ?? this.name,
        description: description ?? this.description,
        responseTimeoutSecs: responseTimeoutSecs ?? this.responseTimeoutSecs,
        type: type ?? this.type,
        parameters: parameters ?? this.parameters,
        expectsResponse: expectsResponse ?? this.expectsResponse,
        dynamicVariables: dynamicVariables ?? this.dynamicVariables);
  }

  ClientToolConfigInput copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String>? name,
      Wrapped<String>? description,
      Wrapped<int?>? responseTimeoutSecs,
      Wrapped<String?>? type,
      Wrapped<dynamic>? parameters,
      Wrapped<bool?>? expectsResponse,
      Wrapped<DynamicVariablesConfig?>? dynamicVariables}) {
    return ClientToolConfigInput(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        responseTimeoutSecs: (responseTimeoutSecs != null
            ? responseTimeoutSecs.value
            : this.responseTimeoutSecs),
        type: (type != null ? type.value : this.type),
        parameters: (parameters != null ? parameters.value : this.parameters),
        expectsResponse: (expectsResponse != null
            ? expectsResponse.value
            : this.expectsResponse),
        dynamicVariables: (dynamicVariables != null
            ? dynamicVariables.value
            : this.dynamicVariables));
  }
}

@JsonSerializable(explicitToJson: true)
class ClientToolConfigOutput {
  const ClientToolConfigOutput({
    this.id,
    required this.name,
    required this.description,
    this.responseTimeoutSecs,
    this.type,
    this.parameters,
    this.expectsResponse,
    this.dynamicVariables,
  });

  factory ClientToolConfigOutput.fromJson(Map<String, dynamic> json) =>
      _$ClientToolConfigOutputFromJson(json);

  static const toJsonFactory = _$ClientToolConfigOutputToJson;
  Map<String, dynamic> toJson() => _$ClientToolConfigOutputToJson(this);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'response_timeout_secs')
  final int? responseTimeoutSecs;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'parameters')
  final dynamic parameters;
  @JsonKey(name: 'expects_response', defaultValue: false)
  final bool? expectsResponse;
  @JsonKey(name: 'dynamic_variables')
  final DynamicVariablesConfig? dynamicVariables;
  static const fromJsonFactory = _$ClientToolConfigOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ClientToolConfigOutput &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.responseTimeoutSecs, responseTimeoutSecs) ||
                const DeepCollectionEquality()
                    .equals(other.responseTimeoutSecs, responseTimeoutSecs)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)) &&
            (identical(other.expectsResponse, expectsResponse) ||
                const DeepCollectionEquality()
                    .equals(other.expectsResponse, expectsResponse)) &&
            (identical(other.dynamicVariables, dynamicVariables) ||
                const DeepCollectionEquality()
                    .equals(other.dynamicVariables, dynamicVariables)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(responseTimeoutSecs) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(parameters) ^
      const DeepCollectionEquality().hash(expectsResponse) ^
      const DeepCollectionEquality().hash(dynamicVariables) ^
      runtimeType.hashCode;
}

extension $ClientToolConfigOutputExtension on ClientToolConfigOutput {
  ClientToolConfigOutput copyWith(
      {String? id,
      String? name,
      String? description,
      int? responseTimeoutSecs,
      String? type,
      dynamic parameters,
      bool? expectsResponse,
      DynamicVariablesConfig? dynamicVariables}) {
    return ClientToolConfigOutput(
        id: id ?? this.id,
        name: name ?? this.name,
        description: description ?? this.description,
        responseTimeoutSecs: responseTimeoutSecs ?? this.responseTimeoutSecs,
        type: type ?? this.type,
        parameters: parameters ?? this.parameters,
        expectsResponse: expectsResponse ?? this.expectsResponse,
        dynamicVariables: dynamicVariables ?? this.dynamicVariables);
  }

  ClientToolConfigOutput copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String>? name,
      Wrapped<String>? description,
      Wrapped<int?>? responseTimeoutSecs,
      Wrapped<String?>? type,
      Wrapped<dynamic>? parameters,
      Wrapped<bool?>? expectsResponse,
      Wrapped<DynamicVariablesConfig?>? dynamicVariables}) {
    return ClientToolConfigOutput(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        responseTimeoutSecs: (responseTimeoutSecs != null
            ? responseTimeoutSecs.value
            : this.responseTimeoutSecs),
        type: (type != null ? type.value : this.type),
        parameters: (parameters != null ? parameters.value : this.parameters),
        expectsResponse: (expectsResponse != null
            ? expectsResponse.value
            : this.expectsResponse),
        dynamicVariables: (dynamicVariables != null
            ? dynamicVariables.value
            : this.dynamicVariables));
  }
}

@JsonSerializable(explicitToJson: true)
class ConvAIDynamicVariable {
  const ConvAIDynamicVariable({
    required this.variableName,
  });

  factory ConvAIDynamicVariable.fromJson(Map<String, dynamic> json) =>
      _$ConvAIDynamicVariableFromJson(json);

  static const toJsonFactory = _$ConvAIDynamicVariableToJson;
  Map<String, dynamic> toJson() => _$ConvAIDynamicVariableToJson(this);

  @JsonKey(name: 'variable_name')
  final String variableName;
  static const fromJsonFactory = _$ConvAIDynamicVariableFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConvAIDynamicVariable &&
            (identical(other.variableName, variableName) ||
                const DeepCollectionEquality()
                    .equals(other.variableName, variableName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(variableName) ^ runtimeType.hashCode;
}

extension $ConvAIDynamicVariableExtension on ConvAIDynamicVariable {
  ConvAIDynamicVariable copyWith({String? variableName}) {
    return ConvAIDynamicVariable(
        variableName: variableName ?? this.variableName);
  }

  ConvAIDynamicVariable copyWithWrapped({Wrapped<String>? variableName}) {
    return ConvAIDynamicVariable(
        variableName:
            (variableName != null ? variableName.value : this.variableName));
  }
}

@JsonSerializable(explicitToJson: true)
class ConvAISecretLocator {
  const ConvAISecretLocator({
    required this.secretId,
  });

  factory ConvAISecretLocator.fromJson(Map<String, dynamic> json) =>
      _$ConvAISecretLocatorFromJson(json);

  static const toJsonFactory = _$ConvAISecretLocatorToJson;
  Map<String, dynamic> toJson() => _$ConvAISecretLocatorToJson(this);

  @JsonKey(name: 'secret_id')
  final String secretId;
  static const fromJsonFactory = _$ConvAISecretLocatorFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConvAISecretLocator &&
            (identical(other.secretId, secretId) ||
                const DeepCollectionEquality()
                    .equals(other.secretId, secretId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(secretId) ^ runtimeType.hashCode;
}

extension $ConvAISecretLocatorExtension on ConvAISecretLocator {
  ConvAISecretLocator copyWith({String? secretId}) {
    return ConvAISecretLocator(secretId: secretId ?? this.secretId);
  }

  ConvAISecretLocator copyWithWrapped({Wrapped<String>? secretId}) {
    return ConvAISecretLocator(
        secretId: (secretId != null ? secretId.value : this.secretId));
  }
}

@JsonSerializable(explicitToJson: true)
class ConvAIStoredSecretDependencies {
  const ConvAIStoredSecretDependencies({
    required this.tools,
    required this.agentTools,
    required this.others,
    this.phoneNumbers,
  });

  factory ConvAIStoredSecretDependencies.fromJson(Map<String, dynamic> json) =>
      _$ConvAIStoredSecretDependenciesFromJson(json);

  static const toJsonFactory = _$ConvAIStoredSecretDependenciesToJson;
  Map<String, dynamic> toJson() => _$ConvAIStoredSecretDependenciesToJson(this);

  @JsonKey(name: 'tools', defaultValue: <Object>[])
  final List<Object> tools;
  @JsonKey(name: 'agent_tools', defaultValue: <Object>[])
  final List<Object> agentTools;
  @JsonKey(
    name: 'others',
    toJson: secretDependencyTypeListToJson,
    fromJson: secretDependencyTypeListFromJson,
  )
  final List<enums.SecretDependencyType> others;
  @JsonKey(
      name: 'phone_numbers', defaultValue: <DependentPhoneNumberIdentifier>[])
  final List<DependentPhoneNumberIdentifier>? phoneNumbers;
  static const fromJsonFactory = _$ConvAIStoredSecretDependenciesFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConvAIStoredSecretDependencies &&
            (identical(other.tools, tools) ||
                const DeepCollectionEquality().equals(other.tools, tools)) &&
            (identical(other.agentTools, agentTools) ||
                const DeepCollectionEquality()
                    .equals(other.agentTools, agentTools)) &&
            (identical(other.others, others) ||
                const DeepCollectionEquality().equals(other.others, others)) &&
            (identical(other.phoneNumbers, phoneNumbers) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumbers, phoneNumbers)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tools) ^
      const DeepCollectionEquality().hash(agentTools) ^
      const DeepCollectionEquality().hash(others) ^
      const DeepCollectionEquality().hash(phoneNumbers) ^
      runtimeType.hashCode;
}

extension $ConvAIStoredSecretDependenciesExtension
    on ConvAIStoredSecretDependencies {
  ConvAIStoredSecretDependencies copyWith(
      {List<Object>? tools,
      List<Object>? agentTools,
      List<enums.SecretDependencyType>? others,
      List<DependentPhoneNumberIdentifier>? phoneNumbers}) {
    return ConvAIStoredSecretDependencies(
        tools: tools ?? this.tools,
        agentTools: agentTools ?? this.agentTools,
        others: others ?? this.others,
        phoneNumbers: phoneNumbers ?? this.phoneNumbers);
  }

  ConvAIStoredSecretDependencies copyWithWrapped(
      {Wrapped<List<Object>>? tools,
      Wrapped<List<Object>>? agentTools,
      Wrapped<List<enums.SecretDependencyType>>? others,
      Wrapped<List<DependentPhoneNumberIdentifier>?>? phoneNumbers}) {
    return ConvAIStoredSecretDependencies(
        tools: (tools != null ? tools.value : this.tools),
        agentTools: (agentTools != null ? agentTools.value : this.agentTools),
        others: (others != null ? others.value : this.others),
        phoneNumbers:
            (phoneNumbers != null ? phoneNumbers.value : this.phoneNumbers));
  }
}

@JsonSerializable(explicitToJson: true)
class ConvAIWebhooks {
  const ConvAIWebhooks({
    this.postCallWebhookId,
  });

  factory ConvAIWebhooks.fromJson(Map<String, dynamic> json) =>
      _$ConvAIWebhooksFromJson(json);

  static const toJsonFactory = _$ConvAIWebhooksToJson;
  Map<String, dynamic> toJson() => _$ConvAIWebhooksToJson(this);

  @JsonKey(name: 'post_call_webhook_id')
  final dynamic postCallWebhookId;
  static const fromJsonFactory = _$ConvAIWebhooksFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConvAIWebhooks &&
            (identical(other.postCallWebhookId, postCallWebhookId) ||
                const DeepCollectionEquality()
                    .equals(other.postCallWebhookId, postCallWebhookId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(postCallWebhookId) ^
      runtimeType.hashCode;
}

extension $ConvAIWebhooksExtension on ConvAIWebhooks {
  ConvAIWebhooks copyWith({dynamic postCallWebhookId}) {
    return ConvAIWebhooks(
        postCallWebhookId: postCallWebhookId ?? this.postCallWebhookId);
  }

  ConvAIWebhooks copyWithWrapped({Wrapped<dynamic>? postCallWebhookId}) {
    return ConvAIWebhooks(
        postCallWebhookId: (postCallWebhookId != null
            ? postCallWebhookId.value
            : this.postCallWebhookId));
  }
}

@JsonSerializable(explicitToJson: true)
class ConvAIWorkspaceStoredSecretConfig {
  const ConvAIWorkspaceStoredSecretConfig({
    required this.type,
    required this.secretId,
    required this.name,
    required this.usedBy,
  });

  factory ConvAIWorkspaceStoredSecretConfig.fromJson(
          Map<String, dynamic> json) =>
      _$ConvAIWorkspaceStoredSecretConfigFromJson(json);

  static const toJsonFactory = _$ConvAIWorkspaceStoredSecretConfigToJson;
  Map<String, dynamic> toJson() =>
      _$ConvAIWorkspaceStoredSecretConfigToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'secret_id')
  final String secretId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'used_by')
  final ConvAIStoredSecretDependencies usedBy;
  static const fromJsonFactory = _$ConvAIWorkspaceStoredSecretConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConvAIWorkspaceStoredSecretConfig &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.secretId, secretId) ||
                const DeepCollectionEquality()
                    .equals(other.secretId, secretId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.usedBy, usedBy) ||
                const DeepCollectionEquality().equals(other.usedBy, usedBy)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(secretId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(usedBy) ^
      runtimeType.hashCode;
}

extension $ConvAIWorkspaceStoredSecretConfigExtension
    on ConvAIWorkspaceStoredSecretConfig {
  ConvAIWorkspaceStoredSecretConfig copyWith(
      {String? type,
      String? secretId,
      String? name,
      ConvAIStoredSecretDependencies? usedBy}) {
    return ConvAIWorkspaceStoredSecretConfig(
        type: type ?? this.type,
        secretId: secretId ?? this.secretId,
        name: name ?? this.name,
        usedBy: usedBy ?? this.usedBy);
  }

  ConvAIWorkspaceStoredSecretConfig copyWithWrapped(
      {Wrapped<String>? type,
      Wrapped<String>? secretId,
      Wrapped<String>? name,
      Wrapped<ConvAIStoredSecretDependencies>? usedBy}) {
    return ConvAIWorkspaceStoredSecretConfig(
        type: (type != null ? type.value : this.type),
        secretId: (secretId != null ? secretId.value : this.secretId),
        name: (name != null ? name.value : this.name),
        usedBy: (usedBy != null ? usedBy.value : this.usedBy));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationChargingCommonModel {
  const ConversationChargingCommonModel({
    this.devDiscount,
    this.tier,
    this.llmUsage,
    this.llmPrice,
  });

  factory ConversationChargingCommonModel.fromJson(Map<String, dynamic> json) =>
      _$ConversationChargingCommonModelFromJson(json);

  static const toJsonFactory = _$ConversationChargingCommonModelToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationChargingCommonModelToJson(this);

  @JsonKey(name: 'dev_discount', defaultValue: false)
  final bool? devDiscount;
  @JsonKey(name: 'tier')
  final dynamic tier;
  @JsonKey(name: 'llm_usage')
  final LLMCategoryUsage? llmUsage;
  @JsonKey(name: 'llm_price')
  final dynamic llmPrice;
  static const fromJsonFactory = _$ConversationChargingCommonModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationChargingCommonModel &&
            (identical(other.devDiscount, devDiscount) ||
                const DeepCollectionEquality()
                    .equals(other.devDiscount, devDiscount)) &&
            (identical(other.tier, tier) ||
                const DeepCollectionEquality().equals(other.tier, tier)) &&
            (identical(other.llmUsage, llmUsage) ||
                const DeepCollectionEquality()
                    .equals(other.llmUsage, llmUsage)) &&
            (identical(other.llmPrice, llmPrice) ||
                const DeepCollectionEquality()
                    .equals(other.llmPrice, llmPrice)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(devDiscount) ^
      const DeepCollectionEquality().hash(tier) ^
      const DeepCollectionEquality().hash(llmUsage) ^
      const DeepCollectionEquality().hash(llmPrice) ^
      runtimeType.hashCode;
}

extension $ConversationChargingCommonModelExtension
    on ConversationChargingCommonModel {
  ConversationChargingCommonModel copyWith(
      {bool? devDiscount,
      dynamic tier,
      LLMCategoryUsage? llmUsage,
      dynamic llmPrice}) {
    return ConversationChargingCommonModel(
        devDiscount: devDiscount ?? this.devDiscount,
        tier: tier ?? this.tier,
        llmUsage: llmUsage ?? this.llmUsage,
        llmPrice: llmPrice ?? this.llmPrice);
  }

  ConversationChargingCommonModel copyWithWrapped(
      {Wrapped<bool?>? devDiscount,
      Wrapped<dynamic>? tier,
      Wrapped<LLMCategoryUsage?>? llmUsage,
      Wrapped<dynamic>? llmPrice}) {
    return ConversationChargingCommonModel(
        devDiscount:
            (devDiscount != null ? devDiscount.value : this.devDiscount),
        tier: (tier != null ? tier.value : this.tier),
        llmUsage: (llmUsage != null ? llmUsage.value : this.llmUsage),
        llmPrice: (llmPrice != null ? llmPrice.value : this.llmPrice));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationConfig {
  const ConversationConfig({
    this.textOnly,
    this.maxDurationSeconds,
    this.clientEvents,
  });

  factory ConversationConfig.fromJson(Map<String, dynamic> json) =>
      _$ConversationConfigFromJson(json);

  static const toJsonFactory = _$ConversationConfigToJson;
  Map<String, dynamic> toJson() => _$ConversationConfigToJson(this);

  @JsonKey(name: 'text_only', defaultValue: false)
  final bool? textOnly;
  @JsonKey(name: 'max_duration_seconds')
  final int? maxDurationSeconds;
  @JsonKey(
    name: 'client_events',
    toJson: clientEventListToJson,
    fromJson: clientEventListFromJson,
  )
  final List<enums.ClientEvent>? clientEvents;
  static const fromJsonFactory = _$ConversationConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationConfig &&
            (identical(other.textOnly, textOnly) ||
                const DeepCollectionEquality()
                    .equals(other.textOnly, textOnly)) &&
            (identical(other.maxDurationSeconds, maxDurationSeconds) ||
                const DeepCollectionEquality()
                    .equals(other.maxDurationSeconds, maxDurationSeconds)) &&
            (identical(other.clientEvents, clientEvents) ||
                const DeepCollectionEquality()
                    .equals(other.clientEvents, clientEvents)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(textOnly) ^
      const DeepCollectionEquality().hash(maxDurationSeconds) ^
      const DeepCollectionEquality().hash(clientEvents) ^
      runtimeType.hashCode;
}

extension $ConversationConfigExtension on ConversationConfig {
  ConversationConfig copyWith(
      {bool? textOnly,
      int? maxDurationSeconds,
      List<enums.ClientEvent>? clientEvents}) {
    return ConversationConfig(
        textOnly: textOnly ?? this.textOnly,
        maxDurationSeconds: maxDurationSeconds ?? this.maxDurationSeconds,
        clientEvents: clientEvents ?? this.clientEvents);
  }

  ConversationConfig copyWithWrapped(
      {Wrapped<bool?>? textOnly,
      Wrapped<int?>? maxDurationSeconds,
      Wrapped<List<enums.ClientEvent>?>? clientEvents}) {
    return ConversationConfig(
        textOnly: (textOnly != null ? textOnly.value : this.textOnly),
        maxDurationSeconds: (maxDurationSeconds != null
            ? maxDurationSeconds.value
            : this.maxDurationSeconds),
        clientEvents:
            (clientEvents != null ? clientEvents.value : this.clientEvents));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationConfigClientOverrideInput {
  const ConversationConfigClientOverrideInput({
    this.tts,
    this.conversation,
    this.agent,
  });

  factory ConversationConfigClientOverrideInput.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationConfigClientOverrideInputFromJson(json);

  static const toJsonFactory = _$ConversationConfigClientOverrideInputToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationConfigClientOverrideInputToJson(this);

  @JsonKey(name: 'tts')
  final dynamic tts;
  @JsonKey(name: 'conversation')
  final dynamic conversation;
  @JsonKey(name: 'agent')
  final dynamic agent;
  static const fromJsonFactory =
      _$ConversationConfigClientOverrideInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationConfigClientOverrideInput &&
            (identical(other.tts, tts) ||
                const DeepCollectionEquality().equals(other.tts, tts)) &&
            (identical(other.conversation, conversation) ||
                const DeepCollectionEquality()
                    .equals(other.conversation, conversation)) &&
            (identical(other.agent, agent) ||
                const DeepCollectionEquality().equals(other.agent, agent)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tts) ^
      const DeepCollectionEquality().hash(conversation) ^
      const DeepCollectionEquality().hash(agent) ^
      runtimeType.hashCode;
}

extension $ConversationConfigClientOverrideInputExtension
    on ConversationConfigClientOverrideInput {
  ConversationConfigClientOverrideInput copyWith(
      {dynamic tts, dynamic conversation, dynamic agent}) {
    return ConversationConfigClientOverrideInput(
        tts: tts ?? this.tts,
        conversation: conversation ?? this.conversation,
        agent: agent ?? this.agent);
  }

  ConversationConfigClientOverrideInput copyWithWrapped(
      {Wrapped<dynamic>? tts,
      Wrapped<dynamic>? conversation,
      Wrapped<dynamic>? agent}) {
    return ConversationConfigClientOverrideInput(
        tts: (tts != null ? tts.value : this.tts),
        conversation:
            (conversation != null ? conversation.value : this.conversation),
        agent: (agent != null ? agent.value : this.agent));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationConfigClientOverrideOutput {
  const ConversationConfigClientOverrideOutput({
    this.tts,
    this.conversation,
    this.agent,
  });

  factory ConversationConfigClientOverrideOutput.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationConfigClientOverrideOutputFromJson(json);

  static const toJsonFactory = _$ConversationConfigClientOverrideOutputToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationConfigClientOverrideOutputToJson(this);

  @JsonKey(name: 'tts')
  final dynamic tts;
  @JsonKey(name: 'conversation')
  final dynamic conversation;
  @JsonKey(name: 'agent')
  final dynamic agent;
  static const fromJsonFactory =
      _$ConversationConfigClientOverrideOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationConfigClientOverrideOutput &&
            (identical(other.tts, tts) ||
                const DeepCollectionEquality().equals(other.tts, tts)) &&
            (identical(other.conversation, conversation) ||
                const DeepCollectionEquality()
                    .equals(other.conversation, conversation)) &&
            (identical(other.agent, agent) ||
                const DeepCollectionEquality().equals(other.agent, agent)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tts) ^
      const DeepCollectionEquality().hash(conversation) ^
      const DeepCollectionEquality().hash(agent) ^
      runtimeType.hashCode;
}

extension $ConversationConfigClientOverrideOutputExtension
    on ConversationConfigClientOverrideOutput {
  ConversationConfigClientOverrideOutput copyWith(
      {dynamic tts, dynamic conversation, dynamic agent}) {
    return ConversationConfigClientOverrideOutput(
        tts: tts ?? this.tts,
        conversation: conversation ?? this.conversation,
        agent: agent ?? this.agent);
  }

  ConversationConfigClientOverrideOutput copyWithWrapped(
      {Wrapped<dynamic>? tts,
      Wrapped<dynamic>? conversation,
      Wrapped<dynamic>? agent}) {
    return ConversationConfigClientOverrideOutput(
        tts: (tts != null ? tts.value : this.tts),
        conversation:
            (conversation != null ? conversation.value : this.conversation),
        agent: (agent != null ? agent.value : this.agent));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationConfigClientOverrideConfigInput {
  const ConversationConfigClientOverrideConfigInput({
    this.tts,
    this.conversation,
    this.agent,
  });

  factory ConversationConfigClientOverrideConfigInput.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationConfigClientOverrideConfigInputFromJson(json);

  static const toJsonFactory =
      _$ConversationConfigClientOverrideConfigInputToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationConfigClientOverrideConfigInputToJson(this);

  @JsonKey(name: 'tts')
  final TTSConversationalConfigOverrideConfig? tts;
  @JsonKey(name: 'conversation')
  final ConversationConfigOverrideConfig? conversation;
  @JsonKey(name: 'agent')
  final AgentConfigOverrideConfig? agent;
  static const fromJsonFactory =
      _$ConversationConfigClientOverrideConfigInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationConfigClientOverrideConfigInput &&
            (identical(other.tts, tts) ||
                const DeepCollectionEquality().equals(other.tts, tts)) &&
            (identical(other.conversation, conversation) ||
                const DeepCollectionEquality()
                    .equals(other.conversation, conversation)) &&
            (identical(other.agent, agent) ||
                const DeepCollectionEquality().equals(other.agent, agent)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tts) ^
      const DeepCollectionEquality().hash(conversation) ^
      const DeepCollectionEquality().hash(agent) ^
      runtimeType.hashCode;
}

extension $ConversationConfigClientOverrideConfigInputExtension
    on ConversationConfigClientOverrideConfigInput {
  ConversationConfigClientOverrideConfigInput copyWith(
      {TTSConversationalConfigOverrideConfig? tts,
      ConversationConfigOverrideConfig? conversation,
      AgentConfigOverrideConfig? agent}) {
    return ConversationConfigClientOverrideConfigInput(
        tts: tts ?? this.tts,
        conversation: conversation ?? this.conversation,
        agent: agent ?? this.agent);
  }

  ConversationConfigClientOverrideConfigInput copyWithWrapped(
      {Wrapped<TTSConversationalConfigOverrideConfig?>? tts,
      Wrapped<ConversationConfigOverrideConfig?>? conversation,
      Wrapped<AgentConfigOverrideConfig?>? agent}) {
    return ConversationConfigClientOverrideConfigInput(
        tts: (tts != null ? tts.value : this.tts),
        conversation:
            (conversation != null ? conversation.value : this.conversation),
        agent: (agent != null ? agent.value : this.agent));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationConfigClientOverrideConfigOutput {
  const ConversationConfigClientOverrideConfigOutput({
    this.tts,
    this.conversation,
    this.agent,
  });

  factory ConversationConfigClientOverrideConfigOutput.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationConfigClientOverrideConfigOutputFromJson(json);

  static const toJsonFactory =
      _$ConversationConfigClientOverrideConfigOutputToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationConfigClientOverrideConfigOutputToJson(this);

  @JsonKey(name: 'tts')
  final TTSConversationalConfigOverrideConfig? tts;
  @JsonKey(name: 'conversation')
  final ConversationConfigOverrideConfig? conversation;
  @JsonKey(name: 'agent')
  final AgentConfigOverrideConfig? agent;
  static const fromJsonFactory =
      _$ConversationConfigClientOverrideConfigOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationConfigClientOverrideConfigOutput &&
            (identical(other.tts, tts) ||
                const DeepCollectionEquality().equals(other.tts, tts)) &&
            (identical(other.conversation, conversation) ||
                const DeepCollectionEquality()
                    .equals(other.conversation, conversation)) &&
            (identical(other.agent, agent) ||
                const DeepCollectionEquality().equals(other.agent, agent)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tts) ^
      const DeepCollectionEquality().hash(conversation) ^
      const DeepCollectionEquality().hash(agent) ^
      runtimeType.hashCode;
}

extension $ConversationConfigClientOverrideConfigOutputExtension
    on ConversationConfigClientOverrideConfigOutput {
  ConversationConfigClientOverrideConfigOutput copyWith(
      {TTSConversationalConfigOverrideConfig? tts,
      ConversationConfigOverrideConfig? conversation,
      AgentConfigOverrideConfig? agent}) {
    return ConversationConfigClientOverrideConfigOutput(
        tts: tts ?? this.tts,
        conversation: conversation ?? this.conversation,
        agent: agent ?? this.agent);
  }

  ConversationConfigClientOverrideConfigOutput copyWithWrapped(
      {Wrapped<TTSConversationalConfigOverrideConfig?>? tts,
      Wrapped<ConversationConfigOverrideConfig?>? conversation,
      Wrapped<AgentConfigOverrideConfig?>? agent}) {
    return ConversationConfigClientOverrideConfigOutput(
        tts: (tts != null ? tts.value : this.tts),
        conversation:
            (conversation != null ? conversation.value : this.conversation),
        agent: (agent != null ? agent.value : this.agent));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationConfigOverride {
  const ConversationConfigOverride({
    this.textOnly,
  });

  factory ConversationConfigOverride.fromJson(Map<String, dynamic> json) =>
      _$ConversationConfigOverrideFromJson(json);

  static const toJsonFactory = _$ConversationConfigOverrideToJson;
  Map<String, dynamic> toJson() => _$ConversationConfigOverrideToJson(this);

  @JsonKey(name: 'text_only')
  final dynamic textOnly;
  static const fromJsonFactory = _$ConversationConfigOverrideFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationConfigOverride &&
            (identical(other.textOnly, textOnly) ||
                const DeepCollectionEquality()
                    .equals(other.textOnly, textOnly)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(textOnly) ^ runtimeType.hashCode;
}

extension $ConversationConfigOverrideExtension on ConversationConfigOverride {
  ConversationConfigOverride copyWith({dynamic textOnly}) {
    return ConversationConfigOverride(textOnly: textOnly ?? this.textOnly);
  }

  ConversationConfigOverride copyWithWrapped({Wrapped<dynamic>? textOnly}) {
    return ConversationConfigOverride(
        textOnly: (textOnly != null ? textOnly.value : this.textOnly));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationConfigOverrideConfig {
  const ConversationConfigOverrideConfig({
    this.textOnly,
  });

  factory ConversationConfigOverrideConfig.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationConfigOverrideConfigFromJson(json);

  static const toJsonFactory = _$ConversationConfigOverrideConfigToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationConfigOverrideConfigToJson(this);

  @JsonKey(name: 'text_only', defaultValue: false)
  final bool? textOnly;
  static const fromJsonFactory = _$ConversationConfigOverrideConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationConfigOverrideConfig &&
            (identical(other.textOnly, textOnly) ||
                const DeepCollectionEquality()
                    .equals(other.textOnly, textOnly)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(textOnly) ^ runtimeType.hashCode;
}

extension $ConversationConfigOverrideConfigExtension
    on ConversationConfigOverrideConfig {
  ConversationConfigOverrideConfig copyWith({bool? textOnly}) {
    return ConversationConfigOverrideConfig(
        textOnly: textOnly ?? this.textOnly);
  }

  ConversationConfigOverrideConfig copyWithWrapped({Wrapped<bool?>? textOnly}) {
    return ConversationConfigOverrideConfig(
        textOnly: (textOnly != null ? textOnly.value : this.textOnly));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationDeletionSettings {
  const ConversationDeletionSettings({
    this.deletionTimeUnixSecs,
    this.deletedLogsAtTimeUnixSecs,
    this.deletedAudioAtTimeUnixSecs,
    this.deletedTranscriptAtTimeUnixSecs,
    this.deleteTranscriptAndPii,
    this.deleteAudio,
  });

  factory ConversationDeletionSettings.fromJson(Map<String, dynamic> json) =>
      _$ConversationDeletionSettingsFromJson(json);

  static const toJsonFactory = _$ConversationDeletionSettingsToJson;
  Map<String, dynamic> toJson() => _$ConversationDeletionSettingsToJson(this);

  @JsonKey(name: 'deletion_time_unix_secs')
  final dynamic deletionTimeUnixSecs;
  @JsonKey(name: 'deleted_logs_at_time_unix_secs')
  final dynamic deletedLogsAtTimeUnixSecs;
  @JsonKey(name: 'deleted_audio_at_time_unix_secs')
  final dynamic deletedAudioAtTimeUnixSecs;
  @JsonKey(name: 'deleted_transcript_at_time_unix_secs')
  final dynamic deletedTranscriptAtTimeUnixSecs;
  @JsonKey(name: 'delete_transcript_and_pii', defaultValue: false)
  final bool? deleteTranscriptAndPii;
  @JsonKey(name: 'delete_audio', defaultValue: false)
  final bool? deleteAudio;
  static const fromJsonFactory = _$ConversationDeletionSettingsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationDeletionSettings &&
            (identical(other.deletionTimeUnixSecs, deletionTimeUnixSecs) ||
                const DeepCollectionEquality().equals(
                    other.deletionTimeUnixSecs, deletionTimeUnixSecs)) &&
            (identical(other.deletedLogsAtTimeUnixSecs,
                    deletedLogsAtTimeUnixSecs) ||
                const DeepCollectionEquality().equals(
                    other.deletedLogsAtTimeUnixSecs,
                    deletedLogsAtTimeUnixSecs)) &&
            (identical(other.deletedAudioAtTimeUnixSecs,
                    deletedAudioAtTimeUnixSecs) ||
                const DeepCollectionEquality().equals(
                    other.deletedAudioAtTimeUnixSecs,
                    deletedAudioAtTimeUnixSecs)) &&
            (identical(other.deletedTranscriptAtTimeUnixSecs,
                    deletedTranscriptAtTimeUnixSecs) ||
                const DeepCollectionEquality().equals(
                    other.deletedTranscriptAtTimeUnixSecs,
                    deletedTranscriptAtTimeUnixSecs)) &&
            (identical(other.deleteTranscriptAndPii, deleteTranscriptAndPii) ||
                const DeepCollectionEquality().equals(
                    other.deleteTranscriptAndPii, deleteTranscriptAndPii)) &&
            (identical(other.deleteAudio, deleteAudio) ||
                const DeepCollectionEquality()
                    .equals(other.deleteAudio, deleteAudio)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(deletionTimeUnixSecs) ^
      const DeepCollectionEquality().hash(deletedLogsAtTimeUnixSecs) ^
      const DeepCollectionEquality().hash(deletedAudioAtTimeUnixSecs) ^
      const DeepCollectionEquality().hash(deletedTranscriptAtTimeUnixSecs) ^
      const DeepCollectionEquality().hash(deleteTranscriptAndPii) ^
      const DeepCollectionEquality().hash(deleteAudio) ^
      runtimeType.hashCode;
}

extension $ConversationDeletionSettingsExtension
    on ConversationDeletionSettings {
  ConversationDeletionSettings copyWith(
      {dynamic deletionTimeUnixSecs,
      dynamic deletedLogsAtTimeUnixSecs,
      dynamic deletedAudioAtTimeUnixSecs,
      dynamic deletedTranscriptAtTimeUnixSecs,
      bool? deleteTranscriptAndPii,
      bool? deleteAudio}) {
    return ConversationDeletionSettings(
        deletionTimeUnixSecs: deletionTimeUnixSecs ?? this.deletionTimeUnixSecs,
        deletedLogsAtTimeUnixSecs:
            deletedLogsAtTimeUnixSecs ?? this.deletedLogsAtTimeUnixSecs,
        deletedAudioAtTimeUnixSecs:
            deletedAudioAtTimeUnixSecs ?? this.deletedAudioAtTimeUnixSecs,
        deletedTranscriptAtTimeUnixSecs: deletedTranscriptAtTimeUnixSecs ??
            this.deletedTranscriptAtTimeUnixSecs,
        deleteTranscriptAndPii:
            deleteTranscriptAndPii ?? this.deleteTranscriptAndPii,
        deleteAudio: deleteAudio ?? this.deleteAudio);
  }

  ConversationDeletionSettings copyWithWrapped(
      {Wrapped<dynamic>? deletionTimeUnixSecs,
      Wrapped<dynamic>? deletedLogsAtTimeUnixSecs,
      Wrapped<dynamic>? deletedAudioAtTimeUnixSecs,
      Wrapped<dynamic>? deletedTranscriptAtTimeUnixSecs,
      Wrapped<bool?>? deleteTranscriptAndPii,
      Wrapped<bool?>? deleteAudio}) {
    return ConversationDeletionSettings(
        deletionTimeUnixSecs: (deletionTimeUnixSecs != null
            ? deletionTimeUnixSecs.value
            : this.deletionTimeUnixSecs),
        deletedLogsAtTimeUnixSecs: (deletedLogsAtTimeUnixSecs != null
            ? deletedLogsAtTimeUnixSecs.value
            : this.deletedLogsAtTimeUnixSecs),
        deletedAudioAtTimeUnixSecs: (deletedAudioAtTimeUnixSecs != null
            ? deletedAudioAtTimeUnixSecs.value
            : this.deletedAudioAtTimeUnixSecs),
        deletedTranscriptAtTimeUnixSecs:
            (deletedTranscriptAtTimeUnixSecs != null
                ? deletedTranscriptAtTimeUnixSecs.value
                : this.deletedTranscriptAtTimeUnixSecs),
        deleteTranscriptAndPii: (deleteTranscriptAndPii != null
            ? deleteTranscriptAndPii.value
            : this.deleteTranscriptAndPii),
        deleteAudio:
            (deleteAudio != null ? deleteAudio.value : this.deleteAudio));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationHistoryAnalysisCommonModel {
  const ConversationHistoryAnalysisCommonModel({
    this.evaluationCriteriaResults,
    this.dataCollectionResults,
    required this.callSuccessful,
    required this.transcriptSummary,
  });

  factory ConversationHistoryAnalysisCommonModel.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationHistoryAnalysisCommonModelFromJson(json);

  static const toJsonFactory = _$ConversationHistoryAnalysisCommonModelToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationHistoryAnalysisCommonModelToJson(this);

  @JsonKey(name: 'evaluation_criteria_results')
  final Map<String, dynamic>? evaluationCriteriaResults;
  @JsonKey(name: 'data_collection_results')
  final Map<String, dynamic>? dataCollectionResults;
  @JsonKey(
    name: 'call_successful',
    toJson: evaluationSuccessResultToJson,
    fromJson: evaluationSuccessResultFromJson,
  )
  final enums.EvaluationSuccessResult callSuccessful;
  @JsonKey(name: 'transcript_summary')
  final String transcriptSummary;
  static const fromJsonFactory =
      _$ConversationHistoryAnalysisCommonModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationHistoryAnalysisCommonModel &&
            (identical(other.evaluationCriteriaResults,
                    evaluationCriteriaResults) ||
                const DeepCollectionEquality().equals(
                    other.evaluationCriteriaResults,
                    evaluationCriteriaResults)) &&
            (identical(other.dataCollectionResults, dataCollectionResults) ||
                const DeepCollectionEquality().equals(
                    other.dataCollectionResults, dataCollectionResults)) &&
            (identical(other.callSuccessful, callSuccessful) ||
                const DeepCollectionEquality()
                    .equals(other.callSuccessful, callSuccessful)) &&
            (identical(other.transcriptSummary, transcriptSummary) ||
                const DeepCollectionEquality()
                    .equals(other.transcriptSummary, transcriptSummary)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(evaluationCriteriaResults) ^
      const DeepCollectionEquality().hash(dataCollectionResults) ^
      const DeepCollectionEquality().hash(callSuccessful) ^
      const DeepCollectionEquality().hash(transcriptSummary) ^
      runtimeType.hashCode;
}

extension $ConversationHistoryAnalysisCommonModelExtension
    on ConversationHistoryAnalysisCommonModel {
  ConversationHistoryAnalysisCommonModel copyWith(
      {Map<String, dynamic>? evaluationCriteriaResults,
      Map<String, dynamic>? dataCollectionResults,
      enums.EvaluationSuccessResult? callSuccessful,
      String? transcriptSummary}) {
    return ConversationHistoryAnalysisCommonModel(
        evaluationCriteriaResults:
            evaluationCriteriaResults ?? this.evaluationCriteriaResults,
        dataCollectionResults:
            dataCollectionResults ?? this.dataCollectionResults,
        callSuccessful: callSuccessful ?? this.callSuccessful,
        transcriptSummary: transcriptSummary ?? this.transcriptSummary);
  }

  ConversationHistoryAnalysisCommonModel copyWithWrapped(
      {Wrapped<Map<String, dynamic>?>? evaluationCriteriaResults,
      Wrapped<Map<String, dynamic>?>? dataCollectionResults,
      Wrapped<enums.EvaluationSuccessResult>? callSuccessful,
      Wrapped<String>? transcriptSummary}) {
    return ConversationHistoryAnalysisCommonModel(
        evaluationCriteriaResults: (evaluationCriteriaResults != null
            ? evaluationCriteriaResults.value
            : this.evaluationCriteriaResults),
        dataCollectionResults: (dataCollectionResults != null
            ? dataCollectionResults.value
            : this.dataCollectionResults),
        callSuccessful: (callSuccessful != null
            ? callSuccessful.value
            : this.callSuccessful),
        transcriptSummary: (transcriptSummary != null
            ? transcriptSummary.value
            : this.transcriptSummary));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationHistoryBatchCallModel {
  const ConversationHistoryBatchCallModel({
    required this.batchCallId,
    required this.batchCallRecipientId,
  });

  factory ConversationHistoryBatchCallModel.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationHistoryBatchCallModelFromJson(json);

  static const toJsonFactory = _$ConversationHistoryBatchCallModelToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationHistoryBatchCallModelToJson(this);

  @JsonKey(name: 'batch_call_id')
  final String batchCallId;
  @JsonKey(name: 'batch_call_recipient_id')
  final String batchCallRecipientId;
  static const fromJsonFactory = _$ConversationHistoryBatchCallModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationHistoryBatchCallModel &&
            (identical(other.batchCallId, batchCallId) ||
                const DeepCollectionEquality()
                    .equals(other.batchCallId, batchCallId)) &&
            (identical(other.batchCallRecipientId, batchCallRecipientId) ||
                const DeepCollectionEquality()
                    .equals(other.batchCallRecipientId, batchCallRecipientId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(batchCallId) ^
      const DeepCollectionEquality().hash(batchCallRecipientId) ^
      runtimeType.hashCode;
}

extension $ConversationHistoryBatchCallModelExtension
    on ConversationHistoryBatchCallModel {
  ConversationHistoryBatchCallModel copyWith(
      {String? batchCallId, String? batchCallRecipientId}) {
    return ConversationHistoryBatchCallModel(
        batchCallId: batchCallId ?? this.batchCallId,
        batchCallRecipientId:
            batchCallRecipientId ?? this.batchCallRecipientId);
  }

  ConversationHistoryBatchCallModel copyWithWrapped(
      {Wrapped<String>? batchCallId, Wrapped<String>? batchCallRecipientId}) {
    return ConversationHistoryBatchCallModel(
        batchCallId:
            (batchCallId != null ? batchCallId.value : this.batchCallId),
        batchCallRecipientId: (batchCallRecipientId != null
            ? batchCallRecipientId.value
            : this.batchCallRecipientId));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationHistoryErrorCommonModel {
  const ConversationHistoryErrorCommonModel({
    required this.code,
    this.reason,
  });

  factory ConversationHistoryErrorCommonModel.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationHistoryErrorCommonModelFromJson(json);

  static const toJsonFactory = _$ConversationHistoryErrorCommonModelToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationHistoryErrorCommonModelToJson(this);

  @JsonKey(name: 'code')
  final int code;
  @JsonKey(name: 'reason')
  final dynamic reason;
  static const fromJsonFactory = _$ConversationHistoryErrorCommonModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationHistoryErrorCommonModel &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)) &&
            (identical(other.reason, reason) ||
                const DeepCollectionEquality().equals(other.reason, reason)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(code) ^
      const DeepCollectionEquality().hash(reason) ^
      runtimeType.hashCode;
}

extension $ConversationHistoryErrorCommonModelExtension
    on ConversationHistoryErrorCommonModel {
  ConversationHistoryErrorCommonModel copyWith({int? code, dynamic reason}) {
    return ConversationHistoryErrorCommonModel(
        code: code ?? this.code, reason: reason ?? this.reason);
  }

  ConversationHistoryErrorCommonModel copyWithWrapped(
      {Wrapped<int>? code, Wrapped<dynamic>? reason}) {
    return ConversationHistoryErrorCommonModel(
        code: (code != null ? code.value : this.code),
        reason: (reason != null ? reason.value : this.reason));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationHistoryEvaluationCriteriaResultCommonModel {
  const ConversationHistoryEvaluationCriteriaResultCommonModel({
    required this.criteriaId,
    required this.result,
    required this.rationale,
  });

  factory ConversationHistoryEvaluationCriteriaResultCommonModel.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationHistoryEvaluationCriteriaResultCommonModelFromJson(json);

  static const toJsonFactory =
      _$ConversationHistoryEvaluationCriteriaResultCommonModelToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationHistoryEvaluationCriteriaResultCommonModelToJson(this);

  @JsonKey(name: 'criteria_id')
  final String criteriaId;
  @JsonKey(
    name: 'result',
    toJson: evaluationSuccessResultToJson,
    fromJson: evaluationSuccessResultFromJson,
  )
  final enums.EvaluationSuccessResult result;
  @JsonKey(name: 'rationale')
  final String rationale;
  static const fromJsonFactory =
      _$ConversationHistoryEvaluationCriteriaResultCommonModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationHistoryEvaluationCriteriaResultCommonModel &&
            (identical(other.criteriaId, criteriaId) ||
                const DeepCollectionEquality()
                    .equals(other.criteriaId, criteriaId)) &&
            (identical(other.result, result) ||
                const DeepCollectionEquality().equals(other.result, result)) &&
            (identical(other.rationale, rationale) ||
                const DeepCollectionEquality()
                    .equals(other.rationale, rationale)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(criteriaId) ^
      const DeepCollectionEquality().hash(result) ^
      const DeepCollectionEquality().hash(rationale) ^
      runtimeType.hashCode;
}

extension $ConversationHistoryEvaluationCriteriaResultCommonModelExtension
    on ConversationHistoryEvaluationCriteriaResultCommonModel {
  ConversationHistoryEvaluationCriteriaResultCommonModel copyWith(
      {String? criteriaId,
      enums.EvaluationSuccessResult? result,
      String? rationale}) {
    return ConversationHistoryEvaluationCriteriaResultCommonModel(
        criteriaId: criteriaId ?? this.criteriaId,
        result: result ?? this.result,
        rationale: rationale ?? this.rationale);
  }

  ConversationHistoryEvaluationCriteriaResultCommonModel copyWithWrapped(
      {Wrapped<String>? criteriaId,
      Wrapped<enums.EvaluationSuccessResult>? result,
      Wrapped<String>? rationale}) {
    return ConversationHistoryEvaluationCriteriaResultCommonModel(
        criteriaId: (criteriaId != null ? criteriaId.value : this.criteriaId),
        result: (result != null ? result.value : this.result),
        rationale: (rationale != null ? rationale.value : this.rationale));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationHistoryFeedbackCommonModel {
  const ConversationHistoryFeedbackCommonModel({
    this.overallScore,
    this.likes,
    this.dislikes,
  });

  factory ConversationHistoryFeedbackCommonModel.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationHistoryFeedbackCommonModelFromJson(json);

  static const toJsonFactory = _$ConversationHistoryFeedbackCommonModelToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationHistoryFeedbackCommonModelToJson(this);

  @JsonKey(name: 'overall_score')
  final dynamic overallScore;
  @JsonKey(name: 'likes')
  final int? likes;
  @JsonKey(name: 'dislikes')
  final int? dislikes;
  static const fromJsonFactory =
      _$ConversationHistoryFeedbackCommonModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationHistoryFeedbackCommonModel &&
            (identical(other.overallScore, overallScore) ||
                const DeepCollectionEquality()
                    .equals(other.overallScore, overallScore)) &&
            (identical(other.likes, likes) ||
                const DeepCollectionEquality().equals(other.likes, likes)) &&
            (identical(other.dislikes, dislikes) ||
                const DeepCollectionEquality()
                    .equals(other.dislikes, dislikes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(overallScore) ^
      const DeepCollectionEquality().hash(likes) ^
      const DeepCollectionEquality().hash(dislikes) ^
      runtimeType.hashCode;
}

extension $ConversationHistoryFeedbackCommonModelExtension
    on ConversationHistoryFeedbackCommonModel {
  ConversationHistoryFeedbackCommonModel copyWith(
      {dynamic overallScore, int? likes, int? dislikes}) {
    return ConversationHistoryFeedbackCommonModel(
        overallScore: overallScore ?? this.overallScore,
        likes: likes ?? this.likes,
        dislikes: dislikes ?? this.dislikes);
  }

  ConversationHistoryFeedbackCommonModel copyWithWrapped(
      {Wrapped<dynamic>? overallScore,
      Wrapped<int?>? likes,
      Wrapped<int?>? dislikes}) {
    return ConversationHistoryFeedbackCommonModel(
        overallScore:
            (overallScore != null ? overallScore.value : this.overallScore),
        likes: (likes != null ? likes.value : this.likes),
        dislikes: (dislikes != null ? dislikes.value : this.dislikes));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationHistoryMetadataCommonModel {
  const ConversationHistoryMetadataCommonModel({
    required this.startTimeUnixSecs,
    this.acceptedTimeUnixSecs,
    required this.callDurationSecs,
    this.cost,
    this.deletionSettings,
    this.feedback,
    this.authorizationMethod,
    this.charging,
    this.phoneCall,
    this.batchCall,
    this.terminationReason,
    this.error,
    this.mainLanguage,
    this.ragUsage,
    this.textOnly,
  });

  factory ConversationHistoryMetadataCommonModel.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationHistoryMetadataCommonModelFromJson(json);

  static const toJsonFactory = _$ConversationHistoryMetadataCommonModelToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationHistoryMetadataCommonModelToJson(this);

  @JsonKey(name: 'start_time_unix_secs')
  final int startTimeUnixSecs;
  @JsonKey(name: 'accepted_time_unix_secs')
  final dynamic acceptedTimeUnixSecs;
  @JsonKey(name: 'call_duration_secs')
  final int callDurationSecs;
  @JsonKey(name: 'cost')
  final dynamic cost;
  @JsonKey(name: 'deletion_settings')
  final ConversationDeletionSettings? deletionSettings;
  @JsonKey(name: 'feedback')
  final ConversationHistoryFeedbackCommonModel? feedback;
  @JsonKey(
    name: 'authorization_method',
    toJson: authorizationMethodNullableToJson,
    fromJson: authorizationMethodAuthorizationMethodNullableFromJson,
  )
  final enums.AuthorizationMethod? authorizationMethod;
  static enums.AuthorizationMethod?
      authorizationMethodAuthorizationMethodNullableFromJson(Object? value) =>
          authorizationMethodNullableFromJson(
              value, enums.AuthorizationMethod.public);

  @JsonKey(name: 'charging')
  final ConversationChargingCommonModel? charging;
  @JsonKey(name: 'phone_call')
  final dynamic phoneCall;
  @JsonKey(name: 'batch_call')
  final dynamic batchCall;
  @JsonKey(name: 'termination_reason')
  final String? terminationReason;
  @JsonKey(name: 'error')
  final dynamic error;
  @JsonKey(name: 'main_language')
  final dynamic mainLanguage;
  @JsonKey(name: 'rag_usage')
  final dynamic ragUsage;
  @JsonKey(name: 'text_only', defaultValue: false)
  final bool? textOnly;
  static const fromJsonFactory =
      _$ConversationHistoryMetadataCommonModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationHistoryMetadataCommonModel &&
            (identical(other.startTimeUnixSecs, startTimeUnixSecs) ||
                const DeepCollectionEquality()
                    .equals(other.startTimeUnixSecs, startTimeUnixSecs)) &&
            (identical(other.acceptedTimeUnixSecs, acceptedTimeUnixSecs) ||
                const DeepCollectionEquality().equals(
                    other.acceptedTimeUnixSecs, acceptedTimeUnixSecs)) &&
            (identical(other.callDurationSecs, callDurationSecs) ||
                const DeepCollectionEquality()
                    .equals(other.callDurationSecs, callDurationSecs)) &&
            (identical(other.cost, cost) ||
                const DeepCollectionEquality().equals(other.cost, cost)) &&
            (identical(other.deletionSettings, deletionSettings) ||
                const DeepCollectionEquality()
                    .equals(other.deletionSettings, deletionSettings)) &&
            (identical(other.feedback, feedback) ||
                const DeepCollectionEquality()
                    .equals(other.feedback, feedback)) &&
            (identical(other.authorizationMethod, authorizationMethod) ||
                const DeepCollectionEquality()
                    .equals(other.authorizationMethod, authorizationMethod)) &&
            (identical(other.charging, charging) ||
                const DeepCollectionEquality()
                    .equals(other.charging, charging)) &&
            (identical(other.phoneCall, phoneCall) ||
                const DeepCollectionEquality()
                    .equals(other.phoneCall, phoneCall)) &&
            (identical(other.batchCall, batchCall) ||
                const DeepCollectionEquality()
                    .equals(other.batchCall, batchCall)) &&
            (identical(other.terminationReason, terminationReason) ||
                const DeepCollectionEquality()
                    .equals(other.terminationReason, terminationReason)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)) &&
            (identical(other.mainLanguage, mainLanguage) ||
                const DeepCollectionEquality()
                    .equals(other.mainLanguage, mainLanguage)) &&
            (identical(other.ragUsage, ragUsage) ||
                const DeepCollectionEquality()
                    .equals(other.ragUsage, ragUsage)) &&
            (identical(other.textOnly, textOnly) ||
                const DeepCollectionEquality()
                    .equals(other.textOnly, textOnly)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(startTimeUnixSecs) ^
      const DeepCollectionEquality().hash(acceptedTimeUnixSecs) ^
      const DeepCollectionEquality().hash(callDurationSecs) ^
      const DeepCollectionEquality().hash(cost) ^
      const DeepCollectionEquality().hash(deletionSettings) ^
      const DeepCollectionEquality().hash(feedback) ^
      const DeepCollectionEquality().hash(authorizationMethod) ^
      const DeepCollectionEquality().hash(charging) ^
      const DeepCollectionEquality().hash(phoneCall) ^
      const DeepCollectionEquality().hash(batchCall) ^
      const DeepCollectionEquality().hash(terminationReason) ^
      const DeepCollectionEquality().hash(error) ^
      const DeepCollectionEquality().hash(mainLanguage) ^
      const DeepCollectionEquality().hash(ragUsage) ^
      const DeepCollectionEquality().hash(textOnly) ^
      runtimeType.hashCode;
}

extension $ConversationHistoryMetadataCommonModelExtension
    on ConversationHistoryMetadataCommonModel {
  ConversationHistoryMetadataCommonModel copyWith(
      {int? startTimeUnixSecs,
      dynamic acceptedTimeUnixSecs,
      int? callDurationSecs,
      dynamic cost,
      ConversationDeletionSettings? deletionSettings,
      ConversationHistoryFeedbackCommonModel? feedback,
      enums.AuthorizationMethod? authorizationMethod,
      ConversationChargingCommonModel? charging,
      dynamic phoneCall,
      dynamic batchCall,
      String? terminationReason,
      dynamic error,
      dynamic mainLanguage,
      dynamic ragUsage,
      bool? textOnly}) {
    return ConversationHistoryMetadataCommonModel(
        startTimeUnixSecs: startTimeUnixSecs ?? this.startTimeUnixSecs,
        acceptedTimeUnixSecs: acceptedTimeUnixSecs ?? this.acceptedTimeUnixSecs,
        callDurationSecs: callDurationSecs ?? this.callDurationSecs,
        cost: cost ?? this.cost,
        deletionSettings: deletionSettings ?? this.deletionSettings,
        feedback: feedback ?? this.feedback,
        authorizationMethod: authorizationMethod ?? this.authorizationMethod,
        charging: charging ?? this.charging,
        phoneCall: phoneCall ?? this.phoneCall,
        batchCall: batchCall ?? this.batchCall,
        terminationReason: terminationReason ?? this.terminationReason,
        error: error ?? this.error,
        mainLanguage: mainLanguage ?? this.mainLanguage,
        ragUsage: ragUsage ?? this.ragUsage,
        textOnly: textOnly ?? this.textOnly);
  }

  ConversationHistoryMetadataCommonModel copyWithWrapped(
      {Wrapped<int>? startTimeUnixSecs,
      Wrapped<dynamic>? acceptedTimeUnixSecs,
      Wrapped<int>? callDurationSecs,
      Wrapped<dynamic>? cost,
      Wrapped<ConversationDeletionSettings?>? deletionSettings,
      Wrapped<ConversationHistoryFeedbackCommonModel?>? feedback,
      Wrapped<enums.AuthorizationMethod?>? authorizationMethod,
      Wrapped<ConversationChargingCommonModel?>? charging,
      Wrapped<dynamic>? phoneCall,
      Wrapped<dynamic>? batchCall,
      Wrapped<String?>? terminationReason,
      Wrapped<dynamic>? error,
      Wrapped<dynamic>? mainLanguage,
      Wrapped<dynamic>? ragUsage,
      Wrapped<bool?>? textOnly}) {
    return ConversationHistoryMetadataCommonModel(
        startTimeUnixSecs: (startTimeUnixSecs != null
            ? startTimeUnixSecs.value
            : this.startTimeUnixSecs),
        acceptedTimeUnixSecs: (acceptedTimeUnixSecs != null
            ? acceptedTimeUnixSecs.value
            : this.acceptedTimeUnixSecs),
        callDurationSecs: (callDurationSecs != null
            ? callDurationSecs.value
            : this.callDurationSecs),
        cost: (cost != null ? cost.value : this.cost),
        deletionSettings: (deletionSettings != null
            ? deletionSettings.value
            : this.deletionSettings),
        feedback: (feedback != null ? feedback.value : this.feedback),
        authorizationMethod: (authorizationMethod != null
            ? authorizationMethod.value
            : this.authorizationMethod),
        charging: (charging != null ? charging.value : this.charging),
        phoneCall: (phoneCall != null ? phoneCall.value : this.phoneCall),
        batchCall: (batchCall != null ? batchCall.value : this.batchCall),
        terminationReason: (terminationReason != null
            ? terminationReason.value
            : this.terminationReason),
        error: (error != null ? error.value : this.error),
        mainLanguage:
            (mainLanguage != null ? mainLanguage.value : this.mainLanguage),
        ragUsage: (ragUsage != null ? ragUsage.value : this.ragUsage),
        textOnly: (textOnly != null ? textOnly.value : this.textOnly));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationHistoryRagUsageCommonModel {
  const ConversationHistoryRagUsageCommonModel({
    required this.usageCount,
    required this.embeddingModel,
  });

  factory ConversationHistoryRagUsageCommonModel.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationHistoryRagUsageCommonModelFromJson(json);

  static const toJsonFactory = _$ConversationHistoryRagUsageCommonModelToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationHistoryRagUsageCommonModelToJson(this);

  @JsonKey(name: 'usage_count')
  final int usageCount;
  @JsonKey(name: 'embedding_model')
  final String embeddingModel;
  static const fromJsonFactory =
      _$ConversationHistoryRagUsageCommonModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationHistoryRagUsageCommonModel &&
            (identical(other.usageCount, usageCount) ||
                const DeepCollectionEquality()
                    .equals(other.usageCount, usageCount)) &&
            (identical(other.embeddingModel, embeddingModel) ||
                const DeepCollectionEquality()
                    .equals(other.embeddingModel, embeddingModel)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(usageCount) ^
      const DeepCollectionEquality().hash(embeddingModel) ^
      runtimeType.hashCode;
}

extension $ConversationHistoryRagUsageCommonModelExtension
    on ConversationHistoryRagUsageCommonModel {
  ConversationHistoryRagUsageCommonModel copyWith(
      {int? usageCount, String? embeddingModel}) {
    return ConversationHistoryRagUsageCommonModel(
        usageCount: usageCount ?? this.usageCount,
        embeddingModel: embeddingModel ?? this.embeddingModel);
  }

  ConversationHistoryRagUsageCommonModel copyWithWrapped(
      {Wrapped<int>? usageCount, Wrapped<String>? embeddingModel}) {
    return ConversationHistoryRagUsageCommonModel(
        usageCount: (usageCount != null ? usageCount.value : this.usageCount),
        embeddingModel: (embeddingModel != null
            ? embeddingModel.value
            : this.embeddingModel));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationHistorySIPTrunkingPhoneCallModel {
  const ConversationHistorySIPTrunkingPhoneCallModel({
    required this.direction,
    required this.phoneNumberId,
    required this.agentNumber,
    required this.externalNumber,
    required this.type,
    required this.callSid,
  });

  factory ConversationHistorySIPTrunkingPhoneCallModel.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationHistorySIPTrunkingPhoneCallModelFromJson(json);

  static const toJsonFactory =
      _$ConversationHistorySIPTrunkingPhoneCallModelToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationHistorySIPTrunkingPhoneCallModelToJson(this);

  @JsonKey(
    name: 'direction',
    toJson: conversationHistorySIPTrunkingPhoneCallModelDirectionToJson,
    fromJson: conversationHistorySIPTrunkingPhoneCallModelDirectionFromJson,
  )
  final enums.ConversationHistorySIPTrunkingPhoneCallModelDirection direction;
  @JsonKey(name: 'phone_number_id')
  final String phoneNumberId;
  @JsonKey(name: 'agent_number')
  final String agentNumber;
  @JsonKey(name: 'external_number')
  final String externalNumber;
  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'call_sid')
  final String callSid;
  static const fromJsonFactory =
      _$ConversationHistorySIPTrunkingPhoneCallModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationHistorySIPTrunkingPhoneCallModel &&
            (identical(other.direction, direction) ||
                const DeepCollectionEquality()
                    .equals(other.direction, direction)) &&
            (identical(other.phoneNumberId, phoneNumberId) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumberId, phoneNumberId)) &&
            (identical(other.agentNumber, agentNumber) ||
                const DeepCollectionEquality()
                    .equals(other.agentNumber, agentNumber)) &&
            (identical(other.externalNumber, externalNumber) ||
                const DeepCollectionEquality()
                    .equals(other.externalNumber, externalNumber)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.callSid, callSid) ||
                const DeepCollectionEquality().equals(other.callSid, callSid)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(direction) ^
      const DeepCollectionEquality().hash(phoneNumberId) ^
      const DeepCollectionEquality().hash(agentNumber) ^
      const DeepCollectionEquality().hash(externalNumber) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(callSid) ^
      runtimeType.hashCode;
}

extension $ConversationHistorySIPTrunkingPhoneCallModelExtension
    on ConversationHistorySIPTrunkingPhoneCallModel {
  ConversationHistorySIPTrunkingPhoneCallModel copyWith(
      {enums.ConversationHistorySIPTrunkingPhoneCallModelDirection? direction,
      String? phoneNumberId,
      String? agentNumber,
      String? externalNumber,
      String? type,
      String? callSid}) {
    return ConversationHistorySIPTrunkingPhoneCallModel(
        direction: direction ?? this.direction,
        phoneNumberId: phoneNumberId ?? this.phoneNumberId,
        agentNumber: agentNumber ?? this.agentNumber,
        externalNumber: externalNumber ?? this.externalNumber,
        type: type ?? this.type,
        callSid: callSid ?? this.callSid);
  }

  ConversationHistorySIPTrunkingPhoneCallModel copyWithWrapped(
      {Wrapped<enums.ConversationHistorySIPTrunkingPhoneCallModelDirection>?
          direction,
      Wrapped<String>? phoneNumberId,
      Wrapped<String>? agentNumber,
      Wrapped<String>? externalNumber,
      Wrapped<String>? type,
      Wrapped<String>? callSid}) {
    return ConversationHistorySIPTrunkingPhoneCallModel(
        direction: (direction != null ? direction.value : this.direction),
        phoneNumberId:
            (phoneNumberId != null ? phoneNumberId.value : this.phoneNumberId),
        agentNumber:
            (agentNumber != null ? agentNumber.value : this.agentNumber),
        externalNumber: (externalNumber != null
            ? externalNumber.value
            : this.externalNumber),
        type: (type != null ? type.value : this.type),
        callSid: (callSid != null ? callSid.value : this.callSid));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationHistoryTranscriptCommonModelInput {
  const ConversationHistoryTranscriptCommonModelInput({
    required this.role,
    this.message,
    this.toolCalls,
    this.toolResults,
    this.feedback,
    this.llmOverride,
    this.sourceMedium,
    required this.timeInCallSecs,
    this.conversationTurnMetrics,
    this.ragRetrievalInfo,
    this.llmUsage,
    this.interrupted,
    this.originalMessage,
  });

  factory ConversationHistoryTranscriptCommonModelInput.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationHistoryTranscriptCommonModelInputFromJson(json);

  static const toJsonFactory =
      _$ConversationHistoryTranscriptCommonModelInputToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationHistoryTranscriptCommonModelInputToJson(this);

  @JsonKey(
    name: 'role',
    toJson: conversationHistoryTranscriptCommonModelInputRoleToJson,
    fromJson: conversationHistoryTranscriptCommonModelInputRoleFromJson,
  )
  final enums.ConversationHistoryTranscriptCommonModelInputRole role;
  @JsonKey(name: 'message')
  final dynamic message;
  @JsonKey(
      name: 'tool_calls',
      defaultValue: <ConversationHistoryTranscriptToolCallCommonModel>[])
  final List<ConversationHistoryTranscriptToolCallCommonModel>? toolCalls;
  @JsonKey(
      name: 'tool_results',
      defaultValue: <ConversationHistoryTranscriptToolResultCommonModel>[])
  final List<ConversationHistoryTranscriptToolResultCommonModel>? toolResults;
  @JsonKey(name: 'feedback')
  final dynamic feedback;
  @JsonKey(name: 'llm_override')
  final dynamic llmOverride;
  @JsonKey(name: 'source_medium')
  final dynamic sourceMedium;
  @JsonKey(name: 'time_in_call_secs')
  final int timeInCallSecs;
  @JsonKey(name: 'conversation_turn_metrics')
  final dynamic conversationTurnMetrics;
  @JsonKey(name: 'rag_retrieval_info')
  final dynamic ragRetrievalInfo;
  @JsonKey(name: 'llm_usage')
  final dynamic llmUsage;
  @JsonKey(name: 'interrupted', defaultValue: false)
  final bool? interrupted;
  @JsonKey(name: 'original_message')
  final dynamic originalMessage;
  static const fromJsonFactory =
      _$ConversationHistoryTranscriptCommonModelInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationHistoryTranscriptCommonModelInput &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.toolCalls, toolCalls) ||
                const DeepCollectionEquality()
                    .equals(other.toolCalls, toolCalls)) &&
            (identical(other.toolResults, toolResults) ||
                const DeepCollectionEquality()
                    .equals(other.toolResults, toolResults)) &&
            (identical(other.feedback, feedback) ||
                const DeepCollectionEquality()
                    .equals(other.feedback, feedback)) &&
            (identical(other.llmOverride, llmOverride) ||
                const DeepCollectionEquality()
                    .equals(other.llmOverride, llmOverride)) &&
            (identical(other.sourceMedium, sourceMedium) ||
                const DeepCollectionEquality()
                    .equals(other.sourceMedium, sourceMedium)) &&
            (identical(other.timeInCallSecs, timeInCallSecs) ||
                const DeepCollectionEquality()
                    .equals(other.timeInCallSecs, timeInCallSecs)) &&
            (identical(
                    other.conversationTurnMetrics, conversationTurnMetrics) ||
                const DeepCollectionEquality().equals(
                    other.conversationTurnMetrics, conversationTurnMetrics)) &&
            (identical(other.ragRetrievalInfo, ragRetrievalInfo) ||
                const DeepCollectionEquality()
                    .equals(other.ragRetrievalInfo, ragRetrievalInfo)) &&
            (identical(other.llmUsage, llmUsage) ||
                const DeepCollectionEquality()
                    .equals(other.llmUsage, llmUsage)) &&
            (identical(other.interrupted, interrupted) ||
                const DeepCollectionEquality()
                    .equals(other.interrupted, interrupted)) &&
            (identical(other.originalMessage, originalMessage) ||
                const DeepCollectionEquality()
                    .equals(other.originalMessage, originalMessage)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(role) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(toolCalls) ^
      const DeepCollectionEquality().hash(toolResults) ^
      const DeepCollectionEquality().hash(feedback) ^
      const DeepCollectionEquality().hash(llmOverride) ^
      const DeepCollectionEquality().hash(sourceMedium) ^
      const DeepCollectionEquality().hash(timeInCallSecs) ^
      const DeepCollectionEquality().hash(conversationTurnMetrics) ^
      const DeepCollectionEquality().hash(ragRetrievalInfo) ^
      const DeepCollectionEquality().hash(llmUsage) ^
      const DeepCollectionEquality().hash(interrupted) ^
      const DeepCollectionEquality().hash(originalMessage) ^
      runtimeType.hashCode;
}

extension $ConversationHistoryTranscriptCommonModelInputExtension
    on ConversationHistoryTranscriptCommonModelInput {
  ConversationHistoryTranscriptCommonModelInput copyWith(
      {enums.ConversationHistoryTranscriptCommonModelInputRole? role,
      dynamic message,
      List<ConversationHistoryTranscriptToolCallCommonModel>? toolCalls,
      List<ConversationHistoryTranscriptToolResultCommonModel>? toolResults,
      dynamic feedback,
      dynamic llmOverride,
      dynamic sourceMedium,
      int? timeInCallSecs,
      dynamic conversationTurnMetrics,
      dynamic ragRetrievalInfo,
      dynamic llmUsage,
      bool? interrupted,
      dynamic originalMessage}) {
    return ConversationHistoryTranscriptCommonModelInput(
        role: role ?? this.role,
        message: message ?? this.message,
        toolCalls: toolCalls ?? this.toolCalls,
        toolResults: toolResults ?? this.toolResults,
        feedback: feedback ?? this.feedback,
        llmOverride: llmOverride ?? this.llmOverride,
        sourceMedium: sourceMedium ?? this.sourceMedium,
        timeInCallSecs: timeInCallSecs ?? this.timeInCallSecs,
        conversationTurnMetrics:
            conversationTurnMetrics ?? this.conversationTurnMetrics,
        ragRetrievalInfo: ragRetrievalInfo ?? this.ragRetrievalInfo,
        llmUsage: llmUsage ?? this.llmUsage,
        interrupted: interrupted ?? this.interrupted,
        originalMessage: originalMessage ?? this.originalMessage);
  }

  ConversationHistoryTranscriptCommonModelInput copyWithWrapped(
      {Wrapped<enums.ConversationHistoryTranscriptCommonModelInputRole>? role,
      Wrapped<dynamic>? message,
      Wrapped<List<ConversationHistoryTranscriptToolCallCommonModel>?>?
          toolCalls,
      Wrapped<List<ConversationHistoryTranscriptToolResultCommonModel>?>?
          toolResults,
      Wrapped<dynamic>? feedback,
      Wrapped<dynamic>? llmOverride,
      Wrapped<dynamic>? sourceMedium,
      Wrapped<int>? timeInCallSecs,
      Wrapped<dynamic>? conversationTurnMetrics,
      Wrapped<dynamic>? ragRetrievalInfo,
      Wrapped<dynamic>? llmUsage,
      Wrapped<bool?>? interrupted,
      Wrapped<dynamic>? originalMessage}) {
    return ConversationHistoryTranscriptCommonModelInput(
        role: (role != null ? role.value : this.role),
        message: (message != null ? message.value : this.message),
        toolCalls: (toolCalls != null ? toolCalls.value : this.toolCalls),
        toolResults:
            (toolResults != null ? toolResults.value : this.toolResults),
        feedback: (feedback != null ? feedback.value : this.feedback),
        llmOverride:
            (llmOverride != null ? llmOverride.value : this.llmOverride),
        sourceMedium:
            (sourceMedium != null ? sourceMedium.value : this.sourceMedium),
        timeInCallSecs: (timeInCallSecs != null
            ? timeInCallSecs.value
            : this.timeInCallSecs),
        conversationTurnMetrics: (conversationTurnMetrics != null
            ? conversationTurnMetrics.value
            : this.conversationTurnMetrics),
        ragRetrievalInfo: (ragRetrievalInfo != null
            ? ragRetrievalInfo.value
            : this.ragRetrievalInfo),
        llmUsage: (llmUsage != null ? llmUsage.value : this.llmUsage),
        interrupted:
            (interrupted != null ? interrupted.value : this.interrupted),
        originalMessage: (originalMessage != null
            ? originalMessage.value
            : this.originalMessage));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationHistoryTranscriptCommonModelOutput {
  const ConversationHistoryTranscriptCommonModelOutput({
    required this.role,
    this.message,
    this.toolCalls,
    this.toolResults,
    this.feedback,
    this.llmOverride,
    this.sourceMedium,
    required this.timeInCallSecs,
    this.conversationTurnMetrics,
    this.ragRetrievalInfo,
    this.llmUsage,
    this.interrupted,
    this.originalMessage,
  });

  factory ConversationHistoryTranscriptCommonModelOutput.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationHistoryTranscriptCommonModelOutputFromJson(json);

  static const toJsonFactory =
      _$ConversationHistoryTranscriptCommonModelOutputToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationHistoryTranscriptCommonModelOutputToJson(this);

  @JsonKey(
    name: 'role',
    toJson: conversationHistoryTranscriptCommonModelOutputRoleToJson,
    fromJson: conversationHistoryTranscriptCommonModelOutputRoleFromJson,
  )
  final enums.ConversationHistoryTranscriptCommonModelOutputRole role;
  @JsonKey(name: 'message')
  final dynamic message;
  @JsonKey(
      name: 'tool_calls',
      defaultValue: <ConversationHistoryTranscriptToolCallCommonModel>[])
  final List<ConversationHistoryTranscriptToolCallCommonModel>? toolCalls;
  @JsonKey(
      name: 'tool_results',
      defaultValue: <ConversationHistoryTranscriptToolResultCommonModel>[])
  final List<ConversationHistoryTranscriptToolResultCommonModel>? toolResults;
  @JsonKey(name: 'feedback')
  final dynamic feedback;
  @JsonKey(name: 'llm_override')
  final dynamic llmOverride;
  @JsonKey(name: 'source_medium')
  final dynamic sourceMedium;
  @JsonKey(name: 'time_in_call_secs')
  final int timeInCallSecs;
  @JsonKey(name: 'conversation_turn_metrics')
  final dynamic conversationTurnMetrics;
  @JsonKey(name: 'rag_retrieval_info')
  final dynamic ragRetrievalInfo;
  @JsonKey(name: 'llm_usage')
  final dynamic llmUsage;
  @JsonKey(name: 'interrupted', defaultValue: false)
  final bool? interrupted;
  @JsonKey(name: 'original_message')
  final dynamic originalMessage;
  static const fromJsonFactory =
      _$ConversationHistoryTranscriptCommonModelOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationHistoryTranscriptCommonModelOutput &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.toolCalls, toolCalls) ||
                const DeepCollectionEquality()
                    .equals(other.toolCalls, toolCalls)) &&
            (identical(other.toolResults, toolResults) ||
                const DeepCollectionEquality()
                    .equals(other.toolResults, toolResults)) &&
            (identical(other.feedback, feedback) ||
                const DeepCollectionEquality()
                    .equals(other.feedback, feedback)) &&
            (identical(other.llmOverride, llmOverride) ||
                const DeepCollectionEquality()
                    .equals(other.llmOverride, llmOverride)) &&
            (identical(other.sourceMedium, sourceMedium) ||
                const DeepCollectionEquality()
                    .equals(other.sourceMedium, sourceMedium)) &&
            (identical(other.timeInCallSecs, timeInCallSecs) ||
                const DeepCollectionEquality()
                    .equals(other.timeInCallSecs, timeInCallSecs)) &&
            (identical(
                    other.conversationTurnMetrics, conversationTurnMetrics) ||
                const DeepCollectionEquality().equals(
                    other.conversationTurnMetrics, conversationTurnMetrics)) &&
            (identical(other.ragRetrievalInfo, ragRetrievalInfo) ||
                const DeepCollectionEquality()
                    .equals(other.ragRetrievalInfo, ragRetrievalInfo)) &&
            (identical(other.llmUsage, llmUsage) ||
                const DeepCollectionEquality()
                    .equals(other.llmUsage, llmUsage)) &&
            (identical(other.interrupted, interrupted) ||
                const DeepCollectionEquality()
                    .equals(other.interrupted, interrupted)) &&
            (identical(other.originalMessage, originalMessage) ||
                const DeepCollectionEquality()
                    .equals(other.originalMessage, originalMessage)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(role) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(toolCalls) ^
      const DeepCollectionEquality().hash(toolResults) ^
      const DeepCollectionEquality().hash(feedback) ^
      const DeepCollectionEquality().hash(llmOverride) ^
      const DeepCollectionEquality().hash(sourceMedium) ^
      const DeepCollectionEquality().hash(timeInCallSecs) ^
      const DeepCollectionEquality().hash(conversationTurnMetrics) ^
      const DeepCollectionEquality().hash(ragRetrievalInfo) ^
      const DeepCollectionEquality().hash(llmUsage) ^
      const DeepCollectionEquality().hash(interrupted) ^
      const DeepCollectionEquality().hash(originalMessage) ^
      runtimeType.hashCode;
}

extension $ConversationHistoryTranscriptCommonModelOutputExtension
    on ConversationHistoryTranscriptCommonModelOutput {
  ConversationHistoryTranscriptCommonModelOutput copyWith(
      {enums.ConversationHistoryTranscriptCommonModelOutputRole? role,
      dynamic message,
      List<ConversationHistoryTranscriptToolCallCommonModel>? toolCalls,
      List<ConversationHistoryTranscriptToolResultCommonModel>? toolResults,
      dynamic feedback,
      dynamic llmOverride,
      dynamic sourceMedium,
      int? timeInCallSecs,
      dynamic conversationTurnMetrics,
      dynamic ragRetrievalInfo,
      dynamic llmUsage,
      bool? interrupted,
      dynamic originalMessage}) {
    return ConversationHistoryTranscriptCommonModelOutput(
        role: role ?? this.role,
        message: message ?? this.message,
        toolCalls: toolCalls ?? this.toolCalls,
        toolResults: toolResults ?? this.toolResults,
        feedback: feedback ?? this.feedback,
        llmOverride: llmOverride ?? this.llmOverride,
        sourceMedium: sourceMedium ?? this.sourceMedium,
        timeInCallSecs: timeInCallSecs ?? this.timeInCallSecs,
        conversationTurnMetrics:
            conversationTurnMetrics ?? this.conversationTurnMetrics,
        ragRetrievalInfo: ragRetrievalInfo ?? this.ragRetrievalInfo,
        llmUsage: llmUsage ?? this.llmUsage,
        interrupted: interrupted ?? this.interrupted,
        originalMessage: originalMessage ?? this.originalMessage);
  }

  ConversationHistoryTranscriptCommonModelOutput copyWithWrapped(
      {Wrapped<enums.ConversationHistoryTranscriptCommonModelOutputRole>? role,
      Wrapped<dynamic>? message,
      Wrapped<List<ConversationHistoryTranscriptToolCallCommonModel>?>?
          toolCalls,
      Wrapped<List<ConversationHistoryTranscriptToolResultCommonModel>?>?
          toolResults,
      Wrapped<dynamic>? feedback,
      Wrapped<dynamic>? llmOverride,
      Wrapped<dynamic>? sourceMedium,
      Wrapped<int>? timeInCallSecs,
      Wrapped<dynamic>? conversationTurnMetrics,
      Wrapped<dynamic>? ragRetrievalInfo,
      Wrapped<dynamic>? llmUsage,
      Wrapped<bool?>? interrupted,
      Wrapped<dynamic>? originalMessage}) {
    return ConversationHistoryTranscriptCommonModelOutput(
        role: (role != null ? role.value : this.role),
        message: (message != null ? message.value : this.message),
        toolCalls: (toolCalls != null ? toolCalls.value : this.toolCalls),
        toolResults:
            (toolResults != null ? toolResults.value : this.toolResults),
        feedback: (feedback != null ? feedback.value : this.feedback),
        llmOverride:
            (llmOverride != null ? llmOverride.value : this.llmOverride),
        sourceMedium:
            (sourceMedium != null ? sourceMedium.value : this.sourceMedium),
        timeInCallSecs: (timeInCallSecs != null
            ? timeInCallSecs.value
            : this.timeInCallSecs),
        conversationTurnMetrics: (conversationTurnMetrics != null
            ? conversationTurnMetrics.value
            : this.conversationTurnMetrics),
        ragRetrievalInfo: (ragRetrievalInfo != null
            ? ragRetrievalInfo.value
            : this.ragRetrievalInfo),
        llmUsage: (llmUsage != null ? llmUsage.value : this.llmUsage),
        interrupted:
            (interrupted != null ? interrupted.value : this.interrupted),
        originalMessage: (originalMessage != null
            ? originalMessage.value
            : this.originalMessage));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationHistoryTranscriptToolCallClientDetails {
  const ConversationHistoryTranscriptToolCallClientDetails({
    this.type,
    required this.parameters,
  });

  factory ConversationHistoryTranscriptToolCallClientDetails.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationHistoryTranscriptToolCallClientDetailsFromJson(json);

  static const toJsonFactory =
      _$ConversationHistoryTranscriptToolCallClientDetailsToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationHistoryTranscriptToolCallClientDetailsToJson(this);

  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'parameters')
  final String parameters;
  static const fromJsonFactory =
      _$ConversationHistoryTranscriptToolCallClientDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationHistoryTranscriptToolCallClientDetails &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(parameters) ^
      runtimeType.hashCode;
}

extension $ConversationHistoryTranscriptToolCallClientDetailsExtension
    on ConversationHistoryTranscriptToolCallClientDetails {
  ConversationHistoryTranscriptToolCallClientDetails copyWith(
      {String? type, String? parameters}) {
    return ConversationHistoryTranscriptToolCallClientDetails(
        type: type ?? this.type, parameters: parameters ?? this.parameters);
  }

  ConversationHistoryTranscriptToolCallClientDetails copyWithWrapped(
      {Wrapped<String?>? type, Wrapped<String>? parameters}) {
    return ConversationHistoryTranscriptToolCallClientDetails(
        type: (type != null ? type.value : this.type),
        parameters: (parameters != null ? parameters.value : this.parameters));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationHistoryTranscriptToolCallCommonModel {
  const ConversationHistoryTranscriptToolCallCommonModel({
    this.type,
    required this.requestId,
    required this.toolName,
    required this.paramsAsJson,
    required this.toolHasBeenCalled,
    this.toolDetails,
  });

  factory ConversationHistoryTranscriptToolCallCommonModel.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationHistoryTranscriptToolCallCommonModelFromJson(json);

  static const toJsonFactory =
      _$ConversationHistoryTranscriptToolCallCommonModelToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationHistoryTranscriptToolCallCommonModelToJson(this);

  @JsonKey(name: 'type')
  final dynamic type;
  @JsonKey(name: 'request_id')
  final String requestId;
  @JsonKey(name: 'tool_name')
  final String toolName;
  @JsonKey(name: 'params_as_json')
  final String paramsAsJson;
  @JsonKey(name: 'tool_has_been_called')
  final bool toolHasBeenCalled;
  @JsonKey(name: 'tool_details')
  final dynamic toolDetails;
  static const fromJsonFactory =
      _$ConversationHistoryTranscriptToolCallCommonModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationHistoryTranscriptToolCallCommonModel &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.toolName, toolName) ||
                const DeepCollectionEquality()
                    .equals(other.toolName, toolName)) &&
            (identical(other.paramsAsJson, paramsAsJson) ||
                const DeepCollectionEquality()
                    .equals(other.paramsAsJson, paramsAsJson)) &&
            (identical(other.toolHasBeenCalled, toolHasBeenCalled) ||
                const DeepCollectionEquality()
                    .equals(other.toolHasBeenCalled, toolHasBeenCalled)) &&
            (identical(other.toolDetails, toolDetails) ||
                const DeepCollectionEquality()
                    .equals(other.toolDetails, toolDetails)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(toolName) ^
      const DeepCollectionEquality().hash(paramsAsJson) ^
      const DeepCollectionEquality().hash(toolHasBeenCalled) ^
      const DeepCollectionEquality().hash(toolDetails) ^
      runtimeType.hashCode;
}

extension $ConversationHistoryTranscriptToolCallCommonModelExtension
    on ConversationHistoryTranscriptToolCallCommonModel {
  ConversationHistoryTranscriptToolCallCommonModel copyWith(
      {dynamic type,
      String? requestId,
      String? toolName,
      String? paramsAsJson,
      bool? toolHasBeenCalled,
      dynamic toolDetails}) {
    return ConversationHistoryTranscriptToolCallCommonModel(
        type: type ?? this.type,
        requestId: requestId ?? this.requestId,
        toolName: toolName ?? this.toolName,
        paramsAsJson: paramsAsJson ?? this.paramsAsJson,
        toolHasBeenCalled: toolHasBeenCalled ?? this.toolHasBeenCalled,
        toolDetails: toolDetails ?? this.toolDetails);
  }

  ConversationHistoryTranscriptToolCallCommonModel copyWithWrapped(
      {Wrapped<dynamic>? type,
      Wrapped<String>? requestId,
      Wrapped<String>? toolName,
      Wrapped<String>? paramsAsJson,
      Wrapped<bool>? toolHasBeenCalled,
      Wrapped<dynamic>? toolDetails}) {
    return ConversationHistoryTranscriptToolCallCommonModel(
        type: (type != null ? type.value : this.type),
        requestId: (requestId != null ? requestId.value : this.requestId),
        toolName: (toolName != null ? toolName.value : this.toolName),
        paramsAsJson:
            (paramsAsJson != null ? paramsAsJson.value : this.paramsAsJson),
        toolHasBeenCalled: (toolHasBeenCalled != null
            ? toolHasBeenCalled.value
            : this.toolHasBeenCalled),
        toolDetails:
            (toolDetails != null ? toolDetails.value : this.toolDetails));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationHistoryTranscriptToolCallWebhookDetails {
  const ConversationHistoryTranscriptToolCallWebhookDetails({
    this.type,
    required this.method,
    required this.url,
    this.headers,
    this.pathParams,
    this.queryParams,
    this.body,
  });

  factory ConversationHistoryTranscriptToolCallWebhookDetails.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationHistoryTranscriptToolCallWebhookDetailsFromJson(json);

  static const toJsonFactory =
      _$ConversationHistoryTranscriptToolCallWebhookDetailsToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationHistoryTranscriptToolCallWebhookDetailsToJson(this);

  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'method')
  final String method;
  @JsonKey(name: 'url')
  final String url;
  @JsonKey(name: 'headers')
  final Map<String, dynamic>? headers;
  @JsonKey(name: 'path_params')
  final Map<String, dynamic>? pathParams;
  @JsonKey(name: 'query_params')
  final Map<String, dynamic>? queryParams;
  @JsonKey(name: 'body')
  final dynamic body;
  static const fromJsonFactory =
      _$ConversationHistoryTranscriptToolCallWebhookDetailsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationHistoryTranscriptToolCallWebhookDetails &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.method, method) ||
                const DeepCollectionEquality().equals(other.method, method)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.headers, headers) ||
                const DeepCollectionEquality()
                    .equals(other.headers, headers)) &&
            (identical(other.pathParams, pathParams) ||
                const DeepCollectionEquality()
                    .equals(other.pathParams, pathParams)) &&
            (identical(other.queryParams, queryParams) ||
                const DeepCollectionEquality()
                    .equals(other.queryParams, queryParams)) &&
            (identical(other.body, body) ||
                const DeepCollectionEquality().equals(other.body, body)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(method) ^
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(headers) ^
      const DeepCollectionEquality().hash(pathParams) ^
      const DeepCollectionEquality().hash(queryParams) ^
      const DeepCollectionEquality().hash(body) ^
      runtimeType.hashCode;
}

extension $ConversationHistoryTranscriptToolCallWebhookDetailsExtension
    on ConversationHistoryTranscriptToolCallWebhookDetails {
  ConversationHistoryTranscriptToolCallWebhookDetails copyWith(
      {String? type,
      String? method,
      String? url,
      Map<String, dynamic>? headers,
      Map<String, dynamic>? pathParams,
      Map<String, dynamic>? queryParams,
      dynamic body}) {
    return ConversationHistoryTranscriptToolCallWebhookDetails(
        type: type ?? this.type,
        method: method ?? this.method,
        url: url ?? this.url,
        headers: headers ?? this.headers,
        pathParams: pathParams ?? this.pathParams,
        queryParams: queryParams ?? this.queryParams,
        body: body ?? this.body);
  }

  ConversationHistoryTranscriptToolCallWebhookDetails copyWithWrapped(
      {Wrapped<String?>? type,
      Wrapped<String>? method,
      Wrapped<String>? url,
      Wrapped<Map<String, dynamic>?>? headers,
      Wrapped<Map<String, dynamic>?>? pathParams,
      Wrapped<Map<String, dynamic>?>? queryParams,
      Wrapped<dynamic>? body}) {
    return ConversationHistoryTranscriptToolCallWebhookDetails(
        type: (type != null ? type.value : this.type),
        method: (method != null ? method.value : this.method),
        url: (url != null ? url.value : this.url),
        headers: (headers != null ? headers.value : this.headers),
        pathParams: (pathParams != null ? pathParams.value : this.pathParams),
        queryParams:
            (queryParams != null ? queryParams.value : this.queryParams),
        body: (body != null ? body.value : this.body));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationHistoryTranscriptToolResultCommonModel {
  const ConversationHistoryTranscriptToolResultCommonModel({
    this.type,
    required this.requestId,
    required this.toolName,
    required this.resultValue,
    required this.isError,
    required this.toolHasBeenCalled,
    this.toolLatencySecs,
  });

  factory ConversationHistoryTranscriptToolResultCommonModel.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationHistoryTranscriptToolResultCommonModelFromJson(json);

  static const toJsonFactory =
      _$ConversationHistoryTranscriptToolResultCommonModelToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationHistoryTranscriptToolResultCommonModelToJson(this);

  @JsonKey(name: 'type')
  final dynamic type;
  @JsonKey(name: 'request_id')
  final String requestId;
  @JsonKey(name: 'tool_name')
  final String toolName;
  @JsonKey(name: 'result_value')
  final String resultValue;
  @JsonKey(name: 'is_error')
  final bool isError;
  @JsonKey(name: 'tool_has_been_called')
  final bool toolHasBeenCalled;
  @JsonKey(name: 'tool_latency_secs')
  final double? toolLatencySecs;
  static const fromJsonFactory =
      _$ConversationHistoryTranscriptToolResultCommonModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationHistoryTranscriptToolResultCommonModel &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.toolName, toolName) ||
                const DeepCollectionEquality()
                    .equals(other.toolName, toolName)) &&
            (identical(other.resultValue, resultValue) ||
                const DeepCollectionEquality()
                    .equals(other.resultValue, resultValue)) &&
            (identical(other.isError, isError) ||
                const DeepCollectionEquality()
                    .equals(other.isError, isError)) &&
            (identical(other.toolHasBeenCalled, toolHasBeenCalled) ||
                const DeepCollectionEquality()
                    .equals(other.toolHasBeenCalled, toolHasBeenCalled)) &&
            (identical(other.toolLatencySecs, toolLatencySecs) ||
                const DeepCollectionEquality()
                    .equals(other.toolLatencySecs, toolLatencySecs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(toolName) ^
      const DeepCollectionEquality().hash(resultValue) ^
      const DeepCollectionEquality().hash(isError) ^
      const DeepCollectionEquality().hash(toolHasBeenCalled) ^
      const DeepCollectionEquality().hash(toolLatencySecs) ^
      runtimeType.hashCode;
}

extension $ConversationHistoryTranscriptToolResultCommonModelExtension
    on ConversationHistoryTranscriptToolResultCommonModel {
  ConversationHistoryTranscriptToolResultCommonModel copyWith(
      {dynamic type,
      String? requestId,
      String? toolName,
      String? resultValue,
      bool? isError,
      bool? toolHasBeenCalled,
      double? toolLatencySecs}) {
    return ConversationHistoryTranscriptToolResultCommonModel(
        type: type ?? this.type,
        requestId: requestId ?? this.requestId,
        toolName: toolName ?? this.toolName,
        resultValue: resultValue ?? this.resultValue,
        isError: isError ?? this.isError,
        toolHasBeenCalled: toolHasBeenCalled ?? this.toolHasBeenCalled,
        toolLatencySecs: toolLatencySecs ?? this.toolLatencySecs);
  }

  ConversationHistoryTranscriptToolResultCommonModel copyWithWrapped(
      {Wrapped<dynamic>? type,
      Wrapped<String>? requestId,
      Wrapped<String>? toolName,
      Wrapped<String>? resultValue,
      Wrapped<bool>? isError,
      Wrapped<bool>? toolHasBeenCalled,
      Wrapped<double?>? toolLatencySecs}) {
    return ConversationHistoryTranscriptToolResultCommonModel(
        type: (type != null ? type.value : this.type),
        requestId: (requestId != null ? requestId.value : this.requestId),
        toolName: (toolName != null ? toolName.value : this.toolName),
        resultValue:
            (resultValue != null ? resultValue.value : this.resultValue),
        isError: (isError != null ? isError.value : this.isError),
        toolHasBeenCalled: (toolHasBeenCalled != null
            ? toolHasBeenCalled.value
            : this.toolHasBeenCalled),
        toolLatencySecs: (toolLatencySecs != null
            ? toolLatencySecs.value
            : this.toolLatencySecs));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationHistoryTwilioPhoneCallModel {
  const ConversationHistoryTwilioPhoneCallModel({
    required this.direction,
    required this.phoneNumberId,
    required this.agentNumber,
    required this.externalNumber,
    required this.type,
    required this.streamSid,
    required this.callSid,
  });

  factory ConversationHistoryTwilioPhoneCallModel.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationHistoryTwilioPhoneCallModelFromJson(json);

  static const toJsonFactory = _$ConversationHistoryTwilioPhoneCallModelToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationHistoryTwilioPhoneCallModelToJson(this);

  @JsonKey(
    name: 'direction',
    toJson: conversationHistoryTwilioPhoneCallModelDirectionToJson,
    fromJson: conversationHistoryTwilioPhoneCallModelDirectionFromJson,
  )
  final enums.ConversationHistoryTwilioPhoneCallModelDirection direction;
  @JsonKey(name: 'phone_number_id')
  final String phoneNumberId;
  @JsonKey(name: 'agent_number')
  final String agentNumber;
  @JsonKey(name: 'external_number')
  final String externalNumber;
  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'stream_sid')
  final String streamSid;
  @JsonKey(name: 'call_sid')
  final String callSid;
  static const fromJsonFactory =
      _$ConversationHistoryTwilioPhoneCallModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationHistoryTwilioPhoneCallModel &&
            (identical(other.direction, direction) ||
                const DeepCollectionEquality()
                    .equals(other.direction, direction)) &&
            (identical(other.phoneNumberId, phoneNumberId) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumberId, phoneNumberId)) &&
            (identical(other.agentNumber, agentNumber) ||
                const DeepCollectionEquality()
                    .equals(other.agentNumber, agentNumber)) &&
            (identical(other.externalNumber, externalNumber) ||
                const DeepCollectionEquality()
                    .equals(other.externalNumber, externalNumber)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.streamSid, streamSid) ||
                const DeepCollectionEquality()
                    .equals(other.streamSid, streamSid)) &&
            (identical(other.callSid, callSid) ||
                const DeepCollectionEquality().equals(other.callSid, callSid)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(direction) ^
      const DeepCollectionEquality().hash(phoneNumberId) ^
      const DeepCollectionEquality().hash(agentNumber) ^
      const DeepCollectionEquality().hash(externalNumber) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(streamSid) ^
      const DeepCollectionEquality().hash(callSid) ^
      runtimeType.hashCode;
}

extension $ConversationHistoryTwilioPhoneCallModelExtension
    on ConversationHistoryTwilioPhoneCallModel {
  ConversationHistoryTwilioPhoneCallModel copyWith(
      {enums.ConversationHistoryTwilioPhoneCallModelDirection? direction,
      String? phoneNumberId,
      String? agentNumber,
      String? externalNumber,
      String? type,
      String? streamSid,
      String? callSid}) {
    return ConversationHistoryTwilioPhoneCallModel(
        direction: direction ?? this.direction,
        phoneNumberId: phoneNumberId ?? this.phoneNumberId,
        agentNumber: agentNumber ?? this.agentNumber,
        externalNumber: externalNumber ?? this.externalNumber,
        type: type ?? this.type,
        streamSid: streamSid ?? this.streamSid,
        callSid: callSid ?? this.callSid);
  }

  ConversationHistoryTwilioPhoneCallModel copyWithWrapped(
      {Wrapped<enums.ConversationHistoryTwilioPhoneCallModelDirection>?
          direction,
      Wrapped<String>? phoneNumberId,
      Wrapped<String>? agentNumber,
      Wrapped<String>? externalNumber,
      Wrapped<String>? type,
      Wrapped<String>? streamSid,
      Wrapped<String>? callSid}) {
    return ConversationHistoryTwilioPhoneCallModel(
        direction: (direction != null ? direction.value : this.direction),
        phoneNumberId:
            (phoneNumberId != null ? phoneNumberId.value : this.phoneNumberId),
        agentNumber:
            (agentNumber != null ? agentNumber.value : this.agentNumber),
        externalNumber: (externalNumber != null
            ? externalNumber.value
            : this.externalNumber),
        type: (type != null ? type.value : this.type),
        streamSid: (streamSid != null ? streamSid.value : this.streamSid),
        callSid: (callSid != null ? callSid.value : this.callSid));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationInitiationClientDataConfigInput {
  const ConversationInitiationClientDataConfigInput({
    this.conversationConfigOverride,
    this.customLlmExtraBody,
    this.enableConversationInitiationClientDataFromWebhook,
  });

  factory ConversationInitiationClientDataConfigInput.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationInitiationClientDataConfigInputFromJson(json);

  static const toJsonFactory =
      _$ConversationInitiationClientDataConfigInputToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationInitiationClientDataConfigInputToJson(this);

  @JsonKey(name: 'conversation_config_override')
  final ConversationConfigClientOverrideConfigInput? conversationConfigOverride;
  @JsonKey(name: 'custom_llm_extra_body', defaultValue: false)
  final bool? customLlmExtraBody;
  @JsonKey(
      name: 'enable_conversation_initiation_client_data_from_webhook',
      defaultValue: false)
  final bool? enableConversationInitiationClientDataFromWebhook;
  static const fromJsonFactory =
      _$ConversationInitiationClientDataConfigInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationInitiationClientDataConfigInput &&
            (identical(other.conversationConfigOverride,
                    conversationConfigOverride) ||
                const DeepCollectionEquality().equals(
                    other.conversationConfigOverride,
                    conversationConfigOverride)) &&
            (identical(other.customLlmExtraBody, customLlmExtraBody) ||
                const DeepCollectionEquality()
                    .equals(other.customLlmExtraBody, customLlmExtraBody)) &&
            (identical(other.enableConversationInitiationClientDataFromWebhook,
                    enableConversationInitiationClientDataFromWebhook) ||
                const DeepCollectionEquality().equals(
                    other.enableConversationInitiationClientDataFromWebhook,
                    enableConversationInitiationClientDataFromWebhook)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(conversationConfigOverride) ^
      const DeepCollectionEquality().hash(customLlmExtraBody) ^
      const DeepCollectionEquality()
          .hash(enableConversationInitiationClientDataFromWebhook) ^
      runtimeType.hashCode;
}

extension $ConversationInitiationClientDataConfigInputExtension
    on ConversationInitiationClientDataConfigInput {
  ConversationInitiationClientDataConfigInput copyWith(
      {ConversationConfigClientOverrideConfigInput? conversationConfigOverride,
      bool? customLlmExtraBody,
      bool? enableConversationInitiationClientDataFromWebhook}) {
    return ConversationInitiationClientDataConfigInput(
        conversationConfigOverride:
            conversationConfigOverride ?? this.conversationConfigOverride,
        customLlmExtraBody: customLlmExtraBody ?? this.customLlmExtraBody,
        enableConversationInitiationClientDataFromWebhook:
            enableConversationInitiationClientDataFromWebhook ??
                this.enableConversationInitiationClientDataFromWebhook);
  }

  ConversationInitiationClientDataConfigInput copyWithWrapped(
      {Wrapped<ConversationConfigClientOverrideConfigInput?>?
          conversationConfigOverride,
      Wrapped<bool?>? customLlmExtraBody,
      Wrapped<bool?>? enableConversationInitiationClientDataFromWebhook}) {
    return ConversationInitiationClientDataConfigInput(
        conversationConfigOverride: (conversationConfigOverride != null
            ? conversationConfigOverride.value
            : this.conversationConfigOverride),
        customLlmExtraBody: (customLlmExtraBody != null
            ? customLlmExtraBody.value
            : this.customLlmExtraBody),
        enableConversationInitiationClientDataFromWebhook:
            (enableConversationInitiationClientDataFromWebhook != null
                ? enableConversationInitiationClientDataFromWebhook.value
                : this.enableConversationInitiationClientDataFromWebhook));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationInitiationClientDataConfigOutput {
  const ConversationInitiationClientDataConfigOutput({
    this.conversationConfigOverride,
    this.customLlmExtraBody,
    this.enableConversationInitiationClientDataFromWebhook,
  });

  factory ConversationInitiationClientDataConfigOutput.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationInitiationClientDataConfigOutputFromJson(json);

  static const toJsonFactory =
      _$ConversationInitiationClientDataConfigOutputToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationInitiationClientDataConfigOutputToJson(this);

  @JsonKey(name: 'conversation_config_override')
  final ConversationConfigClientOverrideConfigOutput?
      conversationConfigOverride;
  @JsonKey(name: 'custom_llm_extra_body', defaultValue: false)
  final bool? customLlmExtraBody;
  @JsonKey(
      name: 'enable_conversation_initiation_client_data_from_webhook',
      defaultValue: false)
  final bool? enableConversationInitiationClientDataFromWebhook;
  static const fromJsonFactory =
      _$ConversationInitiationClientDataConfigOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationInitiationClientDataConfigOutput &&
            (identical(other.conversationConfigOverride,
                    conversationConfigOverride) ||
                const DeepCollectionEquality().equals(
                    other.conversationConfigOverride,
                    conversationConfigOverride)) &&
            (identical(other.customLlmExtraBody, customLlmExtraBody) ||
                const DeepCollectionEquality()
                    .equals(other.customLlmExtraBody, customLlmExtraBody)) &&
            (identical(other.enableConversationInitiationClientDataFromWebhook,
                    enableConversationInitiationClientDataFromWebhook) ||
                const DeepCollectionEquality().equals(
                    other.enableConversationInitiationClientDataFromWebhook,
                    enableConversationInitiationClientDataFromWebhook)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(conversationConfigOverride) ^
      const DeepCollectionEquality().hash(customLlmExtraBody) ^
      const DeepCollectionEquality()
          .hash(enableConversationInitiationClientDataFromWebhook) ^
      runtimeType.hashCode;
}

extension $ConversationInitiationClientDataConfigOutputExtension
    on ConversationInitiationClientDataConfigOutput {
  ConversationInitiationClientDataConfigOutput copyWith(
      {ConversationConfigClientOverrideConfigOutput? conversationConfigOverride,
      bool? customLlmExtraBody,
      bool? enableConversationInitiationClientDataFromWebhook}) {
    return ConversationInitiationClientDataConfigOutput(
        conversationConfigOverride:
            conversationConfigOverride ?? this.conversationConfigOverride,
        customLlmExtraBody: customLlmExtraBody ?? this.customLlmExtraBody,
        enableConversationInitiationClientDataFromWebhook:
            enableConversationInitiationClientDataFromWebhook ??
                this.enableConversationInitiationClientDataFromWebhook);
  }

  ConversationInitiationClientDataConfigOutput copyWithWrapped(
      {Wrapped<ConversationConfigClientOverrideConfigOutput?>?
          conversationConfigOverride,
      Wrapped<bool?>? customLlmExtraBody,
      Wrapped<bool?>? enableConversationInitiationClientDataFromWebhook}) {
    return ConversationInitiationClientDataConfigOutput(
        conversationConfigOverride: (conversationConfigOverride != null
            ? conversationConfigOverride.value
            : this.conversationConfigOverride),
        customLlmExtraBody: (customLlmExtraBody != null
            ? customLlmExtraBody.value
            : this.customLlmExtraBody),
        enableConversationInitiationClientDataFromWebhook:
            (enableConversationInitiationClientDataFromWebhook != null
                ? enableConversationInitiationClientDataFromWebhook.value
                : this.enableConversationInitiationClientDataFromWebhook));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationInitiationClientDataInternal {
  const ConversationInitiationClientDataInternal({
    this.conversationConfigOverride,
    this.customLlmExtraBody,
    this.dynamicVariables,
  });

  factory ConversationInitiationClientDataInternal.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationInitiationClientDataInternalFromJson(json);

  static const toJsonFactory = _$ConversationInitiationClientDataInternalToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationInitiationClientDataInternalToJson(this);

  @JsonKey(name: 'conversation_config_override')
  final ConversationConfigClientOverrideOutput? conversationConfigOverride;
  @JsonKey(name: 'custom_llm_extra_body')
  final Object? customLlmExtraBody;
  @JsonKey(name: 'dynamic_variables')
  final Map<String, dynamic>? dynamicVariables;
  static const fromJsonFactory =
      _$ConversationInitiationClientDataInternalFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationInitiationClientDataInternal &&
            (identical(other.conversationConfigOverride,
                    conversationConfigOverride) ||
                const DeepCollectionEquality().equals(
                    other.conversationConfigOverride,
                    conversationConfigOverride)) &&
            (identical(other.customLlmExtraBody, customLlmExtraBody) ||
                const DeepCollectionEquality()
                    .equals(other.customLlmExtraBody, customLlmExtraBody)) &&
            (identical(other.dynamicVariables, dynamicVariables) ||
                const DeepCollectionEquality()
                    .equals(other.dynamicVariables, dynamicVariables)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(conversationConfigOverride) ^
      const DeepCollectionEquality().hash(customLlmExtraBody) ^
      const DeepCollectionEquality().hash(dynamicVariables) ^
      runtimeType.hashCode;
}

extension $ConversationInitiationClientDataInternalExtension
    on ConversationInitiationClientDataInternal {
  ConversationInitiationClientDataInternal copyWith(
      {ConversationConfigClientOverrideOutput? conversationConfigOverride,
      Object? customLlmExtraBody,
      Map<String, dynamic>? dynamicVariables}) {
    return ConversationInitiationClientDataInternal(
        conversationConfigOverride:
            conversationConfigOverride ?? this.conversationConfigOverride,
        customLlmExtraBody: customLlmExtraBody ?? this.customLlmExtraBody,
        dynamicVariables: dynamicVariables ?? this.dynamicVariables);
  }

  ConversationInitiationClientDataInternal copyWithWrapped(
      {Wrapped<ConversationConfigClientOverrideOutput?>?
          conversationConfigOverride,
      Wrapped<Object?>? customLlmExtraBody,
      Wrapped<Map<String, dynamic>?>? dynamicVariables}) {
    return ConversationInitiationClientDataInternal(
        conversationConfigOverride: (conversationConfigOverride != null
            ? conversationConfigOverride.value
            : this.conversationConfigOverride),
        customLlmExtraBody: (customLlmExtraBody != null
            ? customLlmExtraBody.value
            : this.customLlmExtraBody),
        dynamicVariables: (dynamicVariables != null
            ? dynamicVariables.value
            : this.dynamicVariables));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationInitiationClientDataRequestInput {
  const ConversationInitiationClientDataRequestInput({
    this.conversationConfigOverride,
    this.customLlmExtraBody,
    this.dynamicVariables,
  });

  factory ConversationInitiationClientDataRequestInput.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationInitiationClientDataRequestInputFromJson(json);

  static const toJsonFactory =
      _$ConversationInitiationClientDataRequestInputToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationInitiationClientDataRequestInputToJson(this);

  @JsonKey(name: 'conversation_config_override')
  final ConversationConfigClientOverrideInput? conversationConfigOverride;
  @JsonKey(name: 'custom_llm_extra_body')
  final Object? customLlmExtraBody;
  @JsonKey(name: 'dynamic_variables')
  final Map<String, dynamic>? dynamicVariables;
  static const fromJsonFactory =
      _$ConversationInitiationClientDataRequestInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationInitiationClientDataRequestInput &&
            (identical(other.conversationConfigOverride,
                    conversationConfigOverride) ||
                const DeepCollectionEquality().equals(
                    other.conversationConfigOverride,
                    conversationConfigOverride)) &&
            (identical(other.customLlmExtraBody, customLlmExtraBody) ||
                const DeepCollectionEquality()
                    .equals(other.customLlmExtraBody, customLlmExtraBody)) &&
            (identical(other.dynamicVariables, dynamicVariables) ||
                const DeepCollectionEquality()
                    .equals(other.dynamicVariables, dynamicVariables)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(conversationConfigOverride) ^
      const DeepCollectionEquality().hash(customLlmExtraBody) ^
      const DeepCollectionEquality().hash(dynamicVariables) ^
      runtimeType.hashCode;
}

extension $ConversationInitiationClientDataRequestInputExtension
    on ConversationInitiationClientDataRequestInput {
  ConversationInitiationClientDataRequestInput copyWith(
      {ConversationConfigClientOverrideInput? conversationConfigOverride,
      Object? customLlmExtraBody,
      Map<String, dynamic>? dynamicVariables}) {
    return ConversationInitiationClientDataRequestInput(
        conversationConfigOverride:
            conversationConfigOverride ?? this.conversationConfigOverride,
        customLlmExtraBody: customLlmExtraBody ?? this.customLlmExtraBody,
        dynamicVariables: dynamicVariables ?? this.dynamicVariables);
  }

  ConversationInitiationClientDataRequestInput copyWithWrapped(
      {Wrapped<ConversationConfigClientOverrideInput?>?
          conversationConfigOverride,
      Wrapped<Object?>? customLlmExtraBody,
      Wrapped<Map<String, dynamic>?>? dynamicVariables}) {
    return ConversationInitiationClientDataRequestInput(
        conversationConfigOverride: (conversationConfigOverride != null
            ? conversationConfigOverride.value
            : this.conversationConfigOverride),
        customLlmExtraBody: (customLlmExtraBody != null
            ? customLlmExtraBody.value
            : this.customLlmExtraBody),
        dynamicVariables: (dynamicVariables != null
            ? dynamicVariables.value
            : this.dynamicVariables));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationInitiationClientDataRequestOutput {
  const ConversationInitiationClientDataRequestOutput({
    this.conversationConfigOverride,
    this.customLlmExtraBody,
    this.dynamicVariables,
  });

  factory ConversationInitiationClientDataRequestOutput.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationInitiationClientDataRequestOutputFromJson(json);

  static const toJsonFactory =
      _$ConversationInitiationClientDataRequestOutputToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationInitiationClientDataRequestOutputToJson(this);

  @JsonKey(name: 'conversation_config_override')
  final ConversationConfigClientOverrideOutput? conversationConfigOverride;
  @JsonKey(name: 'custom_llm_extra_body')
  final Object? customLlmExtraBody;
  @JsonKey(name: 'dynamic_variables')
  final Map<String, dynamic>? dynamicVariables;
  static const fromJsonFactory =
      _$ConversationInitiationClientDataRequestOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationInitiationClientDataRequestOutput &&
            (identical(other.conversationConfigOverride,
                    conversationConfigOverride) ||
                const DeepCollectionEquality().equals(
                    other.conversationConfigOverride,
                    conversationConfigOverride)) &&
            (identical(other.customLlmExtraBody, customLlmExtraBody) ||
                const DeepCollectionEquality()
                    .equals(other.customLlmExtraBody, customLlmExtraBody)) &&
            (identical(other.dynamicVariables, dynamicVariables) ||
                const DeepCollectionEquality()
                    .equals(other.dynamicVariables, dynamicVariables)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(conversationConfigOverride) ^
      const DeepCollectionEquality().hash(customLlmExtraBody) ^
      const DeepCollectionEquality().hash(dynamicVariables) ^
      runtimeType.hashCode;
}

extension $ConversationInitiationClientDataRequestOutputExtension
    on ConversationInitiationClientDataRequestOutput {
  ConversationInitiationClientDataRequestOutput copyWith(
      {ConversationConfigClientOverrideOutput? conversationConfigOverride,
      Object? customLlmExtraBody,
      Map<String, dynamic>? dynamicVariables}) {
    return ConversationInitiationClientDataRequestOutput(
        conversationConfigOverride:
            conversationConfigOverride ?? this.conversationConfigOverride,
        customLlmExtraBody: customLlmExtraBody ?? this.customLlmExtraBody,
        dynamicVariables: dynamicVariables ?? this.dynamicVariables);
  }

  ConversationInitiationClientDataRequestOutput copyWithWrapped(
      {Wrapped<ConversationConfigClientOverrideOutput?>?
          conversationConfigOverride,
      Wrapped<Object?>? customLlmExtraBody,
      Wrapped<Map<String, dynamic>?>? dynamicVariables}) {
    return ConversationInitiationClientDataRequestOutput(
        conversationConfigOverride: (conversationConfigOverride != null
            ? conversationConfigOverride.value
            : this.conversationConfigOverride),
        customLlmExtraBody: (customLlmExtraBody != null
            ? customLlmExtraBody.value
            : this.customLlmExtraBody),
        dynamicVariables: (dynamicVariables != null
            ? dynamicVariables.value
            : this.dynamicVariables));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationInitiationClientDataWebhook {
  const ConversationInitiationClientDataWebhook({
    required this.url,
    required this.requestHeaders,
  });

  factory ConversationInitiationClientDataWebhook.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationInitiationClientDataWebhookFromJson(json);

  static const toJsonFactory = _$ConversationInitiationClientDataWebhookToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationInitiationClientDataWebhookToJson(this);

  @JsonKey(name: 'url')
  final String url;
  @JsonKey(name: 'request_headers')
  final Map<String, dynamic> requestHeaders;
  static const fromJsonFactory =
      _$ConversationInitiationClientDataWebhookFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationInitiationClientDataWebhook &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.requestHeaders, requestHeaders) ||
                const DeepCollectionEquality()
                    .equals(other.requestHeaders, requestHeaders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(requestHeaders) ^
      runtimeType.hashCode;
}

extension $ConversationInitiationClientDataWebhookExtension
    on ConversationInitiationClientDataWebhook {
  ConversationInitiationClientDataWebhook copyWith(
      {String? url, Map<String, dynamic>? requestHeaders}) {
    return ConversationInitiationClientDataWebhook(
        url: url ?? this.url,
        requestHeaders: requestHeaders ?? this.requestHeaders);
  }

  ConversationInitiationClientDataWebhook copyWithWrapped(
      {Wrapped<String>? url, Wrapped<Map<String, dynamic>>? requestHeaders}) {
    return ConversationInitiationClientDataWebhook(
        url: (url != null ? url.value : this.url),
        requestHeaders: (requestHeaders != null
            ? requestHeaders.value
            : this.requestHeaders));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationSignedUrlResponseModel {
  const ConversationSignedUrlResponseModel({
    required this.signedUrl,
  });

  factory ConversationSignedUrlResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationSignedUrlResponseModelFromJson(json);

  static const toJsonFactory = _$ConversationSignedUrlResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationSignedUrlResponseModelToJson(this);

  @JsonKey(name: 'signed_url')
  final String signedUrl;
  static const fromJsonFactory = _$ConversationSignedUrlResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationSignedUrlResponseModel &&
            (identical(other.signedUrl, signedUrl) ||
                const DeepCollectionEquality()
                    .equals(other.signedUrl, signedUrl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(signedUrl) ^ runtimeType.hashCode;
}

extension $ConversationSignedUrlResponseModelExtension
    on ConversationSignedUrlResponseModel {
  ConversationSignedUrlResponseModel copyWith({String? signedUrl}) {
    return ConversationSignedUrlResponseModel(
        signedUrl: signedUrl ?? this.signedUrl);
  }

  ConversationSignedUrlResponseModel copyWithWrapped(
      {Wrapped<String>? signedUrl}) {
    return ConversationSignedUrlResponseModel(
        signedUrl: (signedUrl != null ? signedUrl.value : this.signedUrl));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationSimulationSpecification {
  const ConversationSimulationSpecification({
    required this.simulatedUserConfig,
    this.toolMockConfig,
    this.partialConversationHistory,
  });

  factory ConversationSimulationSpecification.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationSimulationSpecificationFromJson(json);

  static const toJsonFactory = _$ConversationSimulationSpecificationToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationSimulationSpecificationToJson(this);

  @JsonKey(name: 'simulated_user_config')
  final AgentConfigDBModel simulatedUserConfig;
  @JsonKey(name: 'tool_mock_config')
  final Map<String, dynamic>? toolMockConfig;
  @JsonKey(
      name: 'partial_conversation_history',
      defaultValue: <ConversationHistoryTranscriptCommonModelInput>[])
  final List<ConversationHistoryTranscriptCommonModelInput>?
      partialConversationHistory;
  static const fromJsonFactory = _$ConversationSimulationSpecificationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationSimulationSpecification &&
            (identical(other.simulatedUserConfig, simulatedUserConfig) ||
                const DeepCollectionEquality()
                    .equals(other.simulatedUserConfig, simulatedUserConfig)) &&
            (identical(other.toolMockConfig, toolMockConfig) ||
                const DeepCollectionEquality()
                    .equals(other.toolMockConfig, toolMockConfig)) &&
            (identical(other.partialConversationHistory,
                    partialConversationHistory) ||
                const DeepCollectionEquality().equals(
                    other.partialConversationHistory,
                    partialConversationHistory)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(simulatedUserConfig) ^
      const DeepCollectionEquality().hash(toolMockConfig) ^
      const DeepCollectionEquality().hash(partialConversationHistory) ^
      runtimeType.hashCode;
}

extension $ConversationSimulationSpecificationExtension
    on ConversationSimulationSpecification {
  ConversationSimulationSpecification copyWith(
      {AgentConfigDBModel? simulatedUserConfig,
      Map<String, dynamic>? toolMockConfig,
      List<ConversationHistoryTranscriptCommonModelInput>?
          partialConversationHistory}) {
    return ConversationSimulationSpecification(
        simulatedUserConfig: simulatedUserConfig ?? this.simulatedUserConfig,
        toolMockConfig: toolMockConfig ?? this.toolMockConfig,
        partialConversationHistory:
            partialConversationHistory ?? this.partialConversationHistory);
  }

  ConversationSimulationSpecification copyWithWrapped(
      {Wrapped<AgentConfigDBModel>? simulatedUserConfig,
      Wrapped<Map<String, dynamic>?>? toolMockConfig,
      Wrapped<List<ConversationHistoryTranscriptCommonModelInput>?>?
          partialConversationHistory}) {
    return ConversationSimulationSpecification(
        simulatedUserConfig: (simulatedUserConfig != null
            ? simulatedUserConfig.value
            : this.simulatedUserConfig),
        toolMockConfig: (toolMockConfig != null
            ? toolMockConfig.value
            : this.toolMockConfig),
        partialConversationHistory: (partialConversationHistory != null
            ? partialConversationHistory.value
            : this.partialConversationHistory));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationSummaryResponseModel {
  const ConversationSummaryResponseModel({
    required this.agentId,
    this.agentName,
    required this.conversationId,
    required this.startTimeUnixSecs,
    required this.callDurationSecs,
    required this.messageCount,
    required this.status,
    required this.callSuccessful,
  });

  factory ConversationSummaryResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationSummaryResponseModelFromJson(json);

  static const toJsonFactory = _$ConversationSummaryResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationSummaryResponseModelToJson(this);

  @JsonKey(name: 'agent_id')
  final String agentId;
  @JsonKey(name: 'agent_name')
  final dynamic agentName;
  @JsonKey(name: 'conversation_id')
  final String conversationId;
  @JsonKey(name: 'start_time_unix_secs')
  final int startTimeUnixSecs;
  @JsonKey(name: 'call_duration_secs')
  final int callDurationSecs;
  @JsonKey(name: 'message_count')
  final int messageCount;
  @JsonKey(
    name: 'status',
    toJson: conversationSummaryResponseModelStatusToJson,
    fromJson: conversationSummaryResponseModelStatusFromJson,
  )
  final enums.ConversationSummaryResponseModelStatus status;
  @JsonKey(
    name: 'call_successful',
    toJson: evaluationSuccessResultToJson,
    fromJson: evaluationSuccessResultFromJson,
  )
  final enums.EvaluationSuccessResult callSuccessful;
  static const fromJsonFactory = _$ConversationSummaryResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationSummaryResponseModel &&
            (identical(other.agentId, agentId) ||
                const DeepCollectionEquality()
                    .equals(other.agentId, agentId)) &&
            (identical(other.agentName, agentName) ||
                const DeepCollectionEquality()
                    .equals(other.agentName, agentName)) &&
            (identical(other.conversationId, conversationId) ||
                const DeepCollectionEquality()
                    .equals(other.conversationId, conversationId)) &&
            (identical(other.startTimeUnixSecs, startTimeUnixSecs) ||
                const DeepCollectionEquality()
                    .equals(other.startTimeUnixSecs, startTimeUnixSecs)) &&
            (identical(other.callDurationSecs, callDurationSecs) ||
                const DeepCollectionEquality()
                    .equals(other.callDurationSecs, callDurationSecs)) &&
            (identical(other.messageCount, messageCount) ||
                const DeepCollectionEquality()
                    .equals(other.messageCount, messageCount)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.callSuccessful, callSuccessful) ||
                const DeepCollectionEquality()
                    .equals(other.callSuccessful, callSuccessful)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(agentId) ^
      const DeepCollectionEquality().hash(agentName) ^
      const DeepCollectionEquality().hash(conversationId) ^
      const DeepCollectionEquality().hash(startTimeUnixSecs) ^
      const DeepCollectionEquality().hash(callDurationSecs) ^
      const DeepCollectionEquality().hash(messageCount) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(callSuccessful) ^
      runtimeType.hashCode;
}

extension $ConversationSummaryResponseModelExtension
    on ConversationSummaryResponseModel {
  ConversationSummaryResponseModel copyWith(
      {String? agentId,
      dynamic agentName,
      String? conversationId,
      int? startTimeUnixSecs,
      int? callDurationSecs,
      int? messageCount,
      enums.ConversationSummaryResponseModelStatus? status,
      enums.EvaluationSuccessResult? callSuccessful}) {
    return ConversationSummaryResponseModel(
        agentId: agentId ?? this.agentId,
        agentName: agentName ?? this.agentName,
        conversationId: conversationId ?? this.conversationId,
        startTimeUnixSecs: startTimeUnixSecs ?? this.startTimeUnixSecs,
        callDurationSecs: callDurationSecs ?? this.callDurationSecs,
        messageCount: messageCount ?? this.messageCount,
        status: status ?? this.status,
        callSuccessful: callSuccessful ?? this.callSuccessful);
  }

  ConversationSummaryResponseModel copyWithWrapped(
      {Wrapped<String>? agentId,
      Wrapped<dynamic>? agentName,
      Wrapped<String>? conversationId,
      Wrapped<int>? startTimeUnixSecs,
      Wrapped<int>? callDurationSecs,
      Wrapped<int>? messageCount,
      Wrapped<enums.ConversationSummaryResponseModelStatus>? status,
      Wrapped<enums.EvaluationSuccessResult>? callSuccessful}) {
    return ConversationSummaryResponseModel(
        agentId: (agentId != null ? agentId.value : this.agentId),
        agentName: (agentName != null ? agentName.value : this.agentName),
        conversationId: (conversationId != null
            ? conversationId.value
            : this.conversationId),
        startTimeUnixSecs: (startTimeUnixSecs != null
            ? startTimeUnixSecs.value
            : this.startTimeUnixSecs),
        callDurationSecs: (callDurationSecs != null
            ? callDurationSecs.value
            : this.callDurationSecs),
        messageCount:
            (messageCount != null ? messageCount.value : this.messageCount),
        status: (status != null ? status.value : this.status),
        callSuccessful: (callSuccessful != null
            ? callSuccessful.value
            : this.callSuccessful));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationTokenDBModel {
  const ConversationTokenDBModel({
    required this.agentId,
    required this.conversationToken,
    this.expirationTimeUnixSecs,
    this.conversationId,
    this.purpose,
  });

  factory ConversationTokenDBModel.fromJson(Map<String, dynamic> json) =>
      _$ConversationTokenDBModelFromJson(json);

  static const toJsonFactory = _$ConversationTokenDBModelToJson;
  Map<String, dynamic> toJson() => _$ConversationTokenDBModelToJson(this);

  @JsonKey(name: 'agent_id')
  final String agentId;
  @JsonKey(name: 'conversation_token')
  final String conversationToken;
  @JsonKey(name: 'expiration_time_unix_secs')
  final dynamic expirationTimeUnixSecs;
  @JsonKey(name: 'conversation_id')
  final dynamic conversationId;
  @JsonKey(
    name: 'purpose',
    toJson: conversationTokenPurposeNullableToJson,
    fromJson: conversationTokenPurposePurposeNullableFromJson,
  )
  final enums.ConversationTokenPurpose? purpose;
  static enums.ConversationTokenPurpose?
      conversationTokenPurposePurposeNullableFromJson(Object? value) =>
          conversationTokenPurposeNullableFromJson(
              value, enums.ConversationTokenPurpose.signedUrl);

  static const fromJsonFactory = _$ConversationTokenDBModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationTokenDBModel &&
            (identical(other.agentId, agentId) ||
                const DeepCollectionEquality()
                    .equals(other.agentId, agentId)) &&
            (identical(other.conversationToken, conversationToken) ||
                const DeepCollectionEquality()
                    .equals(other.conversationToken, conversationToken)) &&
            (identical(other.expirationTimeUnixSecs, expirationTimeUnixSecs) ||
                const DeepCollectionEquality().equals(
                    other.expirationTimeUnixSecs, expirationTimeUnixSecs)) &&
            (identical(other.conversationId, conversationId) ||
                const DeepCollectionEquality()
                    .equals(other.conversationId, conversationId)) &&
            (identical(other.purpose, purpose) ||
                const DeepCollectionEquality().equals(other.purpose, purpose)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(agentId) ^
      const DeepCollectionEquality().hash(conversationToken) ^
      const DeepCollectionEquality().hash(expirationTimeUnixSecs) ^
      const DeepCollectionEquality().hash(conversationId) ^
      const DeepCollectionEquality().hash(purpose) ^
      runtimeType.hashCode;
}

extension $ConversationTokenDBModelExtension on ConversationTokenDBModel {
  ConversationTokenDBModel copyWith(
      {String? agentId,
      String? conversationToken,
      dynamic expirationTimeUnixSecs,
      dynamic conversationId,
      enums.ConversationTokenPurpose? purpose}) {
    return ConversationTokenDBModel(
        agentId: agentId ?? this.agentId,
        conversationToken: conversationToken ?? this.conversationToken,
        expirationTimeUnixSecs:
            expirationTimeUnixSecs ?? this.expirationTimeUnixSecs,
        conversationId: conversationId ?? this.conversationId,
        purpose: purpose ?? this.purpose);
  }

  ConversationTokenDBModel copyWithWrapped(
      {Wrapped<String>? agentId,
      Wrapped<String>? conversationToken,
      Wrapped<dynamic>? expirationTimeUnixSecs,
      Wrapped<dynamic>? conversationId,
      Wrapped<enums.ConversationTokenPurpose?>? purpose}) {
    return ConversationTokenDBModel(
        agentId: (agentId != null ? agentId.value : this.agentId),
        conversationToken: (conversationToken != null
            ? conversationToken.value
            : this.conversationToken),
        expirationTimeUnixSecs: (expirationTimeUnixSecs != null
            ? expirationTimeUnixSecs.value
            : this.expirationTimeUnixSecs),
        conversationId: (conversationId != null
            ? conversationId.value
            : this.conversationId),
        purpose: (purpose != null ? purpose.value : this.purpose));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationTurnMetrics {
  const ConversationTurnMetrics({
    this.metrics,
  });

  factory ConversationTurnMetrics.fromJson(Map<String, dynamic> json) =>
      _$ConversationTurnMetricsFromJson(json);

  static const toJsonFactory = _$ConversationTurnMetricsToJson;
  Map<String, dynamic> toJson() => _$ConversationTurnMetricsToJson(this);

  @JsonKey(name: 'metrics')
  final Map<String, dynamic>? metrics;
  static const fromJsonFactory = _$ConversationTurnMetricsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationTurnMetrics &&
            (identical(other.metrics, metrics) ||
                const DeepCollectionEquality().equals(other.metrics, metrics)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(metrics) ^ runtimeType.hashCode;
}

extension $ConversationTurnMetricsExtension on ConversationTurnMetrics {
  ConversationTurnMetrics copyWith({Map<String, dynamic>? metrics}) {
    return ConversationTurnMetrics(metrics: metrics ?? this.metrics);
  }

  ConversationTurnMetrics copyWithWrapped(
      {Wrapped<Map<String, dynamic>?>? metrics}) {
    return ConversationTurnMetrics(
        metrics: (metrics != null ? metrics.value : this.metrics));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationalConfigAPIModelInput {
  const ConversationalConfigAPIModelInput({
    this.asr,
    this.turn,
    this.tts,
    this.conversation,
    this.languagePresets,
    this.agent,
  });

  factory ConversationalConfigAPIModelInput.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationalConfigAPIModelInputFromJson(json);

  static const toJsonFactory = _$ConversationalConfigAPIModelInputToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationalConfigAPIModelInputToJson(this);

  @JsonKey(name: 'asr')
  final ASRConversationalConfig? asr;
  @JsonKey(name: 'turn')
  final TurnConfig? turn;
  @JsonKey(name: 'tts')
  final TTSConversationalConfig? tts;
  @JsonKey(name: 'conversation')
  final ConversationConfig? conversation;
  @JsonKey(name: 'language_presets')
  final Map<String, dynamic>? languagePresets;
  @JsonKey(name: 'agent')
  final AgentConfigAPIModelInput? agent;
  static const fromJsonFactory = _$ConversationalConfigAPIModelInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationalConfigAPIModelInput &&
            (identical(other.asr, asr) ||
                const DeepCollectionEquality().equals(other.asr, asr)) &&
            (identical(other.turn, turn) ||
                const DeepCollectionEquality().equals(other.turn, turn)) &&
            (identical(other.tts, tts) ||
                const DeepCollectionEquality().equals(other.tts, tts)) &&
            (identical(other.conversation, conversation) ||
                const DeepCollectionEquality()
                    .equals(other.conversation, conversation)) &&
            (identical(other.languagePresets, languagePresets) ||
                const DeepCollectionEquality()
                    .equals(other.languagePresets, languagePresets)) &&
            (identical(other.agent, agent) ||
                const DeepCollectionEquality().equals(other.agent, agent)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(asr) ^
      const DeepCollectionEquality().hash(turn) ^
      const DeepCollectionEquality().hash(tts) ^
      const DeepCollectionEquality().hash(conversation) ^
      const DeepCollectionEquality().hash(languagePresets) ^
      const DeepCollectionEquality().hash(agent) ^
      runtimeType.hashCode;
}

extension $ConversationalConfigAPIModelInputExtension
    on ConversationalConfigAPIModelInput {
  ConversationalConfigAPIModelInput copyWith(
      {ASRConversationalConfig? asr,
      TurnConfig? turn,
      TTSConversationalConfig? tts,
      ConversationConfig? conversation,
      Map<String, dynamic>? languagePresets,
      AgentConfigAPIModelInput? agent}) {
    return ConversationalConfigAPIModelInput(
        asr: asr ?? this.asr,
        turn: turn ?? this.turn,
        tts: tts ?? this.tts,
        conversation: conversation ?? this.conversation,
        languagePresets: languagePresets ?? this.languagePresets,
        agent: agent ?? this.agent);
  }

  ConversationalConfigAPIModelInput copyWithWrapped(
      {Wrapped<ASRConversationalConfig?>? asr,
      Wrapped<TurnConfig?>? turn,
      Wrapped<TTSConversationalConfig?>? tts,
      Wrapped<ConversationConfig?>? conversation,
      Wrapped<Map<String, dynamic>?>? languagePresets,
      Wrapped<AgentConfigAPIModelInput?>? agent}) {
    return ConversationalConfigAPIModelInput(
        asr: (asr != null ? asr.value : this.asr),
        turn: (turn != null ? turn.value : this.turn),
        tts: (tts != null ? tts.value : this.tts),
        conversation:
            (conversation != null ? conversation.value : this.conversation),
        languagePresets: (languagePresets != null
            ? languagePresets.value
            : this.languagePresets),
        agent: (agent != null ? agent.value : this.agent));
  }
}

@JsonSerializable(explicitToJson: true)
class ConversationalConfigAPIModelOutput {
  const ConversationalConfigAPIModelOutput({
    this.asr,
    this.turn,
    this.tts,
    this.conversation,
    this.languagePresets,
    this.agent,
  });

  factory ConversationalConfigAPIModelOutput.fromJson(
          Map<String, dynamic> json) =>
      _$ConversationalConfigAPIModelOutputFromJson(json);

  static const toJsonFactory = _$ConversationalConfigAPIModelOutputToJson;
  Map<String, dynamic> toJson() =>
      _$ConversationalConfigAPIModelOutputToJson(this);

  @JsonKey(name: 'asr')
  final ASRConversationalConfig? asr;
  @JsonKey(name: 'turn')
  final TurnConfig? turn;
  @JsonKey(name: 'tts')
  final TTSConversationalConfig? tts;
  @JsonKey(name: 'conversation')
  final ConversationConfig? conversation;
  @JsonKey(name: 'language_presets')
  final Map<String, dynamic>? languagePresets;
  @JsonKey(name: 'agent')
  final AgentConfigAPIModelOutput? agent;
  static const fromJsonFactory = _$ConversationalConfigAPIModelOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConversationalConfigAPIModelOutput &&
            (identical(other.asr, asr) ||
                const DeepCollectionEquality().equals(other.asr, asr)) &&
            (identical(other.turn, turn) ||
                const DeepCollectionEquality().equals(other.turn, turn)) &&
            (identical(other.tts, tts) ||
                const DeepCollectionEquality().equals(other.tts, tts)) &&
            (identical(other.conversation, conversation) ||
                const DeepCollectionEquality()
                    .equals(other.conversation, conversation)) &&
            (identical(other.languagePresets, languagePresets) ||
                const DeepCollectionEquality()
                    .equals(other.languagePresets, languagePresets)) &&
            (identical(other.agent, agent) ||
                const DeepCollectionEquality().equals(other.agent, agent)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(asr) ^
      const DeepCollectionEquality().hash(turn) ^
      const DeepCollectionEquality().hash(tts) ^
      const DeepCollectionEquality().hash(conversation) ^
      const DeepCollectionEquality().hash(languagePresets) ^
      const DeepCollectionEquality().hash(agent) ^
      runtimeType.hashCode;
}

extension $ConversationalConfigAPIModelOutputExtension
    on ConversationalConfigAPIModelOutput {
  ConversationalConfigAPIModelOutput copyWith(
      {ASRConversationalConfig? asr,
      TurnConfig? turn,
      TTSConversationalConfig? tts,
      ConversationConfig? conversation,
      Map<String, dynamic>? languagePresets,
      AgentConfigAPIModelOutput? agent}) {
    return ConversationalConfigAPIModelOutput(
        asr: asr ?? this.asr,
        turn: turn ?? this.turn,
        tts: tts ?? this.tts,
        conversation: conversation ?? this.conversation,
        languagePresets: languagePresets ?? this.languagePresets,
        agent: agent ?? this.agent);
  }

  ConversationalConfigAPIModelOutput copyWithWrapped(
      {Wrapped<ASRConversationalConfig?>? asr,
      Wrapped<TurnConfig?>? turn,
      Wrapped<TTSConversationalConfig?>? tts,
      Wrapped<ConversationConfig?>? conversation,
      Wrapped<Map<String, dynamic>?>? languagePresets,
      Wrapped<AgentConfigAPIModelOutput?>? agent}) {
    return ConversationalConfigAPIModelOutput(
        asr: (asr != null ? asr.value : this.asr),
        turn: (turn != null ? turn.value : this.turn),
        tts: (tts != null ? tts.value : this.tts),
        conversation:
            (conversation != null ? conversation.value : this.conversation),
        languagePresets: (languagePresets != null
            ? languagePresets.value
            : this.languagePresets),
        agent: (agent != null ? agent.value : this.agent));
  }
}

@JsonSerializable(explicitToJson: true)
class ConvertChapterResponseModel {
  const ConvertChapterResponseModel({
    required this.status,
  });

  factory ConvertChapterResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ConvertChapterResponseModelFromJson(json);

  static const toJsonFactory = _$ConvertChapterResponseModelToJson;
  Map<String, dynamic> toJson() => _$ConvertChapterResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$ConvertChapterResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConvertChapterResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $ConvertChapterResponseModelExtension on ConvertChapterResponseModel {
  ConvertChapterResponseModel copyWith({String? status}) {
    return ConvertChapterResponseModel(status: status ?? this.status);
  }

  ConvertChapterResponseModel copyWithWrapped({Wrapped<String>? status}) {
    return ConvertChapterResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class ConvertProjectResponseModel {
  const ConvertProjectResponseModel({
    required this.status,
  });

  factory ConvertProjectResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ConvertProjectResponseModelFromJson(json);

  static const toJsonFactory = _$ConvertProjectResponseModelToJson;
  Map<String, dynamic> toJson() => _$ConvertProjectResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$ConvertProjectResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ConvertProjectResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $ConvertProjectResponseModelExtension on ConvertProjectResponseModel {
  ConvertProjectResponseModel copyWith({String? status}) {
    return ConvertProjectResponseModel(status: status ?? this.status);
  }

  ConvertProjectResponseModel copyWithWrapped({Wrapped<String>? status}) {
    return ConvertProjectResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateAgentResponseModel {
  const CreateAgentResponseModel({
    required this.agentId,
  });

  factory CreateAgentResponseModel.fromJson(Map<String, dynamic> json) =>
      _$CreateAgentResponseModelFromJson(json);

  static const toJsonFactory = _$CreateAgentResponseModelToJson;
  Map<String, dynamic> toJson() => _$CreateAgentResponseModelToJson(this);

  @JsonKey(name: 'agent_id')
  final String agentId;
  static const fromJsonFactory = _$CreateAgentResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateAgentResponseModel &&
            (identical(other.agentId, agentId) ||
                const DeepCollectionEquality().equals(other.agentId, agentId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(agentId) ^ runtimeType.hashCode;
}

extension $CreateAgentResponseModelExtension on CreateAgentResponseModel {
  CreateAgentResponseModel copyWith({String? agentId}) {
    return CreateAgentResponseModel(agentId: agentId ?? this.agentId);
  }

  CreateAgentResponseModel copyWithWrapped({Wrapped<String>? agentId}) {
    return CreateAgentResponseModel(
        agentId: (agentId != null ? agentId.value : this.agentId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePhoneNumberResponseModel {
  const CreatePhoneNumberResponseModel({
    required this.phoneNumberId,
  });

  factory CreatePhoneNumberResponseModel.fromJson(Map<String, dynamic> json) =>
      _$CreatePhoneNumberResponseModelFromJson(json);

  static const toJsonFactory = _$CreatePhoneNumberResponseModelToJson;
  Map<String, dynamic> toJson() => _$CreatePhoneNumberResponseModelToJson(this);

  @JsonKey(name: 'phone_number_id')
  final String phoneNumberId;
  static const fromJsonFactory = _$CreatePhoneNumberResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePhoneNumberResponseModel &&
            (identical(other.phoneNumberId, phoneNumberId) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumberId, phoneNumberId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(phoneNumberId) ^ runtimeType.hashCode;
}

extension $CreatePhoneNumberResponseModelExtension
    on CreatePhoneNumberResponseModel {
  CreatePhoneNumberResponseModel copyWith({String? phoneNumberId}) {
    return CreatePhoneNumberResponseModel(
        phoneNumberId: phoneNumberId ?? this.phoneNumberId);
  }

  CreatePhoneNumberResponseModel copyWithWrapped(
      {Wrapped<String>? phoneNumberId}) {
    return CreatePhoneNumberResponseModel(
        phoneNumberId:
            (phoneNumberId != null ? phoneNumberId.value : this.phoneNumberId));
  }
}

@JsonSerializable(explicitToJson: true)
class CreatePronunciationDictionaryResponseModel {
  const CreatePronunciationDictionaryResponseModel({
    required this.status,
  });

  factory CreatePronunciationDictionaryResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$CreatePronunciationDictionaryResponseModelFromJson(json);

  static const toJsonFactory =
      _$CreatePronunciationDictionaryResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$CreatePronunciationDictionaryResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory =
      _$CreatePronunciationDictionaryResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreatePronunciationDictionaryResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $CreatePronunciationDictionaryResponseModelExtension
    on CreatePronunciationDictionaryResponseModel {
  CreatePronunciationDictionaryResponseModel copyWith({String? status}) {
    return CreatePronunciationDictionaryResponseModel(
        status: status ?? this.status);
  }

  CreatePronunciationDictionaryResponseModel copyWithWrapped(
      {Wrapped<String>? status}) {
    return CreatePronunciationDictionaryResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateSIPTrunkPhoneNumberRequest {
  const CreateSIPTrunkPhoneNumberRequest({
    required this.phoneNumber,
    required this.label,
    this.provider,
    required this.terminationUri,
    this.address,
    this.transport,
    this.mediaEncryption,
    this.headers,
    this.credentials,
  });

  factory CreateSIPTrunkPhoneNumberRequest.fromJson(
          Map<String, dynamic> json) =>
      _$CreateSIPTrunkPhoneNumberRequestFromJson(json);

  static const toJsonFactory = _$CreateSIPTrunkPhoneNumberRequestToJson;
  Map<String, dynamic> toJson() =>
      _$CreateSIPTrunkPhoneNumberRequestToJson(this);

  @JsonKey(name: 'phone_number')
  final String phoneNumber;
  @JsonKey(name: 'label')
  final String label;
  @JsonKey(name: 'provider')
  final String? provider;
  @JsonKey(name: 'termination_uri')
  final String terminationUri;
  @JsonKey(name: 'address')
  final dynamic address;
  @JsonKey(
    name: 'transport',
    toJson: sIPTrunkTransportEnumNullableToJson,
    fromJson: sIPTrunkTransportEnumTransportNullableFromJson,
  )
  final enums.SIPTrunkTransportEnum? transport;
  static enums.SIPTrunkTransportEnum?
      sIPTrunkTransportEnumTransportNullableFromJson(Object? value) =>
          sIPTrunkTransportEnumNullableFromJson(
              value, enums.SIPTrunkTransportEnum.auto);

  @JsonKey(
    name: 'media_encryption',
    toJson: sIPMediaEncryptionEnumNullableToJson,
    fromJson: sIPMediaEncryptionEnumMediaEncryptionNullableFromJson,
  )
  final enums.SIPMediaEncryptionEnum? mediaEncryption;
  static enums.SIPMediaEncryptionEnum?
      sIPMediaEncryptionEnumMediaEncryptionNullableFromJson(Object? value) =>
          sIPMediaEncryptionEnumNullableFromJson(
              value, enums.SIPMediaEncryptionEnum.allowed);

  @JsonKey(name: 'headers')
  final Map<String, dynamic>? headers;
  @JsonKey(name: 'credentials')
  final dynamic credentials;
  static const fromJsonFactory = _$CreateSIPTrunkPhoneNumberRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateSIPTrunkPhoneNumberRequest &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.provider, provider) ||
                const DeepCollectionEquality()
                    .equals(other.provider, provider)) &&
            (identical(other.terminationUri, terminationUri) ||
                const DeepCollectionEquality()
                    .equals(other.terminationUri, terminationUri)) &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.transport, transport) ||
                const DeepCollectionEquality()
                    .equals(other.transport, transport)) &&
            (identical(other.mediaEncryption, mediaEncryption) ||
                const DeepCollectionEquality()
                    .equals(other.mediaEncryption, mediaEncryption)) &&
            (identical(other.headers, headers) ||
                const DeepCollectionEquality()
                    .equals(other.headers, headers)) &&
            (identical(other.credentials, credentials) ||
                const DeepCollectionEquality()
                    .equals(other.credentials, credentials)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(provider) ^
      const DeepCollectionEquality().hash(terminationUri) ^
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(transport) ^
      const DeepCollectionEquality().hash(mediaEncryption) ^
      const DeepCollectionEquality().hash(headers) ^
      const DeepCollectionEquality().hash(credentials) ^
      runtimeType.hashCode;
}

extension $CreateSIPTrunkPhoneNumberRequestExtension
    on CreateSIPTrunkPhoneNumberRequest {
  CreateSIPTrunkPhoneNumberRequest copyWith(
      {String? phoneNumber,
      String? label,
      String? provider,
      String? terminationUri,
      dynamic address,
      enums.SIPTrunkTransportEnum? transport,
      enums.SIPMediaEncryptionEnum? mediaEncryption,
      Map<String, dynamic>? headers,
      dynamic credentials}) {
    return CreateSIPTrunkPhoneNumberRequest(
        phoneNumber: phoneNumber ?? this.phoneNumber,
        label: label ?? this.label,
        provider: provider ?? this.provider,
        terminationUri: terminationUri ?? this.terminationUri,
        address: address ?? this.address,
        transport: transport ?? this.transport,
        mediaEncryption: mediaEncryption ?? this.mediaEncryption,
        headers: headers ?? this.headers,
        credentials: credentials ?? this.credentials);
  }

  CreateSIPTrunkPhoneNumberRequest copyWithWrapped(
      {Wrapped<String>? phoneNumber,
      Wrapped<String>? label,
      Wrapped<String?>? provider,
      Wrapped<String>? terminationUri,
      Wrapped<dynamic>? address,
      Wrapped<enums.SIPTrunkTransportEnum?>? transport,
      Wrapped<enums.SIPMediaEncryptionEnum?>? mediaEncryption,
      Wrapped<Map<String, dynamic>?>? headers,
      Wrapped<dynamic>? credentials}) {
    return CreateSIPTrunkPhoneNumberRequest(
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        label: (label != null ? label.value : this.label),
        provider: (provider != null ? provider.value : this.provider),
        terminationUri: (terminationUri != null
            ? terminationUri.value
            : this.terminationUri),
        address: (address != null ? address.value : this.address),
        transport: (transport != null ? transport.value : this.transport),
        mediaEncryption: (mediaEncryption != null
            ? mediaEncryption.value
            : this.mediaEncryption),
        headers: (headers != null ? headers.value : this.headers),
        credentials:
            (credentials != null ? credentials.value : this.credentials));
  }
}

@JsonSerializable(explicitToJson: true)
class CreateTwilioPhoneNumberRequest {
  const CreateTwilioPhoneNumberRequest({
    required this.phoneNumber,
    required this.label,
    this.provider,
    required this.sid,
    required this.token,
  });

  factory CreateTwilioPhoneNumberRequest.fromJson(Map<String, dynamic> json) =>
      _$CreateTwilioPhoneNumberRequestFromJson(json);

  static const toJsonFactory = _$CreateTwilioPhoneNumberRequestToJson;
  Map<String, dynamic> toJson() => _$CreateTwilioPhoneNumberRequestToJson(this);

  @JsonKey(name: 'phone_number')
  final String phoneNumber;
  @JsonKey(name: 'label')
  final String label;
  @JsonKey(name: 'provider')
  final String? provider;
  @JsonKey(name: 'sid')
  final String sid;
  @JsonKey(name: 'token')
  final String token;
  static const fromJsonFactory = _$CreateTwilioPhoneNumberRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CreateTwilioPhoneNumberRequest &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.provider, provider) ||
                const DeepCollectionEquality()
                    .equals(other.provider, provider)) &&
            (identical(other.sid, sid) ||
                const DeepCollectionEquality().equals(other.sid, sid)) &&
            (identical(other.token, token) ||
                const DeepCollectionEquality().equals(other.token, token)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(provider) ^
      const DeepCollectionEquality().hash(sid) ^
      const DeepCollectionEquality().hash(token) ^
      runtimeType.hashCode;
}

extension $CreateTwilioPhoneNumberRequestExtension
    on CreateTwilioPhoneNumberRequest {
  CreateTwilioPhoneNumberRequest copyWith(
      {String? phoneNumber,
      String? label,
      String? provider,
      String? sid,
      String? token}) {
    return CreateTwilioPhoneNumberRequest(
        phoneNumber: phoneNumber ?? this.phoneNumber,
        label: label ?? this.label,
        provider: provider ?? this.provider,
        sid: sid ?? this.sid,
        token: token ?? this.token);
  }

  CreateTwilioPhoneNumberRequest copyWithWrapped(
      {Wrapped<String>? phoneNumber,
      Wrapped<String>? label,
      Wrapped<String?>? provider,
      Wrapped<String>? sid,
      Wrapped<String>? token}) {
    return CreateTwilioPhoneNumberRequest(
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        label: (label != null ? label.value : this.label),
        provider: (provider != null ? provider.value : this.provider),
        sid: (sid != null ? sid.value : this.sid),
        token: (token != null ? token.value : this.token));
  }
}

@JsonSerializable(explicitToJson: true)
class CustomLLM {
  const CustomLLM({
    required this.url,
    this.modelId,
    this.apiKey,
  });

  factory CustomLLM.fromJson(Map<String, dynamic> json) =>
      _$CustomLLMFromJson(json);

  static const toJsonFactory = _$CustomLLMToJson;
  Map<String, dynamic> toJson() => _$CustomLLMToJson(this);

  @JsonKey(name: 'url')
  final String url;
  @JsonKey(name: 'model_id')
  final dynamic modelId;
  @JsonKey(name: 'api_key')
  final dynamic apiKey;
  static const fromJsonFactory = _$CustomLLMFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is CustomLLM &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.apiKey, apiKey) ||
                const DeepCollectionEquality().equals(other.apiKey, apiKey)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(apiKey) ^
      runtimeType.hashCode;
}

extension $CustomLLMExtension on CustomLLM {
  CustomLLM copyWith({String? url, dynamic modelId, dynamic apiKey}) {
    return CustomLLM(
        url: url ?? this.url,
        modelId: modelId ?? this.modelId,
        apiKey: apiKey ?? this.apiKey);
  }

  CustomLLM copyWithWrapped(
      {Wrapped<String>? url,
      Wrapped<dynamic>? modelId,
      Wrapped<dynamic>? apiKey}) {
    return CustomLLM(
        url: (url != null ? url.value : this.url),
        modelId: (modelId != null ? modelId.value : this.modelId),
        apiKey: (apiKey != null ? apiKey.value : this.apiKey));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardCallSuccessChartModel {
  const DashboardCallSuccessChartModel({
    required this.name,
    this.type,
  });

  factory DashboardCallSuccessChartModel.fromJson(Map<String, dynamic> json) =>
      _$DashboardCallSuccessChartModelFromJson(json);

  static const toJsonFactory = _$DashboardCallSuccessChartModelToJson;
  Map<String, dynamic> toJson() => _$DashboardCallSuccessChartModelToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'type')
  final String? type;
  static const fromJsonFactory = _$DashboardCallSuccessChartModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardCallSuccessChartModel &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $DashboardCallSuccessChartModelExtension
    on DashboardCallSuccessChartModel {
  DashboardCallSuccessChartModel copyWith({String? name, String? type}) {
    return DashboardCallSuccessChartModel(
        name: name ?? this.name, type: type ?? this.type);
  }

  DashboardCallSuccessChartModel copyWithWrapped(
      {Wrapped<String>? name, Wrapped<String?>? type}) {
    return DashboardCallSuccessChartModel(
        name: (name != null ? name.value : this.name),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardCriteriaChartModel {
  const DashboardCriteriaChartModel({
    required this.name,
    this.type,
    required this.criteriaId,
  });

  factory DashboardCriteriaChartModel.fromJson(Map<String, dynamic> json) =>
      _$DashboardCriteriaChartModelFromJson(json);

  static const toJsonFactory = _$DashboardCriteriaChartModelToJson;
  Map<String, dynamic> toJson() => _$DashboardCriteriaChartModelToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'criteria_id')
  final String criteriaId;
  static const fromJsonFactory = _$DashboardCriteriaChartModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardCriteriaChartModel &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.criteriaId, criteriaId) ||
                const DeepCollectionEquality()
                    .equals(other.criteriaId, criteriaId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(criteriaId) ^
      runtimeType.hashCode;
}

extension $DashboardCriteriaChartModelExtension on DashboardCriteriaChartModel {
  DashboardCriteriaChartModel copyWith(
      {String? name, String? type, String? criteriaId}) {
    return DashboardCriteriaChartModel(
        name: name ?? this.name,
        type: type ?? this.type,
        criteriaId: criteriaId ?? this.criteriaId);
  }

  DashboardCriteriaChartModel copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? type,
      Wrapped<String>? criteriaId}) {
    return DashboardCriteriaChartModel(
        name: (name != null ? name.value : this.name),
        type: (type != null ? type.value : this.type),
        criteriaId: (criteriaId != null ? criteriaId.value : this.criteriaId));
  }
}

@JsonSerializable(explicitToJson: true)
class DashboardDataCollectionChartModel {
  const DashboardDataCollectionChartModel({
    required this.name,
    this.type,
    required this.dataCollectionId,
  });

  factory DashboardDataCollectionChartModel.fromJson(
          Map<String, dynamic> json) =>
      _$DashboardDataCollectionChartModelFromJson(json);

  static const toJsonFactory = _$DashboardDataCollectionChartModelToJson;
  Map<String, dynamic> toJson() =>
      _$DashboardDataCollectionChartModelToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'data_collection_id')
  final String dataCollectionId;
  static const fromJsonFactory = _$DashboardDataCollectionChartModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DashboardDataCollectionChartModel &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.dataCollectionId, dataCollectionId) ||
                const DeepCollectionEquality()
                    .equals(other.dataCollectionId, dataCollectionId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(dataCollectionId) ^
      runtimeType.hashCode;
}

extension $DashboardDataCollectionChartModelExtension
    on DashboardDataCollectionChartModel {
  DashboardDataCollectionChartModel copyWith(
      {String? name, String? type, String? dataCollectionId}) {
    return DashboardDataCollectionChartModel(
        name: name ?? this.name,
        type: type ?? this.type,
        dataCollectionId: dataCollectionId ?? this.dataCollectionId);
  }

  DashboardDataCollectionChartModel copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String?>? type,
      Wrapped<String>? dataCollectionId}) {
    return DashboardDataCollectionChartModel(
        name: (name != null ? name.value : this.name),
        type: (type != null ? type.value : this.type),
        dataCollectionId: (dataCollectionId != null
            ? dataCollectionId.value
            : this.dataCollectionId));
  }
}

@JsonSerializable(explicitToJson: true)
class DataCollectionResultCommonModel {
  const DataCollectionResultCommonModel({
    required this.dataCollectionId,
    this.$value,
    this.jsonSchema,
    required this.rationale,
  });

  factory DataCollectionResultCommonModel.fromJson(Map<String, dynamic> json) =>
      _$DataCollectionResultCommonModelFromJson(json);

  static const toJsonFactory = _$DataCollectionResultCommonModelToJson;
  Map<String, dynamic> toJson() =>
      _$DataCollectionResultCommonModelToJson(this);

  @JsonKey(name: 'data_collection_id')
  final String dataCollectionId;
  @JsonKey(name: 'value')
  final dynamic $value;
  @JsonKey(name: 'json_schema')
  final dynamic jsonSchema;
  @JsonKey(name: 'rationale')
  final String rationale;
  static const fromJsonFactory = _$DataCollectionResultCommonModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DataCollectionResultCommonModel &&
            (identical(other.dataCollectionId, dataCollectionId) ||
                const DeepCollectionEquality()
                    .equals(other.dataCollectionId, dataCollectionId)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)) &&
            (identical(other.jsonSchema, jsonSchema) ||
                const DeepCollectionEquality()
                    .equals(other.jsonSchema, jsonSchema)) &&
            (identical(other.rationale, rationale) ||
                const DeepCollectionEquality()
                    .equals(other.rationale, rationale)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dataCollectionId) ^
      const DeepCollectionEquality().hash($value) ^
      const DeepCollectionEquality().hash(jsonSchema) ^
      const DeepCollectionEquality().hash(rationale) ^
      runtimeType.hashCode;
}

extension $DataCollectionResultCommonModelExtension
    on DataCollectionResultCommonModel {
  DataCollectionResultCommonModel copyWith(
      {String? dataCollectionId,
      dynamic $value,
      dynamic jsonSchema,
      String? rationale}) {
    return DataCollectionResultCommonModel(
        dataCollectionId: dataCollectionId ?? this.dataCollectionId,
        $value: $value ?? this.$value,
        jsonSchema: jsonSchema ?? this.jsonSchema,
        rationale: rationale ?? this.rationale);
  }

  DataCollectionResultCommonModel copyWithWrapped(
      {Wrapped<String>? dataCollectionId,
      Wrapped<dynamic>? $value,
      Wrapped<dynamic>? jsonSchema,
      Wrapped<String>? rationale}) {
    return DataCollectionResultCommonModel(
        dataCollectionId: (dataCollectionId != null
            ? dataCollectionId.value
            : this.dataCollectionId),
        $value: ($value != null ? $value.value : this.$value),
        jsonSchema: (jsonSchema != null ? jsonSchema.value : this.jsonSchema),
        rationale: (rationale != null ? rationale.value : this.rationale));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteChapterResponseModel {
  const DeleteChapterResponseModel({
    required this.status,
  });

  factory DeleteChapterResponseModel.fromJson(Map<String, dynamic> json) =>
      _$DeleteChapterResponseModelFromJson(json);

  static const toJsonFactory = _$DeleteChapterResponseModelToJson;
  Map<String, dynamic> toJson() => _$DeleteChapterResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$DeleteChapterResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteChapterResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $DeleteChapterResponseModelExtension on DeleteChapterResponseModel {
  DeleteChapterResponseModel copyWith({String? status}) {
    return DeleteChapterResponseModel(status: status ?? this.status);
  }

  DeleteChapterResponseModel copyWithWrapped({Wrapped<String>? status}) {
    return DeleteChapterResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteDubbingResponseModel {
  const DeleteDubbingResponseModel({
    required this.status,
  });

  factory DeleteDubbingResponseModel.fromJson(Map<String, dynamic> json) =>
      _$DeleteDubbingResponseModelFromJson(json);

  static const toJsonFactory = _$DeleteDubbingResponseModelToJson;
  Map<String, dynamic> toJson() => _$DeleteDubbingResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$DeleteDubbingResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteDubbingResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $DeleteDubbingResponseModelExtension on DeleteDubbingResponseModel {
  DeleteDubbingResponseModel copyWith({String? status}) {
    return DeleteDubbingResponseModel(status: status ?? this.status);
  }

  DeleteDubbingResponseModel copyWithWrapped({Wrapped<String>? status}) {
    return DeleteDubbingResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteHistoryItemResponse {
  const DeleteHistoryItemResponse({
    required this.status,
  });

  factory DeleteHistoryItemResponse.fromJson(Map<String, dynamic> json) =>
      _$DeleteHistoryItemResponseFromJson(json);

  static const toJsonFactory = _$DeleteHistoryItemResponseToJson;
  Map<String, dynamic> toJson() => _$DeleteHistoryItemResponseToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$DeleteHistoryItemResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteHistoryItemResponse &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $DeleteHistoryItemResponseExtension on DeleteHistoryItemResponse {
  DeleteHistoryItemResponse copyWith({String? status}) {
    return DeleteHistoryItemResponse(status: status ?? this.status);
  }

  DeleteHistoryItemResponse copyWithWrapped({Wrapped<String>? status}) {
    return DeleteHistoryItemResponse(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteProjectResponseModel {
  const DeleteProjectResponseModel({
    required this.status,
  });

  factory DeleteProjectResponseModel.fromJson(Map<String, dynamic> json) =>
      _$DeleteProjectResponseModelFromJson(json);

  static const toJsonFactory = _$DeleteProjectResponseModelToJson;
  Map<String, dynamic> toJson() => _$DeleteProjectResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$DeleteProjectResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteProjectResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $DeleteProjectResponseModelExtension on DeleteProjectResponseModel {
  DeleteProjectResponseModel copyWith({String? status}) {
    return DeleteProjectResponseModel(status: status ?? this.status);
  }

  DeleteProjectResponseModel copyWithWrapped({Wrapped<String>? status}) {
    return DeleteProjectResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteSampleResponseModel {
  const DeleteSampleResponseModel({
    required this.status,
  });

  factory DeleteSampleResponseModel.fromJson(Map<String, dynamic> json) =>
      _$DeleteSampleResponseModelFromJson(json);

  static const toJsonFactory = _$DeleteSampleResponseModelToJson;
  Map<String, dynamic> toJson() => _$DeleteSampleResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$DeleteSampleResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteSampleResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $DeleteSampleResponseModelExtension on DeleteSampleResponseModel {
  DeleteSampleResponseModel copyWith({String? status}) {
    return DeleteSampleResponseModel(status: status ?? this.status);
  }

  DeleteSampleResponseModel copyWithWrapped({Wrapped<String>? status}) {
    return DeleteSampleResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteVoiceResponseModel {
  const DeleteVoiceResponseModel({
    required this.status,
  });

  factory DeleteVoiceResponseModel.fromJson(Map<String, dynamic> json) =>
      _$DeleteVoiceResponseModelFromJson(json);

  static const toJsonFactory = _$DeleteVoiceResponseModelToJson;
  Map<String, dynamic> toJson() => _$DeleteVoiceResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$DeleteVoiceResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteVoiceResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $DeleteVoiceResponseModelExtension on DeleteVoiceResponseModel {
  DeleteVoiceResponseModel copyWith({String? status}) {
    return DeleteVoiceResponseModel(status: status ?? this.status);
  }

  DeleteVoiceResponseModel copyWithWrapped({Wrapped<String>? status}) {
    return DeleteVoiceResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteVoiceSampleResponseModel {
  const DeleteVoiceSampleResponseModel({
    required this.status,
  });

  factory DeleteVoiceSampleResponseModel.fromJson(Map<String, dynamic> json) =>
      _$DeleteVoiceSampleResponseModelFromJson(json);

  static const toJsonFactory = _$DeleteVoiceSampleResponseModelToJson;
  Map<String, dynamic> toJson() => _$DeleteVoiceSampleResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$DeleteVoiceSampleResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteVoiceSampleResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $DeleteVoiceSampleResponseModelExtension
    on DeleteVoiceSampleResponseModel {
  DeleteVoiceSampleResponseModel copyWith({String? status}) {
    return DeleteVoiceSampleResponseModel(status: status ?? this.status);
  }

  DeleteVoiceSampleResponseModel copyWithWrapped({Wrapped<String>? status}) {
    return DeleteVoiceSampleResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteWorkspaceGroupMemberResponseModel {
  const DeleteWorkspaceGroupMemberResponseModel({
    required this.status,
  });

  factory DeleteWorkspaceGroupMemberResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$DeleteWorkspaceGroupMemberResponseModelFromJson(json);

  static const toJsonFactory = _$DeleteWorkspaceGroupMemberResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$DeleteWorkspaceGroupMemberResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory =
      _$DeleteWorkspaceGroupMemberResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteWorkspaceGroupMemberResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $DeleteWorkspaceGroupMemberResponseModelExtension
    on DeleteWorkspaceGroupMemberResponseModel {
  DeleteWorkspaceGroupMemberResponseModel copyWith({String? status}) {
    return DeleteWorkspaceGroupMemberResponseModel(
        status: status ?? this.status);
  }

  DeleteWorkspaceGroupMemberResponseModel copyWithWrapped(
      {Wrapped<String>? status}) {
    return DeleteWorkspaceGroupMemberResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteWorkspaceInviteResponseModel {
  const DeleteWorkspaceInviteResponseModel({
    required this.status,
  });

  factory DeleteWorkspaceInviteResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$DeleteWorkspaceInviteResponseModelFromJson(json);

  static const toJsonFactory = _$DeleteWorkspaceInviteResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$DeleteWorkspaceInviteResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$DeleteWorkspaceInviteResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteWorkspaceInviteResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $DeleteWorkspaceInviteResponseModelExtension
    on DeleteWorkspaceInviteResponseModel {
  DeleteWorkspaceInviteResponseModel copyWith({String? status}) {
    return DeleteWorkspaceInviteResponseModel(status: status ?? this.status);
  }

  DeleteWorkspaceInviteResponseModel copyWithWrapped(
      {Wrapped<String>? status}) {
    return DeleteWorkspaceInviteResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class DeleteWorkspaceMemberResponseModel {
  const DeleteWorkspaceMemberResponseModel({
    required this.status,
  });

  factory DeleteWorkspaceMemberResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$DeleteWorkspaceMemberResponseModelFromJson(json);

  static const toJsonFactory = _$DeleteWorkspaceMemberResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$DeleteWorkspaceMemberResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$DeleteWorkspaceMemberResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DeleteWorkspaceMemberResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $DeleteWorkspaceMemberResponseModelExtension
    on DeleteWorkspaceMemberResponseModel {
  DeleteWorkspaceMemberResponseModel copyWith({String? status}) {
    return DeleteWorkspaceMemberResponseModel(status: status ?? this.status);
  }

  DeleteWorkspaceMemberResponseModel copyWithWrapped(
      {Wrapped<String>? status}) {
    return DeleteWorkspaceMemberResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class DependentAvailableAgentIdentifier {
  const DependentAvailableAgentIdentifier({
    required this.id,
    required this.name,
    this.type,
    required this.createdAtUnixSecs,
    required this.accessLevel,
  });

  factory DependentAvailableAgentIdentifier.fromJson(
          Map<String, dynamic> json) =>
      _$DependentAvailableAgentIdentifierFromJson(json);

  static const toJsonFactory = _$DependentAvailableAgentIdentifierToJson;
  Map<String, dynamic> toJson() =>
      _$DependentAvailableAgentIdentifierToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'created_at_unix_secs')
  final int createdAtUnixSecs;
  @JsonKey(
    name: 'access_level',
    toJson: dependentAvailableAgentIdentifierAccessLevelToJson,
    fromJson: dependentAvailableAgentIdentifierAccessLevelFromJson,
  )
  final enums.DependentAvailableAgentIdentifierAccessLevel accessLevel;
  static const fromJsonFactory = _$DependentAvailableAgentIdentifierFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DependentAvailableAgentIdentifier &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.createdAtUnixSecs, createdAtUnixSecs) ||
                const DeepCollectionEquality()
                    .equals(other.createdAtUnixSecs, createdAtUnixSecs)) &&
            (identical(other.accessLevel, accessLevel) ||
                const DeepCollectionEquality()
                    .equals(other.accessLevel, accessLevel)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(createdAtUnixSecs) ^
      const DeepCollectionEquality().hash(accessLevel) ^
      runtimeType.hashCode;
}

extension $DependentAvailableAgentIdentifierExtension
    on DependentAvailableAgentIdentifier {
  DependentAvailableAgentIdentifier copyWith(
      {String? id,
      String? name,
      String? type,
      int? createdAtUnixSecs,
      enums.DependentAvailableAgentIdentifierAccessLevel? accessLevel}) {
    return DependentAvailableAgentIdentifier(
        id: id ?? this.id,
        name: name ?? this.name,
        type: type ?? this.type,
        createdAtUnixSecs: createdAtUnixSecs ?? this.createdAtUnixSecs,
        accessLevel: accessLevel ?? this.accessLevel);
  }

  DependentAvailableAgentIdentifier copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? name,
      Wrapped<String?>? type,
      Wrapped<int>? createdAtUnixSecs,
      Wrapped<enums.DependentAvailableAgentIdentifierAccessLevel>?
          accessLevel}) {
    return DependentAvailableAgentIdentifier(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        type: (type != null ? type.value : this.type),
        createdAtUnixSecs: (createdAtUnixSecs != null
            ? createdAtUnixSecs.value
            : this.createdAtUnixSecs),
        accessLevel:
            (accessLevel != null ? accessLevel.value : this.accessLevel));
  }
}

@JsonSerializable(explicitToJson: true)
class DependentAvailableAgentToolIdentifier {
  const DependentAvailableAgentToolIdentifier({
    required this.agentId,
    required this.agentName,
    required this.usedBy,
    this.type,
    required this.createdAtUnixSecs,
    required this.accessLevel,
  });

  factory DependentAvailableAgentToolIdentifier.fromJson(
          Map<String, dynamic> json) =>
      _$DependentAvailableAgentToolIdentifierFromJson(json);

  static const toJsonFactory = _$DependentAvailableAgentToolIdentifierToJson;
  Map<String, dynamic> toJson() =>
      _$DependentAvailableAgentToolIdentifierToJson(this);

  @JsonKey(name: 'agent_id')
  final String agentId;
  @JsonKey(name: 'agent_name')
  final String agentName;
  @JsonKey(name: 'used_by', defaultValue: <String>[])
  final List<String> usedBy;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'created_at_unix_secs')
  final int createdAtUnixSecs;
  @JsonKey(
    name: 'access_level',
    toJson: dependentAvailableAgentToolIdentifierAccessLevelToJson,
    fromJson: dependentAvailableAgentToolIdentifierAccessLevelFromJson,
  )
  final enums.DependentAvailableAgentToolIdentifierAccessLevel accessLevel;
  static const fromJsonFactory =
      _$DependentAvailableAgentToolIdentifierFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DependentAvailableAgentToolIdentifier &&
            (identical(other.agentId, agentId) ||
                const DeepCollectionEquality()
                    .equals(other.agentId, agentId)) &&
            (identical(other.agentName, agentName) ||
                const DeepCollectionEquality()
                    .equals(other.agentName, agentName)) &&
            (identical(other.usedBy, usedBy) ||
                const DeepCollectionEquality().equals(other.usedBy, usedBy)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.createdAtUnixSecs, createdAtUnixSecs) ||
                const DeepCollectionEquality()
                    .equals(other.createdAtUnixSecs, createdAtUnixSecs)) &&
            (identical(other.accessLevel, accessLevel) ||
                const DeepCollectionEquality()
                    .equals(other.accessLevel, accessLevel)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(agentId) ^
      const DeepCollectionEquality().hash(agentName) ^
      const DeepCollectionEquality().hash(usedBy) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(createdAtUnixSecs) ^
      const DeepCollectionEquality().hash(accessLevel) ^
      runtimeType.hashCode;
}

extension $DependentAvailableAgentToolIdentifierExtension
    on DependentAvailableAgentToolIdentifier {
  DependentAvailableAgentToolIdentifier copyWith(
      {String? agentId,
      String? agentName,
      List<String>? usedBy,
      String? type,
      int? createdAtUnixSecs,
      enums.DependentAvailableAgentToolIdentifierAccessLevel? accessLevel}) {
    return DependentAvailableAgentToolIdentifier(
        agentId: agentId ?? this.agentId,
        agentName: agentName ?? this.agentName,
        usedBy: usedBy ?? this.usedBy,
        type: type ?? this.type,
        createdAtUnixSecs: createdAtUnixSecs ?? this.createdAtUnixSecs,
        accessLevel: accessLevel ?? this.accessLevel);
  }

  DependentAvailableAgentToolIdentifier copyWithWrapped(
      {Wrapped<String>? agentId,
      Wrapped<String>? agentName,
      Wrapped<List<String>>? usedBy,
      Wrapped<String?>? type,
      Wrapped<int>? createdAtUnixSecs,
      Wrapped<enums.DependentAvailableAgentToolIdentifierAccessLevel>?
          accessLevel}) {
    return DependentAvailableAgentToolIdentifier(
        agentId: (agentId != null ? agentId.value : this.agentId),
        agentName: (agentName != null ? agentName.value : this.agentName),
        usedBy: (usedBy != null ? usedBy.value : this.usedBy),
        type: (type != null ? type.value : this.type),
        createdAtUnixSecs: (createdAtUnixSecs != null
            ? createdAtUnixSecs.value
            : this.createdAtUnixSecs),
        accessLevel:
            (accessLevel != null ? accessLevel.value : this.accessLevel));
  }
}

@JsonSerializable(explicitToJson: true)
class DependentAvailableToolIdentifier {
  const DependentAvailableToolIdentifier({
    required this.id,
    required this.name,
    this.type,
    required this.createdAtUnixSecs,
    required this.accessLevel,
  });

  factory DependentAvailableToolIdentifier.fromJson(
          Map<String, dynamic> json) =>
      _$DependentAvailableToolIdentifierFromJson(json);

  static const toJsonFactory = _$DependentAvailableToolIdentifierToJson;
  Map<String, dynamic> toJson() =>
      _$DependentAvailableToolIdentifierToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'created_at_unix_secs')
  final int createdAtUnixSecs;
  @JsonKey(
    name: 'access_level',
    toJson: dependentAvailableToolIdentifierAccessLevelToJson,
    fromJson: dependentAvailableToolIdentifierAccessLevelFromJson,
  )
  final enums.DependentAvailableToolIdentifierAccessLevel accessLevel;
  static const fromJsonFactory = _$DependentAvailableToolIdentifierFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DependentAvailableToolIdentifier &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.createdAtUnixSecs, createdAtUnixSecs) ||
                const DeepCollectionEquality()
                    .equals(other.createdAtUnixSecs, createdAtUnixSecs)) &&
            (identical(other.accessLevel, accessLevel) ||
                const DeepCollectionEquality()
                    .equals(other.accessLevel, accessLevel)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(createdAtUnixSecs) ^
      const DeepCollectionEquality().hash(accessLevel) ^
      runtimeType.hashCode;
}

extension $DependentAvailableToolIdentifierExtension
    on DependentAvailableToolIdentifier {
  DependentAvailableToolIdentifier copyWith(
      {String? id,
      String? name,
      String? type,
      int? createdAtUnixSecs,
      enums.DependentAvailableToolIdentifierAccessLevel? accessLevel}) {
    return DependentAvailableToolIdentifier(
        id: id ?? this.id,
        name: name ?? this.name,
        type: type ?? this.type,
        createdAtUnixSecs: createdAtUnixSecs ?? this.createdAtUnixSecs,
        accessLevel: accessLevel ?? this.accessLevel);
  }

  DependentAvailableToolIdentifier copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? name,
      Wrapped<String?>? type,
      Wrapped<int>? createdAtUnixSecs,
      Wrapped<enums.DependentAvailableToolIdentifierAccessLevel>?
          accessLevel}) {
    return DependentAvailableToolIdentifier(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        type: (type != null ? type.value : this.type),
        createdAtUnixSecs: (createdAtUnixSecs != null
            ? createdAtUnixSecs.value
            : this.createdAtUnixSecs),
        accessLevel:
            (accessLevel != null ? accessLevel.value : this.accessLevel));
  }
}

@JsonSerializable(explicitToJson: true)
class DependentPhoneNumberIdentifier {
  const DependentPhoneNumberIdentifier({
    required this.phoneNumberId,
    required this.phoneNumber,
    required this.label,
    required this.provider,
  });

  factory DependentPhoneNumberIdentifier.fromJson(Map<String, dynamic> json) =>
      _$DependentPhoneNumberIdentifierFromJson(json);

  static const toJsonFactory = _$DependentPhoneNumberIdentifierToJson;
  Map<String, dynamic> toJson() => _$DependentPhoneNumberIdentifierToJson(this);

  @JsonKey(name: 'phone_number_id')
  final String phoneNumberId;
  @JsonKey(name: 'phone_number')
  final String phoneNumber;
  @JsonKey(name: 'label')
  final String label;
  @JsonKey(
    name: 'provider',
    toJson: telephonyProviderToJson,
    fromJson: telephonyProviderFromJson,
  )
  final enums.TelephonyProvider provider;
  static const fromJsonFactory = _$DependentPhoneNumberIdentifierFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DependentPhoneNumberIdentifier &&
            (identical(other.phoneNumberId, phoneNumberId) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumberId, phoneNumberId)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.provider, provider) ||
                const DeepCollectionEquality()
                    .equals(other.provider, provider)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(phoneNumberId) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(provider) ^
      runtimeType.hashCode;
}

extension $DependentPhoneNumberIdentifierExtension
    on DependentPhoneNumberIdentifier {
  DependentPhoneNumberIdentifier copyWith(
      {String? phoneNumberId,
      String? phoneNumber,
      String? label,
      enums.TelephonyProvider? provider}) {
    return DependentPhoneNumberIdentifier(
        phoneNumberId: phoneNumberId ?? this.phoneNumberId,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        label: label ?? this.label,
        provider: provider ?? this.provider);
  }

  DependentPhoneNumberIdentifier copyWithWrapped(
      {Wrapped<String>? phoneNumberId,
      Wrapped<String>? phoneNumber,
      Wrapped<String>? label,
      Wrapped<enums.TelephonyProvider>? provider}) {
    return DependentPhoneNumberIdentifier(
        phoneNumberId:
            (phoneNumberId != null ? phoneNumberId.value : this.phoneNumberId),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        label: (label != null ? label.value : this.label),
        provider: (provider != null ? provider.value : this.provider));
  }
}

@JsonSerializable(explicitToJson: true)
class DependentUnknownAgentIdentifier {
  const DependentUnknownAgentIdentifier({
    this.type,
  });

  factory DependentUnknownAgentIdentifier.fromJson(Map<String, dynamic> json) =>
      _$DependentUnknownAgentIdentifierFromJson(json);

  static const toJsonFactory = _$DependentUnknownAgentIdentifierToJson;
  Map<String, dynamic> toJson() =>
      _$DependentUnknownAgentIdentifierToJson(this);

  @JsonKey(name: 'type')
  final String? type;
  static const fromJsonFactory = _$DependentUnknownAgentIdentifierFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DependentUnknownAgentIdentifier &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^ runtimeType.hashCode;
}

extension $DependentUnknownAgentIdentifierExtension
    on DependentUnknownAgentIdentifier {
  DependentUnknownAgentIdentifier copyWith({String? type}) {
    return DependentUnknownAgentIdentifier(type: type ?? this.type);
  }

  DependentUnknownAgentIdentifier copyWithWrapped({Wrapped<String?>? type}) {
    return DependentUnknownAgentIdentifier(
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class DependentUnknownAgentToolIdentifier {
  const DependentUnknownAgentToolIdentifier({
    this.type,
  });

  factory DependentUnknownAgentToolIdentifier.fromJson(
          Map<String, dynamic> json) =>
      _$DependentUnknownAgentToolIdentifierFromJson(json);

  static const toJsonFactory = _$DependentUnknownAgentToolIdentifierToJson;
  Map<String, dynamic> toJson() =>
      _$DependentUnknownAgentToolIdentifierToJson(this);

  @JsonKey(name: 'type')
  final String? type;
  static const fromJsonFactory = _$DependentUnknownAgentToolIdentifierFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DependentUnknownAgentToolIdentifier &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^ runtimeType.hashCode;
}

extension $DependentUnknownAgentToolIdentifierExtension
    on DependentUnknownAgentToolIdentifier {
  DependentUnknownAgentToolIdentifier copyWith({String? type}) {
    return DependentUnknownAgentToolIdentifier(type: type ?? this.type);
  }

  DependentUnknownAgentToolIdentifier copyWithWrapped(
      {Wrapped<String?>? type}) {
    return DependentUnknownAgentToolIdentifier(
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class DependentUnknownToolIdentifier {
  const DependentUnknownToolIdentifier({
    this.type,
  });

  factory DependentUnknownToolIdentifier.fromJson(Map<String, dynamic> json) =>
      _$DependentUnknownToolIdentifierFromJson(json);

  static const toJsonFactory = _$DependentUnknownToolIdentifierToJson;
  Map<String, dynamic> toJson() => _$DependentUnknownToolIdentifierToJson(this);

  @JsonKey(name: 'type')
  final String? type;
  static const fromJsonFactory = _$DependentUnknownToolIdentifierFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DependentUnknownToolIdentifier &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^ runtimeType.hashCode;
}

extension $DependentUnknownToolIdentifierExtension
    on DependentUnknownToolIdentifier {
  DependentUnknownToolIdentifier copyWith({String? type}) {
    return DependentUnknownToolIdentifier(type: type ?? this.type);
  }

  DependentUnknownToolIdentifier copyWithWrapped({Wrapped<String?>? type}) {
    return DependentUnknownToolIdentifier(
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class DialogueInput {
  const DialogueInput({
    required this.text,
    required this.voiceId,
  });

  factory DialogueInput.fromJson(Map<String, dynamic> json) =>
      _$DialogueInputFromJson(json);

  static const toJsonFactory = _$DialogueInputToJson;
  Map<String, dynamic> toJson() => _$DialogueInputToJson(this);

  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'voice_id')
  final String voiceId;
  static const fromJsonFactory = _$DialogueInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DialogueInput &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.voiceId, voiceId) ||
                const DeepCollectionEquality().equals(other.voiceId, voiceId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(voiceId) ^
      runtimeType.hashCode;
}

extension $DialogueInputExtension on DialogueInput {
  DialogueInput copyWith({String? text, String? voiceId}) {
    return DialogueInput(
        text: text ?? this.text, voiceId: voiceId ?? this.voiceId);
  }

  DialogueInput copyWithWrapped(
      {Wrapped<String>? text, Wrapped<String>? voiceId}) {
    return DialogueInput(
        text: (text != null ? text.value : this.text),
        voiceId: (voiceId != null ? voiceId.value : this.voiceId));
  }
}

@JsonSerializable(explicitToJson: true)
class DialogueInputResponseModel {
  const DialogueInputResponseModel({
    required this.text,
    required this.voiceId,
    required this.voiceName,
  });

  factory DialogueInputResponseModel.fromJson(Map<String, dynamic> json) =>
      _$DialogueInputResponseModelFromJson(json);

  static const toJsonFactory = _$DialogueInputResponseModelToJson;
  Map<String, dynamic> toJson() => _$DialogueInputResponseModelToJson(this);

  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'voice_id')
  final String voiceId;
  @JsonKey(name: 'voice_name')
  final String voiceName;
  static const fromJsonFactory = _$DialogueInputResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DialogueInputResponseModel &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.voiceId, voiceId) ||
                const DeepCollectionEquality()
                    .equals(other.voiceId, voiceId)) &&
            (identical(other.voiceName, voiceName) ||
                const DeepCollectionEquality()
                    .equals(other.voiceName, voiceName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(voiceId) ^
      const DeepCollectionEquality().hash(voiceName) ^
      runtimeType.hashCode;
}

extension $DialogueInputResponseModelExtension on DialogueInputResponseModel {
  DialogueInputResponseModel copyWith(
      {String? text, String? voiceId, String? voiceName}) {
    return DialogueInputResponseModel(
        text: text ?? this.text,
        voiceId: voiceId ?? this.voiceId,
        voiceName: voiceName ?? this.voiceName);
  }

  DialogueInputResponseModel copyWithWrapped(
      {Wrapped<String>? text,
      Wrapped<String>? voiceId,
      Wrapped<String>? voiceName}) {
    return DialogueInputResponseModel(
        text: (text != null ? text.value : this.text),
        voiceId: (voiceId != null ? voiceId.value : this.voiceId),
        voiceName: (voiceName != null ? voiceName.value : this.voiceName));
  }
}

@JsonSerializable(explicitToJson: true)
class DoDubbingResponseModel {
  const DoDubbingResponseModel({
    required this.dubbingId,
    required this.expectedDurationSec,
  });

  factory DoDubbingResponseModel.fromJson(Map<String, dynamic> json) =>
      _$DoDubbingResponseModelFromJson(json);

  static const toJsonFactory = _$DoDubbingResponseModelToJson;
  Map<String, dynamic> toJson() => _$DoDubbingResponseModelToJson(this);

  @JsonKey(name: 'dubbing_id')
  final String dubbingId;
  @JsonKey(name: 'expected_duration_sec')
  final double expectedDurationSec;
  static const fromJsonFactory = _$DoDubbingResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DoDubbingResponseModel &&
            (identical(other.dubbingId, dubbingId) ||
                const DeepCollectionEquality()
                    .equals(other.dubbingId, dubbingId)) &&
            (identical(other.expectedDurationSec, expectedDurationSec) ||
                const DeepCollectionEquality()
                    .equals(other.expectedDurationSec, expectedDurationSec)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dubbingId) ^
      const DeepCollectionEquality().hash(expectedDurationSec) ^
      runtimeType.hashCode;
}

extension $DoDubbingResponseModelExtension on DoDubbingResponseModel {
  DoDubbingResponseModel copyWith(
      {String? dubbingId, double? expectedDurationSec}) {
    return DoDubbingResponseModel(
        dubbingId: dubbingId ?? this.dubbingId,
        expectedDurationSec: expectedDurationSec ?? this.expectedDurationSec);
  }

  DoDubbingResponseModel copyWithWrapped(
      {Wrapped<String>? dubbingId, Wrapped<double>? expectedDurationSec}) {
    return DoDubbingResponseModel(
        dubbingId: (dubbingId != null ? dubbingId.value : this.dubbingId),
        expectedDurationSec: (expectedDurationSec != null
            ? expectedDurationSec.value
            : this.expectedDurationSec));
  }
}

@JsonSerializable(explicitToJson: true)
class DocxExportOptions {
  const DocxExportOptions({
    this.includeSpeakers,
    this.includeTimestamps,
    required this.format,
    this.segmentOnSilenceLongerThanS,
    this.maxSegmentDurationS,
    this.maxSegmentChars,
  });

  factory DocxExportOptions.fromJson(Map<String, dynamic> json) =>
      _$DocxExportOptionsFromJson(json);

  static const toJsonFactory = _$DocxExportOptionsToJson;
  Map<String, dynamic> toJson() => _$DocxExportOptionsToJson(this);

  @JsonKey(name: 'include_speakers', defaultValue: true)
  final bool? includeSpeakers;
  @JsonKey(name: 'include_timestamps', defaultValue: true)
  final bool? includeTimestamps;
  @JsonKey(name: 'format')
  final String format;
  @JsonKey(name: 'segment_on_silence_longer_than_s')
  final dynamic segmentOnSilenceLongerThanS;
  @JsonKey(name: 'max_segment_duration_s')
  final dynamic maxSegmentDurationS;
  @JsonKey(name: 'max_segment_chars')
  final dynamic maxSegmentChars;
  static const fromJsonFactory = _$DocxExportOptionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DocxExportOptions &&
            (identical(other.includeSpeakers, includeSpeakers) ||
                const DeepCollectionEquality()
                    .equals(other.includeSpeakers, includeSpeakers)) &&
            (identical(other.includeTimestamps, includeTimestamps) ||
                const DeepCollectionEquality()
                    .equals(other.includeTimestamps, includeTimestamps)) &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)) &&
            (identical(other.segmentOnSilenceLongerThanS,
                    segmentOnSilenceLongerThanS) ||
                const DeepCollectionEquality().equals(
                    other.segmentOnSilenceLongerThanS,
                    segmentOnSilenceLongerThanS)) &&
            (identical(other.maxSegmentDurationS, maxSegmentDurationS) ||
                const DeepCollectionEquality()
                    .equals(other.maxSegmentDurationS, maxSegmentDurationS)) &&
            (identical(other.maxSegmentChars, maxSegmentChars) ||
                const DeepCollectionEquality()
                    .equals(other.maxSegmentChars, maxSegmentChars)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(includeSpeakers) ^
      const DeepCollectionEquality().hash(includeTimestamps) ^
      const DeepCollectionEquality().hash(format) ^
      const DeepCollectionEquality().hash(segmentOnSilenceLongerThanS) ^
      const DeepCollectionEquality().hash(maxSegmentDurationS) ^
      const DeepCollectionEquality().hash(maxSegmentChars) ^
      runtimeType.hashCode;
}

extension $DocxExportOptionsExtension on DocxExportOptions {
  DocxExportOptions copyWith(
      {bool? includeSpeakers,
      bool? includeTimestamps,
      String? format,
      dynamic segmentOnSilenceLongerThanS,
      dynamic maxSegmentDurationS,
      dynamic maxSegmentChars}) {
    return DocxExportOptions(
        includeSpeakers: includeSpeakers ?? this.includeSpeakers,
        includeTimestamps: includeTimestamps ?? this.includeTimestamps,
        format: format ?? this.format,
        segmentOnSilenceLongerThanS:
            segmentOnSilenceLongerThanS ?? this.segmentOnSilenceLongerThanS,
        maxSegmentDurationS: maxSegmentDurationS ?? this.maxSegmentDurationS,
        maxSegmentChars: maxSegmentChars ?? this.maxSegmentChars);
  }

  DocxExportOptions copyWithWrapped(
      {Wrapped<bool?>? includeSpeakers,
      Wrapped<bool?>? includeTimestamps,
      Wrapped<String>? format,
      Wrapped<dynamic>? segmentOnSilenceLongerThanS,
      Wrapped<dynamic>? maxSegmentDurationS,
      Wrapped<dynamic>? maxSegmentChars}) {
    return DocxExportOptions(
        includeSpeakers: (includeSpeakers != null
            ? includeSpeakers.value
            : this.includeSpeakers),
        includeTimestamps: (includeTimestamps != null
            ? includeTimestamps.value
            : this.includeTimestamps),
        format: (format != null ? format.value : this.format),
        segmentOnSilenceLongerThanS: (segmentOnSilenceLongerThanS != null
            ? segmentOnSilenceLongerThanS.value
            : this.segmentOnSilenceLongerThanS),
        maxSegmentDurationS: (maxSegmentDurationS != null
            ? maxSegmentDurationS.value
            : this.maxSegmentDurationS),
        maxSegmentChars: (maxSegmentChars != null
            ? maxSegmentChars.value
            : this.maxSegmentChars));
  }
}

@JsonSerializable(explicitToJson: true)
class DubbedSegment {
  const DubbedSegment({
    required this.startTime,
    required this.endTime,
    required this.text,
    required this.audioStale,
    required this.mediaRef,
  });

  factory DubbedSegment.fromJson(Map<String, dynamic> json) =>
      _$DubbedSegmentFromJson(json);

  static const toJsonFactory = _$DubbedSegmentToJson;
  Map<String, dynamic> toJson() => _$DubbedSegmentToJson(this);

  @JsonKey(name: 'start_time')
  final double startTime;
  @JsonKey(name: 'end_time')
  final double endTime;
  @JsonKey(name: 'text')
  final dynamic text;
  @JsonKey(name: 'audio_stale')
  final bool audioStale;
  @JsonKey(name: 'media_ref')
  final dynamic mediaRef;
  static const fromJsonFactory = _$DubbedSegmentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DubbedSegment &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality()
                    .equals(other.startTime, startTime)) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality()
                    .equals(other.endTime, endTime)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.audioStale, audioStale) ||
                const DeepCollectionEquality()
                    .equals(other.audioStale, audioStale)) &&
            (identical(other.mediaRef, mediaRef) ||
                const DeepCollectionEquality()
                    .equals(other.mediaRef, mediaRef)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(audioStale) ^
      const DeepCollectionEquality().hash(mediaRef) ^
      runtimeType.hashCode;
}

extension $DubbedSegmentExtension on DubbedSegment {
  DubbedSegment copyWith(
      {double? startTime,
      double? endTime,
      dynamic text,
      bool? audioStale,
      dynamic mediaRef}) {
    return DubbedSegment(
        startTime: startTime ?? this.startTime,
        endTime: endTime ?? this.endTime,
        text: text ?? this.text,
        audioStale: audioStale ?? this.audioStale,
        mediaRef: mediaRef ?? this.mediaRef);
  }

  DubbedSegment copyWithWrapped(
      {Wrapped<double>? startTime,
      Wrapped<double>? endTime,
      Wrapped<dynamic>? text,
      Wrapped<bool>? audioStale,
      Wrapped<dynamic>? mediaRef}) {
    return DubbedSegment(
        startTime: (startTime != null ? startTime.value : this.startTime),
        endTime: (endTime != null ? endTime.value : this.endTime),
        text: (text != null ? text.value : this.text),
        audioStale: (audioStale != null ? audioStale.value : this.audioStale),
        mediaRef: (mediaRef != null ? mediaRef.value : this.mediaRef));
  }
}

@JsonSerializable(explicitToJson: true)
class DubbingMediaMetadata {
  const DubbingMediaMetadata({
    required this.contentType,
    required this.duration,
  });

  factory DubbingMediaMetadata.fromJson(Map<String, dynamic> json) =>
      _$DubbingMediaMetadataFromJson(json);

  static const toJsonFactory = _$DubbingMediaMetadataToJson;
  Map<String, dynamic> toJson() => _$DubbingMediaMetadataToJson(this);

  @JsonKey(name: 'content_type')
  final String contentType;
  @JsonKey(name: 'duration')
  final double duration;
  static const fromJsonFactory = _$DubbingMediaMetadataFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DubbingMediaMetadata &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality()
                    .equals(other.contentType, contentType)) &&
            (identical(other.duration, duration) ||
                const DeepCollectionEquality()
                    .equals(other.duration, duration)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(duration) ^
      runtimeType.hashCode;
}

extension $DubbingMediaMetadataExtension on DubbingMediaMetadata {
  DubbingMediaMetadata copyWith({String? contentType, double? duration}) {
    return DubbingMediaMetadata(
        contentType: contentType ?? this.contentType,
        duration: duration ?? this.duration);
  }

  DubbingMediaMetadata copyWithWrapped(
      {Wrapped<String>? contentType, Wrapped<double>? duration}) {
    return DubbingMediaMetadata(
        contentType:
            (contentType != null ? contentType.value : this.contentType),
        duration: (duration != null ? duration.value : this.duration));
  }
}

@JsonSerializable(explicitToJson: true)
class DubbingMediaReference {
  const DubbingMediaReference({
    required this.src,
    required this.contentType,
    required this.bucketName,
    required this.randomPathSlug,
    required this.durationSecs,
    required this.isAudio,
    required this.url,
  });

  factory DubbingMediaReference.fromJson(Map<String, dynamic> json) =>
      _$DubbingMediaReferenceFromJson(json);

  static const toJsonFactory = _$DubbingMediaReferenceToJson;
  Map<String, dynamic> toJson() => _$DubbingMediaReferenceToJson(this);

  @JsonKey(name: 'src')
  final String src;
  @JsonKey(name: 'content_type')
  final String contentType;
  @JsonKey(name: 'bucket_name')
  final String bucketName;
  @JsonKey(name: 'random_path_slug')
  final String randomPathSlug;
  @JsonKey(name: 'duration_secs')
  final double durationSecs;
  @JsonKey(name: 'is_audio')
  final bool isAudio;
  @JsonKey(name: 'url')
  final String url;
  static const fromJsonFactory = _$DubbingMediaReferenceFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DubbingMediaReference &&
            (identical(other.src, src) ||
                const DeepCollectionEquality().equals(other.src, src)) &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality()
                    .equals(other.contentType, contentType)) &&
            (identical(other.bucketName, bucketName) ||
                const DeepCollectionEquality()
                    .equals(other.bucketName, bucketName)) &&
            (identical(other.randomPathSlug, randomPathSlug) ||
                const DeepCollectionEquality()
                    .equals(other.randomPathSlug, randomPathSlug)) &&
            (identical(other.durationSecs, durationSecs) ||
                const DeepCollectionEquality()
                    .equals(other.durationSecs, durationSecs)) &&
            (identical(other.isAudio, isAudio) ||
                const DeepCollectionEquality()
                    .equals(other.isAudio, isAudio)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(src) ^
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(bucketName) ^
      const DeepCollectionEquality().hash(randomPathSlug) ^
      const DeepCollectionEquality().hash(durationSecs) ^
      const DeepCollectionEquality().hash(isAudio) ^
      const DeepCollectionEquality().hash(url) ^
      runtimeType.hashCode;
}

extension $DubbingMediaReferenceExtension on DubbingMediaReference {
  DubbingMediaReference copyWith(
      {String? src,
      String? contentType,
      String? bucketName,
      String? randomPathSlug,
      double? durationSecs,
      bool? isAudio,
      String? url}) {
    return DubbingMediaReference(
        src: src ?? this.src,
        contentType: contentType ?? this.contentType,
        bucketName: bucketName ?? this.bucketName,
        randomPathSlug: randomPathSlug ?? this.randomPathSlug,
        durationSecs: durationSecs ?? this.durationSecs,
        isAudio: isAudio ?? this.isAudio,
        url: url ?? this.url);
  }

  DubbingMediaReference copyWithWrapped(
      {Wrapped<String>? src,
      Wrapped<String>? contentType,
      Wrapped<String>? bucketName,
      Wrapped<String>? randomPathSlug,
      Wrapped<double>? durationSecs,
      Wrapped<bool>? isAudio,
      Wrapped<String>? url}) {
    return DubbingMediaReference(
        src: (src != null ? src.value : this.src),
        contentType:
            (contentType != null ? contentType.value : this.contentType),
        bucketName: (bucketName != null ? bucketName.value : this.bucketName),
        randomPathSlug: (randomPathSlug != null
            ? randomPathSlug.value
            : this.randomPathSlug),
        durationSecs:
            (durationSecs != null ? durationSecs.value : this.durationSecs),
        isAudio: (isAudio != null ? isAudio.value : this.isAudio),
        url: (url != null ? url.value : this.url));
  }
}

@JsonSerializable(explicitToJson: true)
class DubbingMetadataResponse {
  const DubbingMetadataResponse({
    required this.dubbingId,
    required this.name,
    required this.status,
    required this.targetLanguages,
    this.mediaMetadata,
    this.error,
  });

  factory DubbingMetadataResponse.fromJson(Map<String, dynamic> json) =>
      _$DubbingMetadataResponseFromJson(json);

  static const toJsonFactory = _$DubbingMetadataResponseToJson;
  Map<String, dynamic> toJson() => _$DubbingMetadataResponseToJson(this);

  @JsonKey(name: 'dubbing_id')
  final String dubbingId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'status')
  final String status;
  @JsonKey(name: 'target_languages', defaultValue: <String>[])
  final List<String> targetLanguages;
  @JsonKey(name: 'media_metadata')
  final dynamic mediaMetadata;
  @JsonKey(name: 'error')
  final dynamic error;
  static const fromJsonFactory = _$DubbingMetadataResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DubbingMetadataResponse &&
            (identical(other.dubbingId, dubbingId) ||
                const DeepCollectionEquality()
                    .equals(other.dubbingId, dubbingId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.targetLanguages, targetLanguages) ||
                const DeepCollectionEquality()
                    .equals(other.targetLanguages, targetLanguages)) &&
            (identical(other.mediaMetadata, mediaMetadata) ||
                const DeepCollectionEquality()
                    .equals(other.mediaMetadata, mediaMetadata)) &&
            (identical(other.error, error) ||
                const DeepCollectionEquality().equals(other.error, error)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dubbingId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(targetLanguages) ^
      const DeepCollectionEquality().hash(mediaMetadata) ^
      const DeepCollectionEquality().hash(error) ^
      runtimeType.hashCode;
}

extension $DubbingMetadataResponseExtension on DubbingMetadataResponse {
  DubbingMetadataResponse copyWith(
      {String? dubbingId,
      String? name,
      String? status,
      List<String>? targetLanguages,
      dynamic mediaMetadata,
      dynamic error}) {
    return DubbingMetadataResponse(
        dubbingId: dubbingId ?? this.dubbingId,
        name: name ?? this.name,
        status: status ?? this.status,
        targetLanguages: targetLanguages ?? this.targetLanguages,
        mediaMetadata: mediaMetadata ?? this.mediaMetadata,
        error: error ?? this.error);
  }

  DubbingMetadataResponse copyWithWrapped(
      {Wrapped<String>? dubbingId,
      Wrapped<String>? name,
      Wrapped<String>? status,
      Wrapped<List<String>>? targetLanguages,
      Wrapped<dynamic>? mediaMetadata,
      Wrapped<dynamic>? error}) {
    return DubbingMetadataResponse(
        dubbingId: (dubbingId != null ? dubbingId.value : this.dubbingId),
        name: (name != null ? name.value : this.name),
        status: (status != null ? status.value : this.status),
        targetLanguages: (targetLanguages != null
            ? targetLanguages.value
            : this.targetLanguages),
        mediaMetadata:
            (mediaMetadata != null ? mediaMetadata.value : this.mediaMetadata),
        error: (error != null ? error.value : this.error));
  }
}

@JsonSerializable(explicitToJson: true)
class DubbingRenderResponseModel {
  const DubbingRenderResponseModel({
    required this.version,
    required this.renderId,
  });

  factory DubbingRenderResponseModel.fromJson(Map<String, dynamic> json) =>
      _$DubbingRenderResponseModelFromJson(json);

  static const toJsonFactory = _$DubbingRenderResponseModelToJson;
  Map<String, dynamic> toJson() => _$DubbingRenderResponseModelToJson(this);

  @JsonKey(name: 'version')
  final int version;
  @JsonKey(name: 'render_id')
  final String renderId;
  static const fromJsonFactory = _$DubbingRenderResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DubbingRenderResponseModel &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.renderId, renderId) ||
                const DeepCollectionEquality()
                    .equals(other.renderId, renderId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(renderId) ^
      runtimeType.hashCode;
}

extension $DubbingRenderResponseModelExtension on DubbingRenderResponseModel {
  DubbingRenderResponseModel copyWith({int? version, String? renderId}) {
    return DubbingRenderResponseModel(
        version: version ?? this.version, renderId: renderId ?? this.renderId);
  }

  DubbingRenderResponseModel copyWithWrapped(
      {Wrapped<int>? version, Wrapped<String>? renderId}) {
    return DubbingRenderResponseModel(
        version: (version != null ? version.value : this.version),
        renderId: (renderId != null ? renderId.value : this.renderId));
  }
}

@JsonSerializable(explicitToJson: true)
class DubbingResource {
  const DubbingResource({
    required this.id,
    required this.version,
    required this.sourceLanguage,
    required this.targetLanguages,
    required this.input,
    required this.background,
    required this.foreground,
    required this.speakerTracks,
    required this.speakerSegments,
    required this.renders,
  });

  factory DubbingResource.fromJson(Map<String, dynamic> json) =>
      _$DubbingResourceFromJson(json);

  static const toJsonFactory = _$DubbingResourceToJson;
  Map<String, dynamic> toJson() => _$DubbingResourceToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'version')
  final int version;
  @JsonKey(name: 'source_language')
  final String sourceLanguage;
  @JsonKey(name: 'target_languages', defaultValue: <String>[])
  final List<String> targetLanguages;
  @JsonKey(name: 'input')
  final DubbingMediaReference input;
  @JsonKey(name: 'background')
  final DubbingMediaReference background;
  @JsonKey(name: 'foreground')
  final DubbingMediaReference foreground;
  @JsonKey(name: 'speaker_tracks')
  final Map<String, dynamic> speakerTracks;
  @JsonKey(name: 'speaker_segments')
  final Map<String, dynamic> speakerSegments;
  @JsonKey(name: 'renders')
  final Map<String, dynamic> renders;
  static const fromJsonFactory = _$DubbingResourceFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DubbingResource &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.sourceLanguage, sourceLanguage) ||
                const DeepCollectionEquality()
                    .equals(other.sourceLanguage, sourceLanguage)) &&
            (identical(other.targetLanguages, targetLanguages) ||
                const DeepCollectionEquality()
                    .equals(other.targetLanguages, targetLanguages)) &&
            (identical(other.input, input) ||
                const DeepCollectionEquality().equals(other.input, input)) &&
            (identical(other.background, background) ||
                const DeepCollectionEquality()
                    .equals(other.background, background)) &&
            (identical(other.foreground, foreground) ||
                const DeepCollectionEquality()
                    .equals(other.foreground, foreground)) &&
            (identical(other.speakerTracks, speakerTracks) ||
                const DeepCollectionEquality()
                    .equals(other.speakerTracks, speakerTracks)) &&
            (identical(other.speakerSegments, speakerSegments) ||
                const DeepCollectionEquality()
                    .equals(other.speakerSegments, speakerSegments)) &&
            (identical(other.renders, renders) ||
                const DeepCollectionEquality().equals(other.renders, renders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(sourceLanguage) ^
      const DeepCollectionEquality().hash(targetLanguages) ^
      const DeepCollectionEquality().hash(input) ^
      const DeepCollectionEquality().hash(background) ^
      const DeepCollectionEquality().hash(foreground) ^
      const DeepCollectionEquality().hash(speakerTracks) ^
      const DeepCollectionEquality().hash(speakerSegments) ^
      const DeepCollectionEquality().hash(renders) ^
      runtimeType.hashCode;
}

extension $DubbingResourceExtension on DubbingResource {
  DubbingResource copyWith(
      {String? id,
      int? version,
      String? sourceLanguage,
      List<String>? targetLanguages,
      DubbingMediaReference? input,
      DubbingMediaReference? background,
      DubbingMediaReference? foreground,
      Map<String, dynamic>? speakerTracks,
      Map<String, dynamic>? speakerSegments,
      Map<String, dynamic>? renders}) {
    return DubbingResource(
        id: id ?? this.id,
        version: version ?? this.version,
        sourceLanguage: sourceLanguage ?? this.sourceLanguage,
        targetLanguages: targetLanguages ?? this.targetLanguages,
        input: input ?? this.input,
        background: background ?? this.background,
        foreground: foreground ?? this.foreground,
        speakerTracks: speakerTracks ?? this.speakerTracks,
        speakerSegments: speakerSegments ?? this.speakerSegments,
        renders: renders ?? this.renders);
  }

  DubbingResource copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<int>? version,
      Wrapped<String>? sourceLanguage,
      Wrapped<List<String>>? targetLanguages,
      Wrapped<DubbingMediaReference>? input,
      Wrapped<DubbingMediaReference>? background,
      Wrapped<DubbingMediaReference>? foreground,
      Wrapped<Map<String, dynamic>>? speakerTracks,
      Wrapped<Map<String, dynamic>>? speakerSegments,
      Wrapped<Map<String, dynamic>>? renders}) {
    return DubbingResource(
        id: (id != null ? id.value : this.id),
        version: (version != null ? version.value : this.version),
        sourceLanguage: (sourceLanguage != null
            ? sourceLanguage.value
            : this.sourceLanguage),
        targetLanguages: (targetLanguages != null
            ? targetLanguages.value
            : this.targetLanguages),
        input: (input != null ? input.value : this.input),
        background: (background != null ? background.value : this.background),
        foreground: (foreground != null ? foreground.value : this.foreground),
        speakerTracks:
            (speakerTracks != null ? speakerTracks.value : this.speakerTracks),
        speakerSegments: (speakerSegments != null
            ? speakerSegments.value
            : this.speakerSegments),
        renders: (renders != null ? renders.value : this.renders));
  }
}

@JsonSerializable(explicitToJson: true)
class DynamicVariablesConfig {
  const DynamicVariablesConfig({
    this.dynamicVariablePlaceholders,
  });

  factory DynamicVariablesConfig.fromJson(Map<String, dynamic> json) =>
      _$DynamicVariablesConfigFromJson(json);

  static const toJsonFactory = _$DynamicVariablesConfigToJson;
  Map<String, dynamic> toJson() => _$DynamicVariablesConfigToJson(this);

  @JsonKey(name: 'dynamic_variable_placeholders')
  final Map<String, dynamic>? dynamicVariablePlaceholders;
  static const fromJsonFactory = _$DynamicVariablesConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is DynamicVariablesConfig &&
            (identical(other.dynamicVariablePlaceholders,
                    dynamicVariablePlaceholders) ||
                const DeepCollectionEquality().equals(
                    other.dynamicVariablePlaceholders,
                    dynamicVariablePlaceholders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dynamicVariablePlaceholders) ^
      runtimeType.hashCode;
}

extension $DynamicVariablesConfigExtension on DynamicVariablesConfig {
  DynamicVariablesConfig copyWith(
      {Map<String, dynamic>? dynamicVariablePlaceholders}) {
    return DynamicVariablesConfig(
        dynamicVariablePlaceholders:
            dynamicVariablePlaceholders ?? this.dynamicVariablePlaceholders);
  }

  DynamicVariablesConfig copyWithWrapped(
      {Wrapped<Map<String, dynamic>?>? dynamicVariablePlaceholders}) {
    return DynamicVariablesConfig(
        dynamicVariablePlaceholders: (dynamicVariablePlaceholders != null
            ? dynamicVariablePlaceholders.value
            : this.dynamicVariablePlaceholders));
  }
}

@JsonSerializable(explicitToJson: true)
class EditChapterResponseModel {
  const EditChapterResponseModel({
    required this.chapter,
  });

  factory EditChapterResponseModel.fromJson(Map<String, dynamic> json) =>
      _$EditChapterResponseModelFromJson(json);

  static const toJsonFactory = _$EditChapterResponseModelToJson;
  Map<String, dynamic> toJson() => _$EditChapterResponseModelToJson(this);

  @JsonKey(name: 'chapter')
  final ChapterWithContentResponseModel chapter;
  static const fromJsonFactory = _$EditChapterResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EditChapterResponseModel &&
            (identical(other.chapter, chapter) ||
                const DeepCollectionEquality().equals(other.chapter, chapter)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(chapter) ^ runtimeType.hashCode;
}

extension $EditChapterResponseModelExtension on EditChapterResponseModel {
  EditChapterResponseModel copyWith(
      {ChapterWithContentResponseModel? chapter}) {
    return EditChapterResponseModel(chapter: chapter ?? this.chapter);
  }

  EditChapterResponseModel copyWithWrapped(
      {Wrapped<ChapterWithContentResponseModel>? chapter}) {
    return EditChapterResponseModel(
        chapter: (chapter != null ? chapter.value : this.chapter));
  }
}

@JsonSerializable(explicitToJson: true)
class EditProjectResponseModel {
  const EditProjectResponseModel({
    required this.project,
  });

  factory EditProjectResponseModel.fromJson(Map<String, dynamic> json) =>
      _$EditProjectResponseModelFromJson(json);

  static const toJsonFactory = _$EditProjectResponseModelToJson;
  Map<String, dynamic> toJson() => _$EditProjectResponseModelToJson(this);

  @JsonKey(name: 'project')
  final ProjectResponseModel project;
  static const fromJsonFactory = _$EditProjectResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EditProjectResponseModel &&
            (identical(other.project, project) ||
                const DeepCollectionEquality().equals(other.project, project)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(project) ^ runtimeType.hashCode;
}

extension $EditProjectResponseModelExtension on EditProjectResponseModel {
  EditProjectResponseModel copyWith({ProjectResponseModel? project}) {
    return EditProjectResponseModel(project: project ?? this.project);
  }

  EditProjectResponseModel copyWithWrapped(
      {Wrapped<ProjectResponseModel>? project}) {
    return EditProjectResponseModel(
        project: (project != null ? project.value : this.project));
  }
}

@JsonSerializable(explicitToJson: true)
class EditVoiceResponseModel {
  const EditVoiceResponseModel({
    required this.status,
  });

  factory EditVoiceResponseModel.fromJson(Map<String, dynamic> json) =>
      _$EditVoiceResponseModelFromJson(json);

  static const toJsonFactory = _$EditVoiceResponseModelToJson;
  Map<String, dynamic> toJson() => _$EditVoiceResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$EditVoiceResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EditVoiceResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $EditVoiceResponseModelExtension on EditVoiceResponseModel {
  EditVoiceResponseModel copyWith({String? status}) {
    return EditVoiceResponseModel(status: status ?? this.status);
  }

  EditVoiceResponseModel copyWithWrapped({Wrapped<String>? status}) {
    return EditVoiceResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class EditVoiceSettingsResponseModel {
  const EditVoiceSettingsResponseModel({
    required this.status,
  });

  factory EditVoiceSettingsResponseModel.fromJson(Map<String, dynamic> json) =>
      _$EditVoiceSettingsResponseModelFromJson(json);

  static const toJsonFactory = _$EditVoiceSettingsResponseModelToJson;
  Map<String, dynamic> toJson() => _$EditVoiceSettingsResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$EditVoiceSettingsResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EditVoiceSettingsResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $EditVoiceSettingsResponseModelExtension
    on EditVoiceSettingsResponseModel {
  EditVoiceSettingsResponseModel copyWith({String? status}) {
    return EditVoiceSettingsResponseModel(status: status ?? this.status);
  }

  EditVoiceSettingsResponseModel copyWithWrapped({Wrapped<String>? status}) {
    return EditVoiceSettingsResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class EndCallToolConfig {
  const EndCallToolConfig({
    this.systemToolType,
  });

  factory EndCallToolConfig.fromJson(Map<String, dynamic> json) =>
      _$EndCallToolConfigFromJson(json);

  static const toJsonFactory = _$EndCallToolConfigToJson;
  Map<String, dynamic> toJson() => _$EndCallToolConfigToJson(this);

  @JsonKey(name: 'system_tool_type')
  final String? systemToolType;
  static const fromJsonFactory = _$EndCallToolConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EndCallToolConfig &&
            (identical(other.systemToolType, systemToolType) ||
                const DeepCollectionEquality()
                    .equals(other.systemToolType, systemToolType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(systemToolType) ^
      runtimeType.hashCode;
}

extension $EndCallToolConfigExtension on EndCallToolConfig {
  EndCallToolConfig copyWith({String? systemToolType}) {
    return EndCallToolConfig(
        systemToolType: systemToolType ?? this.systemToolType);
  }

  EndCallToolConfig copyWithWrapped({Wrapped<String?>? systemToolType}) {
    return EndCallToolConfig(
        systemToolType: (systemToolType != null
            ? systemToolType.value
            : this.systemToolType));
  }
}

@JsonSerializable(explicitToJson: true)
class EvaluationSettings {
  const EvaluationSettings({
    this.criteria,
  });

  factory EvaluationSettings.fromJson(Map<String, dynamic> json) =>
      _$EvaluationSettingsFromJson(json);

  static const toJsonFactory = _$EvaluationSettingsToJson;
  Map<String, dynamic> toJson() => _$EvaluationSettingsToJson(this);

  @JsonKey(name: 'criteria', defaultValue: <PromptEvaluationCriteria>[])
  final List<PromptEvaluationCriteria>? criteria;
  static const fromJsonFactory = _$EvaluationSettingsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is EvaluationSettings &&
            (identical(other.criteria, criteria) ||
                const DeepCollectionEquality()
                    .equals(other.criteria, criteria)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(criteria) ^ runtimeType.hashCode;
}

extension $EvaluationSettingsExtension on EvaluationSettings {
  EvaluationSettings copyWith({List<PromptEvaluationCriteria>? criteria}) {
    return EvaluationSettings(criteria: criteria ?? this.criteria);
  }

  EvaluationSettings copyWithWrapped(
      {Wrapped<List<PromptEvaluationCriteria>?>? criteria}) {
    return EvaluationSettings(
        criteria: (criteria != null ? criteria.value : this.criteria));
  }
}

@JsonSerializable(explicitToJson: true)
class ExportOptions {
  const ExportOptions();

  factory ExportOptions.fromJson(Map<String, dynamic> json) =>
      _$ExportOptionsFromJson(json);

  static const toJsonFactory = _$ExportOptionsToJson;
  Map<String, dynamic> toJson() => _$ExportOptionsToJson(this);

  static const fromJsonFactory = _$ExportOptionsFromJson;

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode => runtimeType.hashCode;
}

@JsonSerializable(explicitToJson: true)
class ExtendedSubscriptionResponseModel {
  const ExtendedSubscriptionResponseModel({
    required this.tier,
    required this.characterCount,
    required this.characterLimit,
    required this.maxCharacterLimitExtension,
    required this.canExtendCharacterLimit,
    required this.allowedToExtendCharacterLimit,
    this.nextCharacterCountResetUnix,
    required this.voiceSlotsUsed,
    required this.professionalVoiceSlotsUsed,
    required this.voiceLimit,
    this.maxVoiceAddEdits,
    required this.voiceAddEditCounter,
    required this.professionalVoiceLimit,
    required this.canExtendVoiceLimit,
    required this.canUseInstantVoiceCloning,
    required this.canUseProfessionalVoiceCloning,
    this.currency,
    required this.status,
    this.billingPeriod,
    this.characterRefreshPeriod,
    this.nextInvoice,
    required this.hasOpenInvoices,
  });

  factory ExtendedSubscriptionResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$ExtendedSubscriptionResponseModelFromJson(json);

  static const toJsonFactory = _$ExtendedSubscriptionResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$ExtendedSubscriptionResponseModelToJson(this);

  @JsonKey(name: 'tier')
  final String tier;
  @JsonKey(name: 'character_count')
  final int characterCount;
  @JsonKey(name: 'character_limit')
  final int characterLimit;
  @JsonKey(name: 'max_character_limit_extension')
  final dynamic maxCharacterLimitExtension;
  @JsonKey(name: 'can_extend_character_limit')
  final bool canExtendCharacterLimit;
  @JsonKey(name: 'allowed_to_extend_character_limit')
  final bool allowedToExtendCharacterLimit;
  @JsonKey(name: 'next_character_count_reset_unix')
  final dynamic nextCharacterCountResetUnix;
  @JsonKey(name: 'voice_slots_used')
  final int voiceSlotsUsed;
  @JsonKey(name: 'professional_voice_slots_used')
  final int professionalVoiceSlotsUsed;
  @JsonKey(name: 'voice_limit')
  final int voiceLimit;
  @JsonKey(name: 'max_voice_add_edits')
  final dynamic maxVoiceAddEdits;
  @JsonKey(name: 'voice_add_edit_counter')
  final int voiceAddEditCounter;
  @JsonKey(name: 'professional_voice_limit')
  final int professionalVoiceLimit;
  @JsonKey(name: 'can_extend_voice_limit')
  final bool canExtendVoiceLimit;
  @JsonKey(name: 'can_use_instant_voice_cloning')
  final bool canUseInstantVoiceCloning;
  @JsonKey(name: 'can_use_professional_voice_cloning')
  final bool canUseProfessionalVoiceCloning;
  @JsonKey(name: 'currency')
  final dynamic currency;
  @JsonKey(
    name: 'status',
    toJson: extendedSubscriptionResponseModelStatusToJson,
    fromJson: extendedSubscriptionResponseModelStatusFromJson,
  )
  final enums.ExtendedSubscriptionResponseModelStatus status;
  @JsonKey(name: 'billing_period')
  final dynamic billingPeriod;
  @JsonKey(name: 'character_refresh_period')
  final dynamic characterRefreshPeriod;
  @JsonKey(name: 'next_invoice')
  final dynamic nextInvoice;
  @JsonKey(name: 'has_open_invoices')
  final bool hasOpenInvoices;
  static const fromJsonFactory = _$ExtendedSubscriptionResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ExtendedSubscriptionResponseModel &&
            (identical(other.tier, tier) ||
                const DeepCollectionEquality().equals(other.tier, tier)) &&
            (identical(other.characterCount, characterCount) ||
                const DeepCollectionEquality()
                    .equals(other.characterCount, characterCount)) &&
            (identical(other.characterLimit, characterLimit) ||
                const DeepCollectionEquality()
                    .equals(other.characterLimit, characterLimit)) &&
            (identical(other.maxCharacterLimitExtension, maxCharacterLimitExtension) ||
                const DeepCollectionEquality().equals(
                    other.maxCharacterLimitExtension,
                    maxCharacterLimitExtension)) &&
            (identical(other.canExtendCharacterLimit, canExtendCharacterLimit) ||
                const DeepCollectionEquality().equals(
                    other.canExtendCharacterLimit, canExtendCharacterLimit)) &&
            (identical(other.allowedToExtendCharacterLimit, allowedToExtendCharacterLimit) ||
                const DeepCollectionEquality().equals(
                    other.allowedToExtendCharacterLimit,
                    allowedToExtendCharacterLimit)) &&
            (identical(other.nextCharacterCountResetUnix, nextCharacterCountResetUnix) ||
                const DeepCollectionEquality().equals(
                    other.nextCharacterCountResetUnix,
                    nextCharacterCountResetUnix)) &&
            (identical(other.voiceSlotsUsed, voiceSlotsUsed) ||
                const DeepCollectionEquality()
                    .equals(other.voiceSlotsUsed, voiceSlotsUsed)) &&
            (identical(other.professionalVoiceSlotsUsed, professionalVoiceSlotsUsed) ||
                const DeepCollectionEquality().equals(
                    other.professionalVoiceSlotsUsed,
                    professionalVoiceSlotsUsed)) &&
            (identical(other.voiceLimit, voiceLimit) ||
                const DeepCollectionEquality()
                    .equals(other.voiceLimit, voiceLimit)) &&
            (identical(other.maxVoiceAddEdits, maxVoiceAddEdits) ||
                const DeepCollectionEquality().equals(other.maxVoiceAddEdits, maxVoiceAddEdits)) &&
            (identical(other.voiceAddEditCounter, voiceAddEditCounter) || const DeepCollectionEquality().equals(other.voiceAddEditCounter, voiceAddEditCounter)) &&
            (identical(other.professionalVoiceLimit, professionalVoiceLimit) || const DeepCollectionEquality().equals(other.professionalVoiceLimit, professionalVoiceLimit)) &&
            (identical(other.canExtendVoiceLimit, canExtendVoiceLimit) || const DeepCollectionEquality().equals(other.canExtendVoiceLimit, canExtendVoiceLimit)) &&
            (identical(other.canUseInstantVoiceCloning, canUseInstantVoiceCloning) || const DeepCollectionEquality().equals(other.canUseInstantVoiceCloning, canUseInstantVoiceCloning)) &&
            (identical(other.canUseProfessionalVoiceCloning, canUseProfessionalVoiceCloning) || const DeepCollectionEquality().equals(other.canUseProfessionalVoiceCloning, canUseProfessionalVoiceCloning)) &&
            (identical(other.currency, currency) || const DeepCollectionEquality().equals(other.currency, currency)) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.billingPeriod, billingPeriod) || const DeepCollectionEquality().equals(other.billingPeriod, billingPeriod)) &&
            (identical(other.characterRefreshPeriod, characterRefreshPeriod) || const DeepCollectionEquality().equals(other.characterRefreshPeriod, characterRefreshPeriod)) &&
            (identical(other.nextInvoice, nextInvoice) || const DeepCollectionEquality().equals(other.nextInvoice, nextInvoice)) &&
            (identical(other.hasOpenInvoices, hasOpenInvoices) || const DeepCollectionEquality().equals(other.hasOpenInvoices, hasOpenInvoices)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tier) ^
      const DeepCollectionEquality().hash(characterCount) ^
      const DeepCollectionEquality().hash(characterLimit) ^
      const DeepCollectionEquality().hash(maxCharacterLimitExtension) ^
      const DeepCollectionEquality().hash(canExtendCharacterLimit) ^
      const DeepCollectionEquality().hash(allowedToExtendCharacterLimit) ^
      const DeepCollectionEquality().hash(nextCharacterCountResetUnix) ^
      const DeepCollectionEquality().hash(voiceSlotsUsed) ^
      const DeepCollectionEquality().hash(professionalVoiceSlotsUsed) ^
      const DeepCollectionEquality().hash(voiceLimit) ^
      const DeepCollectionEquality().hash(maxVoiceAddEdits) ^
      const DeepCollectionEquality().hash(voiceAddEditCounter) ^
      const DeepCollectionEquality().hash(professionalVoiceLimit) ^
      const DeepCollectionEquality().hash(canExtendVoiceLimit) ^
      const DeepCollectionEquality().hash(canUseInstantVoiceCloning) ^
      const DeepCollectionEquality().hash(canUseProfessionalVoiceCloning) ^
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(billingPeriod) ^
      const DeepCollectionEquality().hash(characterRefreshPeriod) ^
      const DeepCollectionEquality().hash(nextInvoice) ^
      const DeepCollectionEquality().hash(hasOpenInvoices) ^
      runtimeType.hashCode;
}

extension $ExtendedSubscriptionResponseModelExtension
    on ExtendedSubscriptionResponseModel {
  ExtendedSubscriptionResponseModel copyWith(
      {String? tier,
      int? characterCount,
      int? characterLimit,
      dynamic maxCharacterLimitExtension,
      bool? canExtendCharacterLimit,
      bool? allowedToExtendCharacterLimit,
      dynamic nextCharacterCountResetUnix,
      int? voiceSlotsUsed,
      int? professionalVoiceSlotsUsed,
      int? voiceLimit,
      dynamic maxVoiceAddEdits,
      int? voiceAddEditCounter,
      int? professionalVoiceLimit,
      bool? canExtendVoiceLimit,
      bool? canUseInstantVoiceCloning,
      bool? canUseProfessionalVoiceCloning,
      dynamic currency,
      enums.ExtendedSubscriptionResponseModelStatus? status,
      dynamic billingPeriod,
      dynamic characterRefreshPeriod,
      dynamic nextInvoice,
      bool? hasOpenInvoices}) {
    return ExtendedSubscriptionResponseModel(
        tier: tier ?? this.tier,
        characterCount: characterCount ?? this.characterCount,
        characterLimit: characterLimit ?? this.characterLimit,
        maxCharacterLimitExtension:
            maxCharacterLimitExtension ?? this.maxCharacterLimitExtension,
        canExtendCharacterLimit:
            canExtendCharacterLimit ?? this.canExtendCharacterLimit,
        allowedToExtendCharacterLimit:
            allowedToExtendCharacterLimit ?? this.allowedToExtendCharacterLimit,
        nextCharacterCountResetUnix:
            nextCharacterCountResetUnix ?? this.nextCharacterCountResetUnix,
        voiceSlotsUsed: voiceSlotsUsed ?? this.voiceSlotsUsed,
        professionalVoiceSlotsUsed:
            professionalVoiceSlotsUsed ?? this.professionalVoiceSlotsUsed,
        voiceLimit: voiceLimit ?? this.voiceLimit,
        maxVoiceAddEdits: maxVoiceAddEdits ?? this.maxVoiceAddEdits,
        voiceAddEditCounter: voiceAddEditCounter ?? this.voiceAddEditCounter,
        professionalVoiceLimit:
            professionalVoiceLimit ?? this.professionalVoiceLimit,
        canExtendVoiceLimit: canExtendVoiceLimit ?? this.canExtendVoiceLimit,
        canUseInstantVoiceCloning:
            canUseInstantVoiceCloning ?? this.canUseInstantVoiceCloning,
        canUseProfessionalVoiceCloning: canUseProfessionalVoiceCloning ??
            this.canUseProfessionalVoiceCloning,
        currency: currency ?? this.currency,
        status: status ?? this.status,
        billingPeriod: billingPeriod ?? this.billingPeriod,
        characterRefreshPeriod:
            characterRefreshPeriod ?? this.characterRefreshPeriod,
        nextInvoice: nextInvoice ?? this.nextInvoice,
        hasOpenInvoices: hasOpenInvoices ?? this.hasOpenInvoices);
  }

  ExtendedSubscriptionResponseModel copyWithWrapped(
      {Wrapped<String>? tier,
      Wrapped<int>? characterCount,
      Wrapped<int>? characterLimit,
      Wrapped<dynamic>? maxCharacterLimitExtension,
      Wrapped<bool>? canExtendCharacterLimit,
      Wrapped<bool>? allowedToExtendCharacterLimit,
      Wrapped<dynamic>? nextCharacterCountResetUnix,
      Wrapped<int>? voiceSlotsUsed,
      Wrapped<int>? professionalVoiceSlotsUsed,
      Wrapped<int>? voiceLimit,
      Wrapped<dynamic>? maxVoiceAddEdits,
      Wrapped<int>? voiceAddEditCounter,
      Wrapped<int>? professionalVoiceLimit,
      Wrapped<bool>? canExtendVoiceLimit,
      Wrapped<bool>? canUseInstantVoiceCloning,
      Wrapped<bool>? canUseProfessionalVoiceCloning,
      Wrapped<dynamic>? currency,
      Wrapped<enums.ExtendedSubscriptionResponseModelStatus>? status,
      Wrapped<dynamic>? billingPeriod,
      Wrapped<dynamic>? characterRefreshPeriod,
      Wrapped<dynamic>? nextInvoice,
      Wrapped<bool>? hasOpenInvoices}) {
    return ExtendedSubscriptionResponseModel(
        tier: (tier != null ? tier.value : this.tier),
        characterCount: (characterCount != null
            ? characterCount.value
            : this.characterCount),
        characterLimit: (characterLimit != null
            ? characterLimit.value
            : this.characterLimit),
        maxCharacterLimitExtension: (maxCharacterLimitExtension != null
            ? maxCharacterLimitExtension.value
            : this.maxCharacterLimitExtension),
        canExtendCharacterLimit: (canExtendCharacterLimit != null
            ? canExtendCharacterLimit.value
            : this.canExtendCharacterLimit),
        allowedToExtendCharacterLimit: (allowedToExtendCharacterLimit != null
            ? allowedToExtendCharacterLimit.value
            : this.allowedToExtendCharacterLimit),
        nextCharacterCountResetUnix: (nextCharacterCountResetUnix != null
            ? nextCharacterCountResetUnix.value
            : this.nextCharacterCountResetUnix),
        voiceSlotsUsed: (voiceSlotsUsed != null
            ? voiceSlotsUsed.value
            : this.voiceSlotsUsed),
        professionalVoiceSlotsUsed: (professionalVoiceSlotsUsed != null
            ? professionalVoiceSlotsUsed.value
            : this.professionalVoiceSlotsUsed),
        voiceLimit: (voiceLimit != null ? voiceLimit.value : this.voiceLimit),
        maxVoiceAddEdits: (maxVoiceAddEdits != null
            ? maxVoiceAddEdits.value
            : this.maxVoiceAddEdits),
        voiceAddEditCounter: (voiceAddEditCounter != null
            ? voiceAddEditCounter.value
            : this.voiceAddEditCounter),
        professionalVoiceLimit: (professionalVoiceLimit != null
            ? professionalVoiceLimit.value
            : this.professionalVoiceLimit),
        canExtendVoiceLimit: (canExtendVoiceLimit != null
            ? canExtendVoiceLimit.value
            : this.canExtendVoiceLimit),
        canUseInstantVoiceCloning: (canUseInstantVoiceCloning != null
            ? canUseInstantVoiceCloning.value
            : this.canUseInstantVoiceCloning),
        canUseProfessionalVoiceCloning: (canUseProfessionalVoiceCloning != null
            ? canUseProfessionalVoiceCloning.value
            : this.canUseProfessionalVoiceCloning),
        currency: (currency != null ? currency.value : this.currency),
        status: (status != null ? status.value : this.status),
        billingPeriod:
            (billingPeriod != null ? billingPeriod.value : this.billingPeriod),
        characterRefreshPeriod: (characterRefreshPeriod != null
            ? characterRefreshPeriod.value
            : this.characterRefreshPeriod),
        nextInvoice:
            (nextInvoice != null ? nextInvoice.value : this.nextInvoice),
        hasOpenInvoices: (hasOpenInvoices != null
            ? hasOpenInvoices.value
            : this.hasOpenInvoices));
  }
}

@JsonSerializable(explicitToJson: true)
class FeedbackResponseModel {
  const FeedbackResponseModel({
    required this.thumbsUp,
    required this.feedback,
    required this.emotions,
    required this.inaccurateClone,
    required this.glitches,
    required this.audioQuality,
    required this.other,
    this.reviewStatus,
  });

  factory FeedbackResponseModel.fromJson(Map<String, dynamic> json) =>
      _$FeedbackResponseModelFromJson(json);

  static const toJsonFactory = _$FeedbackResponseModelToJson;
  Map<String, dynamic> toJson() => _$FeedbackResponseModelToJson(this);

  @JsonKey(name: 'thumbs_up')
  final bool thumbsUp;
  @JsonKey(name: 'feedback')
  final String feedback;
  @JsonKey(name: 'emotions')
  final bool emotions;
  @JsonKey(name: 'inaccurate_clone')
  final bool inaccurateClone;
  @JsonKey(name: 'glitches')
  final bool glitches;
  @JsonKey(name: 'audio_quality')
  final bool audioQuality;
  @JsonKey(name: 'other')
  final bool other;
  @JsonKey(name: 'review_status')
  final String? reviewStatus;
  static const fromJsonFactory = _$FeedbackResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FeedbackResponseModel &&
            (identical(other.thumbsUp, thumbsUp) ||
                const DeepCollectionEquality()
                    .equals(other.thumbsUp, thumbsUp)) &&
            (identical(other.feedback, feedback) ||
                const DeepCollectionEquality()
                    .equals(other.feedback, feedback)) &&
            (identical(other.emotions, emotions) ||
                const DeepCollectionEquality()
                    .equals(other.emotions, emotions)) &&
            (identical(other.inaccurateClone, inaccurateClone) ||
                const DeepCollectionEquality()
                    .equals(other.inaccurateClone, inaccurateClone)) &&
            (identical(other.glitches, glitches) ||
                const DeepCollectionEquality()
                    .equals(other.glitches, glitches)) &&
            (identical(other.audioQuality, audioQuality) ||
                const DeepCollectionEquality()
                    .equals(other.audioQuality, audioQuality)) &&
            (identical(other.other, other) ||
                const DeepCollectionEquality().equals(other.other, other)) &&
            (identical(other.reviewStatus, reviewStatus) ||
                const DeepCollectionEquality()
                    .equals(other.reviewStatus, reviewStatus)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(thumbsUp) ^
      const DeepCollectionEquality().hash(feedback) ^
      const DeepCollectionEquality().hash(emotions) ^
      const DeepCollectionEquality().hash(inaccurateClone) ^
      const DeepCollectionEquality().hash(glitches) ^
      const DeepCollectionEquality().hash(audioQuality) ^
      const DeepCollectionEquality().hash(other) ^
      const DeepCollectionEquality().hash(reviewStatus) ^
      runtimeType.hashCode;
}

extension $FeedbackResponseModelExtension on FeedbackResponseModel {
  FeedbackResponseModel copyWith(
      {bool? thumbsUp,
      String? feedback,
      bool? emotions,
      bool? inaccurateClone,
      bool? glitches,
      bool? audioQuality,
      bool? other,
      String? reviewStatus}) {
    return FeedbackResponseModel(
        thumbsUp: thumbsUp ?? this.thumbsUp,
        feedback: feedback ?? this.feedback,
        emotions: emotions ?? this.emotions,
        inaccurateClone: inaccurateClone ?? this.inaccurateClone,
        glitches: glitches ?? this.glitches,
        audioQuality: audioQuality ?? this.audioQuality,
        other: other ?? this.other,
        reviewStatus: reviewStatus ?? this.reviewStatus);
  }

  FeedbackResponseModel copyWithWrapped(
      {Wrapped<bool>? thumbsUp,
      Wrapped<String>? feedback,
      Wrapped<bool>? emotions,
      Wrapped<bool>? inaccurateClone,
      Wrapped<bool>? glitches,
      Wrapped<bool>? audioQuality,
      Wrapped<bool>? other,
      Wrapped<String?>? reviewStatus}) {
    return FeedbackResponseModel(
        thumbsUp: (thumbsUp != null ? thumbsUp.value : this.thumbsUp),
        feedback: (feedback != null ? feedback.value : this.feedback),
        emotions: (emotions != null ? emotions.value : this.emotions),
        inaccurateClone: (inaccurateClone != null
            ? inaccurateClone.value
            : this.inaccurateClone),
        glitches: (glitches != null ? glitches.value : this.glitches),
        audioQuality:
            (audioQuality != null ? audioQuality.value : this.audioQuality),
        other: (other != null ? other.value : this.other),
        reviewStatus:
            (reviewStatus != null ? reviewStatus.value : this.reviewStatus));
  }
}

@JsonSerializable(explicitToJson: true)
class FineTuningResponseModel {
  const FineTuningResponseModel({
    required this.isAllowedToFineTune,
    required this.state,
    required this.verificationFailures,
    required this.verificationAttemptsCount,
    required this.manualVerificationRequested,
    this.language,
    this.progress,
    this.message,
    this.datasetDurationSeconds,
    this.verificationAttempts,
    this.sliceIds,
    this.manualVerification,
    this.maxVerificationAttempts,
    this.nextMaxVerificationAttemptsResetUnixMs,
  });

  factory FineTuningResponseModel.fromJson(Map<String, dynamic> json) =>
      _$FineTuningResponseModelFromJson(json);

  static const toJsonFactory = _$FineTuningResponseModelToJson;
  Map<String, dynamic> toJson() => _$FineTuningResponseModelToJson(this);

  @JsonKey(name: 'is_allowed_to_fine_tune')
  final bool isAllowedToFineTune;
  @JsonKey(name: 'state')
  final Map<String, dynamic> state;
  @JsonKey(name: 'verification_failures', defaultValue: <String>[])
  final List<String> verificationFailures;
  @JsonKey(name: 'verification_attempts_count')
  final int verificationAttemptsCount;
  @JsonKey(name: 'manual_verification_requested')
  final bool manualVerificationRequested;
  @JsonKey(name: 'language')
  final dynamic language;
  @JsonKey(name: 'progress')
  final dynamic progress;
  @JsonKey(name: 'message')
  final dynamic message;
  @JsonKey(name: 'dataset_duration_seconds')
  final dynamic datasetDurationSeconds;
  @JsonKey(name: 'verification_attempts')
  final dynamic verificationAttempts;
  @JsonKey(name: 'slice_ids')
  final dynamic sliceIds;
  @JsonKey(name: 'manual_verification')
  final dynamic manualVerification;
  @JsonKey(name: 'max_verification_attempts')
  final dynamic maxVerificationAttempts;
  @JsonKey(name: 'next_max_verification_attempts_reset_unix_ms')
  final dynamic nextMaxVerificationAttemptsResetUnixMs;
  static const fromJsonFactory = _$FineTuningResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is FineTuningResponseModel &&
            (identical(other.isAllowedToFineTune, isAllowedToFineTune) ||
                const DeepCollectionEquality()
                    .equals(other.isAllowedToFineTune, isAllowedToFineTune)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.verificationFailures, verificationFailures) ||
                const DeepCollectionEquality().equals(
                    other.verificationFailures, verificationFailures)) &&
            (identical(other.verificationAttemptsCount, verificationAttemptsCount) ||
                const DeepCollectionEquality().equals(
                    other.verificationAttemptsCount,
                    verificationAttemptsCount)) &&
            (identical(other.manualVerificationRequested, manualVerificationRequested) ||
                const DeepCollectionEquality().equals(
                    other.manualVerificationRequested,
                    manualVerificationRequested)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.progress, progress) ||
                const DeepCollectionEquality()
                    .equals(other.progress, progress)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.datasetDurationSeconds, datasetDurationSeconds) ||
                const DeepCollectionEquality().equals(
                    other.datasetDurationSeconds, datasetDurationSeconds)) &&
            (identical(other.verificationAttempts, verificationAttempts) ||
                const DeepCollectionEquality().equals(
                    other.verificationAttempts, verificationAttempts)) &&
            (identical(other.sliceIds, sliceIds) ||
                const DeepCollectionEquality()
                    .equals(other.sliceIds, sliceIds)) &&
            (identical(other.manualVerification, manualVerification) ||
                const DeepCollectionEquality()
                    .equals(other.manualVerification, manualVerification)) &&
            (identical(other.maxVerificationAttempts, maxVerificationAttempts) ||
                const DeepCollectionEquality().equals(
                    other.maxVerificationAttempts, maxVerificationAttempts)) &&
            (identical(other.nextMaxVerificationAttemptsResetUnixMs, nextMaxVerificationAttemptsResetUnixMs) ||
                const DeepCollectionEquality().equals(other.nextMaxVerificationAttemptsResetUnixMs, nextMaxVerificationAttemptsResetUnixMs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isAllowedToFineTune) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(verificationFailures) ^
      const DeepCollectionEquality().hash(verificationAttemptsCount) ^
      const DeepCollectionEquality().hash(manualVerificationRequested) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(progress) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(datasetDurationSeconds) ^
      const DeepCollectionEquality().hash(verificationAttempts) ^
      const DeepCollectionEquality().hash(sliceIds) ^
      const DeepCollectionEquality().hash(manualVerification) ^
      const DeepCollectionEquality().hash(maxVerificationAttempts) ^
      const DeepCollectionEquality()
          .hash(nextMaxVerificationAttemptsResetUnixMs) ^
      runtimeType.hashCode;
}

extension $FineTuningResponseModelExtension on FineTuningResponseModel {
  FineTuningResponseModel copyWith(
      {bool? isAllowedToFineTune,
      Map<String, dynamic>? state,
      List<String>? verificationFailures,
      int? verificationAttemptsCount,
      bool? manualVerificationRequested,
      dynamic language,
      dynamic progress,
      dynamic message,
      dynamic datasetDurationSeconds,
      dynamic verificationAttempts,
      dynamic sliceIds,
      dynamic manualVerification,
      dynamic maxVerificationAttempts,
      dynamic nextMaxVerificationAttemptsResetUnixMs}) {
    return FineTuningResponseModel(
        isAllowedToFineTune: isAllowedToFineTune ?? this.isAllowedToFineTune,
        state: state ?? this.state,
        verificationFailures: verificationFailures ?? this.verificationFailures,
        verificationAttemptsCount:
            verificationAttemptsCount ?? this.verificationAttemptsCount,
        manualVerificationRequested:
            manualVerificationRequested ?? this.manualVerificationRequested,
        language: language ?? this.language,
        progress: progress ?? this.progress,
        message: message ?? this.message,
        datasetDurationSeconds:
            datasetDurationSeconds ?? this.datasetDurationSeconds,
        verificationAttempts: verificationAttempts ?? this.verificationAttempts,
        sliceIds: sliceIds ?? this.sliceIds,
        manualVerification: manualVerification ?? this.manualVerification,
        maxVerificationAttempts:
            maxVerificationAttempts ?? this.maxVerificationAttempts,
        nextMaxVerificationAttemptsResetUnixMs:
            nextMaxVerificationAttemptsResetUnixMs ??
                this.nextMaxVerificationAttemptsResetUnixMs);
  }

  FineTuningResponseModel copyWithWrapped(
      {Wrapped<bool>? isAllowedToFineTune,
      Wrapped<Map<String, dynamic>>? state,
      Wrapped<List<String>>? verificationFailures,
      Wrapped<int>? verificationAttemptsCount,
      Wrapped<bool>? manualVerificationRequested,
      Wrapped<dynamic>? language,
      Wrapped<dynamic>? progress,
      Wrapped<dynamic>? message,
      Wrapped<dynamic>? datasetDurationSeconds,
      Wrapped<dynamic>? verificationAttempts,
      Wrapped<dynamic>? sliceIds,
      Wrapped<dynamic>? manualVerification,
      Wrapped<dynamic>? maxVerificationAttempts,
      Wrapped<dynamic>? nextMaxVerificationAttemptsResetUnixMs}) {
    return FineTuningResponseModel(
        isAllowedToFineTune: (isAllowedToFineTune != null
            ? isAllowedToFineTune.value
            : this.isAllowedToFineTune),
        state: (state != null ? state.value : this.state),
        verificationFailures: (verificationFailures != null
            ? verificationFailures.value
            : this.verificationFailures),
        verificationAttemptsCount: (verificationAttemptsCount != null
            ? verificationAttemptsCount.value
            : this.verificationAttemptsCount),
        manualVerificationRequested: (manualVerificationRequested != null
            ? manualVerificationRequested.value
            : this.manualVerificationRequested),
        language: (language != null ? language.value : this.language),
        progress: (progress != null ? progress.value : this.progress),
        message: (message != null ? message.value : this.message),
        datasetDurationSeconds: (datasetDurationSeconds != null
            ? datasetDurationSeconds.value
            : this.datasetDurationSeconds),
        verificationAttempts: (verificationAttempts != null
            ? verificationAttempts.value
            : this.verificationAttempts),
        sliceIds: (sliceIds != null ? sliceIds.value : this.sliceIds),
        manualVerification: (manualVerification != null
            ? manualVerification.value
            : this.manualVerification),
        maxVerificationAttempts: (maxVerificationAttempts != null
            ? maxVerificationAttempts.value
            : this.maxVerificationAttempts),
        nextMaxVerificationAttemptsResetUnixMs:
            (nextMaxVerificationAttemptsResetUnixMs != null
                ? nextMaxVerificationAttemptsResetUnixMs.value
                : this.nextMaxVerificationAttemptsResetUnixMs));
  }
}

@JsonSerializable(explicitToJson: true)
class ForcedAlignmentCharacterResponseModel {
  const ForcedAlignmentCharacterResponseModel({
    required this.text,
    required this.start,
    required this.end,
  });

  factory ForcedAlignmentCharacterResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$ForcedAlignmentCharacterResponseModelFromJson(json);

  static const toJsonFactory = _$ForcedAlignmentCharacterResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$ForcedAlignmentCharacterResponseModelToJson(this);

  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'start')
  final double start;
  @JsonKey(name: 'end')
  final double end;
  static const fromJsonFactory =
      _$ForcedAlignmentCharacterResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForcedAlignmentCharacterResponseModel &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.start, start) ||
                const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) ||
                const DeepCollectionEquality().equals(other.end, end)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      runtimeType.hashCode;
}

extension $ForcedAlignmentCharacterResponseModelExtension
    on ForcedAlignmentCharacterResponseModel {
  ForcedAlignmentCharacterResponseModel copyWith(
      {String? text, double? start, double? end}) {
    return ForcedAlignmentCharacterResponseModel(
        text: text ?? this.text,
        start: start ?? this.start,
        end: end ?? this.end);
  }

  ForcedAlignmentCharacterResponseModel copyWithWrapped(
      {Wrapped<String>? text, Wrapped<double>? start, Wrapped<double>? end}) {
    return ForcedAlignmentCharacterResponseModel(
        text: (text != null ? text.value : this.text),
        start: (start != null ? start.value : this.start),
        end: (end != null ? end.value : this.end));
  }
}

@JsonSerializable(explicitToJson: true)
class ForcedAlignmentResponseModel {
  const ForcedAlignmentResponseModel({
    required this.characters,
    required this.words,
  });

  factory ForcedAlignmentResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ForcedAlignmentResponseModelFromJson(json);

  static const toJsonFactory = _$ForcedAlignmentResponseModelToJson;
  Map<String, dynamic> toJson() => _$ForcedAlignmentResponseModelToJson(this);

  @JsonKey(
      name: 'characters',
      defaultValue: <ForcedAlignmentCharacterResponseModel>[])
  final List<ForcedAlignmentCharacterResponseModel> characters;
  @JsonKey(name: 'words', defaultValue: <ForcedAlignmentWordResponseModel>[])
  final List<ForcedAlignmentWordResponseModel> words;
  static const fromJsonFactory = _$ForcedAlignmentResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForcedAlignmentResponseModel &&
            (identical(other.characters, characters) ||
                const DeepCollectionEquality()
                    .equals(other.characters, characters)) &&
            (identical(other.words, words) ||
                const DeepCollectionEquality().equals(other.words, words)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(characters) ^
      const DeepCollectionEquality().hash(words) ^
      runtimeType.hashCode;
}

extension $ForcedAlignmentResponseModelExtension
    on ForcedAlignmentResponseModel {
  ForcedAlignmentResponseModel copyWith(
      {List<ForcedAlignmentCharacterResponseModel>? characters,
      List<ForcedAlignmentWordResponseModel>? words}) {
    return ForcedAlignmentResponseModel(
        characters: characters ?? this.characters, words: words ?? this.words);
  }

  ForcedAlignmentResponseModel copyWithWrapped(
      {Wrapped<List<ForcedAlignmentCharacterResponseModel>>? characters,
      Wrapped<List<ForcedAlignmentWordResponseModel>>? words}) {
    return ForcedAlignmentResponseModel(
        characters: (characters != null ? characters.value : this.characters),
        words: (words != null ? words.value : this.words));
  }
}

@JsonSerializable(explicitToJson: true)
class ForcedAlignmentWordResponseModel {
  const ForcedAlignmentWordResponseModel({
    required this.text,
    required this.start,
    required this.end,
  });

  factory ForcedAlignmentWordResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$ForcedAlignmentWordResponseModelFromJson(json);

  static const toJsonFactory = _$ForcedAlignmentWordResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$ForcedAlignmentWordResponseModelToJson(this);

  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'start')
  final double start;
  @JsonKey(name: 'end')
  final double end;
  static const fromJsonFactory = _$ForcedAlignmentWordResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ForcedAlignmentWordResponseModel &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.start, start) ||
                const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) ||
                const DeepCollectionEquality().equals(other.end, end)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      runtimeType.hashCode;
}

extension $ForcedAlignmentWordResponseModelExtension
    on ForcedAlignmentWordResponseModel {
  ForcedAlignmentWordResponseModel copyWith(
      {String? text, double? start, double? end}) {
    return ForcedAlignmentWordResponseModel(
        text: text ?? this.text,
        start: start ?? this.start,
        end: end ?? this.end);
  }

  ForcedAlignmentWordResponseModel copyWithWrapped(
      {Wrapped<String>? text, Wrapped<double>? start, Wrapped<double>? end}) {
    return ForcedAlignmentWordResponseModel(
        text: (text != null ? text.value : this.text),
        start: (start != null ? start.value : this.start),
        end: (end != null ? end.value : this.end));
  }
}

@JsonSerializable(explicitToJson: true)
class GetAgentEmbedResponseModel {
  const GetAgentEmbedResponseModel({
    required this.agentId,
    required this.widgetConfig,
  });

  factory GetAgentEmbedResponseModel.fromJson(Map<String, dynamic> json) =>
      _$GetAgentEmbedResponseModelFromJson(json);

  static const toJsonFactory = _$GetAgentEmbedResponseModelToJson;
  Map<String, dynamic> toJson() => _$GetAgentEmbedResponseModelToJson(this);

  @JsonKey(name: 'agent_id')
  final String agentId;
  @JsonKey(name: 'widget_config')
  final WidgetConfigResponseModel widgetConfig;
  static const fromJsonFactory = _$GetAgentEmbedResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetAgentEmbedResponseModel &&
            (identical(other.agentId, agentId) ||
                const DeepCollectionEquality()
                    .equals(other.agentId, agentId)) &&
            (identical(other.widgetConfig, widgetConfig) ||
                const DeepCollectionEquality()
                    .equals(other.widgetConfig, widgetConfig)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(agentId) ^
      const DeepCollectionEquality().hash(widgetConfig) ^
      runtimeType.hashCode;
}

extension $GetAgentEmbedResponseModelExtension on GetAgentEmbedResponseModel {
  GetAgentEmbedResponseModel copyWith(
      {String? agentId, WidgetConfigResponseModel? widgetConfig}) {
    return GetAgentEmbedResponseModel(
        agentId: agentId ?? this.agentId,
        widgetConfig: widgetConfig ?? this.widgetConfig);
  }

  GetAgentEmbedResponseModel copyWithWrapped(
      {Wrapped<String>? agentId,
      Wrapped<WidgetConfigResponseModel>? widgetConfig}) {
    return GetAgentEmbedResponseModel(
        agentId: (agentId != null ? agentId.value : this.agentId),
        widgetConfig:
            (widgetConfig != null ? widgetConfig.value : this.widgetConfig));
  }
}

@JsonSerializable(explicitToJson: true)
class GetAgentKnowledgebaseSizeResponseModel {
  const GetAgentKnowledgebaseSizeResponseModel({
    required this.numberOfPages,
  });

  factory GetAgentKnowledgebaseSizeResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$GetAgentKnowledgebaseSizeResponseModelFromJson(json);

  static const toJsonFactory = _$GetAgentKnowledgebaseSizeResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$GetAgentKnowledgebaseSizeResponseModelToJson(this);

  @JsonKey(name: 'number_of_pages')
  final double numberOfPages;
  static const fromJsonFactory =
      _$GetAgentKnowledgebaseSizeResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetAgentKnowledgebaseSizeResponseModel &&
            (identical(other.numberOfPages, numberOfPages) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfPages, numberOfPages)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(numberOfPages) ^ runtimeType.hashCode;
}

extension $GetAgentKnowledgebaseSizeResponseModelExtension
    on GetAgentKnowledgebaseSizeResponseModel {
  GetAgentKnowledgebaseSizeResponseModel copyWith({double? numberOfPages}) {
    return GetAgentKnowledgebaseSizeResponseModel(
        numberOfPages: numberOfPages ?? this.numberOfPages);
  }

  GetAgentKnowledgebaseSizeResponseModel copyWithWrapped(
      {Wrapped<double>? numberOfPages}) {
    return GetAgentKnowledgebaseSizeResponseModel(
        numberOfPages:
            (numberOfPages != null ? numberOfPages.value : this.numberOfPages));
  }
}

@JsonSerializable(explicitToJson: true)
class GetAgentLinkResponseModel {
  const GetAgentLinkResponseModel({
    required this.agentId,
    this.token,
  });

  factory GetAgentLinkResponseModel.fromJson(Map<String, dynamic> json) =>
      _$GetAgentLinkResponseModelFromJson(json);

  static const toJsonFactory = _$GetAgentLinkResponseModelToJson;
  Map<String, dynamic> toJson() => _$GetAgentLinkResponseModelToJson(this);

  @JsonKey(name: 'agent_id')
  final String agentId;
  @JsonKey(name: 'token')
  final dynamic token;
  static const fromJsonFactory = _$GetAgentLinkResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetAgentLinkResponseModel &&
            (identical(other.agentId, agentId) ||
                const DeepCollectionEquality()
                    .equals(other.agentId, agentId)) &&
            (identical(other.token, token) ||
                const DeepCollectionEquality().equals(other.token, token)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(agentId) ^
      const DeepCollectionEquality().hash(token) ^
      runtimeType.hashCode;
}

extension $GetAgentLinkResponseModelExtension on GetAgentLinkResponseModel {
  GetAgentLinkResponseModel copyWith({String? agentId, dynamic token}) {
    return GetAgentLinkResponseModel(
        agentId: agentId ?? this.agentId, token: token ?? this.token);
  }

  GetAgentLinkResponseModel copyWithWrapped(
      {Wrapped<String>? agentId, Wrapped<dynamic>? token}) {
    return GetAgentLinkResponseModel(
        agentId: (agentId != null ? agentId.value : this.agentId),
        token: (token != null ? token.value : this.token));
  }
}

@JsonSerializable(explicitToJson: true)
class GetAgentResponseModel {
  const GetAgentResponseModel({
    required this.agentId,
    required this.name,
    required this.conversationConfig,
    required this.metadata,
    this.platformSettings,
    this.phoneNumbers,
    this.accessInfo,
    this.tags,
  });

  factory GetAgentResponseModel.fromJson(Map<String, dynamic> json) =>
      _$GetAgentResponseModelFromJson(json);

  static const toJsonFactory = _$GetAgentResponseModelToJson;
  Map<String, dynamic> toJson() => _$GetAgentResponseModelToJson(this);

  @JsonKey(name: 'agent_id')
  final String agentId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'conversation_config')
  final ConversationalConfigAPIModelOutput conversationConfig;
  @JsonKey(name: 'metadata')
  final AgentMetadataResponseModel metadata;
  @JsonKey(name: 'platform_settings')
  final AgentPlatformSettingsResponseModel? platformSettings;
  @JsonKey(name: 'phone_numbers', defaultValue: <Object>[])
  final List<Object>? phoneNumbers;
  @JsonKey(name: 'access_info')
  final dynamic accessInfo;
  @JsonKey(name: 'tags', defaultValue: <String>[])
  final List<String>? tags;
  static const fromJsonFactory = _$GetAgentResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetAgentResponseModel &&
            (identical(other.agentId, agentId) ||
                const DeepCollectionEquality()
                    .equals(other.agentId, agentId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.conversationConfig, conversationConfig) ||
                const DeepCollectionEquality()
                    .equals(other.conversationConfig, conversationConfig)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.platformSettings, platformSettings) ||
                const DeepCollectionEquality()
                    .equals(other.platformSettings, platformSettings)) &&
            (identical(other.phoneNumbers, phoneNumbers) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumbers, phoneNumbers)) &&
            (identical(other.accessInfo, accessInfo) ||
                const DeepCollectionEquality()
                    .equals(other.accessInfo, accessInfo)) &&
            (identical(other.tags, tags) ||
                const DeepCollectionEquality().equals(other.tags, tags)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(agentId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(conversationConfig) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(platformSettings) ^
      const DeepCollectionEquality().hash(phoneNumbers) ^
      const DeepCollectionEquality().hash(accessInfo) ^
      const DeepCollectionEquality().hash(tags) ^
      runtimeType.hashCode;
}

extension $GetAgentResponseModelExtension on GetAgentResponseModel {
  GetAgentResponseModel copyWith(
      {String? agentId,
      String? name,
      ConversationalConfigAPIModelOutput? conversationConfig,
      AgentMetadataResponseModel? metadata,
      AgentPlatformSettingsResponseModel? platformSettings,
      List<Object>? phoneNumbers,
      dynamic accessInfo,
      List<String>? tags}) {
    return GetAgentResponseModel(
        agentId: agentId ?? this.agentId,
        name: name ?? this.name,
        conversationConfig: conversationConfig ?? this.conversationConfig,
        metadata: metadata ?? this.metadata,
        platformSettings: platformSettings ?? this.platformSettings,
        phoneNumbers: phoneNumbers ?? this.phoneNumbers,
        accessInfo: accessInfo ?? this.accessInfo,
        tags: tags ?? this.tags);
  }

  GetAgentResponseModel copyWithWrapped(
      {Wrapped<String>? agentId,
      Wrapped<String>? name,
      Wrapped<ConversationalConfigAPIModelOutput>? conversationConfig,
      Wrapped<AgentMetadataResponseModel>? metadata,
      Wrapped<AgentPlatformSettingsResponseModel?>? platformSettings,
      Wrapped<List<Object>?>? phoneNumbers,
      Wrapped<dynamic>? accessInfo,
      Wrapped<List<String>?>? tags}) {
    return GetAgentResponseModel(
        agentId: (agentId != null ? agentId.value : this.agentId),
        name: (name != null ? name.value : this.name),
        conversationConfig: (conversationConfig != null
            ? conversationConfig.value
            : this.conversationConfig),
        metadata: (metadata != null ? metadata.value : this.metadata),
        platformSettings: (platformSettings != null
            ? platformSettings.value
            : this.platformSettings),
        phoneNumbers:
            (phoneNumbers != null ? phoneNumbers.value : this.phoneNumbers),
        accessInfo: (accessInfo != null ? accessInfo.value : this.accessInfo),
        tags: (tags != null ? tags.value : this.tags));
  }
}

@JsonSerializable(explicitToJson: true)
class GetAgentsPageResponseModel {
  const GetAgentsPageResponseModel({
    required this.agents,
    this.nextCursor,
    required this.hasMore,
  });

  factory GetAgentsPageResponseModel.fromJson(Map<String, dynamic> json) =>
      _$GetAgentsPageResponseModelFromJson(json);

  static const toJsonFactory = _$GetAgentsPageResponseModelToJson;
  Map<String, dynamic> toJson() => _$GetAgentsPageResponseModelToJson(this);

  @JsonKey(name: 'agents', defaultValue: <AgentSummaryResponseModel>[])
  final List<AgentSummaryResponseModel> agents;
  @JsonKey(name: 'next_cursor')
  final dynamic nextCursor;
  @JsonKey(name: 'has_more')
  final bool hasMore;
  static const fromJsonFactory = _$GetAgentsPageResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetAgentsPageResponseModel &&
            (identical(other.agents, agents) ||
                const DeepCollectionEquality().equals(other.agents, agents)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.hasMore, hasMore) ||
                const DeepCollectionEquality().equals(other.hasMore, hasMore)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(agents) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(hasMore) ^
      runtimeType.hashCode;
}

extension $GetAgentsPageResponseModelExtension on GetAgentsPageResponseModel {
  GetAgentsPageResponseModel copyWith(
      {List<AgentSummaryResponseModel>? agents,
      dynamic nextCursor,
      bool? hasMore}) {
    return GetAgentsPageResponseModel(
        agents: agents ?? this.agents,
        nextCursor: nextCursor ?? this.nextCursor,
        hasMore: hasMore ?? this.hasMore);
  }

  GetAgentsPageResponseModel copyWithWrapped(
      {Wrapped<List<AgentSummaryResponseModel>>? agents,
      Wrapped<dynamic>? nextCursor,
      Wrapped<bool>? hasMore}) {
    return GetAgentsPageResponseModel(
        agents: (agents != null ? agents.value : this.agents),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        hasMore: (hasMore != null ? hasMore.value : this.hasMore));
  }
}

@JsonSerializable(explicitToJson: true)
class GetAudioNativeProjectSettingsResponseModel {
  const GetAudioNativeProjectSettingsResponseModel({
    required this.enabled,
    this.snapshotId,
    this.settings,
  });

  factory GetAudioNativeProjectSettingsResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$GetAudioNativeProjectSettingsResponseModelFromJson(json);

  static const toJsonFactory =
      _$GetAudioNativeProjectSettingsResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$GetAudioNativeProjectSettingsResponseModelToJson(this);

  @JsonKey(name: 'enabled')
  final bool enabled;
  @JsonKey(name: 'snapshot_id')
  final dynamic snapshotId;
  @JsonKey(name: 'settings')
  final dynamic settings;
  static const fromJsonFactory =
      _$GetAudioNativeProjectSettingsResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetAudioNativeProjectSettingsResponseModel &&
            (identical(other.enabled, enabled) ||
                const DeepCollectionEquality()
                    .equals(other.enabled, enabled)) &&
            (identical(other.snapshotId, snapshotId) ||
                const DeepCollectionEquality()
                    .equals(other.snapshotId, snapshotId)) &&
            (identical(other.settings, settings) ||
                const DeepCollectionEquality()
                    .equals(other.settings, settings)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(enabled) ^
      const DeepCollectionEquality().hash(snapshotId) ^
      const DeepCollectionEquality().hash(settings) ^
      runtimeType.hashCode;
}

extension $GetAudioNativeProjectSettingsResponseModelExtension
    on GetAudioNativeProjectSettingsResponseModel {
  GetAudioNativeProjectSettingsResponseModel copyWith(
      {bool? enabled, dynamic snapshotId, dynamic settings}) {
    return GetAudioNativeProjectSettingsResponseModel(
        enabled: enabled ?? this.enabled,
        snapshotId: snapshotId ?? this.snapshotId,
        settings: settings ?? this.settings);
  }

  GetAudioNativeProjectSettingsResponseModel copyWithWrapped(
      {Wrapped<bool>? enabled,
      Wrapped<dynamic>? snapshotId,
      Wrapped<dynamic>? settings}) {
    return GetAudioNativeProjectSettingsResponseModel(
        enabled: (enabled != null ? enabled.value : this.enabled),
        snapshotId: (snapshotId != null ? snapshotId.value : this.snapshotId),
        settings: (settings != null ? settings.value : this.settings));
  }
}

@JsonSerializable(explicitToJson: true)
class GetChaptersResponseModel {
  const GetChaptersResponseModel({
    required this.chapters,
  });

  factory GetChaptersResponseModel.fromJson(Map<String, dynamic> json) =>
      _$GetChaptersResponseModelFromJson(json);

  static const toJsonFactory = _$GetChaptersResponseModelToJson;
  Map<String, dynamic> toJson() => _$GetChaptersResponseModelToJson(this);

  @JsonKey(name: 'chapters', defaultValue: <ChapterResponseModel>[])
  final List<ChapterResponseModel> chapters;
  static const fromJsonFactory = _$GetChaptersResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetChaptersResponseModel &&
            (identical(other.chapters, chapters) ||
                const DeepCollectionEquality()
                    .equals(other.chapters, chapters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(chapters) ^ runtimeType.hashCode;
}

extension $GetChaptersResponseModelExtension on GetChaptersResponseModel {
  GetChaptersResponseModel copyWith({List<ChapterResponseModel>? chapters}) {
    return GetChaptersResponseModel(chapters: chapters ?? this.chapters);
  }

  GetChaptersResponseModel copyWithWrapped(
      {Wrapped<List<ChapterResponseModel>>? chapters}) {
    return GetChaptersResponseModel(
        chapters: (chapters != null ? chapters.value : this.chapters));
  }
}

@JsonSerializable(explicitToJson: true)
class GetConvAIDashboardSettingsResponseModel {
  const GetConvAIDashboardSettingsResponseModel({
    this.charts,
  });

  factory GetConvAIDashboardSettingsResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$GetConvAIDashboardSettingsResponseModelFromJson(json);

  static const toJsonFactory = _$GetConvAIDashboardSettingsResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$GetConvAIDashboardSettingsResponseModelToJson(this);

  @JsonKey(name: 'charts', defaultValue: <Object>[])
  final List<Object>? charts;
  static const fromJsonFactory =
      _$GetConvAIDashboardSettingsResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetConvAIDashboardSettingsResponseModel &&
            (identical(other.charts, charts) ||
                const DeepCollectionEquality().equals(other.charts, charts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(charts) ^ runtimeType.hashCode;
}

extension $GetConvAIDashboardSettingsResponseModelExtension
    on GetConvAIDashboardSettingsResponseModel {
  GetConvAIDashboardSettingsResponseModel copyWith({List<Object>? charts}) {
    return GetConvAIDashboardSettingsResponseModel(
        charts: charts ?? this.charts);
  }

  GetConvAIDashboardSettingsResponseModel copyWithWrapped(
      {Wrapped<List<Object>?>? charts}) {
    return GetConvAIDashboardSettingsResponseModel(
        charts: (charts != null ? charts.value : this.charts));
  }
}

@JsonSerializable(explicitToJson: true)
class GetConvAISettingsResponseModel {
  const GetConvAISettingsResponseModel({
    this.conversationInitiationClientDataWebhook,
    this.webhooks,
    this.canUseMcpServers,
    this.ragRetentionPeriodDays,
  });

  factory GetConvAISettingsResponseModel.fromJson(Map<String, dynamic> json) =>
      _$GetConvAISettingsResponseModelFromJson(json);

  static const toJsonFactory = _$GetConvAISettingsResponseModelToJson;
  Map<String, dynamic> toJson() => _$GetConvAISettingsResponseModelToJson(this);

  @JsonKey(name: 'conversation_initiation_client_data_webhook')
  final dynamic conversationInitiationClientDataWebhook;
  @JsonKey(name: 'webhooks')
  final ConvAIWebhooks? webhooks;
  @JsonKey(name: 'can_use_mcp_servers', defaultValue: false)
  final bool? canUseMcpServers;
  @JsonKey(name: 'rag_retention_period_days')
  final int? ragRetentionPeriodDays;
  static const fromJsonFactory = _$GetConvAISettingsResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetConvAISettingsResponseModel &&
            (identical(other.conversationInitiationClientDataWebhook,
                    conversationInitiationClientDataWebhook) ||
                const DeepCollectionEquality().equals(
                    other.conversationInitiationClientDataWebhook,
                    conversationInitiationClientDataWebhook)) &&
            (identical(other.webhooks, webhooks) ||
                const DeepCollectionEquality()
                    .equals(other.webhooks, webhooks)) &&
            (identical(other.canUseMcpServers, canUseMcpServers) ||
                const DeepCollectionEquality()
                    .equals(other.canUseMcpServers, canUseMcpServers)) &&
            (identical(other.ragRetentionPeriodDays, ragRetentionPeriodDays) ||
                const DeepCollectionEquality().equals(
                    other.ragRetentionPeriodDays, ragRetentionPeriodDays)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality()
          .hash(conversationInitiationClientDataWebhook) ^
      const DeepCollectionEquality().hash(webhooks) ^
      const DeepCollectionEquality().hash(canUseMcpServers) ^
      const DeepCollectionEquality().hash(ragRetentionPeriodDays) ^
      runtimeType.hashCode;
}

extension $GetConvAISettingsResponseModelExtension
    on GetConvAISettingsResponseModel {
  GetConvAISettingsResponseModel copyWith(
      {dynamic conversationInitiationClientDataWebhook,
      ConvAIWebhooks? webhooks,
      bool? canUseMcpServers,
      int? ragRetentionPeriodDays}) {
    return GetConvAISettingsResponseModel(
        conversationInitiationClientDataWebhook:
            conversationInitiationClientDataWebhook ??
                this.conversationInitiationClientDataWebhook,
        webhooks: webhooks ?? this.webhooks,
        canUseMcpServers: canUseMcpServers ?? this.canUseMcpServers,
        ragRetentionPeriodDays:
            ragRetentionPeriodDays ?? this.ragRetentionPeriodDays);
  }

  GetConvAISettingsResponseModel copyWithWrapped(
      {Wrapped<dynamic>? conversationInitiationClientDataWebhook,
      Wrapped<ConvAIWebhooks?>? webhooks,
      Wrapped<bool?>? canUseMcpServers,
      Wrapped<int?>? ragRetentionPeriodDays}) {
    return GetConvAISettingsResponseModel(
        conversationInitiationClientDataWebhook:
            (conversationInitiationClientDataWebhook != null
                ? conversationInitiationClientDataWebhook.value
                : this.conversationInitiationClientDataWebhook),
        webhooks: (webhooks != null ? webhooks.value : this.webhooks),
        canUseMcpServers: (canUseMcpServers != null
            ? canUseMcpServers.value
            : this.canUseMcpServers),
        ragRetentionPeriodDays: (ragRetentionPeriodDays != null
            ? ragRetentionPeriodDays.value
            : this.ragRetentionPeriodDays));
  }
}

@JsonSerializable(explicitToJson: true)
class GetConversationResponseModel {
  const GetConversationResponseModel({
    required this.agentId,
    required this.conversationId,
    required this.status,
    required this.transcript,
    required this.metadata,
    this.analysis,
    this.conversationInitiationClientData,
    required this.hasAudio,
    required this.hasUserAudio,
    required this.hasResponseAudio,
  });

  factory GetConversationResponseModel.fromJson(Map<String, dynamic> json) =>
      _$GetConversationResponseModelFromJson(json);

  static const toJsonFactory = _$GetConversationResponseModelToJson;
  Map<String, dynamic> toJson() => _$GetConversationResponseModelToJson(this);

  @JsonKey(name: 'agent_id')
  final String agentId;
  @JsonKey(name: 'conversation_id')
  final String conversationId;
  @JsonKey(
    name: 'status',
    toJson: getConversationResponseModelStatusToJson,
    fromJson: getConversationResponseModelStatusFromJson,
  )
  final enums.GetConversationResponseModelStatus status;
  @JsonKey(
      name: 'transcript',
      defaultValue: <ConversationHistoryTranscriptCommonModelOutput>[])
  final List<ConversationHistoryTranscriptCommonModelOutput> transcript;
  @JsonKey(name: 'metadata')
  final ConversationHistoryMetadataCommonModel metadata;
  @JsonKey(name: 'analysis')
  final dynamic analysis;
  @JsonKey(name: 'conversation_initiation_client_data')
  final ConversationInitiationClientDataRequestOutput?
      conversationInitiationClientData;
  @JsonKey(name: 'has_audio')
  final bool hasAudio;
  @JsonKey(name: 'has_user_audio')
  final bool hasUserAudio;
  @JsonKey(name: 'has_response_audio')
  final bool hasResponseAudio;
  static const fromJsonFactory = _$GetConversationResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetConversationResponseModel &&
            (identical(other.agentId, agentId) ||
                const DeepCollectionEquality()
                    .equals(other.agentId, agentId)) &&
            (identical(other.conversationId, conversationId) ||
                const DeepCollectionEquality()
                    .equals(other.conversationId, conversationId)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.transcript, transcript) ||
                const DeepCollectionEquality()
                    .equals(other.transcript, transcript)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.analysis, analysis) ||
                const DeepCollectionEquality()
                    .equals(other.analysis, analysis)) &&
            (identical(other.conversationInitiationClientData,
                    conversationInitiationClientData) ||
                const DeepCollectionEquality().equals(
                    other.conversationInitiationClientData,
                    conversationInitiationClientData)) &&
            (identical(other.hasAudio, hasAudio) ||
                const DeepCollectionEquality()
                    .equals(other.hasAudio, hasAudio)) &&
            (identical(other.hasUserAudio, hasUserAudio) ||
                const DeepCollectionEquality()
                    .equals(other.hasUserAudio, hasUserAudio)) &&
            (identical(other.hasResponseAudio, hasResponseAudio) ||
                const DeepCollectionEquality()
                    .equals(other.hasResponseAudio, hasResponseAudio)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(agentId) ^
      const DeepCollectionEquality().hash(conversationId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(transcript) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(analysis) ^
      const DeepCollectionEquality().hash(conversationInitiationClientData) ^
      const DeepCollectionEquality().hash(hasAudio) ^
      const DeepCollectionEquality().hash(hasUserAudio) ^
      const DeepCollectionEquality().hash(hasResponseAudio) ^
      runtimeType.hashCode;
}

extension $GetConversationResponseModelExtension
    on GetConversationResponseModel {
  GetConversationResponseModel copyWith(
      {String? agentId,
      String? conversationId,
      enums.GetConversationResponseModelStatus? status,
      List<ConversationHistoryTranscriptCommonModelOutput>? transcript,
      ConversationHistoryMetadataCommonModel? metadata,
      dynamic analysis,
      ConversationInitiationClientDataRequestOutput?
          conversationInitiationClientData,
      bool? hasAudio,
      bool? hasUserAudio,
      bool? hasResponseAudio}) {
    return GetConversationResponseModel(
        agentId: agentId ?? this.agentId,
        conversationId: conversationId ?? this.conversationId,
        status: status ?? this.status,
        transcript: transcript ?? this.transcript,
        metadata: metadata ?? this.metadata,
        analysis: analysis ?? this.analysis,
        conversationInitiationClientData: conversationInitiationClientData ??
            this.conversationInitiationClientData,
        hasAudio: hasAudio ?? this.hasAudio,
        hasUserAudio: hasUserAudio ?? this.hasUserAudio,
        hasResponseAudio: hasResponseAudio ?? this.hasResponseAudio);
  }

  GetConversationResponseModel copyWithWrapped(
      {Wrapped<String>? agentId,
      Wrapped<String>? conversationId,
      Wrapped<enums.GetConversationResponseModelStatus>? status,
      Wrapped<List<ConversationHistoryTranscriptCommonModelOutput>>? transcript,
      Wrapped<ConversationHistoryMetadataCommonModel>? metadata,
      Wrapped<dynamic>? analysis,
      Wrapped<ConversationInitiationClientDataRequestOutput?>?
          conversationInitiationClientData,
      Wrapped<bool>? hasAudio,
      Wrapped<bool>? hasUserAudio,
      Wrapped<bool>? hasResponseAudio}) {
    return GetConversationResponseModel(
        agentId: (agentId != null ? agentId.value : this.agentId),
        conversationId: (conversationId != null
            ? conversationId.value
            : this.conversationId),
        status: (status != null ? status.value : this.status),
        transcript: (transcript != null ? transcript.value : this.transcript),
        metadata: (metadata != null ? metadata.value : this.metadata),
        analysis: (analysis != null ? analysis.value : this.analysis),
        conversationInitiationClientData:
            (conversationInitiationClientData != null
                ? conversationInitiationClientData.value
                : this.conversationInitiationClientData),
        hasAudio: (hasAudio != null ? hasAudio.value : this.hasAudio),
        hasUserAudio:
            (hasUserAudio != null ? hasUserAudio.value : this.hasUserAudio),
        hasResponseAudio: (hasResponseAudio != null
            ? hasResponseAudio.value
            : this.hasResponseAudio));
  }
}

@JsonSerializable(explicitToJson: true)
class GetConversationsPageResponseModel {
  const GetConversationsPageResponseModel({
    required this.conversations,
    this.nextCursor,
    required this.hasMore,
  });

  factory GetConversationsPageResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$GetConversationsPageResponseModelFromJson(json);

  static const toJsonFactory = _$GetConversationsPageResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$GetConversationsPageResponseModelToJson(this);

  @JsonKey(
      name: 'conversations', defaultValue: <ConversationSummaryResponseModel>[])
  final List<ConversationSummaryResponseModel> conversations;
  @JsonKey(name: 'next_cursor')
  final dynamic nextCursor;
  @JsonKey(name: 'has_more')
  final bool hasMore;
  static const fromJsonFactory = _$GetConversationsPageResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetConversationsPageResponseModel &&
            (identical(other.conversations, conversations) ||
                const DeepCollectionEquality()
                    .equals(other.conversations, conversations)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.hasMore, hasMore) ||
                const DeepCollectionEquality().equals(other.hasMore, hasMore)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(conversations) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(hasMore) ^
      runtimeType.hashCode;
}

extension $GetConversationsPageResponseModelExtension
    on GetConversationsPageResponseModel {
  GetConversationsPageResponseModel copyWith(
      {List<ConversationSummaryResponseModel>? conversations,
      dynamic nextCursor,
      bool? hasMore}) {
    return GetConversationsPageResponseModel(
        conversations: conversations ?? this.conversations,
        nextCursor: nextCursor ?? this.nextCursor,
        hasMore: hasMore ?? this.hasMore);
  }

  GetConversationsPageResponseModel copyWithWrapped(
      {Wrapped<List<ConversationSummaryResponseModel>>? conversations,
      Wrapped<dynamic>? nextCursor,
      Wrapped<bool>? hasMore}) {
    return GetConversationsPageResponseModel(
        conversations:
            (conversations != null ? conversations.value : this.conversations),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        hasMore: (hasMore != null ? hasMore.value : this.hasMore));
  }
}

@JsonSerializable(explicitToJson: true)
class GetKnowledgeBaseDependentAgentsResponseModel {
  const GetKnowledgeBaseDependentAgentsResponseModel({
    required this.agents,
    this.nextCursor,
    required this.hasMore,
  });

  factory GetKnowledgeBaseDependentAgentsResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$GetKnowledgeBaseDependentAgentsResponseModelFromJson(json);

  static const toJsonFactory =
      _$GetKnowledgeBaseDependentAgentsResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$GetKnowledgeBaseDependentAgentsResponseModelToJson(this);

  @JsonKey(name: 'agents', defaultValue: <Object>[])
  final List<Object> agents;
  @JsonKey(name: 'next_cursor')
  final dynamic nextCursor;
  @JsonKey(name: 'has_more')
  final bool hasMore;
  static const fromJsonFactory =
      _$GetKnowledgeBaseDependentAgentsResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetKnowledgeBaseDependentAgentsResponseModel &&
            (identical(other.agents, agents) ||
                const DeepCollectionEquality().equals(other.agents, agents)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.hasMore, hasMore) ||
                const DeepCollectionEquality().equals(other.hasMore, hasMore)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(agents) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(hasMore) ^
      runtimeType.hashCode;
}

extension $GetKnowledgeBaseDependentAgentsResponseModelExtension
    on GetKnowledgeBaseDependentAgentsResponseModel {
  GetKnowledgeBaseDependentAgentsResponseModel copyWith(
      {List<Object>? agents, dynamic nextCursor, bool? hasMore}) {
    return GetKnowledgeBaseDependentAgentsResponseModel(
        agents: agents ?? this.agents,
        nextCursor: nextCursor ?? this.nextCursor,
        hasMore: hasMore ?? this.hasMore);
  }

  GetKnowledgeBaseDependentAgentsResponseModel copyWithWrapped(
      {Wrapped<List<Object>>? agents,
      Wrapped<dynamic>? nextCursor,
      Wrapped<bool>? hasMore}) {
    return GetKnowledgeBaseDependentAgentsResponseModel(
        agents: (agents != null ? agents.value : this.agents),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        hasMore: (hasMore != null ? hasMore.value : this.hasMore));
  }
}

@JsonSerializable(explicitToJson: true)
class GetKnowledgeBaseFileResponseModel {
  const GetKnowledgeBaseFileResponseModel({
    required this.id,
    required this.name,
    required this.metadata,
    required this.promptInjectable,
    required this.accessInfo,
    required this.extractedInnerHtml,
    required this.type,
  });

  factory GetKnowledgeBaseFileResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$GetKnowledgeBaseFileResponseModelFromJson(json);

  static const toJsonFactory = _$GetKnowledgeBaseFileResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$GetKnowledgeBaseFileResponseModelToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'metadata')
  final KnowledgeBaseDocumentMetadataResponseModel metadata;
  @JsonKey(name: 'prompt_injectable')
  final bool promptInjectable;
  @JsonKey(name: 'access_info')
  final ResourceAccessInfo accessInfo;
  @JsonKey(name: 'extracted_inner_html')
  final String extractedInnerHtml;
  @JsonKey(name: 'type')
  final String type;
  static const fromJsonFactory = _$GetKnowledgeBaseFileResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetKnowledgeBaseFileResponseModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.promptInjectable, promptInjectable) ||
                const DeepCollectionEquality()
                    .equals(other.promptInjectable, promptInjectable)) &&
            (identical(other.accessInfo, accessInfo) ||
                const DeepCollectionEquality()
                    .equals(other.accessInfo, accessInfo)) &&
            (identical(other.extractedInnerHtml, extractedInnerHtml) ||
                const DeepCollectionEquality()
                    .equals(other.extractedInnerHtml, extractedInnerHtml)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(promptInjectable) ^
      const DeepCollectionEquality().hash(accessInfo) ^
      const DeepCollectionEquality().hash(extractedInnerHtml) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $GetKnowledgeBaseFileResponseModelExtension
    on GetKnowledgeBaseFileResponseModel {
  GetKnowledgeBaseFileResponseModel copyWith(
      {String? id,
      String? name,
      KnowledgeBaseDocumentMetadataResponseModel? metadata,
      bool? promptInjectable,
      ResourceAccessInfo? accessInfo,
      String? extractedInnerHtml,
      String? type}) {
    return GetKnowledgeBaseFileResponseModel(
        id: id ?? this.id,
        name: name ?? this.name,
        metadata: metadata ?? this.metadata,
        promptInjectable: promptInjectable ?? this.promptInjectable,
        accessInfo: accessInfo ?? this.accessInfo,
        extractedInnerHtml: extractedInnerHtml ?? this.extractedInnerHtml,
        type: type ?? this.type);
  }

  GetKnowledgeBaseFileResponseModel copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? name,
      Wrapped<KnowledgeBaseDocumentMetadataResponseModel>? metadata,
      Wrapped<bool>? promptInjectable,
      Wrapped<ResourceAccessInfo>? accessInfo,
      Wrapped<String>? extractedInnerHtml,
      Wrapped<String>? type}) {
    return GetKnowledgeBaseFileResponseModel(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        metadata: (metadata != null ? metadata.value : this.metadata),
        promptInjectable: (promptInjectable != null
            ? promptInjectable.value
            : this.promptInjectable),
        accessInfo: (accessInfo != null ? accessInfo.value : this.accessInfo),
        extractedInnerHtml: (extractedInnerHtml != null
            ? extractedInnerHtml.value
            : this.extractedInnerHtml),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class GetKnowledgeBaseListResponseModel {
  const GetKnowledgeBaseListResponseModel({
    required this.documents,
    this.nextCursor,
    required this.hasMore,
  });

  factory GetKnowledgeBaseListResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$GetKnowledgeBaseListResponseModelFromJson(json);

  static const toJsonFactory = _$GetKnowledgeBaseListResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$GetKnowledgeBaseListResponseModelToJson(this);

  @JsonKey(name: 'documents', defaultValue: <Object>[])
  final List<Object> documents;
  @JsonKey(name: 'next_cursor')
  final dynamic nextCursor;
  @JsonKey(name: 'has_more')
  final bool hasMore;
  static const fromJsonFactory = _$GetKnowledgeBaseListResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetKnowledgeBaseListResponseModel &&
            (identical(other.documents, documents) ||
                const DeepCollectionEquality()
                    .equals(other.documents, documents)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.hasMore, hasMore) ||
                const DeepCollectionEquality().equals(other.hasMore, hasMore)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(documents) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(hasMore) ^
      runtimeType.hashCode;
}

extension $GetKnowledgeBaseListResponseModelExtension
    on GetKnowledgeBaseListResponseModel {
  GetKnowledgeBaseListResponseModel copyWith(
      {List<Object>? documents, dynamic nextCursor, bool? hasMore}) {
    return GetKnowledgeBaseListResponseModel(
        documents: documents ?? this.documents,
        nextCursor: nextCursor ?? this.nextCursor,
        hasMore: hasMore ?? this.hasMore);
  }

  GetKnowledgeBaseListResponseModel copyWithWrapped(
      {Wrapped<List<Object>>? documents,
      Wrapped<dynamic>? nextCursor,
      Wrapped<bool>? hasMore}) {
    return GetKnowledgeBaseListResponseModel(
        documents: (documents != null ? documents.value : this.documents),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        hasMore: (hasMore != null ? hasMore.value : this.hasMore));
  }
}

@JsonSerializable(explicitToJson: true)
class GetKnowledgeBaseSummaryFileResponseModel {
  const GetKnowledgeBaseSummaryFileResponseModel({
    required this.id,
    required this.name,
    required this.metadata,
    required this.promptInjectable,
    required this.accessInfo,
    required this.dependentAgents,
    required this.type,
  });

  factory GetKnowledgeBaseSummaryFileResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$GetKnowledgeBaseSummaryFileResponseModelFromJson(json);

  static const toJsonFactory = _$GetKnowledgeBaseSummaryFileResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$GetKnowledgeBaseSummaryFileResponseModelToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'metadata')
  final KnowledgeBaseDocumentMetadataResponseModel metadata;
  @JsonKey(name: 'prompt_injectable')
  final bool promptInjectable;
  @JsonKey(name: 'access_info')
  final ResourceAccessInfo accessInfo;
  @JsonKey(name: 'dependent_agents', defaultValue: <Object>[])
  final List<Object> dependentAgents;
  @JsonKey(name: 'type')
  final String type;
  static const fromJsonFactory =
      _$GetKnowledgeBaseSummaryFileResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetKnowledgeBaseSummaryFileResponseModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.promptInjectable, promptInjectable) ||
                const DeepCollectionEquality()
                    .equals(other.promptInjectable, promptInjectable)) &&
            (identical(other.accessInfo, accessInfo) ||
                const DeepCollectionEquality()
                    .equals(other.accessInfo, accessInfo)) &&
            (identical(other.dependentAgents, dependentAgents) ||
                const DeepCollectionEquality()
                    .equals(other.dependentAgents, dependentAgents)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(promptInjectable) ^
      const DeepCollectionEquality().hash(accessInfo) ^
      const DeepCollectionEquality().hash(dependentAgents) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $GetKnowledgeBaseSummaryFileResponseModelExtension
    on GetKnowledgeBaseSummaryFileResponseModel {
  GetKnowledgeBaseSummaryFileResponseModel copyWith(
      {String? id,
      String? name,
      KnowledgeBaseDocumentMetadataResponseModel? metadata,
      bool? promptInjectable,
      ResourceAccessInfo? accessInfo,
      List<Object>? dependentAgents,
      String? type}) {
    return GetKnowledgeBaseSummaryFileResponseModel(
        id: id ?? this.id,
        name: name ?? this.name,
        metadata: metadata ?? this.metadata,
        promptInjectable: promptInjectable ?? this.promptInjectable,
        accessInfo: accessInfo ?? this.accessInfo,
        dependentAgents: dependentAgents ?? this.dependentAgents,
        type: type ?? this.type);
  }

  GetKnowledgeBaseSummaryFileResponseModel copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? name,
      Wrapped<KnowledgeBaseDocumentMetadataResponseModel>? metadata,
      Wrapped<bool>? promptInjectable,
      Wrapped<ResourceAccessInfo>? accessInfo,
      Wrapped<List<Object>>? dependentAgents,
      Wrapped<String>? type}) {
    return GetKnowledgeBaseSummaryFileResponseModel(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        metadata: (metadata != null ? metadata.value : this.metadata),
        promptInjectable: (promptInjectable != null
            ? promptInjectable.value
            : this.promptInjectable),
        accessInfo: (accessInfo != null ? accessInfo.value : this.accessInfo),
        dependentAgents: (dependentAgents != null
            ? dependentAgents.value
            : this.dependentAgents),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class GetKnowledgeBaseSummaryTextResponseModel {
  const GetKnowledgeBaseSummaryTextResponseModel({
    required this.id,
    required this.name,
    required this.metadata,
    required this.promptInjectable,
    required this.accessInfo,
    required this.dependentAgents,
    required this.type,
  });

  factory GetKnowledgeBaseSummaryTextResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$GetKnowledgeBaseSummaryTextResponseModelFromJson(json);

  static const toJsonFactory = _$GetKnowledgeBaseSummaryTextResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$GetKnowledgeBaseSummaryTextResponseModelToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'metadata')
  final KnowledgeBaseDocumentMetadataResponseModel metadata;
  @JsonKey(name: 'prompt_injectable')
  final bool promptInjectable;
  @JsonKey(name: 'access_info')
  final ResourceAccessInfo accessInfo;
  @JsonKey(name: 'dependent_agents', defaultValue: <Object>[])
  final List<Object> dependentAgents;
  @JsonKey(name: 'type')
  final String type;
  static const fromJsonFactory =
      _$GetKnowledgeBaseSummaryTextResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetKnowledgeBaseSummaryTextResponseModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.promptInjectable, promptInjectable) ||
                const DeepCollectionEquality()
                    .equals(other.promptInjectable, promptInjectable)) &&
            (identical(other.accessInfo, accessInfo) ||
                const DeepCollectionEquality()
                    .equals(other.accessInfo, accessInfo)) &&
            (identical(other.dependentAgents, dependentAgents) ||
                const DeepCollectionEquality()
                    .equals(other.dependentAgents, dependentAgents)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(promptInjectable) ^
      const DeepCollectionEquality().hash(accessInfo) ^
      const DeepCollectionEquality().hash(dependentAgents) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $GetKnowledgeBaseSummaryTextResponseModelExtension
    on GetKnowledgeBaseSummaryTextResponseModel {
  GetKnowledgeBaseSummaryTextResponseModel copyWith(
      {String? id,
      String? name,
      KnowledgeBaseDocumentMetadataResponseModel? metadata,
      bool? promptInjectable,
      ResourceAccessInfo? accessInfo,
      List<Object>? dependentAgents,
      String? type}) {
    return GetKnowledgeBaseSummaryTextResponseModel(
        id: id ?? this.id,
        name: name ?? this.name,
        metadata: metadata ?? this.metadata,
        promptInjectable: promptInjectable ?? this.promptInjectable,
        accessInfo: accessInfo ?? this.accessInfo,
        dependentAgents: dependentAgents ?? this.dependentAgents,
        type: type ?? this.type);
  }

  GetKnowledgeBaseSummaryTextResponseModel copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? name,
      Wrapped<KnowledgeBaseDocumentMetadataResponseModel>? metadata,
      Wrapped<bool>? promptInjectable,
      Wrapped<ResourceAccessInfo>? accessInfo,
      Wrapped<List<Object>>? dependentAgents,
      Wrapped<String>? type}) {
    return GetKnowledgeBaseSummaryTextResponseModel(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        metadata: (metadata != null ? metadata.value : this.metadata),
        promptInjectable: (promptInjectable != null
            ? promptInjectable.value
            : this.promptInjectable),
        accessInfo: (accessInfo != null ? accessInfo.value : this.accessInfo),
        dependentAgents: (dependentAgents != null
            ? dependentAgents.value
            : this.dependentAgents),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class GetKnowledgeBaseSummaryURLResponseModel {
  const GetKnowledgeBaseSummaryURLResponseModel({
    required this.id,
    required this.name,
    required this.metadata,
    required this.promptInjectable,
    required this.accessInfo,
    required this.dependentAgents,
    required this.type,
    required this.url,
  });

  factory GetKnowledgeBaseSummaryURLResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$GetKnowledgeBaseSummaryURLResponseModelFromJson(json);

  static const toJsonFactory = _$GetKnowledgeBaseSummaryURLResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$GetKnowledgeBaseSummaryURLResponseModelToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'metadata')
  final KnowledgeBaseDocumentMetadataResponseModel metadata;
  @JsonKey(name: 'prompt_injectable')
  final bool promptInjectable;
  @JsonKey(name: 'access_info')
  final ResourceAccessInfo accessInfo;
  @JsonKey(name: 'dependent_agents', defaultValue: <Object>[])
  final List<Object> dependentAgents;
  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'url')
  final String url;
  static const fromJsonFactory =
      _$GetKnowledgeBaseSummaryURLResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetKnowledgeBaseSummaryURLResponseModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.promptInjectable, promptInjectable) ||
                const DeepCollectionEquality()
                    .equals(other.promptInjectable, promptInjectable)) &&
            (identical(other.accessInfo, accessInfo) ||
                const DeepCollectionEquality()
                    .equals(other.accessInfo, accessInfo)) &&
            (identical(other.dependentAgents, dependentAgents) ||
                const DeepCollectionEquality()
                    .equals(other.dependentAgents, dependentAgents)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(promptInjectable) ^
      const DeepCollectionEquality().hash(accessInfo) ^
      const DeepCollectionEquality().hash(dependentAgents) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(url) ^
      runtimeType.hashCode;
}

extension $GetKnowledgeBaseSummaryURLResponseModelExtension
    on GetKnowledgeBaseSummaryURLResponseModel {
  GetKnowledgeBaseSummaryURLResponseModel copyWith(
      {String? id,
      String? name,
      KnowledgeBaseDocumentMetadataResponseModel? metadata,
      bool? promptInjectable,
      ResourceAccessInfo? accessInfo,
      List<Object>? dependentAgents,
      String? type,
      String? url}) {
    return GetKnowledgeBaseSummaryURLResponseModel(
        id: id ?? this.id,
        name: name ?? this.name,
        metadata: metadata ?? this.metadata,
        promptInjectable: promptInjectable ?? this.promptInjectable,
        accessInfo: accessInfo ?? this.accessInfo,
        dependentAgents: dependentAgents ?? this.dependentAgents,
        type: type ?? this.type,
        url: url ?? this.url);
  }

  GetKnowledgeBaseSummaryURLResponseModel copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? name,
      Wrapped<KnowledgeBaseDocumentMetadataResponseModel>? metadata,
      Wrapped<bool>? promptInjectable,
      Wrapped<ResourceAccessInfo>? accessInfo,
      Wrapped<List<Object>>? dependentAgents,
      Wrapped<String>? type,
      Wrapped<String>? url}) {
    return GetKnowledgeBaseSummaryURLResponseModel(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        metadata: (metadata != null ? metadata.value : this.metadata),
        promptInjectable: (promptInjectable != null
            ? promptInjectable.value
            : this.promptInjectable),
        accessInfo: (accessInfo != null ? accessInfo.value : this.accessInfo),
        dependentAgents: (dependentAgents != null
            ? dependentAgents.value
            : this.dependentAgents),
        type: (type != null ? type.value : this.type),
        url: (url != null ? url.value : this.url));
  }
}

@JsonSerializable(explicitToJson: true)
class GetKnowledgeBaseTextResponseModel {
  const GetKnowledgeBaseTextResponseModel({
    required this.id,
    required this.name,
    required this.metadata,
    required this.promptInjectable,
    required this.accessInfo,
    required this.extractedInnerHtml,
    required this.type,
  });

  factory GetKnowledgeBaseTextResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$GetKnowledgeBaseTextResponseModelFromJson(json);

  static const toJsonFactory = _$GetKnowledgeBaseTextResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$GetKnowledgeBaseTextResponseModelToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'metadata')
  final KnowledgeBaseDocumentMetadataResponseModel metadata;
  @JsonKey(name: 'prompt_injectable')
  final bool promptInjectable;
  @JsonKey(name: 'access_info')
  final ResourceAccessInfo accessInfo;
  @JsonKey(name: 'extracted_inner_html')
  final String extractedInnerHtml;
  @JsonKey(name: 'type')
  final String type;
  static const fromJsonFactory = _$GetKnowledgeBaseTextResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetKnowledgeBaseTextResponseModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.promptInjectable, promptInjectable) ||
                const DeepCollectionEquality()
                    .equals(other.promptInjectable, promptInjectable)) &&
            (identical(other.accessInfo, accessInfo) ||
                const DeepCollectionEquality()
                    .equals(other.accessInfo, accessInfo)) &&
            (identical(other.extractedInnerHtml, extractedInnerHtml) ||
                const DeepCollectionEquality()
                    .equals(other.extractedInnerHtml, extractedInnerHtml)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(promptInjectable) ^
      const DeepCollectionEquality().hash(accessInfo) ^
      const DeepCollectionEquality().hash(extractedInnerHtml) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $GetKnowledgeBaseTextResponseModelExtension
    on GetKnowledgeBaseTextResponseModel {
  GetKnowledgeBaseTextResponseModel copyWith(
      {String? id,
      String? name,
      KnowledgeBaseDocumentMetadataResponseModel? metadata,
      bool? promptInjectable,
      ResourceAccessInfo? accessInfo,
      String? extractedInnerHtml,
      String? type}) {
    return GetKnowledgeBaseTextResponseModel(
        id: id ?? this.id,
        name: name ?? this.name,
        metadata: metadata ?? this.metadata,
        promptInjectable: promptInjectable ?? this.promptInjectable,
        accessInfo: accessInfo ?? this.accessInfo,
        extractedInnerHtml: extractedInnerHtml ?? this.extractedInnerHtml,
        type: type ?? this.type);
  }

  GetKnowledgeBaseTextResponseModel copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? name,
      Wrapped<KnowledgeBaseDocumentMetadataResponseModel>? metadata,
      Wrapped<bool>? promptInjectable,
      Wrapped<ResourceAccessInfo>? accessInfo,
      Wrapped<String>? extractedInnerHtml,
      Wrapped<String>? type}) {
    return GetKnowledgeBaseTextResponseModel(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        metadata: (metadata != null ? metadata.value : this.metadata),
        promptInjectable: (promptInjectable != null
            ? promptInjectable.value
            : this.promptInjectable),
        accessInfo: (accessInfo != null ? accessInfo.value : this.accessInfo),
        extractedInnerHtml: (extractedInnerHtml != null
            ? extractedInnerHtml.value
            : this.extractedInnerHtml),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class GetKnowledgeBaseURLResponseModel {
  const GetKnowledgeBaseURLResponseModel({
    required this.id,
    required this.name,
    required this.metadata,
    required this.promptInjectable,
    required this.accessInfo,
    required this.extractedInnerHtml,
    required this.type,
    required this.url,
  });

  factory GetKnowledgeBaseURLResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$GetKnowledgeBaseURLResponseModelFromJson(json);

  static const toJsonFactory = _$GetKnowledgeBaseURLResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$GetKnowledgeBaseURLResponseModelToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'metadata')
  final KnowledgeBaseDocumentMetadataResponseModel metadata;
  @JsonKey(name: 'prompt_injectable')
  final bool promptInjectable;
  @JsonKey(name: 'access_info')
  final ResourceAccessInfo accessInfo;
  @JsonKey(name: 'extracted_inner_html')
  final String extractedInnerHtml;
  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'url')
  final String url;
  static const fromJsonFactory = _$GetKnowledgeBaseURLResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetKnowledgeBaseURLResponseModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.metadata, metadata) ||
                const DeepCollectionEquality()
                    .equals(other.metadata, metadata)) &&
            (identical(other.promptInjectable, promptInjectable) ||
                const DeepCollectionEquality()
                    .equals(other.promptInjectable, promptInjectable)) &&
            (identical(other.accessInfo, accessInfo) ||
                const DeepCollectionEquality()
                    .equals(other.accessInfo, accessInfo)) &&
            (identical(other.extractedInnerHtml, extractedInnerHtml) ||
                const DeepCollectionEquality()
                    .equals(other.extractedInnerHtml, extractedInnerHtml)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(metadata) ^
      const DeepCollectionEquality().hash(promptInjectable) ^
      const DeepCollectionEquality().hash(accessInfo) ^
      const DeepCollectionEquality().hash(extractedInnerHtml) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(url) ^
      runtimeType.hashCode;
}

extension $GetKnowledgeBaseURLResponseModelExtension
    on GetKnowledgeBaseURLResponseModel {
  GetKnowledgeBaseURLResponseModel copyWith(
      {String? id,
      String? name,
      KnowledgeBaseDocumentMetadataResponseModel? metadata,
      bool? promptInjectable,
      ResourceAccessInfo? accessInfo,
      String? extractedInnerHtml,
      String? type,
      String? url}) {
    return GetKnowledgeBaseURLResponseModel(
        id: id ?? this.id,
        name: name ?? this.name,
        metadata: metadata ?? this.metadata,
        promptInjectable: promptInjectable ?? this.promptInjectable,
        accessInfo: accessInfo ?? this.accessInfo,
        extractedInnerHtml: extractedInnerHtml ?? this.extractedInnerHtml,
        type: type ?? this.type,
        url: url ?? this.url);
  }

  GetKnowledgeBaseURLResponseModel copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? name,
      Wrapped<KnowledgeBaseDocumentMetadataResponseModel>? metadata,
      Wrapped<bool>? promptInjectable,
      Wrapped<ResourceAccessInfo>? accessInfo,
      Wrapped<String>? extractedInnerHtml,
      Wrapped<String>? type,
      Wrapped<String>? url}) {
    return GetKnowledgeBaseURLResponseModel(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        metadata: (metadata != null ? metadata.value : this.metadata),
        promptInjectable: (promptInjectable != null
            ? promptInjectable.value
            : this.promptInjectable),
        accessInfo: (accessInfo != null ? accessInfo.value : this.accessInfo),
        extractedInnerHtml: (extractedInnerHtml != null
            ? extractedInnerHtml.value
            : this.extractedInnerHtml),
        type: (type != null ? type.value : this.type),
        url: (url != null ? url.value : this.url));
  }
}

@JsonSerializable(explicitToJson: true)
class GetLibraryVoicesResponseModel {
  const GetLibraryVoicesResponseModel({
    required this.voices,
    required this.hasMore,
    this.lastSortId,
  });

  factory GetLibraryVoicesResponseModel.fromJson(Map<String, dynamic> json) =>
      _$GetLibraryVoicesResponseModelFromJson(json);

  static const toJsonFactory = _$GetLibraryVoicesResponseModelToJson;
  Map<String, dynamic> toJson() => _$GetLibraryVoicesResponseModelToJson(this);

  @JsonKey(name: 'voices', defaultValue: <LibraryVoiceResponseModel>[])
  final List<LibraryVoiceResponseModel> voices;
  @JsonKey(name: 'has_more')
  final bool hasMore;
  @JsonKey(name: 'last_sort_id')
  final dynamic lastSortId;
  static const fromJsonFactory = _$GetLibraryVoicesResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetLibraryVoicesResponseModel &&
            (identical(other.voices, voices) ||
                const DeepCollectionEquality().equals(other.voices, voices)) &&
            (identical(other.hasMore, hasMore) ||
                const DeepCollectionEquality()
                    .equals(other.hasMore, hasMore)) &&
            (identical(other.lastSortId, lastSortId) ||
                const DeepCollectionEquality()
                    .equals(other.lastSortId, lastSortId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(voices) ^
      const DeepCollectionEquality().hash(hasMore) ^
      const DeepCollectionEquality().hash(lastSortId) ^
      runtimeType.hashCode;
}

extension $GetLibraryVoicesResponseModelExtension
    on GetLibraryVoicesResponseModel {
  GetLibraryVoicesResponseModel copyWith(
      {List<LibraryVoiceResponseModel>? voices,
      bool? hasMore,
      dynamic lastSortId}) {
    return GetLibraryVoicesResponseModel(
        voices: voices ?? this.voices,
        hasMore: hasMore ?? this.hasMore,
        lastSortId: lastSortId ?? this.lastSortId);
  }

  GetLibraryVoicesResponseModel copyWithWrapped(
      {Wrapped<List<LibraryVoiceResponseModel>>? voices,
      Wrapped<bool>? hasMore,
      Wrapped<dynamic>? lastSortId}) {
    return GetLibraryVoicesResponseModel(
        voices: (voices != null ? voices.value : this.voices),
        hasMore: (hasMore != null ? hasMore.value : this.hasMore),
        lastSortId: (lastSortId != null ? lastSortId.value : this.lastSortId));
  }
}

@JsonSerializable(explicitToJson: true)
class GetPhoneNumberSIPTrunkResponseModel {
  const GetPhoneNumberSIPTrunkResponseModel({
    required this.phoneNumber,
    required this.label,
    required this.phoneNumberId,
    this.assignedAgent,
    this.provider,
    this.providerConfig,
  });

  factory GetPhoneNumberSIPTrunkResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$GetPhoneNumberSIPTrunkResponseModelFromJson(json);

  static const toJsonFactory = _$GetPhoneNumberSIPTrunkResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$GetPhoneNumberSIPTrunkResponseModelToJson(this);

  @JsonKey(name: 'phone_number')
  final String phoneNumber;
  @JsonKey(name: 'label')
  final String label;
  @JsonKey(name: 'phone_number_id')
  final String phoneNumberId;
  @JsonKey(name: 'assigned_agent')
  final dynamic assignedAgent;
  @JsonKey(name: 'provider')
  final String? provider;
  @JsonKey(name: 'provider_config')
  final dynamic providerConfig;
  static const fromJsonFactory = _$GetPhoneNumberSIPTrunkResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetPhoneNumberSIPTrunkResponseModel &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.phoneNumberId, phoneNumberId) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumberId, phoneNumberId)) &&
            (identical(other.assignedAgent, assignedAgent) ||
                const DeepCollectionEquality()
                    .equals(other.assignedAgent, assignedAgent)) &&
            (identical(other.provider, provider) ||
                const DeepCollectionEquality()
                    .equals(other.provider, provider)) &&
            (identical(other.providerConfig, providerConfig) ||
                const DeepCollectionEquality()
                    .equals(other.providerConfig, providerConfig)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(phoneNumberId) ^
      const DeepCollectionEquality().hash(assignedAgent) ^
      const DeepCollectionEquality().hash(provider) ^
      const DeepCollectionEquality().hash(providerConfig) ^
      runtimeType.hashCode;
}

extension $GetPhoneNumberSIPTrunkResponseModelExtension
    on GetPhoneNumberSIPTrunkResponseModel {
  GetPhoneNumberSIPTrunkResponseModel copyWith(
      {String? phoneNumber,
      String? label,
      String? phoneNumberId,
      dynamic assignedAgent,
      String? provider,
      dynamic providerConfig}) {
    return GetPhoneNumberSIPTrunkResponseModel(
        phoneNumber: phoneNumber ?? this.phoneNumber,
        label: label ?? this.label,
        phoneNumberId: phoneNumberId ?? this.phoneNumberId,
        assignedAgent: assignedAgent ?? this.assignedAgent,
        provider: provider ?? this.provider,
        providerConfig: providerConfig ?? this.providerConfig);
  }

  GetPhoneNumberSIPTrunkResponseModel copyWithWrapped(
      {Wrapped<String>? phoneNumber,
      Wrapped<String>? label,
      Wrapped<String>? phoneNumberId,
      Wrapped<dynamic>? assignedAgent,
      Wrapped<String?>? provider,
      Wrapped<dynamic>? providerConfig}) {
    return GetPhoneNumberSIPTrunkResponseModel(
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        label: (label != null ? label.value : this.label),
        phoneNumberId:
            (phoneNumberId != null ? phoneNumberId.value : this.phoneNumberId),
        assignedAgent:
            (assignedAgent != null ? assignedAgent.value : this.assignedAgent),
        provider: (provider != null ? provider.value : this.provider),
        providerConfig: (providerConfig != null
            ? providerConfig.value
            : this.providerConfig));
  }
}

@JsonSerializable(explicitToJson: true)
class GetPhoneNumberTwilioResponseModel {
  const GetPhoneNumberTwilioResponseModel({
    required this.phoneNumber,
    required this.label,
    required this.phoneNumberId,
    this.assignedAgent,
    this.provider,
  });

  factory GetPhoneNumberTwilioResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$GetPhoneNumberTwilioResponseModelFromJson(json);

  static const toJsonFactory = _$GetPhoneNumberTwilioResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$GetPhoneNumberTwilioResponseModelToJson(this);

  @JsonKey(name: 'phone_number')
  final String phoneNumber;
  @JsonKey(name: 'label')
  final String label;
  @JsonKey(name: 'phone_number_id')
  final String phoneNumberId;
  @JsonKey(name: 'assigned_agent')
  final dynamic assignedAgent;
  @JsonKey(name: 'provider')
  final String? provider;
  static const fromJsonFactory = _$GetPhoneNumberTwilioResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetPhoneNumberTwilioResponseModel &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.label, label) ||
                const DeepCollectionEquality().equals(other.label, label)) &&
            (identical(other.phoneNumberId, phoneNumberId) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumberId, phoneNumberId)) &&
            (identical(other.assignedAgent, assignedAgent) ||
                const DeepCollectionEquality()
                    .equals(other.assignedAgent, assignedAgent)) &&
            (identical(other.provider, provider) ||
                const DeepCollectionEquality()
                    .equals(other.provider, provider)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(label) ^
      const DeepCollectionEquality().hash(phoneNumberId) ^
      const DeepCollectionEquality().hash(assignedAgent) ^
      const DeepCollectionEquality().hash(provider) ^
      runtimeType.hashCode;
}

extension $GetPhoneNumberTwilioResponseModelExtension
    on GetPhoneNumberTwilioResponseModel {
  GetPhoneNumberTwilioResponseModel copyWith(
      {String? phoneNumber,
      String? label,
      String? phoneNumberId,
      dynamic assignedAgent,
      String? provider}) {
    return GetPhoneNumberTwilioResponseModel(
        phoneNumber: phoneNumber ?? this.phoneNumber,
        label: label ?? this.label,
        phoneNumberId: phoneNumberId ?? this.phoneNumberId,
        assignedAgent: assignedAgent ?? this.assignedAgent,
        provider: provider ?? this.provider);
  }

  GetPhoneNumberTwilioResponseModel copyWithWrapped(
      {Wrapped<String>? phoneNumber,
      Wrapped<String>? label,
      Wrapped<String>? phoneNumberId,
      Wrapped<dynamic>? assignedAgent,
      Wrapped<String?>? provider}) {
    return GetPhoneNumberTwilioResponseModel(
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        label: (label != null ? label.value : this.label),
        phoneNumberId:
            (phoneNumberId != null ? phoneNumberId.value : this.phoneNumberId),
        assignedAgent:
            (assignedAgent != null ? assignedAgent.value : this.assignedAgent),
        provider: (provider != null ? provider.value : this.provider));
  }
}

@JsonSerializable(explicitToJson: true)
class GetProjectsResponseModel {
  const GetProjectsResponseModel({
    required this.projects,
  });

  factory GetProjectsResponseModel.fromJson(Map<String, dynamic> json) =>
      _$GetProjectsResponseModelFromJson(json);

  static const toJsonFactory = _$GetProjectsResponseModelToJson;
  Map<String, dynamic> toJson() => _$GetProjectsResponseModelToJson(this);

  @JsonKey(name: 'projects', defaultValue: <ProjectResponseModel>[])
  final List<ProjectResponseModel> projects;
  static const fromJsonFactory = _$GetProjectsResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetProjectsResponseModel &&
            (identical(other.projects, projects) ||
                const DeepCollectionEquality()
                    .equals(other.projects, projects)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(projects) ^ runtimeType.hashCode;
}

extension $GetProjectsResponseModelExtension on GetProjectsResponseModel {
  GetProjectsResponseModel copyWith({List<ProjectResponseModel>? projects}) {
    return GetProjectsResponseModel(projects: projects ?? this.projects);
  }

  GetProjectsResponseModel copyWithWrapped(
      {Wrapped<List<ProjectResponseModel>>? projects}) {
    return GetProjectsResponseModel(
        projects: (projects != null ? projects.value : this.projects));
  }
}

@JsonSerializable(explicitToJson: true)
class GetPronunciationDictionariesMetadataResponseModel {
  const GetPronunciationDictionariesMetadataResponseModel({
    required this.pronunciationDictionaries,
    this.nextCursor,
    required this.hasMore,
  });

  factory GetPronunciationDictionariesMetadataResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$GetPronunciationDictionariesMetadataResponseModelFromJson(json);

  static const toJsonFactory =
      _$GetPronunciationDictionariesMetadataResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$GetPronunciationDictionariesMetadataResponseModelToJson(this);

  @JsonKey(
      name: 'pronunciation_dictionaries',
      defaultValue: <GetPronunciationDictionaryMetadataResponseModel>[])
  final List<GetPronunciationDictionaryMetadataResponseModel>
      pronunciationDictionaries;
  @JsonKey(name: 'next_cursor')
  final dynamic nextCursor;
  @JsonKey(name: 'has_more')
  final bool hasMore;
  static const fromJsonFactory =
      _$GetPronunciationDictionariesMetadataResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetPronunciationDictionariesMetadataResponseModel &&
            (identical(other.pronunciationDictionaries,
                    pronunciationDictionaries) ||
                const DeepCollectionEquality().equals(
                    other.pronunciationDictionaries,
                    pronunciationDictionaries)) &&
            (identical(other.nextCursor, nextCursor) ||
                const DeepCollectionEquality()
                    .equals(other.nextCursor, nextCursor)) &&
            (identical(other.hasMore, hasMore) ||
                const DeepCollectionEquality().equals(other.hasMore, hasMore)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(pronunciationDictionaries) ^
      const DeepCollectionEquality().hash(nextCursor) ^
      const DeepCollectionEquality().hash(hasMore) ^
      runtimeType.hashCode;
}

extension $GetPronunciationDictionariesMetadataResponseModelExtension
    on GetPronunciationDictionariesMetadataResponseModel {
  GetPronunciationDictionariesMetadataResponseModel copyWith(
      {List<GetPronunciationDictionaryMetadataResponseModel>?
          pronunciationDictionaries,
      dynamic nextCursor,
      bool? hasMore}) {
    return GetPronunciationDictionariesMetadataResponseModel(
        pronunciationDictionaries:
            pronunciationDictionaries ?? this.pronunciationDictionaries,
        nextCursor: nextCursor ?? this.nextCursor,
        hasMore: hasMore ?? this.hasMore);
  }

  GetPronunciationDictionariesMetadataResponseModel copyWithWrapped(
      {Wrapped<List<GetPronunciationDictionaryMetadataResponseModel>>?
          pronunciationDictionaries,
      Wrapped<dynamic>? nextCursor,
      Wrapped<bool>? hasMore}) {
    return GetPronunciationDictionariesMetadataResponseModel(
        pronunciationDictionaries: (pronunciationDictionaries != null
            ? pronunciationDictionaries.value
            : this.pronunciationDictionaries),
        nextCursor: (nextCursor != null ? nextCursor.value : this.nextCursor),
        hasMore: (hasMore != null ? hasMore.value : this.hasMore));
  }
}

@JsonSerializable(explicitToJson: true)
class GetPronunciationDictionaryMetadataResponseModel {
  const GetPronunciationDictionaryMetadataResponseModel({
    required this.id,
    required this.latestVersionId,
    required this.latestVersionRulesNum,
    required this.name,
    required this.permissionOnResource,
    required this.createdBy,
    required this.creationTimeUnix,
    required this.archivedTimeUnix,
    this.description,
  });

  factory GetPronunciationDictionaryMetadataResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$GetPronunciationDictionaryMetadataResponseModelFromJson(json);

  static const toJsonFactory =
      _$GetPronunciationDictionaryMetadataResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$GetPronunciationDictionaryMetadataResponseModelToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'latest_version_id')
  final String latestVersionId;
  @JsonKey(name: 'latest_version_rules_num')
  final int latestVersionRulesNum;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'permission_on_resource')
  final dynamic permissionOnResource;
  @JsonKey(name: 'created_by')
  final String createdBy;
  @JsonKey(name: 'creation_time_unix')
  final int creationTimeUnix;
  @JsonKey(name: 'archived_time_unix')
  final dynamic archivedTimeUnix;
  @JsonKey(name: 'description')
  final dynamic description;
  static const fromJsonFactory =
      _$GetPronunciationDictionaryMetadataResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetPronunciationDictionaryMetadataResponseModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.latestVersionId, latestVersionId) ||
                const DeepCollectionEquality()
                    .equals(other.latestVersionId, latestVersionId)) &&
            (identical(other.latestVersionRulesNum, latestVersionRulesNum) ||
                const DeepCollectionEquality().equals(
                    other.latestVersionRulesNum, latestVersionRulesNum)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.permissionOnResource, permissionOnResource) ||
                const DeepCollectionEquality().equals(
                    other.permissionOnResource, permissionOnResource)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.creationTimeUnix, creationTimeUnix) ||
                const DeepCollectionEquality()
                    .equals(other.creationTimeUnix, creationTimeUnix)) &&
            (identical(other.archivedTimeUnix, archivedTimeUnix) ||
                const DeepCollectionEquality()
                    .equals(other.archivedTimeUnix, archivedTimeUnix)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(latestVersionId) ^
      const DeepCollectionEquality().hash(latestVersionRulesNum) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(permissionOnResource) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(creationTimeUnix) ^
      const DeepCollectionEquality().hash(archivedTimeUnix) ^
      const DeepCollectionEquality().hash(description) ^
      runtimeType.hashCode;
}

extension $GetPronunciationDictionaryMetadataResponseModelExtension
    on GetPronunciationDictionaryMetadataResponseModel {
  GetPronunciationDictionaryMetadataResponseModel copyWith(
      {String? id,
      String? latestVersionId,
      int? latestVersionRulesNum,
      String? name,
      dynamic permissionOnResource,
      String? createdBy,
      int? creationTimeUnix,
      dynamic archivedTimeUnix,
      dynamic description}) {
    return GetPronunciationDictionaryMetadataResponseModel(
        id: id ?? this.id,
        latestVersionId: latestVersionId ?? this.latestVersionId,
        latestVersionRulesNum:
            latestVersionRulesNum ?? this.latestVersionRulesNum,
        name: name ?? this.name,
        permissionOnResource: permissionOnResource ?? this.permissionOnResource,
        createdBy: createdBy ?? this.createdBy,
        creationTimeUnix: creationTimeUnix ?? this.creationTimeUnix,
        archivedTimeUnix: archivedTimeUnix ?? this.archivedTimeUnix,
        description: description ?? this.description);
  }

  GetPronunciationDictionaryMetadataResponseModel copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? latestVersionId,
      Wrapped<int>? latestVersionRulesNum,
      Wrapped<String>? name,
      Wrapped<dynamic>? permissionOnResource,
      Wrapped<String>? createdBy,
      Wrapped<int>? creationTimeUnix,
      Wrapped<dynamic>? archivedTimeUnix,
      Wrapped<dynamic>? description}) {
    return GetPronunciationDictionaryMetadataResponseModel(
        id: (id != null ? id.value : this.id),
        latestVersionId: (latestVersionId != null
            ? latestVersionId.value
            : this.latestVersionId),
        latestVersionRulesNum: (latestVersionRulesNum != null
            ? latestVersionRulesNum.value
            : this.latestVersionRulesNum),
        name: (name != null ? name.value : this.name),
        permissionOnResource: (permissionOnResource != null
            ? permissionOnResource.value
            : this.permissionOnResource),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        creationTimeUnix: (creationTimeUnix != null
            ? creationTimeUnix.value
            : this.creationTimeUnix),
        archivedTimeUnix: (archivedTimeUnix != null
            ? archivedTimeUnix.value
            : this.archivedTimeUnix),
        description:
            (description != null ? description.value : this.description));
  }
}

@JsonSerializable(explicitToJson: true)
class GetSpeechHistoryResponseModel {
  const GetSpeechHistoryResponseModel({
    required this.history,
    this.lastHistoryItemId,
    required this.hasMore,
  });

  factory GetSpeechHistoryResponseModel.fromJson(Map<String, dynamic> json) =>
      _$GetSpeechHistoryResponseModelFromJson(json);

  static const toJsonFactory = _$GetSpeechHistoryResponseModelToJson;
  Map<String, dynamic> toJson() => _$GetSpeechHistoryResponseModelToJson(this);

  @JsonKey(name: 'history', defaultValue: <SpeechHistoryItemResponseModel>[])
  final List<SpeechHistoryItemResponseModel> history;
  @JsonKey(name: 'last_history_item_id')
  final dynamic lastHistoryItemId;
  @JsonKey(name: 'has_more')
  final bool hasMore;
  static const fromJsonFactory = _$GetSpeechHistoryResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetSpeechHistoryResponseModel &&
            (identical(other.history, history) ||
                const DeepCollectionEquality()
                    .equals(other.history, history)) &&
            (identical(other.lastHistoryItemId, lastHistoryItemId) ||
                const DeepCollectionEquality()
                    .equals(other.lastHistoryItemId, lastHistoryItemId)) &&
            (identical(other.hasMore, hasMore) ||
                const DeepCollectionEquality().equals(other.hasMore, hasMore)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(history) ^
      const DeepCollectionEquality().hash(lastHistoryItemId) ^
      const DeepCollectionEquality().hash(hasMore) ^
      runtimeType.hashCode;
}

extension $GetSpeechHistoryResponseModelExtension
    on GetSpeechHistoryResponseModel {
  GetSpeechHistoryResponseModel copyWith(
      {List<SpeechHistoryItemResponseModel>? history,
      dynamic lastHistoryItemId,
      bool? hasMore}) {
    return GetSpeechHistoryResponseModel(
        history: history ?? this.history,
        lastHistoryItemId: lastHistoryItemId ?? this.lastHistoryItemId,
        hasMore: hasMore ?? this.hasMore);
  }

  GetSpeechHistoryResponseModel copyWithWrapped(
      {Wrapped<List<SpeechHistoryItemResponseModel>>? history,
      Wrapped<dynamic>? lastHistoryItemId,
      Wrapped<bool>? hasMore}) {
    return GetSpeechHistoryResponseModel(
        history: (history != null ? history.value : this.history),
        lastHistoryItemId: (lastHistoryItemId != null
            ? lastHistoryItemId.value
            : this.lastHistoryItemId),
        hasMore: (hasMore != null ? hasMore.value : this.hasMore));
  }
}

@JsonSerializable(explicitToJson: true)
class GetVoicesResponseModel {
  const GetVoicesResponseModel({
    required this.voices,
  });

  factory GetVoicesResponseModel.fromJson(Map<String, dynamic> json) =>
      _$GetVoicesResponseModelFromJson(json);

  static const toJsonFactory = _$GetVoicesResponseModelToJson;
  Map<String, dynamic> toJson() => _$GetVoicesResponseModelToJson(this);

  @JsonKey(name: 'voices', defaultValue: <VoiceResponseModel>[])
  final List<VoiceResponseModel> voices;
  static const fromJsonFactory = _$GetVoicesResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetVoicesResponseModel &&
            (identical(other.voices, voices) ||
                const DeepCollectionEquality().equals(other.voices, voices)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(voices) ^ runtimeType.hashCode;
}

extension $GetVoicesResponseModelExtension on GetVoicesResponseModel {
  GetVoicesResponseModel copyWith({List<VoiceResponseModel>? voices}) {
    return GetVoicesResponseModel(voices: voices ?? this.voices);
  }

  GetVoicesResponseModel copyWithWrapped(
      {Wrapped<List<VoiceResponseModel>>? voices}) {
    return GetVoicesResponseModel(
        voices: (voices != null ? voices.value : this.voices));
  }
}

@JsonSerializable(explicitToJson: true)
class GetVoicesV2ResponseModel {
  const GetVoicesV2ResponseModel({
    required this.voices,
    required this.hasMore,
    required this.totalCount,
    this.nextPageToken,
  });

  factory GetVoicesV2ResponseModel.fromJson(Map<String, dynamic> json) =>
      _$GetVoicesV2ResponseModelFromJson(json);

  static const toJsonFactory = _$GetVoicesV2ResponseModelToJson;
  Map<String, dynamic> toJson() => _$GetVoicesV2ResponseModelToJson(this);

  @JsonKey(name: 'voices', defaultValue: <VoiceResponseModel>[])
  final List<VoiceResponseModel> voices;
  @JsonKey(name: 'has_more')
  final bool hasMore;
  @JsonKey(name: 'total_count')
  final int totalCount;
  @JsonKey(name: 'next_page_token')
  final dynamic nextPageToken;
  static const fromJsonFactory = _$GetVoicesV2ResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetVoicesV2ResponseModel &&
            (identical(other.voices, voices) ||
                const DeepCollectionEquality().equals(other.voices, voices)) &&
            (identical(other.hasMore, hasMore) ||
                const DeepCollectionEquality()
                    .equals(other.hasMore, hasMore)) &&
            (identical(other.totalCount, totalCount) ||
                const DeepCollectionEquality()
                    .equals(other.totalCount, totalCount)) &&
            (identical(other.nextPageToken, nextPageToken) ||
                const DeepCollectionEquality()
                    .equals(other.nextPageToken, nextPageToken)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(voices) ^
      const DeepCollectionEquality().hash(hasMore) ^
      const DeepCollectionEquality().hash(totalCount) ^
      const DeepCollectionEquality().hash(nextPageToken) ^
      runtimeType.hashCode;
}

extension $GetVoicesV2ResponseModelExtension on GetVoicesV2ResponseModel {
  GetVoicesV2ResponseModel copyWith(
      {List<VoiceResponseModel>? voices,
      bool? hasMore,
      int? totalCount,
      dynamic nextPageToken}) {
    return GetVoicesV2ResponseModel(
        voices: voices ?? this.voices,
        hasMore: hasMore ?? this.hasMore,
        totalCount: totalCount ?? this.totalCount,
        nextPageToken: nextPageToken ?? this.nextPageToken);
  }

  GetVoicesV2ResponseModel copyWithWrapped(
      {Wrapped<List<VoiceResponseModel>>? voices,
      Wrapped<bool>? hasMore,
      Wrapped<int>? totalCount,
      Wrapped<dynamic>? nextPageToken}) {
    return GetVoicesV2ResponseModel(
        voices: (voices != null ? voices.value : this.voices),
        hasMore: (hasMore != null ? hasMore.value : this.hasMore),
        totalCount: (totalCount != null ? totalCount.value : this.totalCount),
        nextPageToken:
            (nextPageToken != null ? nextPageToken.value : this.nextPageToken));
  }
}

@JsonSerializable(explicitToJson: true)
class GetWorkspaceSecretsResponseModel {
  const GetWorkspaceSecretsResponseModel({
    required this.secrets,
  });

  factory GetWorkspaceSecretsResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$GetWorkspaceSecretsResponseModelFromJson(json);

  static const toJsonFactory = _$GetWorkspaceSecretsResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$GetWorkspaceSecretsResponseModelToJson(this);

  @JsonKey(name: 'secrets', defaultValue: <ConvAIWorkspaceStoredSecretConfig>[])
  final List<ConvAIWorkspaceStoredSecretConfig> secrets;
  static const fromJsonFactory = _$GetWorkspaceSecretsResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is GetWorkspaceSecretsResponseModel &&
            (identical(other.secrets, secrets) ||
                const DeepCollectionEquality().equals(other.secrets, secrets)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(secrets) ^ runtimeType.hashCode;
}

extension $GetWorkspaceSecretsResponseModelExtension
    on GetWorkspaceSecretsResponseModel {
  GetWorkspaceSecretsResponseModel copyWith(
      {List<ConvAIWorkspaceStoredSecretConfig>? secrets}) {
    return GetWorkspaceSecretsResponseModel(secrets: secrets ?? this.secrets);
  }

  GetWorkspaceSecretsResponseModel copyWithWrapped(
      {Wrapped<List<ConvAIWorkspaceStoredSecretConfig>>? secrets}) {
    return GetWorkspaceSecretsResponseModel(
        secrets: (secrets != null ? secrets.value : this.secrets));
  }
}

@JsonSerializable(explicitToJson: true)
class HTTPValidationError {
  const HTTPValidationError({
    this.detail,
  });

  factory HTTPValidationError.fromJson(Map<String, dynamic> json) =>
      _$HTTPValidationErrorFromJson(json);

  static const toJsonFactory = _$HTTPValidationErrorToJson;
  Map<String, dynamic> toJson() => _$HTTPValidationErrorToJson(this);

  @JsonKey(name: 'detail', defaultValue: <ValidationError>[])
  final List<ValidationError>? detail;
  static const fromJsonFactory = _$HTTPValidationErrorFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is HTTPValidationError &&
            (identical(other.detail, detail) ||
                const DeepCollectionEquality().equals(other.detail, detail)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(detail) ^ runtimeType.hashCode;
}

extension $HTTPValidationErrorExtension on HTTPValidationError {
  HTTPValidationError copyWith({List<ValidationError>? detail}) {
    return HTTPValidationError(detail: detail ?? this.detail);
  }

  HTTPValidationError copyWithWrapped(
      {Wrapped<List<ValidationError>?>? detail}) {
    return HTTPValidationError(
        detail: (detail != null ? detail.value : this.detail));
  }
}

@JsonSerializable(explicitToJson: true)
class HistoryAlignmentResponseModel {
  const HistoryAlignmentResponseModel({
    required this.characters,
    required this.characterStartTimesSeconds,
    required this.characterEndTimesSeconds,
  });

  factory HistoryAlignmentResponseModel.fromJson(Map<String, dynamic> json) =>
      _$HistoryAlignmentResponseModelFromJson(json);

  static const toJsonFactory = _$HistoryAlignmentResponseModelToJson;
  Map<String, dynamic> toJson() => _$HistoryAlignmentResponseModelToJson(this);

  @JsonKey(name: 'characters', defaultValue: <String>[])
  final List<String> characters;
  @JsonKey(name: 'character_start_times_seconds', defaultValue: <double>[])
  final List<double> characterStartTimesSeconds;
  @JsonKey(name: 'character_end_times_seconds', defaultValue: <double>[])
  final List<double> characterEndTimesSeconds;
  static const fromJsonFactory = _$HistoryAlignmentResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is HistoryAlignmentResponseModel &&
            (identical(other.characters, characters) ||
                const DeepCollectionEquality()
                    .equals(other.characters, characters)) &&
            (identical(other.characterStartTimesSeconds,
                    characterStartTimesSeconds) ||
                const DeepCollectionEquality().equals(
                    other.characterStartTimesSeconds,
                    characterStartTimesSeconds)) &&
            (identical(
                    other.characterEndTimesSeconds, characterEndTimesSeconds) ||
                const DeepCollectionEquality().equals(
                    other.characterEndTimesSeconds, characterEndTimesSeconds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(characters) ^
      const DeepCollectionEquality().hash(characterStartTimesSeconds) ^
      const DeepCollectionEquality().hash(characterEndTimesSeconds) ^
      runtimeType.hashCode;
}

extension $HistoryAlignmentResponseModelExtension
    on HistoryAlignmentResponseModel {
  HistoryAlignmentResponseModel copyWith(
      {List<String>? characters,
      List<double>? characterStartTimesSeconds,
      List<double>? characterEndTimesSeconds}) {
    return HistoryAlignmentResponseModel(
        characters: characters ?? this.characters,
        characterStartTimesSeconds:
            characterStartTimesSeconds ?? this.characterStartTimesSeconds,
        characterEndTimesSeconds:
            characterEndTimesSeconds ?? this.characterEndTimesSeconds);
  }

  HistoryAlignmentResponseModel copyWithWrapped(
      {Wrapped<List<String>>? characters,
      Wrapped<List<double>>? characterStartTimesSeconds,
      Wrapped<List<double>>? characterEndTimesSeconds}) {
    return HistoryAlignmentResponseModel(
        characters: (characters != null ? characters.value : this.characters),
        characterStartTimesSeconds: (characterStartTimesSeconds != null
            ? characterStartTimesSeconds.value
            : this.characterStartTimesSeconds),
        characterEndTimesSeconds: (characterEndTimesSeconds != null
            ? characterEndTimesSeconds.value
            : this.characterEndTimesSeconds));
  }
}

@JsonSerializable(explicitToJson: true)
class HistoryAlignmentsResponseModel {
  const HistoryAlignmentsResponseModel({
    required this.alignment,
    required this.normalizedAlignment,
  });

  factory HistoryAlignmentsResponseModel.fromJson(Map<String, dynamic> json) =>
      _$HistoryAlignmentsResponseModelFromJson(json);

  static const toJsonFactory = _$HistoryAlignmentsResponseModelToJson;
  Map<String, dynamic> toJson() => _$HistoryAlignmentsResponseModelToJson(this);

  @JsonKey(name: 'alignment')
  final HistoryAlignmentResponseModel alignment;
  @JsonKey(name: 'normalized_alignment')
  final HistoryAlignmentResponseModel normalizedAlignment;
  static const fromJsonFactory = _$HistoryAlignmentsResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is HistoryAlignmentsResponseModel &&
            (identical(other.alignment, alignment) ||
                const DeepCollectionEquality()
                    .equals(other.alignment, alignment)) &&
            (identical(other.normalizedAlignment, normalizedAlignment) ||
                const DeepCollectionEquality()
                    .equals(other.normalizedAlignment, normalizedAlignment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(alignment) ^
      const DeepCollectionEquality().hash(normalizedAlignment) ^
      runtimeType.hashCode;
}

extension $HistoryAlignmentsResponseModelExtension
    on HistoryAlignmentsResponseModel {
  HistoryAlignmentsResponseModel copyWith(
      {HistoryAlignmentResponseModel? alignment,
      HistoryAlignmentResponseModel? normalizedAlignment}) {
    return HistoryAlignmentsResponseModel(
        alignment: alignment ?? this.alignment,
        normalizedAlignment: normalizedAlignment ?? this.normalizedAlignment);
  }

  HistoryAlignmentsResponseModel copyWithWrapped(
      {Wrapped<HistoryAlignmentResponseModel>? alignment,
      Wrapped<HistoryAlignmentResponseModel>? normalizedAlignment}) {
    return HistoryAlignmentsResponseModel(
        alignment: (alignment != null ? alignment.value : this.alignment),
        normalizedAlignment: (normalizedAlignment != null
            ? normalizedAlignment.value
            : this.normalizedAlignment));
  }
}

@JsonSerializable(explicitToJson: true)
class HtmlExportOptions {
  const HtmlExportOptions({
    this.includeSpeakers,
    this.includeTimestamps,
    required this.format,
    this.segmentOnSilenceLongerThanS,
    this.maxSegmentDurationS,
    this.maxSegmentChars,
  });

  factory HtmlExportOptions.fromJson(Map<String, dynamic> json) =>
      _$HtmlExportOptionsFromJson(json);

  static const toJsonFactory = _$HtmlExportOptionsToJson;
  Map<String, dynamic> toJson() => _$HtmlExportOptionsToJson(this);

  @JsonKey(name: 'include_speakers', defaultValue: true)
  final bool? includeSpeakers;
  @JsonKey(name: 'include_timestamps', defaultValue: true)
  final bool? includeTimestamps;
  @JsonKey(name: 'format')
  final String format;
  @JsonKey(name: 'segment_on_silence_longer_than_s')
  final dynamic segmentOnSilenceLongerThanS;
  @JsonKey(name: 'max_segment_duration_s')
  final dynamic maxSegmentDurationS;
  @JsonKey(name: 'max_segment_chars')
  final dynamic maxSegmentChars;
  static const fromJsonFactory = _$HtmlExportOptionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is HtmlExportOptions &&
            (identical(other.includeSpeakers, includeSpeakers) ||
                const DeepCollectionEquality()
                    .equals(other.includeSpeakers, includeSpeakers)) &&
            (identical(other.includeTimestamps, includeTimestamps) ||
                const DeepCollectionEquality()
                    .equals(other.includeTimestamps, includeTimestamps)) &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)) &&
            (identical(other.segmentOnSilenceLongerThanS,
                    segmentOnSilenceLongerThanS) ||
                const DeepCollectionEquality().equals(
                    other.segmentOnSilenceLongerThanS,
                    segmentOnSilenceLongerThanS)) &&
            (identical(other.maxSegmentDurationS, maxSegmentDurationS) ||
                const DeepCollectionEquality()
                    .equals(other.maxSegmentDurationS, maxSegmentDurationS)) &&
            (identical(other.maxSegmentChars, maxSegmentChars) ||
                const DeepCollectionEquality()
                    .equals(other.maxSegmentChars, maxSegmentChars)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(includeSpeakers) ^
      const DeepCollectionEquality().hash(includeTimestamps) ^
      const DeepCollectionEquality().hash(format) ^
      const DeepCollectionEquality().hash(segmentOnSilenceLongerThanS) ^
      const DeepCollectionEquality().hash(maxSegmentDurationS) ^
      const DeepCollectionEquality().hash(maxSegmentChars) ^
      runtimeType.hashCode;
}

extension $HtmlExportOptionsExtension on HtmlExportOptions {
  HtmlExportOptions copyWith(
      {bool? includeSpeakers,
      bool? includeTimestamps,
      String? format,
      dynamic segmentOnSilenceLongerThanS,
      dynamic maxSegmentDurationS,
      dynamic maxSegmentChars}) {
    return HtmlExportOptions(
        includeSpeakers: includeSpeakers ?? this.includeSpeakers,
        includeTimestamps: includeTimestamps ?? this.includeTimestamps,
        format: format ?? this.format,
        segmentOnSilenceLongerThanS:
            segmentOnSilenceLongerThanS ?? this.segmentOnSilenceLongerThanS,
        maxSegmentDurationS: maxSegmentDurationS ?? this.maxSegmentDurationS,
        maxSegmentChars: maxSegmentChars ?? this.maxSegmentChars);
  }

  HtmlExportOptions copyWithWrapped(
      {Wrapped<bool?>? includeSpeakers,
      Wrapped<bool?>? includeTimestamps,
      Wrapped<String>? format,
      Wrapped<dynamic>? segmentOnSilenceLongerThanS,
      Wrapped<dynamic>? maxSegmentDurationS,
      Wrapped<dynamic>? maxSegmentChars}) {
    return HtmlExportOptions(
        includeSpeakers: (includeSpeakers != null
            ? includeSpeakers.value
            : this.includeSpeakers),
        includeTimestamps: (includeTimestamps != null
            ? includeTimestamps.value
            : this.includeTimestamps),
        format: (format != null ? format.value : this.format),
        segmentOnSilenceLongerThanS: (segmentOnSilenceLongerThanS != null
            ? segmentOnSilenceLongerThanS.value
            : this.segmentOnSilenceLongerThanS),
        maxSegmentDurationS: (maxSegmentDurationS != null
            ? maxSegmentDurationS.value
            : this.maxSegmentDurationS),
        maxSegmentChars: (maxSegmentChars != null
            ? maxSegmentChars.value
            : this.maxSegmentChars));
  }
}

@JsonSerializable(explicitToJson: true)
class ImageAvatar {
  const ImageAvatar({
    this.type,
    this.url,
  });

  factory ImageAvatar.fromJson(Map<String, dynamic> json) =>
      _$ImageAvatarFromJson(json);

  static const toJsonFactory = _$ImageAvatarToJson;
  Map<String, dynamic> toJson() => _$ImageAvatarToJson(this);

  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'url')
  final String? url;
  static const fromJsonFactory = _$ImageAvatarFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ImageAvatar &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(url) ^
      runtimeType.hashCode;
}

extension $ImageAvatarExtension on ImageAvatar {
  ImageAvatar copyWith({String? type, String? url}) {
    return ImageAvatar(type: type ?? this.type, url: url ?? this.url);
  }

  ImageAvatar copyWithWrapped({Wrapped<String?>? type, Wrapped<String?>? url}) {
    return ImageAvatar(
        type: (type != null ? type.value : this.type),
        url: (url != null ? url.value : this.url));
  }
}

@JsonSerializable(explicitToJson: true)
class InvoiceResponseModel {
  const InvoiceResponseModel({
    required this.amountDueCents,
    this.discountPercentOff,
    required this.nextPaymentAttemptUnix,
  });

  factory InvoiceResponseModel.fromJson(Map<String, dynamic> json) =>
      _$InvoiceResponseModelFromJson(json);

  static const toJsonFactory = _$InvoiceResponseModelToJson;
  Map<String, dynamic> toJson() => _$InvoiceResponseModelToJson(this);

  @JsonKey(name: 'amount_due_cents')
  final int amountDueCents;
  @JsonKey(name: 'discount_percent_off')
  final dynamic discountPercentOff;
  @JsonKey(name: 'next_payment_attempt_unix')
  final int nextPaymentAttemptUnix;
  static const fromJsonFactory = _$InvoiceResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is InvoiceResponseModel &&
            (identical(other.amountDueCents, amountDueCents) ||
                const DeepCollectionEquality()
                    .equals(other.amountDueCents, amountDueCents)) &&
            (identical(other.discountPercentOff, discountPercentOff) ||
                const DeepCollectionEquality()
                    .equals(other.discountPercentOff, discountPercentOff)) &&
            (identical(other.nextPaymentAttemptUnix, nextPaymentAttemptUnix) ||
                const DeepCollectionEquality().equals(
                    other.nextPaymentAttemptUnix, nextPaymentAttemptUnix)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(amountDueCents) ^
      const DeepCollectionEquality().hash(discountPercentOff) ^
      const DeepCollectionEquality().hash(nextPaymentAttemptUnix) ^
      runtimeType.hashCode;
}

extension $InvoiceResponseModelExtension on InvoiceResponseModel {
  InvoiceResponseModel copyWith(
      {int? amountDueCents,
      dynamic discountPercentOff,
      int? nextPaymentAttemptUnix}) {
    return InvoiceResponseModel(
        amountDueCents: amountDueCents ?? this.amountDueCents,
        discountPercentOff: discountPercentOff ?? this.discountPercentOff,
        nextPaymentAttemptUnix:
            nextPaymentAttemptUnix ?? this.nextPaymentAttemptUnix);
  }

  InvoiceResponseModel copyWithWrapped(
      {Wrapped<int>? amountDueCents,
      Wrapped<dynamic>? discountPercentOff,
      Wrapped<int>? nextPaymentAttemptUnix}) {
    return InvoiceResponseModel(
        amountDueCents: (amountDueCents != null
            ? amountDueCents.value
            : this.amountDueCents),
        discountPercentOff: (discountPercentOff != null
            ? discountPercentOff.value
            : this.discountPercentOff),
        nextPaymentAttemptUnix: (nextPaymentAttemptUnix != null
            ? nextPaymentAttemptUnix.value
            : this.nextPaymentAttemptUnix));
  }
}

@JsonSerializable(explicitToJson: true)
class KnowledgeBaseDocumentChunkResponseModel {
  const KnowledgeBaseDocumentChunkResponseModel({
    required this.id,
    required this.name,
    required this.content,
  });

  factory KnowledgeBaseDocumentChunkResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$KnowledgeBaseDocumentChunkResponseModelFromJson(json);

  static const toJsonFactory = _$KnowledgeBaseDocumentChunkResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$KnowledgeBaseDocumentChunkResponseModelToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'content')
  final String content;
  static const fromJsonFactory =
      _$KnowledgeBaseDocumentChunkResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is KnowledgeBaseDocumentChunkResponseModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.content, content) ||
                const DeepCollectionEquality().equals(other.content, content)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(content) ^
      runtimeType.hashCode;
}

extension $KnowledgeBaseDocumentChunkResponseModelExtension
    on KnowledgeBaseDocumentChunkResponseModel {
  KnowledgeBaseDocumentChunkResponseModel copyWith(
      {String? id, String? name, String? content}) {
    return KnowledgeBaseDocumentChunkResponseModel(
        id: id ?? this.id,
        name: name ?? this.name,
        content: content ?? this.content);
  }

  KnowledgeBaseDocumentChunkResponseModel copyWithWrapped(
      {Wrapped<String>? id, Wrapped<String>? name, Wrapped<String>? content}) {
    return KnowledgeBaseDocumentChunkResponseModel(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        content: (content != null ? content.value : this.content));
  }
}

@JsonSerializable(explicitToJson: true)
class KnowledgeBaseDocumentMetadataResponseModel {
  const KnowledgeBaseDocumentMetadataResponseModel({
    required this.createdAtUnixSecs,
    required this.lastUpdatedAtUnixSecs,
    required this.sizeBytes,
  });

  factory KnowledgeBaseDocumentMetadataResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$KnowledgeBaseDocumentMetadataResponseModelFromJson(json);

  static const toJsonFactory =
      _$KnowledgeBaseDocumentMetadataResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$KnowledgeBaseDocumentMetadataResponseModelToJson(this);

  @JsonKey(name: 'created_at_unix_secs')
  final int createdAtUnixSecs;
  @JsonKey(name: 'last_updated_at_unix_secs')
  final int lastUpdatedAtUnixSecs;
  @JsonKey(name: 'size_bytes')
  final int sizeBytes;
  static const fromJsonFactory =
      _$KnowledgeBaseDocumentMetadataResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is KnowledgeBaseDocumentMetadataResponseModel &&
            (identical(other.createdAtUnixSecs, createdAtUnixSecs) ||
                const DeepCollectionEquality()
                    .equals(other.createdAtUnixSecs, createdAtUnixSecs)) &&
            (identical(other.lastUpdatedAtUnixSecs, lastUpdatedAtUnixSecs) ||
                const DeepCollectionEquality().equals(
                    other.lastUpdatedAtUnixSecs, lastUpdatedAtUnixSecs)) &&
            (identical(other.sizeBytes, sizeBytes) ||
                const DeepCollectionEquality()
                    .equals(other.sizeBytes, sizeBytes)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(createdAtUnixSecs) ^
      const DeepCollectionEquality().hash(lastUpdatedAtUnixSecs) ^
      const DeepCollectionEquality().hash(sizeBytes) ^
      runtimeType.hashCode;
}

extension $KnowledgeBaseDocumentMetadataResponseModelExtension
    on KnowledgeBaseDocumentMetadataResponseModel {
  KnowledgeBaseDocumentMetadataResponseModel copyWith(
      {int? createdAtUnixSecs, int? lastUpdatedAtUnixSecs, int? sizeBytes}) {
    return KnowledgeBaseDocumentMetadataResponseModel(
        createdAtUnixSecs: createdAtUnixSecs ?? this.createdAtUnixSecs,
        lastUpdatedAtUnixSecs:
            lastUpdatedAtUnixSecs ?? this.lastUpdatedAtUnixSecs,
        sizeBytes: sizeBytes ?? this.sizeBytes);
  }

  KnowledgeBaseDocumentMetadataResponseModel copyWithWrapped(
      {Wrapped<int>? createdAtUnixSecs,
      Wrapped<int>? lastUpdatedAtUnixSecs,
      Wrapped<int>? sizeBytes}) {
    return KnowledgeBaseDocumentMetadataResponseModel(
        createdAtUnixSecs: (createdAtUnixSecs != null
            ? createdAtUnixSecs.value
            : this.createdAtUnixSecs),
        lastUpdatedAtUnixSecs: (lastUpdatedAtUnixSecs != null
            ? lastUpdatedAtUnixSecs.value
            : this.lastUpdatedAtUnixSecs),
        sizeBytes: (sizeBytes != null ? sizeBytes.value : this.sizeBytes));
  }
}

@JsonSerializable(explicitToJson: true)
class KnowledgeBaseLocator {
  const KnowledgeBaseLocator({
    required this.type,
    required this.name,
    required this.id,
    this.usageMode,
  });

  factory KnowledgeBaseLocator.fromJson(Map<String, dynamic> json) =>
      _$KnowledgeBaseLocatorFromJson(json);

  static const toJsonFactory = _$KnowledgeBaseLocatorToJson;
  Map<String, dynamic> toJson() => _$KnowledgeBaseLocatorToJson(this);

  @JsonKey(
    name: 'type',
    toJson: knowledgeBaseDocumentTypeToJson,
    fromJson: knowledgeBaseDocumentTypeFromJson,
  )
  final enums.KnowledgeBaseDocumentType type;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(
    name: 'usage_mode',
    toJson: documentUsageModeEnumNullableToJson,
    fromJson: documentUsageModeEnumUsageModeNullableFromJson,
  )
  final enums.DocumentUsageModeEnum? usageMode;
  static enums.DocumentUsageModeEnum?
      documentUsageModeEnumUsageModeNullableFromJson(Object? value) =>
          documentUsageModeEnumNullableFromJson(
              value, enums.DocumentUsageModeEnum.auto);

  static const fromJsonFactory = _$KnowledgeBaseLocatorFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is KnowledgeBaseLocator &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.usageMode, usageMode) ||
                const DeepCollectionEquality()
                    .equals(other.usageMode, usageMode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(usageMode) ^
      runtimeType.hashCode;
}

extension $KnowledgeBaseLocatorExtension on KnowledgeBaseLocator {
  KnowledgeBaseLocator copyWith(
      {enums.KnowledgeBaseDocumentType? type,
      String? name,
      String? id,
      enums.DocumentUsageModeEnum? usageMode}) {
    return KnowledgeBaseLocator(
        type: type ?? this.type,
        name: name ?? this.name,
        id: id ?? this.id,
        usageMode: usageMode ?? this.usageMode);
  }

  KnowledgeBaseLocator copyWithWrapped(
      {Wrapped<enums.KnowledgeBaseDocumentType>? type,
      Wrapped<String>? name,
      Wrapped<String>? id,
      Wrapped<enums.DocumentUsageModeEnum?>? usageMode}) {
    return KnowledgeBaseLocator(
        type: (type != null ? type.value : this.type),
        name: (name != null ? name.value : this.name),
        id: (id != null ? id.value : this.id),
        usageMode: (usageMode != null ? usageMode.value : this.usageMode));
  }
}

@JsonSerializable(explicitToJson: true)
class LLMCategoryUsage {
  const LLMCategoryUsage({
    this.irreversibleGeneration,
    this.initiatedGeneration,
  });

  factory LLMCategoryUsage.fromJson(Map<String, dynamic> json) =>
      _$LLMCategoryUsageFromJson(json);

  static const toJsonFactory = _$LLMCategoryUsageToJson;
  Map<String, dynamic> toJson() => _$LLMCategoryUsageToJson(this);

  @JsonKey(name: 'irreversible_generation')
  final LLMUsageOutput? irreversibleGeneration;
  @JsonKey(name: 'initiated_generation')
  final LLMUsageOutput? initiatedGeneration;
  static const fromJsonFactory = _$LLMCategoryUsageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LLMCategoryUsage &&
            (identical(other.irreversibleGeneration, irreversibleGeneration) ||
                const DeepCollectionEquality().equals(
                    other.irreversibleGeneration, irreversibleGeneration)) &&
            (identical(other.initiatedGeneration, initiatedGeneration) ||
                const DeepCollectionEquality()
                    .equals(other.initiatedGeneration, initiatedGeneration)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(irreversibleGeneration) ^
      const DeepCollectionEquality().hash(initiatedGeneration) ^
      runtimeType.hashCode;
}

extension $LLMCategoryUsageExtension on LLMCategoryUsage {
  LLMCategoryUsage copyWith(
      {LLMUsageOutput? irreversibleGeneration,
      LLMUsageOutput? initiatedGeneration}) {
    return LLMCategoryUsage(
        irreversibleGeneration:
            irreversibleGeneration ?? this.irreversibleGeneration,
        initiatedGeneration: initiatedGeneration ?? this.initiatedGeneration);
  }

  LLMCategoryUsage copyWithWrapped(
      {Wrapped<LLMUsageOutput?>? irreversibleGeneration,
      Wrapped<LLMUsageOutput?>? initiatedGeneration}) {
    return LLMCategoryUsage(
        irreversibleGeneration: (irreversibleGeneration != null
            ? irreversibleGeneration.value
            : this.irreversibleGeneration),
        initiatedGeneration: (initiatedGeneration != null
            ? initiatedGeneration.value
            : this.initiatedGeneration));
  }
}

@JsonSerializable(explicitToJson: true)
class LLMInputOutputTokensUsage {
  const LLMInputOutputTokensUsage({
    this.input,
    this.inputCacheRead,
    this.inputCacheWrite,
    this.outputTotal,
  });

  factory LLMInputOutputTokensUsage.fromJson(Map<String, dynamic> json) =>
      _$LLMInputOutputTokensUsageFromJson(json);

  static const toJsonFactory = _$LLMInputOutputTokensUsageToJson;
  Map<String, dynamic> toJson() => _$LLMInputOutputTokensUsageToJson(this);

  @JsonKey(name: 'input')
  final LLMTokensCategoryUsage? input;
  @JsonKey(name: 'input_cache_read')
  final LLMTokensCategoryUsage? inputCacheRead;
  @JsonKey(name: 'input_cache_write')
  final LLMTokensCategoryUsage? inputCacheWrite;
  @JsonKey(name: 'output_total')
  final LLMTokensCategoryUsage? outputTotal;
  static const fromJsonFactory = _$LLMInputOutputTokensUsageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LLMInputOutputTokensUsage &&
            (identical(other.input, input) ||
                const DeepCollectionEquality().equals(other.input, input)) &&
            (identical(other.inputCacheRead, inputCacheRead) ||
                const DeepCollectionEquality()
                    .equals(other.inputCacheRead, inputCacheRead)) &&
            (identical(other.inputCacheWrite, inputCacheWrite) ||
                const DeepCollectionEquality()
                    .equals(other.inputCacheWrite, inputCacheWrite)) &&
            (identical(other.outputTotal, outputTotal) ||
                const DeepCollectionEquality()
                    .equals(other.outputTotal, outputTotal)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(input) ^
      const DeepCollectionEquality().hash(inputCacheRead) ^
      const DeepCollectionEquality().hash(inputCacheWrite) ^
      const DeepCollectionEquality().hash(outputTotal) ^
      runtimeType.hashCode;
}

extension $LLMInputOutputTokensUsageExtension on LLMInputOutputTokensUsage {
  LLMInputOutputTokensUsage copyWith(
      {LLMTokensCategoryUsage? input,
      LLMTokensCategoryUsage? inputCacheRead,
      LLMTokensCategoryUsage? inputCacheWrite,
      LLMTokensCategoryUsage? outputTotal}) {
    return LLMInputOutputTokensUsage(
        input: input ?? this.input,
        inputCacheRead: inputCacheRead ?? this.inputCacheRead,
        inputCacheWrite: inputCacheWrite ?? this.inputCacheWrite,
        outputTotal: outputTotal ?? this.outputTotal);
  }

  LLMInputOutputTokensUsage copyWithWrapped(
      {Wrapped<LLMTokensCategoryUsage?>? input,
      Wrapped<LLMTokensCategoryUsage?>? inputCacheRead,
      Wrapped<LLMTokensCategoryUsage?>? inputCacheWrite,
      Wrapped<LLMTokensCategoryUsage?>? outputTotal}) {
    return LLMInputOutputTokensUsage(
        input: (input != null ? input.value : this.input),
        inputCacheRead: (inputCacheRead != null
            ? inputCacheRead.value
            : this.inputCacheRead),
        inputCacheWrite: (inputCacheWrite != null
            ? inputCacheWrite.value
            : this.inputCacheWrite),
        outputTotal:
            (outputTotal != null ? outputTotal.value : this.outputTotal));
  }
}

@JsonSerializable(explicitToJson: true)
class LLMTokensCategoryUsage {
  const LLMTokensCategoryUsage({
    this.tokens,
    this.price,
  });

  factory LLMTokensCategoryUsage.fromJson(Map<String, dynamic> json) =>
      _$LLMTokensCategoryUsageFromJson(json);

  static const toJsonFactory = _$LLMTokensCategoryUsageToJson;
  Map<String, dynamic> toJson() => _$LLMTokensCategoryUsageToJson(this);

  @JsonKey(name: 'tokens')
  final int? tokens;
  @JsonKey(name: 'price')
  final double? price;
  static const fromJsonFactory = _$LLMTokensCategoryUsageFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LLMTokensCategoryUsage &&
            (identical(other.tokens, tokens) ||
                const DeepCollectionEquality().equals(other.tokens, tokens)) &&
            (identical(other.price, price) ||
                const DeepCollectionEquality().equals(other.price, price)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tokens) ^
      const DeepCollectionEquality().hash(price) ^
      runtimeType.hashCode;
}

extension $LLMTokensCategoryUsageExtension on LLMTokensCategoryUsage {
  LLMTokensCategoryUsage copyWith({int? tokens, double? price}) {
    return LLMTokensCategoryUsage(
        tokens: tokens ?? this.tokens, price: price ?? this.price);
  }

  LLMTokensCategoryUsage copyWithWrapped(
      {Wrapped<int?>? tokens, Wrapped<double?>? price}) {
    return LLMTokensCategoryUsage(
        tokens: (tokens != null ? tokens.value : this.tokens),
        price: (price != null ? price.value : this.price));
  }
}

@JsonSerializable(explicitToJson: true)
class LLMUsageInput {
  const LLMUsageInput({
    this.modelUsage,
  });

  factory LLMUsageInput.fromJson(Map<String, dynamic> json) =>
      _$LLMUsageInputFromJson(json);

  static const toJsonFactory = _$LLMUsageInputToJson;
  Map<String, dynamic> toJson() => _$LLMUsageInputToJson(this);

  @JsonKey(name: 'model_usage')
  final Map<String, dynamic>? modelUsage;
  static const fromJsonFactory = _$LLMUsageInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LLMUsageInput &&
            (identical(other.modelUsage, modelUsage) ||
                const DeepCollectionEquality()
                    .equals(other.modelUsage, modelUsage)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelUsage) ^ runtimeType.hashCode;
}

extension $LLMUsageInputExtension on LLMUsageInput {
  LLMUsageInput copyWith({Map<String, dynamic>? modelUsage}) {
    return LLMUsageInput(modelUsage: modelUsage ?? this.modelUsage);
  }

  LLMUsageInput copyWithWrapped({Wrapped<Map<String, dynamic>?>? modelUsage}) {
    return LLMUsageInput(
        modelUsage: (modelUsage != null ? modelUsage.value : this.modelUsage));
  }
}

@JsonSerializable(explicitToJson: true)
class LLMUsageOutput {
  const LLMUsageOutput({
    this.modelUsage,
  });

  factory LLMUsageOutput.fromJson(Map<String, dynamic> json) =>
      _$LLMUsageOutputFromJson(json);

  static const toJsonFactory = _$LLMUsageOutputToJson;
  Map<String, dynamic> toJson() => _$LLMUsageOutputToJson(this);

  @JsonKey(name: 'model_usage')
  final Map<String, dynamic>? modelUsage;
  static const fromJsonFactory = _$LLMUsageOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LLMUsageOutput &&
            (identical(other.modelUsage, modelUsage) ||
                const DeepCollectionEquality()
                    .equals(other.modelUsage, modelUsage)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelUsage) ^ runtimeType.hashCode;
}

extension $LLMUsageOutputExtension on LLMUsageOutput {
  LLMUsageOutput copyWith({Map<String, dynamic>? modelUsage}) {
    return LLMUsageOutput(modelUsage: modelUsage ?? this.modelUsage);
  }

  LLMUsageOutput copyWithWrapped({Wrapped<Map<String, dynamic>?>? modelUsage}) {
    return LLMUsageOutput(
        modelUsage: (modelUsage != null ? modelUsage.value : this.modelUsage));
  }
}

@JsonSerializable(explicitToJson: true)
class LLMUsageCalculatorLLMResponseModel {
  const LLMUsageCalculatorLLMResponseModel({
    required this.llm,
    required this.pricePerMinute,
  });

  factory LLMUsageCalculatorLLMResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$LLMUsageCalculatorLLMResponseModelFromJson(json);

  static const toJsonFactory = _$LLMUsageCalculatorLLMResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$LLMUsageCalculatorLLMResponseModelToJson(this);

  @JsonKey(
    name: 'llm',
    toJson: llmToJson,
    fromJson: llmFromJson,
  )
  final enums.Llm llm;
  @JsonKey(name: 'price_per_minute')
  final double pricePerMinute;
  static const fromJsonFactory = _$LLMUsageCalculatorLLMResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LLMUsageCalculatorLLMResponseModel &&
            (identical(other.llm, llm) ||
                const DeepCollectionEquality().equals(other.llm, llm)) &&
            (identical(other.pricePerMinute, pricePerMinute) ||
                const DeepCollectionEquality()
                    .equals(other.pricePerMinute, pricePerMinute)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(llm) ^
      const DeepCollectionEquality().hash(pricePerMinute) ^
      runtimeType.hashCode;
}

extension $LLMUsageCalculatorLLMResponseModelExtension
    on LLMUsageCalculatorLLMResponseModel {
  LLMUsageCalculatorLLMResponseModel copyWith(
      {enums.Llm? llm, double? pricePerMinute}) {
    return LLMUsageCalculatorLLMResponseModel(
        llm: llm ?? this.llm,
        pricePerMinute: pricePerMinute ?? this.pricePerMinute);
  }

  LLMUsageCalculatorLLMResponseModel copyWithWrapped(
      {Wrapped<enums.Llm>? llm, Wrapped<double>? pricePerMinute}) {
    return LLMUsageCalculatorLLMResponseModel(
        llm: (llm != null ? llm.value : this.llm),
        pricePerMinute: (pricePerMinute != null
            ? pricePerMinute.value
            : this.pricePerMinute));
  }
}

@JsonSerializable(explicitToJson: true)
class LLMUsageCalculatorPublicRequestModel {
  const LLMUsageCalculatorPublicRequestModel({
    required this.promptLength,
    required this.numberOfPages,
    required this.ragEnabled,
  });

  factory LLMUsageCalculatorPublicRequestModel.fromJson(
          Map<String, dynamic> json) =>
      _$LLMUsageCalculatorPublicRequestModelFromJson(json);

  static const toJsonFactory = _$LLMUsageCalculatorPublicRequestModelToJson;
  Map<String, dynamic> toJson() =>
      _$LLMUsageCalculatorPublicRequestModelToJson(this);

  @JsonKey(name: 'prompt_length')
  final int promptLength;
  @JsonKey(name: 'number_of_pages')
  final int numberOfPages;
  @JsonKey(name: 'rag_enabled')
  final bool ragEnabled;
  static const fromJsonFactory = _$LLMUsageCalculatorPublicRequestModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LLMUsageCalculatorPublicRequestModel &&
            (identical(other.promptLength, promptLength) ||
                const DeepCollectionEquality()
                    .equals(other.promptLength, promptLength)) &&
            (identical(other.numberOfPages, numberOfPages) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfPages, numberOfPages)) &&
            (identical(other.ragEnabled, ragEnabled) ||
                const DeepCollectionEquality()
                    .equals(other.ragEnabled, ragEnabled)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(promptLength) ^
      const DeepCollectionEquality().hash(numberOfPages) ^
      const DeepCollectionEquality().hash(ragEnabled) ^
      runtimeType.hashCode;
}

extension $LLMUsageCalculatorPublicRequestModelExtension
    on LLMUsageCalculatorPublicRequestModel {
  LLMUsageCalculatorPublicRequestModel copyWith(
      {int? promptLength, int? numberOfPages, bool? ragEnabled}) {
    return LLMUsageCalculatorPublicRequestModel(
        promptLength: promptLength ?? this.promptLength,
        numberOfPages: numberOfPages ?? this.numberOfPages,
        ragEnabled: ragEnabled ?? this.ragEnabled);
  }

  LLMUsageCalculatorPublicRequestModel copyWithWrapped(
      {Wrapped<int>? promptLength,
      Wrapped<int>? numberOfPages,
      Wrapped<bool>? ragEnabled}) {
    return LLMUsageCalculatorPublicRequestModel(
        promptLength:
            (promptLength != null ? promptLength.value : this.promptLength),
        numberOfPages:
            (numberOfPages != null ? numberOfPages.value : this.numberOfPages),
        ragEnabled: (ragEnabled != null ? ragEnabled.value : this.ragEnabled));
  }
}

@JsonSerializable(explicitToJson: true)
class LLMUsageCalculatorRequestModel {
  const LLMUsageCalculatorRequestModel({
    this.promptLength,
    this.numberOfPages,
    this.ragEnabled,
  });

  factory LLMUsageCalculatorRequestModel.fromJson(Map<String, dynamic> json) =>
      _$LLMUsageCalculatorRequestModelFromJson(json);

  static const toJsonFactory = _$LLMUsageCalculatorRequestModelToJson;
  Map<String, dynamic> toJson() => _$LLMUsageCalculatorRequestModelToJson(this);

  @JsonKey(name: 'prompt_length')
  final dynamic promptLength;
  @JsonKey(name: 'number_of_pages')
  final dynamic numberOfPages;
  @JsonKey(name: 'rag_enabled')
  final dynamic ragEnabled;
  static const fromJsonFactory = _$LLMUsageCalculatorRequestModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LLMUsageCalculatorRequestModel &&
            (identical(other.promptLength, promptLength) ||
                const DeepCollectionEquality()
                    .equals(other.promptLength, promptLength)) &&
            (identical(other.numberOfPages, numberOfPages) ||
                const DeepCollectionEquality()
                    .equals(other.numberOfPages, numberOfPages)) &&
            (identical(other.ragEnabled, ragEnabled) ||
                const DeepCollectionEquality()
                    .equals(other.ragEnabled, ragEnabled)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(promptLength) ^
      const DeepCollectionEquality().hash(numberOfPages) ^
      const DeepCollectionEquality().hash(ragEnabled) ^
      runtimeType.hashCode;
}

extension $LLMUsageCalculatorRequestModelExtension
    on LLMUsageCalculatorRequestModel {
  LLMUsageCalculatorRequestModel copyWith(
      {dynamic promptLength, dynamic numberOfPages, dynamic ragEnabled}) {
    return LLMUsageCalculatorRequestModel(
        promptLength: promptLength ?? this.promptLength,
        numberOfPages: numberOfPages ?? this.numberOfPages,
        ragEnabled: ragEnabled ?? this.ragEnabled);
  }

  LLMUsageCalculatorRequestModel copyWithWrapped(
      {Wrapped<dynamic>? promptLength,
      Wrapped<dynamic>? numberOfPages,
      Wrapped<dynamic>? ragEnabled}) {
    return LLMUsageCalculatorRequestModel(
        promptLength:
            (promptLength != null ? promptLength.value : this.promptLength),
        numberOfPages:
            (numberOfPages != null ? numberOfPages.value : this.numberOfPages),
        ragEnabled: (ragEnabled != null ? ragEnabled.value : this.ragEnabled));
  }
}

@JsonSerializable(explicitToJson: true)
class LLMUsageCalculatorResponseModel {
  const LLMUsageCalculatorResponseModel({
    required this.llmPrices,
  });

  factory LLMUsageCalculatorResponseModel.fromJson(Map<String, dynamic> json) =>
      _$LLMUsageCalculatorResponseModelFromJson(json);

  static const toJsonFactory = _$LLMUsageCalculatorResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$LLMUsageCalculatorResponseModelToJson(this);

  @JsonKey(
      name: 'llm_prices', defaultValue: <LLMUsageCalculatorLLMResponseModel>[])
  final List<LLMUsageCalculatorLLMResponseModel> llmPrices;
  static const fromJsonFactory = _$LLMUsageCalculatorResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LLMUsageCalculatorResponseModel &&
            (identical(other.llmPrices, llmPrices) ||
                const DeepCollectionEquality()
                    .equals(other.llmPrices, llmPrices)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(llmPrices) ^ runtimeType.hashCode;
}

extension $LLMUsageCalculatorResponseModelExtension
    on LLMUsageCalculatorResponseModel {
  LLMUsageCalculatorResponseModel copyWith(
      {List<LLMUsageCalculatorLLMResponseModel>? llmPrices}) {
    return LLMUsageCalculatorResponseModel(
        llmPrices: llmPrices ?? this.llmPrices);
  }

  LLMUsageCalculatorResponseModel copyWithWrapped(
      {Wrapped<List<LLMUsageCalculatorLLMResponseModel>>? llmPrices}) {
    return LLMUsageCalculatorResponseModel(
        llmPrices: (llmPrices != null ? llmPrices.value : this.llmPrices));
  }
}

@JsonSerializable(explicitToJson: true)
class LanguageAddedResponse {
  const LanguageAddedResponse({
    required this.version,
  });

  factory LanguageAddedResponse.fromJson(Map<String, dynamic> json) =>
      _$LanguageAddedResponseFromJson(json);

  static const toJsonFactory = _$LanguageAddedResponseToJson;
  Map<String, dynamic> toJson() => _$LanguageAddedResponseToJson(this);

  @JsonKey(name: 'version')
  final int version;
  static const fromJsonFactory = _$LanguageAddedResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LanguageAddedResponse &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(version) ^ runtimeType.hashCode;
}

extension $LanguageAddedResponseExtension on LanguageAddedResponse {
  LanguageAddedResponse copyWith({int? version}) {
    return LanguageAddedResponse(version: version ?? this.version);
  }

  LanguageAddedResponse copyWithWrapped({Wrapped<int>? version}) {
    return LanguageAddedResponse(
        version: (version != null ? version.value : this.version));
  }
}

@JsonSerializable(explicitToJson: true)
class LanguageDetectionToolConfig {
  const LanguageDetectionToolConfig({
    this.systemToolType,
  });

  factory LanguageDetectionToolConfig.fromJson(Map<String, dynamic> json) =>
      _$LanguageDetectionToolConfigFromJson(json);

  static const toJsonFactory = _$LanguageDetectionToolConfigToJson;
  Map<String, dynamic> toJson() => _$LanguageDetectionToolConfigToJson(this);

  @JsonKey(name: 'system_tool_type')
  final String? systemToolType;
  static const fromJsonFactory = _$LanguageDetectionToolConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LanguageDetectionToolConfig &&
            (identical(other.systemToolType, systemToolType) ||
                const DeepCollectionEquality()
                    .equals(other.systemToolType, systemToolType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(systemToolType) ^
      runtimeType.hashCode;
}

extension $LanguageDetectionToolConfigExtension on LanguageDetectionToolConfig {
  LanguageDetectionToolConfig copyWith({String? systemToolType}) {
    return LanguageDetectionToolConfig(
        systemToolType: systemToolType ?? this.systemToolType);
  }

  LanguageDetectionToolConfig copyWithWrapped(
      {Wrapped<String?>? systemToolType}) {
    return LanguageDetectionToolConfig(
        systemToolType: (systemToolType != null
            ? systemToolType.value
            : this.systemToolType));
  }
}

@JsonSerializable(explicitToJson: true)
class LanguagePresetInput {
  const LanguagePresetInput({
    required this.overrides,
    this.firstMessageTranslation,
  });

  factory LanguagePresetInput.fromJson(Map<String, dynamic> json) =>
      _$LanguagePresetInputFromJson(json);

  static const toJsonFactory = _$LanguagePresetInputToJson;
  Map<String, dynamic> toJson() => _$LanguagePresetInputToJson(this);

  @JsonKey(name: 'overrides')
  final ConversationConfigClientOverrideInput overrides;
  @JsonKey(name: 'first_message_translation')
  final dynamic firstMessageTranslation;
  static const fromJsonFactory = _$LanguagePresetInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LanguagePresetInput &&
            (identical(other.overrides, overrides) ||
                const DeepCollectionEquality()
                    .equals(other.overrides, overrides)) &&
            (identical(
                    other.firstMessageTranslation, firstMessageTranslation) ||
                const DeepCollectionEquality().equals(
                    other.firstMessageTranslation, firstMessageTranslation)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(overrides) ^
      const DeepCollectionEquality().hash(firstMessageTranslation) ^
      runtimeType.hashCode;
}

extension $LanguagePresetInputExtension on LanguagePresetInput {
  LanguagePresetInput copyWith(
      {ConversationConfigClientOverrideInput? overrides,
      dynamic firstMessageTranslation}) {
    return LanguagePresetInput(
        overrides: overrides ?? this.overrides,
        firstMessageTranslation:
            firstMessageTranslation ?? this.firstMessageTranslation);
  }

  LanguagePresetInput copyWithWrapped(
      {Wrapped<ConversationConfigClientOverrideInput>? overrides,
      Wrapped<dynamic>? firstMessageTranslation}) {
    return LanguagePresetInput(
        overrides: (overrides != null ? overrides.value : this.overrides),
        firstMessageTranslation: (firstMessageTranslation != null
            ? firstMessageTranslation.value
            : this.firstMessageTranslation));
  }
}

@JsonSerializable(explicitToJson: true)
class LanguagePresetOutput {
  const LanguagePresetOutput({
    required this.overrides,
    this.firstMessageTranslation,
  });

  factory LanguagePresetOutput.fromJson(Map<String, dynamic> json) =>
      _$LanguagePresetOutputFromJson(json);

  static const toJsonFactory = _$LanguagePresetOutputToJson;
  Map<String, dynamic> toJson() => _$LanguagePresetOutputToJson(this);

  @JsonKey(name: 'overrides')
  final ConversationConfigClientOverrideOutput overrides;
  @JsonKey(name: 'first_message_translation')
  final dynamic firstMessageTranslation;
  static const fromJsonFactory = _$LanguagePresetOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LanguagePresetOutput &&
            (identical(other.overrides, overrides) ||
                const DeepCollectionEquality()
                    .equals(other.overrides, overrides)) &&
            (identical(
                    other.firstMessageTranslation, firstMessageTranslation) ||
                const DeepCollectionEquality().equals(
                    other.firstMessageTranslation, firstMessageTranslation)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(overrides) ^
      const DeepCollectionEquality().hash(firstMessageTranslation) ^
      runtimeType.hashCode;
}

extension $LanguagePresetOutputExtension on LanguagePresetOutput {
  LanguagePresetOutput copyWith(
      {ConversationConfigClientOverrideOutput? overrides,
      dynamic firstMessageTranslation}) {
    return LanguagePresetOutput(
        overrides: overrides ?? this.overrides,
        firstMessageTranslation:
            firstMessageTranslation ?? this.firstMessageTranslation);
  }

  LanguagePresetOutput copyWithWrapped(
      {Wrapped<ConversationConfigClientOverrideOutput>? overrides,
      Wrapped<dynamic>? firstMessageTranslation}) {
    return LanguagePresetOutput(
        overrides: (overrides != null ? overrides.value : this.overrides),
        firstMessageTranslation: (firstMessageTranslation != null
            ? firstMessageTranslation.value
            : this.firstMessageTranslation));
  }
}

@JsonSerializable(explicitToJson: true)
class LanguagePresetTranslation {
  const LanguagePresetTranslation({
    required this.sourceHash,
    required this.text,
  });

  factory LanguagePresetTranslation.fromJson(Map<String, dynamic> json) =>
      _$LanguagePresetTranslationFromJson(json);

  static const toJsonFactory = _$LanguagePresetTranslationToJson;
  Map<String, dynamic> toJson() => _$LanguagePresetTranslationToJson(this);

  @JsonKey(name: 'source_hash')
  final String sourceHash;
  @JsonKey(name: 'text')
  final String text;
  static const fromJsonFactory = _$LanguagePresetTranslationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LanguagePresetTranslation &&
            (identical(other.sourceHash, sourceHash) ||
                const DeepCollectionEquality()
                    .equals(other.sourceHash, sourceHash)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sourceHash) ^
      const DeepCollectionEquality().hash(text) ^
      runtimeType.hashCode;
}

extension $LanguagePresetTranslationExtension on LanguagePresetTranslation {
  LanguagePresetTranslation copyWith({String? sourceHash, String? text}) {
    return LanguagePresetTranslation(
        sourceHash: sourceHash ?? this.sourceHash, text: text ?? this.text);
  }

  LanguagePresetTranslation copyWithWrapped(
      {Wrapped<String>? sourceHash, Wrapped<String>? text}) {
    return LanguagePresetTranslation(
        sourceHash: (sourceHash != null ? sourceHash.value : this.sourceHash),
        text: (text != null ? text.value : this.text));
  }
}

@JsonSerializable(explicitToJson: true)
class LanguageResponseModel {
  const LanguageResponseModel({
    required this.languageId,
    required this.name,
  });

  factory LanguageResponseModel.fromJson(Map<String, dynamic> json) =>
      _$LanguageResponseModelFromJson(json);

  static const toJsonFactory = _$LanguageResponseModelToJson;
  Map<String, dynamic> toJson() => _$LanguageResponseModelToJson(this);

  @JsonKey(name: 'language_id')
  final String languageId;
  @JsonKey(name: 'name')
  final String name;
  static const fromJsonFactory = _$LanguageResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LanguageResponseModel &&
            (identical(other.languageId, languageId) ||
                const DeepCollectionEquality()
                    .equals(other.languageId, languageId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(languageId) ^
      const DeepCollectionEquality().hash(name) ^
      runtimeType.hashCode;
}

extension $LanguageResponseModelExtension on LanguageResponseModel {
  LanguageResponseModel copyWith({String? languageId, String? name}) {
    return LanguageResponseModel(
        languageId: languageId ?? this.languageId, name: name ?? this.name);
  }

  LanguageResponseModel copyWithWrapped(
      {Wrapped<String>? languageId, Wrapped<String>? name}) {
    return LanguageResponseModel(
        languageId: (languageId != null ? languageId.value : this.languageId),
        name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class LibraryVoiceResponseModel {
  const LibraryVoiceResponseModel({
    required this.publicOwnerId,
    required this.voiceId,
    required this.dateUnix,
    required this.name,
    required this.accent,
    required this.gender,
    required this.age,
    required this.descriptive,
    required this.useCase,
    required this.category,
    this.language,
    this.locale,
    this.description,
    this.previewUrl,
    required this.usageCharacterCount1y,
    required this.usageCharacterCount7d,
    required this.playApiUsageCharacterCount1y,
    required this.clonedByCount,
    this.rate,
    this.fiatRate,
    required this.freeUsersAllowed,
    required this.liveModerationEnabled,
    required this.featured,
    this.verifiedLanguages,
    this.noticePeriod,
    this.instagramUsername,
    this.twitterUsername,
    this.youtubeUsername,
    this.tiktokUsername,
    this.imageUrl,
    this.isAddedByUser,
  });

  factory LibraryVoiceResponseModel.fromJson(Map<String, dynamic> json) =>
      _$LibraryVoiceResponseModelFromJson(json);

  static const toJsonFactory = _$LibraryVoiceResponseModelToJson;
  Map<String, dynamic> toJson() => _$LibraryVoiceResponseModelToJson(this);

  @JsonKey(name: 'public_owner_id')
  final String publicOwnerId;
  @JsonKey(name: 'voice_id')
  final String voiceId;
  @JsonKey(name: 'date_unix')
  final int dateUnix;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'accent')
  final String accent;
  @JsonKey(name: 'gender')
  final String gender;
  @JsonKey(name: 'age')
  final String age;
  @JsonKey(name: 'descriptive')
  final String descriptive;
  @JsonKey(name: 'use_case')
  final String useCase;
  @JsonKey(
    name: 'category',
    toJson: libraryVoiceResponseModelCategoryToJson,
    fromJson: libraryVoiceResponseModelCategoryFromJson,
  )
  final enums.LibraryVoiceResponseModelCategory category;
  @JsonKey(name: 'language')
  final dynamic language;
  @JsonKey(name: 'locale')
  final dynamic locale;
  @JsonKey(name: 'description')
  final dynamic description;
  @JsonKey(name: 'preview_url')
  final dynamic previewUrl;
  @JsonKey(name: 'usage_character_count_1y')
  final int usageCharacterCount1y;
  @JsonKey(name: 'usage_character_count_7d')
  final int usageCharacterCount7d;
  @JsonKey(name: 'play_api_usage_character_count_1y')
  final int playApiUsageCharacterCount1y;
  @JsonKey(name: 'cloned_by_count')
  final int clonedByCount;
  @JsonKey(name: 'rate')
  final dynamic rate;
  @JsonKey(name: 'fiat_rate')
  final dynamic fiatRate;
  @JsonKey(name: 'free_users_allowed')
  final bool freeUsersAllowed;
  @JsonKey(name: 'live_moderation_enabled')
  final bool liveModerationEnabled;
  @JsonKey(name: 'featured')
  final bool featured;
  @JsonKey(name: 'verified_languages')
  final dynamic verifiedLanguages;
  @JsonKey(name: 'notice_period')
  final dynamic noticePeriod;
  @JsonKey(name: 'instagram_username')
  final dynamic instagramUsername;
  @JsonKey(name: 'twitter_username')
  final dynamic twitterUsername;
  @JsonKey(name: 'youtube_username')
  final dynamic youtubeUsername;
  @JsonKey(name: 'tiktok_username')
  final dynamic tiktokUsername;
  @JsonKey(name: 'image_url')
  final dynamic imageUrl;
  @JsonKey(name: 'is_added_by_user')
  final dynamic isAddedByUser;
  static const fromJsonFactory = _$LibraryVoiceResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LibraryVoiceResponseModel &&
            (identical(other.publicOwnerId, publicOwnerId) ||
                const DeepCollectionEquality()
                    .equals(other.publicOwnerId, publicOwnerId)) &&
            (identical(other.voiceId, voiceId) ||
                const DeepCollectionEquality()
                    .equals(other.voiceId, voiceId)) &&
            (identical(other.dateUnix, dateUnix) ||
                const DeepCollectionEquality()
                    .equals(other.dateUnix, dateUnix)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.accent, accent) ||
                const DeepCollectionEquality().equals(other.accent, accent)) &&
            (identical(other.gender, gender) ||
                const DeepCollectionEquality().equals(other.gender, gender)) &&
            (identical(other.age, age) ||
                const DeepCollectionEquality().equals(other.age, age)) &&
            (identical(other.descriptive, descriptive) ||
                const DeepCollectionEquality()
                    .equals(other.descriptive, descriptive)) &&
            (identical(other.useCase, useCase) ||
                const DeepCollectionEquality()
                    .equals(other.useCase, useCase)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.locale, locale) ||
                const DeepCollectionEquality().equals(other.locale, locale)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.previewUrl, previewUrl) ||
                const DeepCollectionEquality()
                    .equals(other.previewUrl, previewUrl)) &&
            (identical(other.usageCharacterCount1y, usageCharacterCount1y) ||
                const DeepCollectionEquality().equals(
                    other.usageCharacterCount1y, usageCharacterCount1y)) &&
            (identical(other.usageCharacterCount7d, usageCharacterCount7d) ||
                const DeepCollectionEquality().equals(
                    other.usageCharacterCount7d, usageCharacterCount7d)) &&
            (identical(other.playApiUsageCharacterCount1y, playApiUsageCharacterCount1y) ||
                const DeepCollectionEquality().equals(
                    other.playApiUsageCharacterCount1y,
                    playApiUsageCharacterCount1y)) &&
            (identical(other.clonedByCount, clonedByCount) ||
                const DeepCollectionEquality()
                    .equals(other.clonedByCount, clonedByCount)) &&
            (identical(other.rate, rate) ||
                const DeepCollectionEquality().equals(other.rate, rate)) &&
            (identical(other.fiatRate, fiatRate) ||
                const DeepCollectionEquality()
                    .equals(other.fiatRate, fiatRate)) &&
            (identical(other.freeUsersAllowed, freeUsersAllowed) ||
                const DeepCollectionEquality()
                    .equals(other.freeUsersAllowed, freeUsersAllowed)) &&
            (identical(other.liveModerationEnabled, liveModerationEnabled) ||
                const DeepCollectionEquality().equals(
                    other.liveModerationEnabled, liveModerationEnabled)) &&
            (identical(other.featured, featured) ||
                const DeepCollectionEquality().equals(other.featured, featured)) &&
            (identical(other.verifiedLanguages, verifiedLanguages) || const DeepCollectionEquality().equals(other.verifiedLanguages, verifiedLanguages)) &&
            (identical(other.noticePeriod, noticePeriod) || const DeepCollectionEquality().equals(other.noticePeriod, noticePeriod)) &&
            (identical(other.instagramUsername, instagramUsername) || const DeepCollectionEquality().equals(other.instagramUsername, instagramUsername)) &&
            (identical(other.twitterUsername, twitterUsername) || const DeepCollectionEquality().equals(other.twitterUsername, twitterUsername)) &&
            (identical(other.youtubeUsername, youtubeUsername) || const DeepCollectionEquality().equals(other.youtubeUsername, youtubeUsername)) &&
            (identical(other.tiktokUsername, tiktokUsername) || const DeepCollectionEquality().equals(other.tiktokUsername, tiktokUsername)) &&
            (identical(other.imageUrl, imageUrl) || const DeepCollectionEquality().equals(other.imageUrl, imageUrl)) &&
            (identical(other.isAddedByUser, isAddedByUser) || const DeepCollectionEquality().equals(other.isAddedByUser, isAddedByUser)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(publicOwnerId) ^
      const DeepCollectionEquality().hash(voiceId) ^
      const DeepCollectionEquality().hash(dateUnix) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(accent) ^
      const DeepCollectionEquality().hash(gender) ^
      const DeepCollectionEquality().hash(age) ^
      const DeepCollectionEquality().hash(descriptive) ^
      const DeepCollectionEquality().hash(useCase) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(locale) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(previewUrl) ^
      const DeepCollectionEquality().hash(usageCharacterCount1y) ^
      const DeepCollectionEquality().hash(usageCharacterCount7d) ^
      const DeepCollectionEquality().hash(playApiUsageCharacterCount1y) ^
      const DeepCollectionEquality().hash(clonedByCount) ^
      const DeepCollectionEquality().hash(rate) ^
      const DeepCollectionEquality().hash(fiatRate) ^
      const DeepCollectionEquality().hash(freeUsersAllowed) ^
      const DeepCollectionEquality().hash(liveModerationEnabled) ^
      const DeepCollectionEquality().hash(featured) ^
      const DeepCollectionEquality().hash(verifiedLanguages) ^
      const DeepCollectionEquality().hash(noticePeriod) ^
      const DeepCollectionEquality().hash(instagramUsername) ^
      const DeepCollectionEquality().hash(twitterUsername) ^
      const DeepCollectionEquality().hash(youtubeUsername) ^
      const DeepCollectionEquality().hash(tiktokUsername) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(isAddedByUser) ^
      runtimeType.hashCode;
}

extension $LibraryVoiceResponseModelExtension on LibraryVoiceResponseModel {
  LibraryVoiceResponseModel copyWith(
      {String? publicOwnerId,
      String? voiceId,
      int? dateUnix,
      String? name,
      String? accent,
      String? gender,
      String? age,
      String? descriptive,
      String? useCase,
      enums.LibraryVoiceResponseModelCategory? category,
      dynamic language,
      dynamic locale,
      dynamic description,
      dynamic previewUrl,
      int? usageCharacterCount1y,
      int? usageCharacterCount7d,
      int? playApiUsageCharacterCount1y,
      int? clonedByCount,
      dynamic rate,
      dynamic fiatRate,
      bool? freeUsersAllowed,
      bool? liveModerationEnabled,
      bool? featured,
      dynamic verifiedLanguages,
      dynamic noticePeriod,
      dynamic instagramUsername,
      dynamic twitterUsername,
      dynamic youtubeUsername,
      dynamic tiktokUsername,
      dynamic imageUrl,
      dynamic isAddedByUser}) {
    return LibraryVoiceResponseModel(
        publicOwnerId: publicOwnerId ?? this.publicOwnerId,
        voiceId: voiceId ?? this.voiceId,
        dateUnix: dateUnix ?? this.dateUnix,
        name: name ?? this.name,
        accent: accent ?? this.accent,
        gender: gender ?? this.gender,
        age: age ?? this.age,
        descriptive: descriptive ?? this.descriptive,
        useCase: useCase ?? this.useCase,
        category: category ?? this.category,
        language: language ?? this.language,
        locale: locale ?? this.locale,
        description: description ?? this.description,
        previewUrl: previewUrl ?? this.previewUrl,
        usageCharacterCount1y:
            usageCharacterCount1y ?? this.usageCharacterCount1y,
        usageCharacterCount7d:
            usageCharacterCount7d ?? this.usageCharacterCount7d,
        playApiUsageCharacterCount1y:
            playApiUsageCharacterCount1y ?? this.playApiUsageCharacterCount1y,
        clonedByCount: clonedByCount ?? this.clonedByCount,
        rate: rate ?? this.rate,
        fiatRate: fiatRate ?? this.fiatRate,
        freeUsersAllowed: freeUsersAllowed ?? this.freeUsersAllowed,
        liveModerationEnabled:
            liveModerationEnabled ?? this.liveModerationEnabled,
        featured: featured ?? this.featured,
        verifiedLanguages: verifiedLanguages ?? this.verifiedLanguages,
        noticePeriod: noticePeriod ?? this.noticePeriod,
        instagramUsername: instagramUsername ?? this.instagramUsername,
        twitterUsername: twitterUsername ?? this.twitterUsername,
        youtubeUsername: youtubeUsername ?? this.youtubeUsername,
        tiktokUsername: tiktokUsername ?? this.tiktokUsername,
        imageUrl: imageUrl ?? this.imageUrl,
        isAddedByUser: isAddedByUser ?? this.isAddedByUser);
  }

  LibraryVoiceResponseModel copyWithWrapped(
      {Wrapped<String>? publicOwnerId,
      Wrapped<String>? voiceId,
      Wrapped<int>? dateUnix,
      Wrapped<String>? name,
      Wrapped<String>? accent,
      Wrapped<String>? gender,
      Wrapped<String>? age,
      Wrapped<String>? descriptive,
      Wrapped<String>? useCase,
      Wrapped<enums.LibraryVoiceResponseModelCategory>? category,
      Wrapped<dynamic>? language,
      Wrapped<dynamic>? locale,
      Wrapped<dynamic>? description,
      Wrapped<dynamic>? previewUrl,
      Wrapped<int>? usageCharacterCount1y,
      Wrapped<int>? usageCharacterCount7d,
      Wrapped<int>? playApiUsageCharacterCount1y,
      Wrapped<int>? clonedByCount,
      Wrapped<dynamic>? rate,
      Wrapped<dynamic>? fiatRate,
      Wrapped<bool>? freeUsersAllowed,
      Wrapped<bool>? liveModerationEnabled,
      Wrapped<bool>? featured,
      Wrapped<dynamic>? verifiedLanguages,
      Wrapped<dynamic>? noticePeriod,
      Wrapped<dynamic>? instagramUsername,
      Wrapped<dynamic>? twitterUsername,
      Wrapped<dynamic>? youtubeUsername,
      Wrapped<dynamic>? tiktokUsername,
      Wrapped<dynamic>? imageUrl,
      Wrapped<dynamic>? isAddedByUser}) {
    return LibraryVoiceResponseModel(
        publicOwnerId:
            (publicOwnerId != null ? publicOwnerId.value : this.publicOwnerId),
        voiceId: (voiceId != null ? voiceId.value : this.voiceId),
        dateUnix: (dateUnix != null ? dateUnix.value : this.dateUnix),
        name: (name != null ? name.value : this.name),
        accent: (accent != null ? accent.value : this.accent),
        gender: (gender != null ? gender.value : this.gender),
        age: (age != null ? age.value : this.age),
        descriptive:
            (descriptive != null ? descriptive.value : this.descriptive),
        useCase: (useCase != null ? useCase.value : this.useCase),
        category: (category != null ? category.value : this.category),
        language: (language != null ? language.value : this.language),
        locale: (locale != null ? locale.value : this.locale),
        description:
            (description != null ? description.value : this.description),
        previewUrl: (previewUrl != null ? previewUrl.value : this.previewUrl),
        usageCharacterCount1y: (usageCharacterCount1y != null
            ? usageCharacterCount1y.value
            : this.usageCharacterCount1y),
        usageCharacterCount7d: (usageCharacterCount7d != null
            ? usageCharacterCount7d.value
            : this.usageCharacterCount7d),
        playApiUsageCharacterCount1y: (playApiUsageCharacterCount1y != null
            ? playApiUsageCharacterCount1y.value
            : this.playApiUsageCharacterCount1y),
        clonedByCount:
            (clonedByCount != null ? clonedByCount.value : this.clonedByCount),
        rate: (rate != null ? rate.value : this.rate),
        fiatRate: (fiatRate != null ? fiatRate.value : this.fiatRate),
        freeUsersAllowed: (freeUsersAllowed != null
            ? freeUsersAllowed.value
            : this.freeUsersAllowed),
        liveModerationEnabled: (liveModerationEnabled != null
            ? liveModerationEnabled.value
            : this.liveModerationEnabled),
        featured: (featured != null ? featured.value : this.featured),
        verifiedLanguages: (verifiedLanguages != null
            ? verifiedLanguages.value
            : this.verifiedLanguages),
        noticePeriod:
            (noticePeriod != null ? noticePeriod.value : this.noticePeriod),
        instagramUsername: (instagramUsername != null
            ? instagramUsername.value
            : this.instagramUsername),
        twitterUsername: (twitterUsername != null
            ? twitterUsername.value
            : this.twitterUsername),
        youtubeUsername: (youtubeUsername != null
            ? youtubeUsername.value
            : this.youtubeUsername),
        tiktokUsername: (tiktokUsername != null
            ? tiktokUsername.value
            : this.tiktokUsername),
        imageUrl: (imageUrl != null ? imageUrl.value : this.imageUrl),
        isAddedByUser:
            (isAddedByUser != null ? isAddedByUser.value : this.isAddedByUser));
  }
}

@JsonSerializable(explicitToJson: true)
class LiteralJsonSchemaProperty {
  const LiteralJsonSchemaProperty({
    required this.type,
    this.description,
    this.dynamicVariable,
    this.constantValue,
  });

  factory LiteralJsonSchemaProperty.fromJson(Map<String, dynamic> json) =>
      _$LiteralJsonSchemaPropertyFromJson(json);

  static const toJsonFactory = _$LiteralJsonSchemaPropertyToJson;
  Map<String, dynamic> toJson() => _$LiteralJsonSchemaPropertyToJson(this);

  @JsonKey(
    name: 'type',
    toJson: literalJsonSchemaPropertyTypeToJson,
    fromJson: literalJsonSchemaPropertyTypeFromJson,
  )
  final enums.LiteralJsonSchemaPropertyType type;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'dynamic_variable')
  final String? dynamicVariable;
  @JsonKey(name: 'constant_value')
  final dynamic constantValue;
  static const fromJsonFactory = _$LiteralJsonSchemaPropertyFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is LiteralJsonSchemaProperty &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.dynamicVariable, dynamicVariable) ||
                const DeepCollectionEquality()
                    .equals(other.dynamicVariable, dynamicVariable)) &&
            (identical(other.constantValue, constantValue) ||
                const DeepCollectionEquality()
                    .equals(other.constantValue, constantValue)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(dynamicVariable) ^
      const DeepCollectionEquality().hash(constantValue) ^
      runtimeType.hashCode;
}

extension $LiteralJsonSchemaPropertyExtension on LiteralJsonSchemaProperty {
  LiteralJsonSchemaProperty copyWith(
      {enums.LiteralJsonSchemaPropertyType? type,
      String? description,
      String? dynamicVariable,
      dynamic constantValue}) {
    return LiteralJsonSchemaProperty(
        type: type ?? this.type,
        description: description ?? this.description,
        dynamicVariable: dynamicVariable ?? this.dynamicVariable,
        constantValue: constantValue ?? this.constantValue);
  }

  LiteralJsonSchemaProperty copyWithWrapped(
      {Wrapped<enums.LiteralJsonSchemaPropertyType>? type,
      Wrapped<String?>? description,
      Wrapped<String?>? dynamicVariable,
      Wrapped<dynamic>? constantValue}) {
    return LiteralJsonSchemaProperty(
        type: (type != null ? type.value : this.type),
        description:
            (description != null ? description.value : this.description),
        dynamicVariable: (dynamicVariable != null
            ? dynamicVariable.value
            : this.dynamicVariable),
        constantValue:
            (constantValue != null ? constantValue.value : this.constantValue));
  }
}

@JsonSerializable(explicitToJson: true)
class MCPToolConfigInput {
  const MCPToolConfigInput({
    this.id,
    required this.name,
    required this.description,
    this.responseTimeoutSecs,
    this.type,
    this.parameters,
    required this.mcpToolName,
    required this.mcpServerId,
    this.approvalMode,
  });

  factory MCPToolConfigInput.fromJson(Map<String, dynamic> json) =>
      _$MCPToolConfigInputFromJson(json);

  static const toJsonFactory = _$MCPToolConfigInputToJson;
  Map<String, dynamic> toJson() => _$MCPToolConfigInputToJson(this);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'response_timeout_secs')
  final int? responseTimeoutSecs;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'parameters')
  final dynamic parameters;
  @JsonKey(name: 'mcp_tool_name')
  final String mcpToolName;
  @JsonKey(name: 'mcp_server_id')
  final String mcpServerId;
  @JsonKey(
    name: 'approval_mode',
    toJson: mCPApprovalRequiredModelNullableToJson,
    fromJson: mCPApprovalRequiredModelApprovalModeNullableFromJson,
  )
  final enums.MCPApprovalRequiredModel? approvalMode;
  static enums.MCPApprovalRequiredModel?
      mCPApprovalRequiredModelApprovalModeNullableFromJson(Object? value) =>
          mCPApprovalRequiredModelNullableFromJson(
              value, enums.MCPApprovalRequiredModel.userApprovalNeverGiven);

  static const fromJsonFactory = _$MCPToolConfigInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MCPToolConfigInput &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.responseTimeoutSecs, responseTimeoutSecs) ||
                const DeepCollectionEquality()
                    .equals(other.responseTimeoutSecs, responseTimeoutSecs)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)) &&
            (identical(other.mcpToolName, mcpToolName) ||
                const DeepCollectionEquality()
                    .equals(other.mcpToolName, mcpToolName)) &&
            (identical(other.mcpServerId, mcpServerId) ||
                const DeepCollectionEquality()
                    .equals(other.mcpServerId, mcpServerId)) &&
            (identical(other.approvalMode, approvalMode) ||
                const DeepCollectionEquality()
                    .equals(other.approvalMode, approvalMode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(responseTimeoutSecs) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(parameters) ^
      const DeepCollectionEquality().hash(mcpToolName) ^
      const DeepCollectionEquality().hash(mcpServerId) ^
      const DeepCollectionEquality().hash(approvalMode) ^
      runtimeType.hashCode;
}

extension $MCPToolConfigInputExtension on MCPToolConfigInput {
  MCPToolConfigInput copyWith(
      {String? id,
      String? name,
      String? description,
      int? responseTimeoutSecs,
      String? type,
      dynamic parameters,
      String? mcpToolName,
      String? mcpServerId,
      enums.MCPApprovalRequiredModel? approvalMode}) {
    return MCPToolConfigInput(
        id: id ?? this.id,
        name: name ?? this.name,
        description: description ?? this.description,
        responseTimeoutSecs: responseTimeoutSecs ?? this.responseTimeoutSecs,
        type: type ?? this.type,
        parameters: parameters ?? this.parameters,
        mcpToolName: mcpToolName ?? this.mcpToolName,
        mcpServerId: mcpServerId ?? this.mcpServerId,
        approvalMode: approvalMode ?? this.approvalMode);
  }

  MCPToolConfigInput copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String>? name,
      Wrapped<String>? description,
      Wrapped<int?>? responseTimeoutSecs,
      Wrapped<String?>? type,
      Wrapped<dynamic>? parameters,
      Wrapped<String>? mcpToolName,
      Wrapped<String>? mcpServerId,
      Wrapped<enums.MCPApprovalRequiredModel?>? approvalMode}) {
    return MCPToolConfigInput(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        responseTimeoutSecs: (responseTimeoutSecs != null
            ? responseTimeoutSecs.value
            : this.responseTimeoutSecs),
        type: (type != null ? type.value : this.type),
        parameters: (parameters != null ? parameters.value : this.parameters),
        mcpToolName:
            (mcpToolName != null ? mcpToolName.value : this.mcpToolName),
        mcpServerId:
            (mcpServerId != null ? mcpServerId.value : this.mcpServerId),
        approvalMode:
            (approvalMode != null ? approvalMode.value : this.approvalMode));
  }
}

@JsonSerializable(explicitToJson: true)
class MCPToolConfigOutput {
  const MCPToolConfigOutput({
    this.id,
    required this.name,
    required this.description,
    this.responseTimeoutSecs,
    this.type,
    this.parameters,
    required this.mcpToolName,
    required this.mcpServerId,
    this.approvalMode,
  });

  factory MCPToolConfigOutput.fromJson(Map<String, dynamic> json) =>
      _$MCPToolConfigOutputFromJson(json);

  static const toJsonFactory = _$MCPToolConfigOutputToJson;
  Map<String, dynamic> toJson() => _$MCPToolConfigOutputToJson(this);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'response_timeout_secs')
  final int? responseTimeoutSecs;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'parameters')
  final dynamic parameters;
  @JsonKey(name: 'mcp_tool_name')
  final String mcpToolName;
  @JsonKey(name: 'mcp_server_id')
  final String mcpServerId;
  @JsonKey(
    name: 'approval_mode',
    toJson: mCPApprovalRequiredModelNullableToJson,
    fromJson: mCPApprovalRequiredModelApprovalModeNullableFromJson,
  )
  final enums.MCPApprovalRequiredModel? approvalMode;
  static enums.MCPApprovalRequiredModel?
      mCPApprovalRequiredModelApprovalModeNullableFromJson(Object? value) =>
          mCPApprovalRequiredModelNullableFromJson(
              value, enums.MCPApprovalRequiredModel.userApprovalNeverGiven);

  static const fromJsonFactory = _$MCPToolConfigOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MCPToolConfigOutput &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.responseTimeoutSecs, responseTimeoutSecs) ||
                const DeepCollectionEquality()
                    .equals(other.responseTimeoutSecs, responseTimeoutSecs)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)) &&
            (identical(other.mcpToolName, mcpToolName) ||
                const DeepCollectionEquality()
                    .equals(other.mcpToolName, mcpToolName)) &&
            (identical(other.mcpServerId, mcpServerId) ||
                const DeepCollectionEquality()
                    .equals(other.mcpServerId, mcpServerId)) &&
            (identical(other.approvalMode, approvalMode) ||
                const DeepCollectionEquality()
                    .equals(other.approvalMode, approvalMode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(responseTimeoutSecs) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(parameters) ^
      const DeepCollectionEquality().hash(mcpToolName) ^
      const DeepCollectionEquality().hash(mcpServerId) ^
      const DeepCollectionEquality().hash(approvalMode) ^
      runtimeType.hashCode;
}

extension $MCPToolConfigOutputExtension on MCPToolConfigOutput {
  MCPToolConfigOutput copyWith(
      {String? id,
      String? name,
      String? description,
      int? responseTimeoutSecs,
      String? type,
      dynamic parameters,
      String? mcpToolName,
      String? mcpServerId,
      enums.MCPApprovalRequiredModel? approvalMode}) {
    return MCPToolConfigOutput(
        id: id ?? this.id,
        name: name ?? this.name,
        description: description ?? this.description,
        responseTimeoutSecs: responseTimeoutSecs ?? this.responseTimeoutSecs,
        type: type ?? this.type,
        parameters: parameters ?? this.parameters,
        mcpToolName: mcpToolName ?? this.mcpToolName,
        mcpServerId: mcpServerId ?? this.mcpServerId,
        approvalMode: approvalMode ?? this.approvalMode);
  }

  MCPToolConfigOutput copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String>? name,
      Wrapped<String>? description,
      Wrapped<int?>? responseTimeoutSecs,
      Wrapped<String?>? type,
      Wrapped<dynamic>? parameters,
      Wrapped<String>? mcpToolName,
      Wrapped<String>? mcpServerId,
      Wrapped<enums.MCPApprovalRequiredModel?>? approvalMode}) {
    return MCPToolConfigOutput(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        responseTimeoutSecs: (responseTimeoutSecs != null
            ? responseTimeoutSecs.value
            : this.responseTimeoutSecs),
        type: (type != null ? type.value : this.type),
        parameters: (parameters != null ? parameters.value : this.parameters),
        mcpToolName:
            (mcpToolName != null ? mcpToolName.value : this.mcpToolName),
        mcpServerId:
            (mcpServerId != null ? mcpServerId.value : this.mcpServerId),
        approvalMode:
            (approvalMode != null ? approvalMode.value : this.approvalMode));
  }
}

@JsonSerializable(explicitToJson: true)
class ManualVerificationFileResponseModel {
  const ManualVerificationFileResponseModel({
    required this.fileId,
    required this.fileName,
    required this.mimeType,
    required this.sizeBytes,
    required this.uploadDateUnix,
  });

  factory ManualVerificationFileResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$ManualVerificationFileResponseModelFromJson(json);

  static const toJsonFactory = _$ManualVerificationFileResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$ManualVerificationFileResponseModelToJson(this);

  @JsonKey(name: 'file_id')
  final String fileId;
  @JsonKey(name: 'file_name')
  final String fileName;
  @JsonKey(name: 'mime_type')
  final String mimeType;
  @JsonKey(name: 'size_bytes')
  final int sizeBytes;
  @JsonKey(name: 'upload_date_unix')
  final int uploadDateUnix;
  static const fromJsonFactory = _$ManualVerificationFileResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ManualVerificationFileResponseModel &&
            (identical(other.fileId, fileId) ||
                const DeepCollectionEquality().equals(other.fileId, fileId)) &&
            (identical(other.fileName, fileName) ||
                const DeepCollectionEquality()
                    .equals(other.fileName, fileName)) &&
            (identical(other.mimeType, mimeType) ||
                const DeepCollectionEquality()
                    .equals(other.mimeType, mimeType)) &&
            (identical(other.sizeBytes, sizeBytes) ||
                const DeepCollectionEquality()
                    .equals(other.sizeBytes, sizeBytes)) &&
            (identical(other.uploadDateUnix, uploadDateUnix) ||
                const DeepCollectionEquality()
                    .equals(other.uploadDateUnix, uploadDateUnix)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(fileId) ^
      const DeepCollectionEquality().hash(fileName) ^
      const DeepCollectionEquality().hash(mimeType) ^
      const DeepCollectionEquality().hash(sizeBytes) ^
      const DeepCollectionEquality().hash(uploadDateUnix) ^
      runtimeType.hashCode;
}

extension $ManualVerificationFileResponseModelExtension
    on ManualVerificationFileResponseModel {
  ManualVerificationFileResponseModel copyWith(
      {String? fileId,
      String? fileName,
      String? mimeType,
      int? sizeBytes,
      int? uploadDateUnix}) {
    return ManualVerificationFileResponseModel(
        fileId: fileId ?? this.fileId,
        fileName: fileName ?? this.fileName,
        mimeType: mimeType ?? this.mimeType,
        sizeBytes: sizeBytes ?? this.sizeBytes,
        uploadDateUnix: uploadDateUnix ?? this.uploadDateUnix);
  }

  ManualVerificationFileResponseModel copyWithWrapped(
      {Wrapped<String>? fileId,
      Wrapped<String>? fileName,
      Wrapped<String>? mimeType,
      Wrapped<int>? sizeBytes,
      Wrapped<int>? uploadDateUnix}) {
    return ManualVerificationFileResponseModel(
        fileId: (fileId != null ? fileId.value : this.fileId),
        fileName: (fileName != null ? fileName.value : this.fileName),
        mimeType: (mimeType != null ? mimeType.value : this.mimeType),
        sizeBytes: (sizeBytes != null ? sizeBytes.value : this.sizeBytes),
        uploadDateUnix: (uploadDateUnix != null
            ? uploadDateUnix.value
            : this.uploadDateUnix));
  }
}

@JsonSerializable(explicitToJson: true)
class ManualVerificationResponseModel {
  const ManualVerificationResponseModel({
    required this.extraText,
    required this.requestTimeUnix,
    required this.files,
  });

  factory ManualVerificationResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ManualVerificationResponseModelFromJson(json);

  static const toJsonFactory = _$ManualVerificationResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$ManualVerificationResponseModelToJson(this);

  @JsonKey(name: 'extra_text')
  final String extraText;
  @JsonKey(name: 'request_time_unix')
  final int requestTimeUnix;
  @JsonKey(name: 'files', defaultValue: <ManualVerificationFileResponseModel>[])
  final List<ManualVerificationFileResponseModel> files;
  static const fromJsonFactory = _$ManualVerificationResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ManualVerificationResponseModel &&
            (identical(other.extraText, extraText) ||
                const DeepCollectionEquality()
                    .equals(other.extraText, extraText)) &&
            (identical(other.requestTimeUnix, requestTimeUnix) ||
                const DeepCollectionEquality()
                    .equals(other.requestTimeUnix, requestTimeUnix)) &&
            (identical(other.files, files) ||
                const DeepCollectionEquality().equals(other.files, files)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(extraText) ^
      const DeepCollectionEquality().hash(requestTimeUnix) ^
      const DeepCollectionEquality().hash(files) ^
      runtimeType.hashCode;
}

extension $ManualVerificationResponseModelExtension
    on ManualVerificationResponseModel {
  ManualVerificationResponseModel copyWith(
      {String? extraText,
      int? requestTimeUnix,
      List<ManualVerificationFileResponseModel>? files}) {
    return ManualVerificationResponseModel(
        extraText: extraText ?? this.extraText,
        requestTimeUnix: requestTimeUnix ?? this.requestTimeUnix,
        files: files ?? this.files);
  }

  ManualVerificationResponseModel copyWithWrapped(
      {Wrapped<String>? extraText,
      Wrapped<int>? requestTimeUnix,
      Wrapped<List<ManualVerificationFileResponseModel>>? files}) {
    return ManualVerificationResponseModel(
        extraText: (extraText != null ? extraText.value : this.extraText),
        requestTimeUnix: (requestTimeUnix != null
            ? requestTimeUnix.value
            : this.requestTimeUnix),
        files: (files != null ? files.value : this.files));
  }
}

@JsonSerializable(explicitToJson: true)
class MetricRecord {
  const MetricRecord({
    required this.elapsedTime,
  });

  factory MetricRecord.fromJson(Map<String, dynamic> json) =>
      _$MetricRecordFromJson(json);

  static const toJsonFactory = _$MetricRecordToJson;
  Map<String, dynamic> toJson() => _$MetricRecordToJson(this);

  @JsonKey(name: 'elapsed_time')
  final double elapsedTime;
  static const fromJsonFactory = _$MetricRecordFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is MetricRecord &&
            (identical(other.elapsedTime, elapsedTime) ||
                const DeepCollectionEquality()
                    .equals(other.elapsedTime, elapsedTime)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(elapsedTime) ^ runtimeType.hashCode;
}

extension $MetricRecordExtension on MetricRecord {
  MetricRecord copyWith({double? elapsedTime}) {
    return MetricRecord(elapsedTime: elapsedTime ?? this.elapsedTime);
  }

  MetricRecord copyWithWrapped({Wrapped<double>? elapsedTime}) {
    return MetricRecord(
        elapsedTime:
            (elapsedTime != null ? elapsedTime.value : this.elapsedTime));
  }
}

@JsonSerializable(explicitToJson: true)
class ModelRatesResponseModel {
  const ModelRatesResponseModel({
    required this.characterCostMultiplier,
  });

  factory ModelRatesResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ModelRatesResponseModelFromJson(json);

  static const toJsonFactory = _$ModelRatesResponseModelToJson;
  Map<String, dynamic> toJson() => _$ModelRatesResponseModelToJson(this);

  @JsonKey(name: 'character_cost_multiplier')
  final double characterCostMultiplier;
  static const fromJsonFactory = _$ModelRatesResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ModelRatesResponseModel &&
            (identical(
                    other.characterCostMultiplier, characterCostMultiplier) ||
                const DeepCollectionEquality().equals(
                    other.characterCostMultiplier, characterCostMultiplier)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(characterCostMultiplier) ^
      runtimeType.hashCode;
}

extension $ModelRatesResponseModelExtension on ModelRatesResponseModel {
  ModelRatesResponseModel copyWith({double? characterCostMultiplier}) {
    return ModelRatesResponseModel(
        characterCostMultiplier:
            characterCostMultiplier ?? this.characterCostMultiplier);
  }

  ModelRatesResponseModel copyWithWrapped(
      {Wrapped<double>? characterCostMultiplier}) {
    return ModelRatesResponseModel(
        characterCostMultiplier: (characterCostMultiplier != null
            ? characterCostMultiplier.value
            : this.characterCostMultiplier));
  }
}

@JsonSerializable(explicitToJson: true)
class ModelResponseModel {
  const ModelResponseModel({
    required this.modelId,
    required this.name,
    required this.canBeFinetuned,
    required this.canDoTextToSpeech,
    required this.canDoVoiceConversion,
    required this.canUseStyle,
    required this.canUseQuality,
    required this.canUseSpeakerBoost,
    required this.servesProVoices,
    required this.tokenCostFactor,
    required this.description,
    required this.requiresAlphaAccess,
    required this.maxCharactersRequestFreeUser,
    required this.maxCharactersRequestSubscribedUser,
    required this.maximumTextLengthPerRequest,
    required this.languages,
    required this.modelRates,
    required this.concurrencyGroup,
  });

  factory ModelResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ModelResponseModelFromJson(json);

  static const toJsonFactory = _$ModelResponseModelToJson;
  Map<String, dynamic> toJson() => _$ModelResponseModelToJson(this);

  @JsonKey(name: 'model_id')
  final String modelId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'can_be_finetuned')
  final bool canBeFinetuned;
  @JsonKey(name: 'can_do_text_to_speech')
  final bool canDoTextToSpeech;
  @JsonKey(name: 'can_do_voice_conversion')
  final bool canDoVoiceConversion;
  @JsonKey(name: 'can_use_style')
  final bool canUseStyle;
  @JsonKey(name: 'can_use_quality')
  final bool canUseQuality;
  @JsonKey(name: 'can_use_speaker_boost')
  final bool canUseSpeakerBoost;
  @JsonKey(name: 'serves_pro_voices')
  final bool servesProVoices;
  @JsonKey(name: 'token_cost_factor')
  final double tokenCostFactor;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'requires_alpha_access')
  final bool requiresAlphaAccess;
  @JsonKey(name: 'max_characters_request_free_user')
  final int maxCharactersRequestFreeUser;
  @JsonKey(name: 'max_characters_request_subscribed_user')
  final int maxCharactersRequestSubscribedUser;
  @JsonKey(name: 'maximum_text_length_per_request')
  final int maximumTextLengthPerRequest;
  @JsonKey(name: 'languages', defaultValue: <LanguageResponseModel>[])
  final List<LanguageResponseModel> languages;
  @JsonKey(name: 'model_rates')
  final ModelRatesResponseModel modelRates;
  @JsonKey(
    name: 'concurrency_group',
    toJson: modelResponseModelConcurrencyGroupToJson,
    fromJson: modelResponseModelConcurrencyGroupFromJson,
  )
  final enums.ModelResponseModelConcurrencyGroup concurrencyGroup;
  static const fromJsonFactory = _$ModelResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ModelResponseModel &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.canBeFinetuned, canBeFinetuned) ||
                const DeepCollectionEquality()
                    .equals(other.canBeFinetuned, canBeFinetuned)) &&
            (identical(other.canDoTextToSpeech, canDoTextToSpeech) ||
                const DeepCollectionEquality()
                    .equals(other.canDoTextToSpeech, canDoTextToSpeech)) &&
            (identical(other.canDoVoiceConversion, canDoVoiceConversion) ||
                const DeepCollectionEquality().equals(
                    other.canDoVoiceConversion, canDoVoiceConversion)) &&
            (identical(other.canUseStyle, canUseStyle) ||
                const DeepCollectionEquality()
                    .equals(other.canUseStyle, canUseStyle)) &&
            (identical(other.canUseQuality, canUseQuality) ||
                const DeepCollectionEquality()
                    .equals(other.canUseQuality, canUseQuality)) &&
            (identical(other.canUseSpeakerBoost, canUseSpeakerBoost) ||
                const DeepCollectionEquality()
                    .equals(other.canUseSpeakerBoost, canUseSpeakerBoost)) &&
            (identical(other.servesProVoices, servesProVoices) ||
                const DeepCollectionEquality()
                    .equals(other.servesProVoices, servesProVoices)) &&
            (identical(other.tokenCostFactor, tokenCostFactor) ||
                const DeepCollectionEquality()
                    .equals(other.tokenCostFactor, tokenCostFactor)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.requiresAlphaAccess, requiresAlphaAccess) ||
                const DeepCollectionEquality()
                    .equals(other.requiresAlphaAccess, requiresAlphaAccess)) &&
            (identical(other.maxCharactersRequestFreeUser, maxCharactersRequestFreeUser) ||
                const DeepCollectionEquality().equals(
                    other.maxCharactersRequestFreeUser,
                    maxCharactersRequestFreeUser)) &&
            (identical(other.maxCharactersRequestSubscribedUser, maxCharactersRequestSubscribedUser) ||
                const DeepCollectionEquality().equals(
                    other.maxCharactersRequestSubscribedUser,
                    maxCharactersRequestSubscribedUser)) &&
            (identical(other.maximumTextLengthPerRequest, maximumTextLengthPerRequest) ||
                const DeepCollectionEquality().equals(
                    other.maximumTextLengthPerRequest,
                    maximumTextLengthPerRequest)) &&
            (identical(other.languages, languages) ||
                const DeepCollectionEquality()
                    .equals(other.languages, languages)) &&
            (identical(other.modelRates, modelRates) ||
                const DeepCollectionEquality()
                    .equals(other.modelRates, modelRates)) &&
            (identical(other.concurrencyGroup, concurrencyGroup) ||
                const DeepCollectionEquality()
                    .equals(other.concurrencyGroup, concurrencyGroup)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(canBeFinetuned) ^
      const DeepCollectionEquality().hash(canDoTextToSpeech) ^
      const DeepCollectionEquality().hash(canDoVoiceConversion) ^
      const DeepCollectionEquality().hash(canUseStyle) ^
      const DeepCollectionEquality().hash(canUseQuality) ^
      const DeepCollectionEquality().hash(canUseSpeakerBoost) ^
      const DeepCollectionEquality().hash(servesProVoices) ^
      const DeepCollectionEquality().hash(tokenCostFactor) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(requiresAlphaAccess) ^
      const DeepCollectionEquality().hash(maxCharactersRequestFreeUser) ^
      const DeepCollectionEquality().hash(maxCharactersRequestSubscribedUser) ^
      const DeepCollectionEquality().hash(maximumTextLengthPerRequest) ^
      const DeepCollectionEquality().hash(languages) ^
      const DeepCollectionEquality().hash(modelRates) ^
      const DeepCollectionEquality().hash(concurrencyGroup) ^
      runtimeType.hashCode;
}

extension $ModelResponseModelExtension on ModelResponseModel {
  ModelResponseModel copyWith(
      {String? modelId,
      String? name,
      bool? canBeFinetuned,
      bool? canDoTextToSpeech,
      bool? canDoVoiceConversion,
      bool? canUseStyle,
      bool? canUseQuality,
      bool? canUseSpeakerBoost,
      bool? servesProVoices,
      double? tokenCostFactor,
      String? description,
      bool? requiresAlphaAccess,
      int? maxCharactersRequestFreeUser,
      int? maxCharactersRequestSubscribedUser,
      int? maximumTextLengthPerRequest,
      List<LanguageResponseModel>? languages,
      ModelRatesResponseModel? modelRates,
      enums.ModelResponseModelConcurrencyGroup? concurrencyGroup}) {
    return ModelResponseModel(
        modelId: modelId ?? this.modelId,
        name: name ?? this.name,
        canBeFinetuned: canBeFinetuned ?? this.canBeFinetuned,
        canDoTextToSpeech: canDoTextToSpeech ?? this.canDoTextToSpeech,
        canDoVoiceConversion: canDoVoiceConversion ?? this.canDoVoiceConversion,
        canUseStyle: canUseStyle ?? this.canUseStyle,
        canUseQuality: canUseQuality ?? this.canUseQuality,
        canUseSpeakerBoost: canUseSpeakerBoost ?? this.canUseSpeakerBoost,
        servesProVoices: servesProVoices ?? this.servesProVoices,
        tokenCostFactor: tokenCostFactor ?? this.tokenCostFactor,
        description: description ?? this.description,
        requiresAlphaAccess: requiresAlphaAccess ?? this.requiresAlphaAccess,
        maxCharactersRequestFreeUser:
            maxCharactersRequestFreeUser ?? this.maxCharactersRequestFreeUser,
        maxCharactersRequestSubscribedUser:
            maxCharactersRequestSubscribedUser ??
                this.maxCharactersRequestSubscribedUser,
        maximumTextLengthPerRequest:
            maximumTextLengthPerRequest ?? this.maximumTextLengthPerRequest,
        languages: languages ?? this.languages,
        modelRates: modelRates ?? this.modelRates,
        concurrencyGroup: concurrencyGroup ?? this.concurrencyGroup);
  }

  ModelResponseModel copyWithWrapped(
      {Wrapped<String>? modelId,
      Wrapped<String>? name,
      Wrapped<bool>? canBeFinetuned,
      Wrapped<bool>? canDoTextToSpeech,
      Wrapped<bool>? canDoVoiceConversion,
      Wrapped<bool>? canUseStyle,
      Wrapped<bool>? canUseQuality,
      Wrapped<bool>? canUseSpeakerBoost,
      Wrapped<bool>? servesProVoices,
      Wrapped<double>? tokenCostFactor,
      Wrapped<String>? description,
      Wrapped<bool>? requiresAlphaAccess,
      Wrapped<int>? maxCharactersRequestFreeUser,
      Wrapped<int>? maxCharactersRequestSubscribedUser,
      Wrapped<int>? maximumTextLengthPerRequest,
      Wrapped<List<LanguageResponseModel>>? languages,
      Wrapped<ModelRatesResponseModel>? modelRates,
      Wrapped<enums.ModelResponseModelConcurrencyGroup>? concurrencyGroup}) {
    return ModelResponseModel(
        modelId: (modelId != null ? modelId.value : this.modelId),
        name: (name != null ? name.value : this.name),
        canBeFinetuned: (canBeFinetuned != null
            ? canBeFinetuned.value
            : this.canBeFinetuned),
        canDoTextToSpeech: (canDoTextToSpeech != null
            ? canDoTextToSpeech.value
            : this.canDoTextToSpeech),
        canDoVoiceConversion: (canDoVoiceConversion != null
            ? canDoVoiceConversion.value
            : this.canDoVoiceConversion),
        canUseStyle:
            (canUseStyle != null ? canUseStyle.value : this.canUseStyle),
        canUseQuality:
            (canUseQuality != null ? canUseQuality.value : this.canUseQuality),
        canUseSpeakerBoost: (canUseSpeakerBoost != null
            ? canUseSpeakerBoost.value
            : this.canUseSpeakerBoost),
        servesProVoices: (servesProVoices != null
            ? servesProVoices.value
            : this.servesProVoices),
        tokenCostFactor: (tokenCostFactor != null
            ? tokenCostFactor.value
            : this.tokenCostFactor),
        description:
            (description != null ? description.value : this.description),
        requiresAlphaAccess: (requiresAlphaAccess != null
            ? requiresAlphaAccess.value
            : this.requiresAlphaAccess),
        maxCharactersRequestFreeUser: (maxCharactersRequestFreeUser != null
            ? maxCharactersRequestFreeUser.value
            : this.maxCharactersRequestFreeUser),
        maxCharactersRequestSubscribedUser:
            (maxCharactersRequestSubscribedUser != null
                ? maxCharactersRequestSubscribedUser.value
                : this.maxCharactersRequestSubscribedUser),
        maximumTextLengthPerRequest: (maximumTextLengthPerRequest != null
            ? maximumTextLengthPerRequest.value
            : this.maximumTextLengthPerRequest),
        languages: (languages != null ? languages.value : this.languages),
        modelRates: (modelRates != null ? modelRates.value : this.modelRates),
        concurrencyGroup: (concurrencyGroup != null
            ? concurrencyGroup.value
            : this.concurrencyGroup));
  }
}

@JsonSerializable(explicitToJson: true)
class ModelSettingsResponseModel {
  const ModelSettingsResponseModel({
    this.stability,
    this.similarityBoost,
  });

  factory ModelSettingsResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ModelSettingsResponseModelFromJson(json);

  static const toJsonFactory = _$ModelSettingsResponseModelToJson;
  Map<String, dynamic> toJson() => _$ModelSettingsResponseModelToJson(this);

  @JsonKey(name: 'stability')
  final dynamic stability;
  @JsonKey(name: 'similarity_boost')
  final dynamic similarityBoost;
  static const fromJsonFactory = _$ModelSettingsResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ModelSettingsResponseModel &&
            (identical(other.stability, stability) ||
                const DeepCollectionEquality()
                    .equals(other.stability, stability)) &&
            (identical(other.similarityBoost, similarityBoost) ||
                const DeepCollectionEquality()
                    .equals(other.similarityBoost, similarityBoost)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(stability) ^
      const DeepCollectionEquality().hash(similarityBoost) ^
      runtimeType.hashCode;
}

extension $ModelSettingsResponseModelExtension on ModelSettingsResponseModel {
  ModelSettingsResponseModel copyWith(
      {dynamic stability, dynamic similarityBoost}) {
    return ModelSettingsResponseModel(
        stability: stability ?? this.stability,
        similarityBoost: similarityBoost ?? this.similarityBoost);
  }

  ModelSettingsResponseModel copyWithWrapped(
      {Wrapped<dynamic>? stability, Wrapped<dynamic>? similarityBoost}) {
    return ModelSettingsResponseModel(
        stability: (stability != null ? stability.value : this.stability),
        similarityBoost: (similarityBoost != null
            ? similarityBoost.value
            : this.similarityBoost));
  }
}

@JsonSerializable(explicitToJson: true)
class ModerationStatusResponseModel {
  const ModerationStatusResponseModel({
    required this.isInProbation,
    required this.enterpriseCheckNogoVoice,
    required this.enterpriseCheckBlockNogoVoice,
    required this.neverLiveModerate,
    required this.nogoVoiceSimilarVoiceUploadCount,
    required this.enterpriseBackgroundModerationEnabled,
    this.safetyStatus,
    this.warningStatus,
    required this.onWatchlist,
  });

  factory ModerationStatusResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ModerationStatusResponseModelFromJson(json);

  static const toJsonFactory = _$ModerationStatusResponseModelToJson;
  Map<String, dynamic> toJson() => _$ModerationStatusResponseModelToJson(this);

  @JsonKey(name: 'is_in_probation')
  final bool isInProbation;
  @JsonKey(name: 'enterprise_check_nogo_voice')
  final bool enterpriseCheckNogoVoice;
  @JsonKey(name: 'enterprise_check_block_nogo_voice')
  final bool enterpriseCheckBlockNogoVoice;
  @JsonKey(name: 'never_live_moderate')
  final bool neverLiveModerate;
  @JsonKey(name: 'nogo_voice_similar_voice_upload_count')
  final int nogoVoiceSimilarVoiceUploadCount;
  @JsonKey(name: 'enterprise_background_moderation_enabled')
  final bool enterpriseBackgroundModerationEnabled;
  @JsonKey(name: 'safety_status')
  final dynamic safetyStatus;
  @JsonKey(name: 'warning_status')
  final dynamic warningStatus;
  @JsonKey(name: 'on_watchlist')
  final bool onWatchlist;
  static const fromJsonFactory = _$ModerationStatusResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ModerationStatusResponseModel &&
            (identical(other.isInProbation, isInProbation) ||
                const DeepCollectionEquality()
                    .equals(other.isInProbation, isInProbation)) &&
            (identical(other.enterpriseCheckNogoVoice, enterpriseCheckNogoVoice) ||
                const DeepCollectionEquality().equals(
                    other.enterpriseCheckNogoVoice,
                    enterpriseCheckNogoVoice)) &&
            (identical(other.enterpriseCheckBlockNogoVoice, enterpriseCheckBlockNogoVoice) ||
                const DeepCollectionEquality().equals(
                    other.enterpriseCheckBlockNogoVoice,
                    enterpriseCheckBlockNogoVoice)) &&
            (identical(other.neverLiveModerate, neverLiveModerate) ||
                const DeepCollectionEquality()
                    .equals(other.neverLiveModerate, neverLiveModerate)) &&
            (identical(other.nogoVoiceSimilarVoiceUploadCount, nogoVoiceSimilarVoiceUploadCount) ||
                const DeepCollectionEquality().equals(
                    other.nogoVoiceSimilarVoiceUploadCount,
                    nogoVoiceSimilarVoiceUploadCount)) &&
            (identical(other.enterpriseBackgroundModerationEnabled,
                    enterpriseBackgroundModerationEnabled) ||
                const DeepCollectionEquality().equals(
                    other.enterpriseBackgroundModerationEnabled,
                    enterpriseBackgroundModerationEnabled)) &&
            (identical(other.safetyStatus, safetyStatus) ||
                const DeepCollectionEquality()
                    .equals(other.safetyStatus, safetyStatus)) &&
            (identical(other.warningStatus, warningStatus) ||
                const DeepCollectionEquality()
                    .equals(other.warningStatus, warningStatus)) &&
            (identical(other.onWatchlist, onWatchlist) ||
                const DeepCollectionEquality()
                    .equals(other.onWatchlist, onWatchlist)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isInProbation) ^
      const DeepCollectionEquality().hash(enterpriseCheckNogoVoice) ^
      const DeepCollectionEquality().hash(enterpriseCheckBlockNogoVoice) ^
      const DeepCollectionEquality().hash(neverLiveModerate) ^
      const DeepCollectionEquality().hash(nogoVoiceSimilarVoiceUploadCount) ^
      const DeepCollectionEquality()
          .hash(enterpriseBackgroundModerationEnabled) ^
      const DeepCollectionEquality().hash(safetyStatus) ^
      const DeepCollectionEquality().hash(warningStatus) ^
      const DeepCollectionEquality().hash(onWatchlist) ^
      runtimeType.hashCode;
}

extension $ModerationStatusResponseModelExtension
    on ModerationStatusResponseModel {
  ModerationStatusResponseModel copyWith(
      {bool? isInProbation,
      bool? enterpriseCheckNogoVoice,
      bool? enterpriseCheckBlockNogoVoice,
      bool? neverLiveModerate,
      int? nogoVoiceSimilarVoiceUploadCount,
      bool? enterpriseBackgroundModerationEnabled,
      dynamic safetyStatus,
      dynamic warningStatus,
      bool? onWatchlist}) {
    return ModerationStatusResponseModel(
        isInProbation: isInProbation ?? this.isInProbation,
        enterpriseCheckNogoVoice:
            enterpriseCheckNogoVoice ?? this.enterpriseCheckNogoVoice,
        enterpriseCheckBlockNogoVoice:
            enterpriseCheckBlockNogoVoice ?? this.enterpriseCheckBlockNogoVoice,
        neverLiveModerate: neverLiveModerate ?? this.neverLiveModerate,
        nogoVoiceSimilarVoiceUploadCount: nogoVoiceSimilarVoiceUploadCount ??
            this.nogoVoiceSimilarVoiceUploadCount,
        enterpriseBackgroundModerationEnabled:
            enterpriseBackgroundModerationEnabled ??
                this.enterpriseBackgroundModerationEnabled,
        safetyStatus: safetyStatus ?? this.safetyStatus,
        warningStatus: warningStatus ?? this.warningStatus,
        onWatchlist: onWatchlist ?? this.onWatchlist);
  }

  ModerationStatusResponseModel copyWithWrapped(
      {Wrapped<bool>? isInProbation,
      Wrapped<bool>? enterpriseCheckNogoVoice,
      Wrapped<bool>? enterpriseCheckBlockNogoVoice,
      Wrapped<bool>? neverLiveModerate,
      Wrapped<int>? nogoVoiceSimilarVoiceUploadCount,
      Wrapped<bool>? enterpriseBackgroundModerationEnabled,
      Wrapped<dynamic>? safetyStatus,
      Wrapped<dynamic>? warningStatus,
      Wrapped<bool>? onWatchlist}) {
    return ModerationStatusResponseModel(
        isInProbation:
            (isInProbation != null ? isInProbation.value : this.isInProbation),
        enterpriseCheckNogoVoice: (enterpriseCheckNogoVoice != null
            ? enterpriseCheckNogoVoice.value
            : this.enterpriseCheckNogoVoice),
        enterpriseCheckBlockNogoVoice: (enterpriseCheckBlockNogoVoice != null
            ? enterpriseCheckBlockNogoVoice.value
            : this.enterpriseCheckBlockNogoVoice),
        neverLiveModerate: (neverLiveModerate != null
            ? neverLiveModerate.value
            : this.neverLiveModerate),
        nogoVoiceSimilarVoiceUploadCount:
            (nogoVoiceSimilarVoiceUploadCount != null
                ? nogoVoiceSimilarVoiceUploadCount.value
                : this.nogoVoiceSimilarVoiceUploadCount),
        enterpriseBackgroundModerationEnabled:
            (enterpriseBackgroundModerationEnabled != null
                ? enterpriseBackgroundModerationEnabled.value
                : this.enterpriseBackgroundModerationEnabled),
        safetyStatus:
            (safetyStatus != null ? safetyStatus.value : this.safetyStatus),
        warningStatus:
            (warningStatus != null ? warningStatus.value : this.warningStatus),
        onWatchlist:
            (onWatchlist != null ? onWatchlist.value : this.onWatchlist));
  }
}

@JsonSerializable(explicitToJson: true)
class NativeMCPToolConfigInput {
  const NativeMCPToolConfigInput({
    this.id,
    required this.name,
    required this.description,
    this.responseTimeoutSecs,
    this.type,
    this.parameters,
    required this.mcpToolName,
    required this.mcpServerId,
    this.approvalMode,
  });

  factory NativeMCPToolConfigInput.fromJson(Map<String, dynamic> json) =>
      _$NativeMCPToolConfigInputFromJson(json);

  static const toJsonFactory = _$NativeMCPToolConfigInputToJson;
  Map<String, dynamic> toJson() => _$NativeMCPToolConfigInputToJson(this);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'response_timeout_secs')
  final int? responseTimeoutSecs;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'parameters')
  final dynamic parameters;
  @JsonKey(name: 'mcp_tool_name')
  final String mcpToolName;
  @JsonKey(name: 'mcp_server_id')
  final String mcpServerId;
  @JsonKey(
    name: 'approval_mode',
    toJson: mCPApprovalRequiredModelNullableToJson,
    fromJson: mCPApprovalRequiredModelApprovalModeNullableFromJson,
  )
  final enums.MCPApprovalRequiredModel? approvalMode;
  static enums.MCPApprovalRequiredModel?
      mCPApprovalRequiredModelApprovalModeNullableFromJson(Object? value) =>
          mCPApprovalRequiredModelNullableFromJson(
              value, enums.MCPApprovalRequiredModel.userApprovalNeverGiven);

  static const fromJsonFactory = _$NativeMCPToolConfigInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NativeMCPToolConfigInput &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.responseTimeoutSecs, responseTimeoutSecs) ||
                const DeepCollectionEquality()
                    .equals(other.responseTimeoutSecs, responseTimeoutSecs)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)) &&
            (identical(other.mcpToolName, mcpToolName) ||
                const DeepCollectionEquality()
                    .equals(other.mcpToolName, mcpToolName)) &&
            (identical(other.mcpServerId, mcpServerId) ||
                const DeepCollectionEquality()
                    .equals(other.mcpServerId, mcpServerId)) &&
            (identical(other.approvalMode, approvalMode) ||
                const DeepCollectionEquality()
                    .equals(other.approvalMode, approvalMode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(responseTimeoutSecs) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(parameters) ^
      const DeepCollectionEquality().hash(mcpToolName) ^
      const DeepCollectionEquality().hash(mcpServerId) ^
      const DeepCollectionEquality().hash(approvalMode) ^
      runtimeType.hashCode;
}

extension $NativeMCPToolConfigInputExtension on NativeMCPToolConfigInput {
  NativeMCPToolConfigInput copyWith(
      {String? id,
      String? name,
      String? description,
      int? responseTimeoutSecs,
      String? type,
      dynamic parameters,
      String? mcpToolName,
      String? mcpServerId,
      enums.MCPApprovalRequiredModel? approvalMode}) {
    return NativeMCPToolConfigInput(
        id: id ?? this.id,
        name: name ?? this.name,
        description: description ?? this.description,
        responseTimeoutSecs: responseTimeoutSecs ?? this.responseTimeoutSecs,
        type: type ?? this.type,
        parameters: parameters ?? this.parameters,
        mcpToolName: mcpToolName ?? this.mcpToolName,
        mcpServerId: mcpServerId ?? this.mcpServerId,
        approvalMode: approvalMode ?? this.approvalMode);
  }

  NativeMCPToolConfigInput copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String>? name,
      Wrapped<String>? description,
      Wrapped<int?>? responseTimeoutSecs,
      Wrapped<String?>? type,
      Wrapped<dynamic>? parameters,
      Wrapped<String>? mcpToolName,
      Wrapped<String>? mcpServerId,
      Wrapped<enums.MCPApprovalRequiredModel?>? approvalMode}) {
    return NativeMCPToolConfigInput(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        responseTimeoutSecs: (responseTimeoutSecs != null
            ? responseTimeoutSecs.value
            : this.responseTimeoutSecs),
        type: (type != null ? type.value : this.type),
        parameters: (parameters != null ? parameters.value : this.parameters),
        mcpToolName:
            (mcpToolName != null ? mcpToolName.value : this.mcpToolName),
        mcpServerId:
            (mcpServerId != null ? mcpServerId.value : this.mcpServerId),
        approvalMode:
            (approvalMode != null ? approvalMode.value : this.approvalMode));
  }
}

@JsonSerializable(explicitToJson: true)
class NativeMCPToolConfigOutput {
  const NativeMCPToolConfigOutput({
    this.id,
    required this.name,
    required this.description,
    this.responseTimeoutSecs,
    this.type,
    this.parameters,
    required this.mcpToolName,
    required this.mcpServerId,
    this.approvalMode,
  });

  factory NativeMCPToolConfigOutput.fromJson(Map<String, dynamic> json) =>
      _$NativeMCPToolConfigOutputFromJson(json);

  static const toJsonFactory = _$NativeMCPToolConfigOutputToJson;
  Map<String, dynamic> toJson() => _$NativeMCPToolConfigOutputToJson(this);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'response_timeout_secs')
  final int? responseTimeoutSecs;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'parameters')
  final dynamic parameters;
  @JsonKey(name: 'mcp_tool_name')
  final String mcpToolName;
  @JsonKey(name: 'mcp_server_id')
  final String mcpServerId;
  @JsonKey(
    name: 'approval_mode',
    toJson: mCPApprovalRequiredModelNullableToJson,
    fromJson: mCPApprovalRequiredModelApprovalModeNullableFromJson,
  )
  final enums.MCPApprovalRequiredModel? approvalMode;
  static enums.MCPApprovalRequiredModel?
      mCPApprovalRequiredModelApprovalModeNullableFromJson(Object? value) =>
          mCPApprovalRequiredModelNullableFromJson(
              value, enums.MCPApprovalRequiredModel.userApprovalNeverGiven);

  static const fromJsonFactory = _$NativeMCPToolConfigOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is NativeMCPToolConfigOutput &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.responseTimeoutSecs, responseTimeoutSecs) ||
                const DeepCollectionEquality()
                    .equals(other.responseTimeoutSecs, responseTimeoutSecs)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.parameters, parameters) ||
                const DeepCollectionEquality()
                    .equals(other.parameters, parameters)) &&
            (identical(other.mcpToolName, mcpToolName) ||
                const DeepCollectionEquality()
                    .equals(other.mcpToolName, mcpToolName)) &&
            (identical(other.mcpServerId, mcpServerId) ||
                const DeepCollectionEquality()
                    .equals(other.mcpServerId, mcpServerId)) &&
            (identical(other.approvalMode, approvalMode) ||
                const DeepCollectionEquality()
                    .equals(other.approvalMode, approvalMode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(responseTimeoutSecs) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(parameters) ^
      const DeepCollectionEquality().hash(mcpToolName) ^
      const DeepCollectionEquality().hash(mcpServerId) ^
      const DeepCollectionEquality().hash(approvalMode) ^
      runtimeType.hashCode;
}

extension $NativeMCPToolConfigOutputExtension on NativeMCPToolConfigOutput {
  NativeMCPToolConfigOutput copyWith(
      {String? id,
      String? name,
      String? description,
      int? responseTimeoutSecs,
      String? type,
      dynamic parameters,
      String? mcpToolName,
      String? mcpServerId,
      enums.MCPApprovalRequiredModel? approvalMode}) {
    return NativeMCPToolConfigOutput(
        id: id ?? this.id,
        name: name ?? this.name,
        description: description ?? this.description,
        responseTimeoutSecs: responseTimeoutSecs ?? this.responseTimeoutSecs,
        type: type ?? this.type,
        parameters: parameters ?? this.parameters,
        mcpToolName: mcpToolName ?? this.mcpToolName,
        mcpServerId: mcpServerId ?? this.mcpServerId,
        approvalMode: approvalMode ?? this.approvalMode);
  }

  NativeMCPToolConfigOutput copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String>? name,
      Wrapped<String>? description,
      Wrapped<int?>? responseTimeoutSecs,
      Wrapped<String?>? type,
      Wrapped<dynamic>? parameters,
      Wrapped<String>? mcpToolName,
      Wrapped<String>? mcpServerId,
      Wrapped<enums.MCPApprovalRequiredModel?>? approvalMode}) {
    return NativeMCPToolConfigOutput(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        responseTimeoutSecs: (responseTimeoutSecs != null
            ? responseTimeoutSecs.value
            : this.responseTimeoutSecs),
        type: (type != null ? type.value : this.type),
        parameters: (parameters != null ? parameters.value : this.parameters),
        mcpToolName:
            (mcpToolName != null ? mcpToolName.value : this.mcpToolName),
        mcpServerId:
            (mcpServerId != null ? mcpServerId.value : this.mcpServerId),
        approvalMode:
            (approvalMode != null ? approvalMode.value : this.approvalMode));
  }
}

@JsonSerializable(explicitToJson: true)
class ObjectJsonSchemaPropertyInput {
  const ObjectJsonSchemaPropertyInput({
    this.type,
    this.required,
    this.description,
    this.properties,
  });

  factory ObjectJsonSchemaPropertyInput.fromJson(Map<String, dynamic> json) =>
      _$ObjectJsonSchemaPropertyInputFromJson(json);

  static const toJsonFactory = _$ObjectJsonSchemaPropertyInputToJson;
  Map<String, dynamic> toJson() => _$ObjectJsonSchemaPropertyInputToJson(this);

  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'required', defaultValue: <String>[])
  final List<String>? required;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'properties')
  final Map<String, dynamic>? properties;
  static const fromJsonFactory = _$ObjectJsonSchemaPropertyInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ObjectJsonSchemaPropertyInput &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.required, required) ||
                const DeepCollectionEquality()
                    .equals(other.required, required)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.properties, properties) ||
                const DeepCollectionEquality()
                    .equals(other.properties, properties)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(required) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(properties) ^
      runtimeType.hashCode;
}

extension $ObjectJsonSchemaPropertyInputExtension
    on ObjectJsonSchemaPropertyInput {
  ObjectJsonSchemaPropertyInput copyWith(
      {String? type,
      List<String>? required,
      String? description,
      Map<String, dynamic>? properties}) {
    return ObjectJsonSchemaPropertyInput(
        type: type ?? this.type,
        required: required ?? this.required,
        description: description ?? this.description,
        properties: properties ?? this.properties);
  }

  ObjectJsonSchemaPropertyInput copyWithWrapped(
      {Wrapped<String?>? type,
      Wrapped<List<String>?>? required,
      Wrapped<String?>? description,
      Wrapped<Map<String, dynamic>?>? properties}) {
    return ObjectJsonSchemaPropertyInput(
        type: (type != null ? type.value : this.type),
        required: (required != null ? required.value : this.required),
        description:
            (description != null ? description.value : this.description),
        properties: (properties != null ? properties.value : this.properties));
  }
}

@JsonSerializable(explicitToJson: true)
class ObjectJsonSchemaPropertyOutput {
  const ObjectJsonSchemaPropertyOutput({
    this.type,
    this.required,
    this.description,
    this.properties,
  });

  factory ObjectJsonSchemaPropertyOutput.fromJson(Map<String, dynamic> json) =>
      _$ObjectJsonSchemaPropertyOutputFromJson(json);

  static const toJsonFactory = _$ObjectJsonSchemaPropertyOutputToJson;
  Map<String, dynamic> toJson() => _$ObjectJsonSchemaPropertyOutputToJson(this);

  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'required', defaultValue: <String>[])
  final List<String>? required;
  @JsonKey(name: 'description')
  final String? description;
  @JsonKey(name: 'properties')
  final Map<String, dynamic>? properties;
  static const fromJsonFactory = _$ObjectJsonSchemaPropertyOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ObjectJsonSchemaPropertyOutput &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.required, required) ||
                const DeepCollectionEquality()
                    .equals(other.required, required)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.properties, properties) ||
                const DeepCollectionEquality()
                    .equals(other.properties, properties)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(required) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(properties) ^
      runtimeType.hashCode;
}

extension $ObjectJsonSchemaPropertyOutputExtension
    on ObjectJsonSchemaPropertyOutput {
  ObjectJsonSchemaPropertyOutput copyWith(
      {String? type,
      List<String>? required,
      String? description,
      Map<String, dynamic>? properties}) {
    return ObjectJsonSchemaPropertyOutput(
        type: type ?? this.type,
        required: required ?? this.required,
        description: description ?? this.description,
        properties: properties ?? this.properties);
  }

  ObjectJsonSchemaPropertyOutput copyWithWrapped(
      {Wrapped<String?>? type,
      Wrapped<List<String>?>? required,
      Wrapped<String?>? description,
      Wrapped<Map<String, dynamic>?>? properties}) {
    return ObjectJsonSchemaPropertyOutput(
        type: (type != null ? type.value : this.type),
        required: (required != null ? required.value : this.required),
        description:
            (description != null ? description.value : this.description),
        properties: (properties != null ? properties.value : this.properties));
  }
}

@JsonSerializable(explicitToJson: true)
class OrbAvatar {
  const OrbAvatar({
    this.type,
    this.color1,
    this.color2,
  });

  factory OrbAvatar.fromJson(Map<String, dynamic> json) =>
      _$OrbAvatarFromJson(json);

  static const toJsonFactory = _$OrbAvatarToJson;
  Map<String, dynamic> toJson() => _$OrbAvatarToJson(this);

  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'color_1')
  final String? color1;
  @JsonKey(name: 'color_2')
  final String? color2;
  static const fromJsonFactory = _$OrbAvatarFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OrbAvatar &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.color1, color1) ||
                const DeepCollectionEquality().equals(other.color1, color1)) &&
            (identical(other.color2, color2) ||
                const DeepCollectionEquality().equals(other.color2, color2)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(color1) ^
      const DeepCollectionEquality().hash(color2) ^
      runtimeType.hashCode;
}

extension $OrbAvatarExtension on OrbAvatar {
  OrbAvatar copyWith({String? type, String? color1, String? color2}) {
    return OrbAvatar(
        type: type ?? this.type,
        color1: color1 ?? this.color1,
        color2: color2 ?? this.color2);
  }

  OrbAvatar copyWithWrapped(
      {Wrapped<String?>? type,
      Wrapped<String?>? color1,
      Wrapped<String?>? color2}) {
    return OrbAvatar(
        type: (type != null ? type.value : this.type),
        color1: (color1 != null ? color1.value : this.color1),
        color2: (color2 != null ? color2.value : this.color2));
  }
}

@JsonSerializable(explicitToJson: true)
class OutboundCallRecipient {
  const OutboundCallRecipient({
    this.id,
    required this.phoneNumber,
    this.conversationInitiationClientData,
  });

  factory OutboundCallRecipient.fromJson(Map<String, dynamic> json) =>
      _$OutboundCallRecipientFromJson(json);

  static const toJsonFactory = _$OutboundCallRecipientToJson;
  Map<String, dynamic> toJson() => _$OutboundCallRecipientToJson(this);

  @JsonKey(name: 'id')
  final dynamic id;
  @JsonKey(name: 'phone_number')
  final String phoneNumber;
  @JsonKey(name: 'conversation_initiation_client_data')
  final dynamic conversationInitiationClientData;
  static const fromJsonFactory = _$OutboundCallRecipientFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OutboundCallRecipient &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.conversationInitiationClientData,
                    conversationInitiationClientData) ||
                const DeepCollectionEquality().equals(
                    other.conversationInitiationClientData,
                    conversationInitiationClientData)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(conversationInitiationClientData) ^
      runtimeType.hashCode;
}

extension $OutboundCallRecipientExtension on OutboundCallRecipient {
  OutboundCallRecipient copyWith(
      {dynamic id,
      String? phoneNumber,
      dynamic conversationInitiationClientData}) {
    return OutboundCallRecipient(
        id: id ?? this.id,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        conversationInitiationClientData: conversationInitiationClientData ??
            this.conversationInitiationClientData);
  }

  OutboundCallRecipient copyWithWrapped(
      {Wrapped<dynamic>? id,
      Wrapped<String>? phoneNumber,
      Wrapped<dynamic>? conversationInitiationClientData}) {
    return OutboundCallRecipient(
        id: (id != null ? id.value : this.id),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        conversationInitiationClientData:
            (conversationInitiationClientData != null
                ? conversationInitiationClientData.value
                : this.conversationInitiationClientData));
  }
}

@JsonSerializable(explicitToJson: true)
class OutboundCallRecipientResponseModel {
  const OutboundCallRecipientResponseModel({
    required this.id,
    required this.phoneNumber,
    required this.status,
    required this.createdAtUnix,
    required this.updatedAtUnix,
    required this.conversationId,
    this.conversationInitiationClientData,
  });

  factory OutboundCallRecipientResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$OutboundCallRecipientResponseModelFromJson(json);

  static const toJsonFactory = _$OutboundCallRecipientResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$OutboundCallRecipientResponseModelToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'phone_number')
  final String phoneNumber;
  @JsonKey(
    name: 'status',
    toJson: batchCallRecipientStatusToJson,
    fromJson: batchCallRecipientStatusFromJson,
  )
  final enums.BatchCallRecipientStatus status;
  @JsonKey(name: 'created_at_unix')
  final int createdAtUnix;
  @JsonKey(name: 'updated_at_unix')
  final int updatedAtUnix;
  @JsonKey(name: 'conversation_id')
  final dynamic conversationId;
  @JsonKey(name: 'conversation_initiation_client_data')
  final dynamic conversationInitiationClientData;
  static const fromJsonFactory = _$OutboundCallRecipientResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is OutboundCallRecipientResponseModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.createdAtUnix, createdAtUnix) ||
                const DeepCollectionEquality()
                    .equals(other.createdAtUnix, createdAtUnix)) &&
            (identical(other.updatedAtUnix, updatedAtUnix) ||
                const DeepCollectionEquality()
                    .equals(other.updatedAtUnix, updatedAtUnix)) &&
            (identical(other.conversationId, conversationId) ||
                const DeepCollectionEquality()
                    .equals(other.conversationId, conversationId)) &&
            (identical(other.conversationInitiationClientData,
                    conversationInitiationClientData) ||
                const DeepCollectionEquality().equals(
                    other.conversationInitiationClientData,
                    conversationInitiationClientData)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(createdAtUnix) ^
      const DeepCollectionEquality().hash(updatedAtUnix) ^
      const DeepCollectionEquality().hash(conversationId) ^
      const DeepCollectionEquality().hash(conversationInitiationClientData) ^
      runtimeType.hashCode;
}

extension $OutboundCallRecipientResponseModelExtension
    on OutboundCallRecipientResponseModel {
  OutboundCallRecipientResponseModel copyWith(
      {String? id,
      String? phoneNumber,
      enums.BatchCallRecipientStatus? status,
      int? createdAtUnix,
      int? updatedAtUnix,
      dynamic conversationId,
      dynamic conversationInitiationClientData}) {
    return OutboundCallRecipientResponseModel(
        id: id ?? this.id,
        phoneNumber: phoneNumber ?? this.phoneNumber,
        status: status ?? this.status,
        createdAtUnix: createdAtUnix ?? this.createdAtUnix,
        updatedAtUnix: updatedAtUnix ?? this.updatedAtUnix,
        conversationId: conversationId ?? this.conversationId,
        conversationInitiationClientData: conversationInitiationClientData ??
            this.conversationInitiationClientData);
  }

  OutboundCallRecipientResponseModel copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? phoneNumber,
      Wrapped<enums.BatchCallRecipientStatus>? status,
      Wrapped<int>? createdAtUnix,
      Wrapped<int>? updatedAtUnix,
      Wrapped<dynamic>? conversationId,
      Wrapped<dynamic>? conversationInitiationClientData}) {
    return OutboundCallRecipientResponseModel(
        id: (id != null ? id.value : this.id),
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        status: (status != null ? status.value : this.status),
        createdAtUnix:
            (createdAtUnix != null ? createdAtUnix.value : this.createdAtUnix),
        updatedAtUnix:
            (updatedAtUnix != null ? updatedAtUnix.value : this.updatedAtUnix),
        conversationId: (conversationId != null
            ? conversationId.value
            : this.conversationId),
        conversationInitiationClientData:
            (conversationInitiationClientData != null
                ? conversationInitiationClientData.value
                : this.conversationInitiationClientData));
  }
}

@JsonSerializable(explicitToJson: true)
class PatchConvAIDashboardSettingsRequest {
  const PatchConvAIDashboardSettingsRequest({
    this.charts,
  });

  factory PatchConvAIDashboardSettingsRequest.fromJson(
          Map<String, dynamic> json) =>
      _$PatchConvAIDashboardSettingsRequestFromJson(json);

  static const toJsonFactory = _$PatchConvAIDashboardSettingsRequestToJson;
  Map<String, dynamic> toJson() =>
      _$PatchConvAIDashboardSettingsRequestToJson(this);

  @JsonKey(name: 'charts', defaultValue: <Object>[])
  final List<Object>? charts;
  static const fromJsonFactory = _$PatchConvAIDashboardSettingsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PatchConvAIDashboardSettingsRequest &&
            (identical(other.charts, charts) ||
                const DeepCollectionEquality().equals(other.charts, charts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(charts) ^ runtimeType.hashCode;
}

extension $PatchConvAIDashboardSettingsRequestExtension
    on PatchConvAIDashboardSettingsRequest {
  PatchConvAIDashboardSettingsRequest copyWith({List<Object>? charts}) {
    return PatchConvAIDashboardSettingsRequest(charts: charts ?? this.charts);
  }

  PatchConvAIDashboardSettingsRequest copyWithWrapped(
      {Wrapped<List<Object>?>? charts}) {
    return PatchConvAIDashboardSettingsRequest(
        charts: (charts != null ? charts.value : this.charts));
  }
}

@JsonSerializable(explicitToJson: true)
class PatchConvAISettingsRequest {
  const PatchConvAISettingsRequest({
    this.conversationInitiationClientDataWebhook,
    this.webhooks,
    this.canUseMcpServers,
    this.ragRetentionPeriodDays,
  });

  factory PatchConvAISettingsRequest.fromJson(Map<String, dynamic> json) =>
      _$PatchConvAISettingsRequestFromJson(json);

  static const toJsonFactory = _$PatchConvAISettingsRequestToJson;
  Map<String, dynamic> toJson() => _$PatchConvAISettingsRequestToJson(this);

  @JsonKey(name: 'conversation_initiation_client_data_webhook')
  final dynamic conversationInitiationClientDataWebhook;
  @JsonKey(name: 'webhooks')
  final ConvAIWebhooks? webhooks;
  @JsonKey(name: 'can_use_mcp_servers', defaultValue: false)
  final bool? canUseMcpServers;
  @JsonKey(name: 'rag_retention_period_days')
  final int? ragRetentionPeriodDays;
  static const fromJsonFactory = _$PatchConvAISettingsRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PatchConvAISettingsRequest &&
            (identical(other.conversationInitiationClientDataWebhook,
                    conversationInitiationClientDataWebhook) ||
                const DeepCollectionEquality().equals(
                    other.conversationInitiationClientDataWebhook,
                    conversationInitiationClientDataWebhook)) &&
            (identical(other.webhooks, webhooks) ||
                const DeepCollectionEquality()
                    .equals(other.webhooks, webhooks)) &&
            (identical(other.canUseMcpServers, canUseMcpServers) ||
                const DeepCollectionEquality()
                    .equals(other.canUseMcpServers, canUseMcpServers)) &&
            (identical(other.ragRetentionPeriodDays, ragRetentionPeriodDays) ||
                const DeepCollectionEquality().equals(
                    other.ragRetentionPeriodDays, ragRetentionPeriodDays)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality()
          .hash(conversationInitiationClientDataWebhook) ^
      const DeepCollectionEquality().hash(webhooks) ^
      const DeepCollectionEquality().hash(canUseMcpServers) ^
      const DeepCollectionEquality().hash(ragRetentionPeriodDays) ^
      runtimeType.hashCode;
}

extension $PatchConvAISettingsRequestExtension on PatchConvAISettingsRequest {
  PatchConvAISettingsRequest copyWith(
      {dynamic conversationInitiationClientDataWebhook,
      ConvAIWebhooks? webhooks,
      bool? canUseMcpServers,
      int? ragRetentionPeriodDays}) {
    return PatchConvAISettingsRequest(
        conversationInitiationClientDataWebhook:
            conversationInitiationClientDataWebhook ??
                this.conversationInitiationClientDataWebhook,
        webhooks: webhooks ?? this.webhooks,
        canUseMcpServers: canUseMcpServers ?? this.canUseMcpServers,
        ragRetentionPeriodDays:
            ragRetentionPeriodDays ?? this.ragRetentionPeriodDays);
  }

  PatchConvAISettingsRequest copyWithWrapped(
      {Wrapped<dynamic>? conversationInitiationClientDataWebhook,
      Wrapped<ConvAIWebhooks?>? webhooks,
      Wrapped<bool?>? canUseMcpServers,
      Wrapped<int?>? ragRetentionPeriodDays}) {
    return PatchConvAISettingsRequest(
        conversationInitiationClientDataWebhook:
            (conversationInitiationClientDataWebhook != null
                ? conversationInitiationClientDataWebhook.value
                : this.conversationInitiationClientDataWebhook),
        webhooks: (webhooks != null ? webhooks.value : this.webhooks),
        canUseMcpServers: (canUseMcpServers != null
            ? canUseMcpServers.value
            : this.canUseMcpServers),
        ragRetentionPeriodDays: (ragRetentionPeriodDays != null
            ? ragRetentionPeriodDays.value
            : this.ragRetentionPeriodDays));
  }
}

@JsonSerializable(explicitToJson: true)
class PatchWorkspaceSecretRequest {
  const PatchWorkspaceSecretRequest({
    required this.type,
    required this.name,
    required this.$value,
  });

  factory PatchWorkspaceSecretRequest.fromJson(Map<String, dynamic> json) =>
      _$PatchWorkspaceSecretRequestFromJson(json);

  static const toJsonFactory = _$PatchWorkspaceSecretRequestToJson;
  Map<String, dynamic> toJson() => _$PatchWorkspaceSecretRequestToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'value')
  final String $value;
  static const fromJsonFactory = _$PatchWorkspaceSecretRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PatchWorkspaceSecretRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash($value) ^
      runtimeType.hashCode;
}

extension $PatchWorkspaceSecretRequestExtension on PatchWorkspaceSecretRequest {
  PatchWorkspaceSecretRequest copyWith(
      {String? type, String? name, String? $value}) {
    return PatchWorkspaceSecretRequest(
        type: type ?? this.type,
        name: name ?? this.name,
        $value: $value ?? this.$value);
  }

  PatchWorkspaceSecretRequest copyWithWrapped(
      {Wrapped<String>? type, Wrapped<String>? name, Wrapped<String>? $value}) {
    return PatchWorkspaceSecretRequest(
        type: (type != null ? type.value : this.type),
        name: (name != null ? name.value : this.name),
        $value: ($value != null ? $value.value : this.$value));
  }
}

@JsonSerializable(explicitToJson: true)
class PdfExportOptions {
  const PdfExportOptions({
    this.includeSpeakers,
    this.includeTimestamps,
    required this.format,
    this.segmentOnSilenceLongerThanS,
    this.maxSegmentDurationS,
    this.maxSegmentChars,
  });

  factory PdfExportOptions.fromJson(Map<String, dynamic> json) =>
      _$PdfExportOptionsFromJson(json);

  static const toJsonFactory = _$PdfExportOptionsToJson;
  Map<String, dynamic> toJson() => _$PdfExportOptionsToJson(this);

  @JsonKey(name: 'include_speakers', defaultValue: true)
  final bool? includeSpeakers;
  @JsonKey(name: 'include_timestamps', defaultValue: true)
  final bool? includeTimestamps;
  @JsonKey(name: 'format')
  final String format;
  @JsonKey(name: 'segment_on_silence_longer_than_s')
  final dynamic segmentOnSilenceLongerThanS;
  @JsonKey(name: 'max_segment_duration_s')
  final dynamic maxSegmentDurationS;
  @JsonKey(name: 'max_segment_chars')
  final dynamic maxSegmentChars;
  static const fromJsonFactory = _$PdfExportOptionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PdfExportOptions &&
            (identical(other.includeSpeakers, includeSpeakers) ||
                const DeepCollectionEquality()
                    .equals(other.includeSpeakers, includeSpeakers)) &&
            (identical(other.includeTimestamps, includeTimestamps) ||
                const DeepCollectionEquality()
                    .equals(other.includeTimestamps, includeTimestamps)) &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)) &&
            (identical(other.segmentOnSilenceLongerThanS,
                    segmentOnSilenceLongerThanS) ||
                const DeepCollectionEquality().equals(
                    other.segmentOnSilenceLongerThanS,
                    segmentOnSilenceLongerThanS)) &&
            (identical(other.maxSegmentDurationS, maxSegmentDurationS) ||
                const DeepCollectionEquality()
                    .equals(other.maxSegmentDurationS, maxSegmentDurationS)) &&
            (identical(other.maxSegmentChars, maxSegmentChars) ||
                const DeepCollectionEquality()
                    .equals(other.maxSegmentChars, maxSegmentChars)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(includeSpeakers) ^
      const DeepCollectionEquality().hash(includeTimestamps) ^
      const DeepCollectionEquality().hash(format) ^
      const DeepCollectionEquality().hash(segmentOnSilenceLongerThanS) ^
      const DeepCollectionEquality().hash(maxSegmentDurationS) ^
      const DeepCollectionEquality().hash(maxSegmentChars) ^
      runtimeType.hashCode;
}

extension $PdfExportOptionsExtension on PdfExportOptions {
  PdfExportOptions copyWith(
      {bool? includeSpeakers,
      bool? includeTimestamps,
      String? format,
      dynamic segmentOnSilenceLongerThanS,
      dynamic maxSegmentDurationS,
      dynamic maxSegmentChars}) {
    return PdfExportOptions(
        includeSpeakers: includeSpeakers ?? this.includeSpeakers,
        includeTimestamps: includeTimestamps ?? this.includeTimestamps,
        format: format ?? this.format,
        segmentOnSilenceLongerThanS:
            segmentOnSilenceLongerThanS ?? this.segmentOnSilenceLongerThanS,
        maxSegmentDurationS: maxSegmentDurationS ?? this.maxSegmentDurationS,
        maxSegmentChars: maxSegmentChars ?? this.maxSegmentChars);
  }

  PdfExportOptions copyWithWrapped(
      {Wrapped<bool?>? includeSpeakers,
      Wrapped<bool?>? includeTimestamps,
      Wrapped<String>? format,
      Wrapped<dynamic>? segmentOnSilenceLongerThanS,
      Wrapped<dynamic>? maxSegmentDurationS,
      Wrapped<dynamic>? maxSegmentChars}) {
    return PdfExportOptions(
        includeSpeakers: (includeSpeakers != null
            ? includeSpeakers.value
            : this.includeSpeakers),
        includeTimestamps: (includeTimestamps != null
            ? includeTimestamps.value
            : this.includeTimestamps),
        format: (format != null ? format.value : this.format),
        segmentOnSilenceLongerThanS: (segmentOnSilenceLongerThanS != null
            ? segmentOnSilenceLongerThanS.value
            : this.segmentOnSilenceLongerThanS),
        maxSegmentDurationS: (maxSegmentDurationS != null
            ? maxSegmentDurationS.value
            : this.maxSegmentDurationS),
        maxSegmentChars: (maxSegmentChars != null
            ? maxSegmentChars.value
            : this.maxSegmentChars));
  }
}

@JsonSerializable(explicitToJson: true)
class PhoneNumberAgentInfo {
  const PhoneNumberAgentInfo({
    required this.agentId,
    required this.agentName,
  });

  factory PhoneNumberAgentInfo.fromJson(Map<String, dynamic> json) =>
      _$PhoneNumberAgentInfoFromJson(json);

  static const toJsonFactory = _$PhoneNumberAgentInfoToJson;
  Map<String, dynamic> toJson() => _$PhoneNumberAgentInfoToJson(this);

  @JsonKey(name: 'agent_id')
  final String agentId;
  @JsonKey(name: 'agent_name')
  final String agentName;
  static const fromJsonFactory = _$PhoneNumberAgentInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PhoneNumberAgentInfo &&
            (identical(other.agentId, agentId) ||
                const DeepCollectionEquality()
                    .equals(other.agentId, agentId)) &&
            (identical(other.agentName, agentName) ||
                const DeepCollectionEquality()
                    .equals(other.agentName, agentName)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(agentId) ^
      const DeepCollectionEquality().hash(agentName) ^
      runtimeType.hashCode;
}

extension $PhoneNumberAgentInfoExtension on PhoneNumberAgentInfo {
  PhoneNumberAgentInfo copyWith({String? agentId, String? agentName}) {
    return PhoneNumberAgentInfo(
        agentId: agentId ?? this.agentId,
        agentName: agentName ?? this.agentName);
  }

  PhoneNumberAgentInfo copyWithWrapped(
      {Wrapped<String>? agentId, Wrapped<String>? agentName}) {
    return PhoneNumberAgentInfo(
        agentId: (agentId != null ? agentId.value : this.agentId),
        agentName: (agentName != null ? agentName.value : this.agentName));
  }
}

@JsonSerializable(explicitToJson: true)
class PhoneNumberTransfer {
  const PhoneNumberTransfer({
    required this.phoneNumber,
    required this.condition,
  });

  factory PhoneNumberTransfer.fromJson(Map<String, dynamic> json) =>
      _$PhoneNumberTransferFromJson(json);

  static const toJsonFactory = _$PhoneNumberTransferToJson;
  Map<String, dynamic> toJson() => _$PhoneNumberTransferToJson(this);

  @JsonKey(name: 'phone_number')
  final String phoneNumber;
  @JsonKey(name: 'condition')
  final String condition;
  static const fromJsonFactory = _$PhoneNumberTransferFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PhoneNumberTransfer &&
            (identical(other.phoneNumber, phoneNumber) ||
                const DeepCollectionEquality()
                    .equals(other.phoneNumber, phoneNumber)) &&
            (identical(other.condition, condition) ||
                const DeepCollectionEquality()
                    .equals(other.condition, condition)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(phoneNumber) ^
      const DeepCollectionEquality().hash(condition) ^
      runtimeType.hashCode;
}

extension $PhoneNumberTransferExtension on PhoneNumberTransfer {
  PhoneNumberTransfer copyWith({String? phoneNumber, String? condition}) {
    return PhoneNumberTransfer(
        phoneNumber: phoneNumber ?? this.phoneNumber,
        condition: condition ?? this.condition);
  }

  PhoneNumberTransfer copyWithWrapped(
      {Wrapped<String>? phoneNumber, Wrapped<String>? condition}) {
    return PhoneNumberTransfer(
        phoneNumber:
            (phoneNumber != null ? phoneNumber.value : this.phoneNumber),
        condition: (condition != null ? condition.value : this.condition));
  }
}

@JsonSerializable(explicitToJson: true)
class PodcastBulletinMode {
  const PodcastBulletinMode({
    required this.type,
    required this.bulletin,
  });

  factory PodcastBulletinMode.fromJson(Map<String, dynamic> json) =>
      _$PodcastBulletinModeFromJson(json);

  static const toJsonFactory = _$PodcastBulletinModeToJson;
  Map<String, dynamic> toJson() => _$PodcastBulletinModeToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'bulletin')
  final PodcastBulletinModeData bulletin;
  static const fromJsonFactory = _$PodcastBulletinModeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PodcastBulletinMode &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.bulletin, bulletin) ||
                const DeepCollectionEquality()
                    .equals(other.bulletin, bulletin)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(bulletin) ^
      runtimeType.hashCode;
}

extension $PodcastBulletinModeExtension on PodcastBulletinMode {
  PodcastBulletinMode copyWith(
      {String? type, PodcastBulletinModeData? bulletin}) {
    return PodcastBulletinMode(
        type: type ?? this.type, bulletin: bulletin ?? this.bulletin);
  }

  PodcastBulletinMode copyWithWrapped(
      {Wrapped<String>? type, Wrapped<PodcastBulletinModeData>? bulletin}) {
    return PodcastBulletinMode(
        type: (type != null ? type.value : this.type),
        bulletin: (bulletin != null ? bulletin.value : this.bulletin));
  }
}

@JsonSerializable(explicitToJson: true)
class PodcastBulletinModeData {
  const PodcastBulletinModeData({
    required this.hostVoiceId,
  });

  factory PodcastBulletinModeData.fromJson(Map<String, dynamic> json) =>
      _$PodcastBulletinModeDataFromJson(json);

  static const toJsonFactory = _$PodcastBulletinModeDataToJson;
  Map<String, dynamic> toJson() => _$PodcastBulletinModeDataToJson(this);

  @JsonKey(name: 'host_voice_id')
  final String hostVoiceId;
  static const fromJsonFactory = _$PodcastBulletinModeDataFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PodcastBulletinModeData &&
            (identical(other.hostVoiceId, hostVoiceId) ||
                const DeepCollectionEquality()
                    .equals(other.hostVoiceId, hostVoiceId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(hostVoiceId) ^ runtimeType.hashCode;
}

extension $PodcastBulletinModeDataExtension on PodcastBulletinModeData {
  PodcastBulletinModeData copyWith({String? hostVoiceId}) {
    return PodcastBulletinModeData(
        hostVoiceId: hostVoiceId ?? this.hostVoiceId);
  }

  PodcastBulletinModeData copyWithWrapped({Wrapped<String>? hostVoiceId}) {
    return PodcastBulletinModeData(
        hostVoiceId:
            (hostVoiceId != null ? hostVoiceId.value : this.hostVoiceId));
  }
}

@JsonSerializable(explicitToJson: true)
class PodcastConversationMode {
  const PodcastConversationMode({
    required this.type,
    required this.conversation,
  });

  factory PodcastConversationMode.fromJson(Map<String, dynamic> json) =>
      _$PodcastConversationModeFromJson(json);

  static const toJsonFactory = _$PodcastConversationModeToJson;
  Map<String, dynamic> toJson() => _$PodcastConversationModeToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'conversation')
  final PodcastConversationModeData conversation;
  static const fromJsonFactory = _$PodcastConversationModeFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PodcastConversationMode &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.conversation, conversation) ||
                const DeepCollectionEquality()
                    .equals(other.conversation, conversation)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(conversation) ^
      runtimeType.hashCode;
}

extension $PodcastConversationModeExtension on PodcastConversationMode {
  PodcastConversationMode copyWith(
      {String? type, PodcastConversationModeData? conversation}) {
    return PodcastConversationMode(
        type: type ?? this.type,
        conversation: conversation ?? this.conversation);
  }

  PodcastConversationMode copyWithWrapped(
      {Wrapped<String>? type,
      Wrapped<PodcastConversationModeData>? conversation}) {
    return PodcastConversationMode(
        type: (type != null ? type.value : this.type),
        conversation:
            (conversation != null ? conversation.value : this.conversation));
  }
}

@JsonSerializable(explicitToJson: true)
class PodcastConversationModeData {
  const PodcastConversationModeData({
    required this.hostVoiceId,
    required this.guestVoiceId,
  });

  factory PodcastConversationModeData.fromJson(Map<String, dynamic> json) =>
      _$PodcastConversationModeDataFromJson(json);

  static const toJsonFactory = _$PodcastConversationModeDataToJson;
  Map<String, dynamic> toJson() => _$PodcastConversationModeDataToJson(this);

  @JsonKey(name: 'host_voice_id')
  final String hostVoiceId;
  @JsonKey(name: 'guest_voice_id')
  final String guestVoiceId;
  static const fromJsonFactory = _$PodcastConversationModeDataFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PodcastConversationModeData &&
            (identical(other.hostVoiceId, hostVoiceId) ||
                const DeepCollectionEquality()
                    .equals(other.hostVoiceId, hostVoiceId)) &&
            (identical(other.guestVoiceId, guestVoiceId) ||
                const DeepCollectionEquality()
                    .equals(other.guestVoiceId, guestVoiceId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(hostVoiceId) ^
      const DeepCollectionEquality().hash(guestVoiceId) ^
      runtimeType.hashCode;
}

extension $PodcastConversationModeDataExtension on PodcastConversationModeData {
  PodcastConversationModeData copyWith(
      {String? hostVoiceId, String? guestVoiceId}) {
    return PodcastConversationModeData(
        hostVoiceId: hostVoiceId ?? this.hostVoiceId,
        guestVoiceId: guestVoiceId ?? this.guestVoiceId);
  }

  PodcastConversationModeData copyWithWrapped(
      {Wrapped<String>? hostVoiceId, Wrapped<String>? guestVoiceId}) {
    return PodcastConversationModeData(
        hostVoiceId:
            (hostVoiceId != null ? hostVoiceId.value : this.hostVoiceId),
        guestVoiceId:
            (guestVoiceId != null ? guestVoiceId.value : this.guestVoiceId));
  }
}

@JsonSerializable(explicitToJson: true)
class PodcastProjectResponseModel {
  const PodcastProjectResponseModel({
    required this.project,
  });

  factory PodcastProjectResponseModel.fromJson(Map<String, dynamic> json) =>
      _$PodcastProjectResponseModelFromJson(json);

  static const toJsonFactory = _$PodcastProjectResponseModelToJson;
  Map<String, dynamic> toJson() => _$PodcastProjectResponseModelToJson(this);

  @JsonKey(name: 'project')
  final ProjectResponseModel project;
  static const fromJsonFactory = _$PodcastProjectResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PodcastProjectResponseModel &&
            (identical(other.project, project) ||
                const DeepCollectionEquality().equals(other.project, project)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(project) ^ runtimeType.hashCode;
}

extension $PodcastProjectResponseModelExtension on PodcastProjectResponseModel {
  PodcastProjectResponseModel copyWith({ProjectResponseModel? project}) {
    return PodcastProjectResponseModel(project: project ?? this.project);
  }

  PodcastProjectResponseModel copyWithWrapped(
      {Wrapped<ProjectResponseModel>? project}) {
    return PodcastProjectResponseModel(
        project: (project != null ? project.value : this.project));
  }
}

@JsonSerializable(explicitToJson: true)
class PodcastTextSource {
  const PodcastTextSource({
    required this.type,
    required this.text,
  });

  factory PodcastTextSource.fromJson(Map<String, dynamic> json) =>
      _$PodcastTextSourceFromJson(json);

  static const toJsonFactory = _$PodcastTextSourceToJson;
  Map<String, dynamic> toJson() => _$PodcastTextSourceToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'text')
  final String text;
  static const fromJsonFactory = _$PodcastTextSourceFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PodcastTextSource &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(text) ^
      runtimeType.hashCode;
}

extension $PodcastTextSourceExtension on PodcastTextSource {
  PodcastTextSource copyWith({String? type, String? text}) {
    return PodcastTextSource(type: type ?? this.type, text: text ?? this.text);
  }

  PodcastTextSource copyWithWrapped(
      {Wrapped<String>? type, Wrapped<String>? text}) {
    return PodcastTextSource(
        type: (type != null ? type.value : this.type),
        text: (text != null ? text.value : this.text));
  }
}

@JsonSerializable(explicitToJson: true)
class PodcastURLSource {
  const PodcastURLSource({
    required this.type,
    required this.url,
  });

  factory PodcastURLSource.fromJson(Map<String, dynamic> json) =>
      _$PodcastURLSourceFromJson(json);

  static const toJsonFactory = _$PodcastURLSourceToJson;
  Map<String, dynamic> toJson() => _$PodcastURLSourceToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'url')
  final String url;
  static const fromJsonFactory = _$PodcastURLSourceFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PodcastURLSource &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(url) ^
      runtimeType.hashCode;
}

extension $PodcastURLSourceExtension on PodcastURLSource {
  PodcastURLSource copyWith({String? type, String? url}) {
    return PodcastURLSource(type: type ?? this.type, url: url ?? this.url);
  }

  PodcastURLSource copyWithWrapped(
      {Wrapped<String>? type, Wrapped<String>? url}) {
    return PodcastURLSource(
        type: (type != null ? type.value : this.type),
        url: (url != null ? url.value : this.url));
  }
}

@JsonSerializable(explicitToJson: true)
class PostAgentAvatarResponseModel {
  const PostAgentAvatarResponseModel({
    required this.agentId,
    this.avatarUrl,
  });

  factory PostAgentAvatarResponseModel.fromJson(Map<String, dynamic> json) =>
      _$PostAgentAvatarResponseModelFromJson(json);

  static const toJsonFactory = _$PostAgentAvatarResponseModelToJson;
  Map<String, dynamic> toJson() => _$PostAgentAvatarResponseModelToJson(this);

  @JsonKey(name: 'agent_id')
  final String agentId;
  @JsonKey(name: 'avatar_url')
  final dynamic avatarUrl;
  static const fromJsonFactory = _$PostAgentAvatarResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PostAgentAvatarResponseModel &&
            (identical(other.agentId, agentId) ||
                const DeepCollectionEquality()
                    .equals(other.agentId, agentId)) &&
            (identical(other.avatarUrl, avatarUrl) ||
                const DeepCollectionEquality()
                    .equals(other.avatarUrl, avatarUrl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(agentId) ^
      const DeepCollectionEquality().hash(avatarUrl) ^
      runtimeType.hashCode;
}

extension $PostAgentAvatarResponseModelExtension
    on PostAgentAvatarResponseModel {
  PostAgentAvatarResponseModel copyWith({String? agentId, dynamic avatarUrl}) {
    return PostAgentAvatarResponseModel(
        agentId: agentId ?? this.agentId,
        avatarUrl: avatarUrl ?? this.avatarUrl);
  }

  PostAgentAvatarResponseModel copyWithWrapped(
      {Wrapped<String>? agentId, Wrapped<dynamic>? avatarUrl}) {
    return PostAgentAvatarResponseModel(
        agentId: (agentId != null ? agentId.value : this.agentId),
        avatarUrl: (avatarUrl != null ? avatarUrl.value : this.avatarUrl));
  }
}

@JsonSerializable(explicitToJson: true)
class PostWorkspaceSecretRequest {
  const PostWorkspaceSecretRequest({
    required this.type,
    required this.name,
    required this.$value,
  });

  factory PostWorkspaceSecretRequest.fromJson(Map<String, dynamic> json) =>
      _$PostWorkspaceSecretRequestFromJson(json);

  static const toJsonFactory = _$PostWorkspaceSecretRequestToJson;
  Map<String, dynamic> toJson() => _$PostWorkspaceSecretRequestToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'value')
  final String $value;
  static const fromJsonFactory = _$PostWorkspaceSecretRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PostWorkspaceSecretRequest &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.$value, $value) ||
                const DeepCollectionEquality().equals(other.$value, $value)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash($value) ^
      runtimeType.hashCode;
}

extension $PostWorkspaceSecretRequestExtension on PostWorkspaceSecretRequest {
  PostWorkspaceSecretRequest copyWith(
      {String? type, String? name, String? $value}) {
    return PostWorkspaceSecretRequest(
        type: type ?? this.type,
        name: name ?? this.name,
        $value: $value ?? this.$value);
  }

  PostWorkspaceSecretRequest copyWithWrapped(
      {Wrapped<String>? type, Wrapped<String>? name, Wrapped<String>? $value}) {
    return PostWorkspaceSecretRequest(
        type: (type != null ? type.value : this.type),
        name: (name != null ? name.value : this.name),
        $value: ($value != null ? $value.value : this.$value));
  }
}

@JsonSerializable(explicitToJson: true)
class PostWorkspaceSecretResponseModel {
  const PostWorkspaceSecretResponseModel({
    required this.type,
    required this.secretId,
    required this.name,
  });

  factory PostWorkspaceSecretResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$PostWorkspaceSecretResponseModelFromJson(json);

  static const toJsonFactory = _$PostWorkspaceSecretResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$PostWorkspaceSecretResponseModelToJson(this);

  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'secret_id')
  final String secretId;
  @JsonKey(name: 'name')
  final String name;
  static const fromJsonFactory = _$PostWorkspaceSecretResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PostWorkspaceSecretResponseModel &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.secretId, secretId) ||
                const DeepCollectionEquality()
                    .equals(other.secretId, secretId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(secretId) ^
      const DeepCollectionEquality().hash(name) ^
      runtimeType.hashCode;
}

extension $PostWorkspaceSecretResponseModelExtension
    on PostWorkspaceSecretResponseModel {
  PostWorkspaceSecretResponseModel copyWith(
      {String? type, String? secretId, String? name}) {
    return PostWorkspaceSecretResponseModel(
        type: type ?? this.type,
        secretId: secretId ?? this.secretId,
        name: name ?? this.name);
  }

  PostWorkspaceSecretResponseModel copyWithWrapped(
      {Wrapped<String>? type,
      Wrapped<String>? secretId,
      Wrapped<String>? name}) {
    return PostWorkspaceSecretResponseModel(
        type: (type != null ? type.value : this.type),
        secretId: (secretId != null ? secretId.value : this.secretId),
        name: (name != null ? name.value : this.name));
  }
}

@JsonSerializable(explicitToJson: true)
class PrivacyConfig {
  const PrivacyConfig({
    this.recordVoice,
    this.retentionDays,
    this.deleteTranscriptAndPii,
    this.deleteAudio,
    this.applyToExistingConversations,
    this.zeroRetentionMode,
  });

  factory PrivacyConfig.fromJson(Map<String, dynamic> json) =>
      _$PrivacyConfigFromJson(json);

  static const toJsonFactory = _$PrivacyConfigToJson;
  Map<String, dynamic> toJson() => _$PrivacyConfigToJson(this);

  @JsonKey(name: 'record_voice', defaultValue: true)
  final bool? recordVoice;
  @JsonKey(name: 'retention_days')
  final int? retentionDays;
  @JsonKey(name: 'delete_transcript_and_pii', defaultValue: false)
  final bool? deleteTranscriptAndPii;
  @JsonKey(name: 'delete_audio', defaultValue: false)
  final bool? deleteAudio;
  @JsonKey(name: 'apply_to_existing_conversations', defaultValue: false)
  final bool? applyToExistingConversations;
  @JsonKey(name: 'zero_retention_mode', defaultValue: false)
  final bool? zeroRetentionMode;
  static const fromJsonFactory = _$PrivacyConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PrivacyConfig &&
            (identical(other.recordVoice, recordVoice) ||
                const DeepCollectionEquality()
                    .equals(other.recordVoice, recordVoice)) &&
            (identical(other.retentionDays, retentionDays) ||
                const DeepCollectionEquality()
                    .equals(other.retentionDays, retentionDays)) &&
            (identical(other.deleteTranscriptAndPii, deleteTranscriptAndPii) ||
                const DeepCollectionEquality().equals(
                    other.deleteTranscriptAndPii, deleteTranscriptAndPii)) &&
            (identical(other.deleteAudio, deleteAudio) ||
                const DeepCollectionEquality()
                    .equals(other.deleteAudio, deleteAudio)) &&
            (identical(other.applyToExistingConversations,
                    applyToExistingConversations) ||
                const DeepCollectionEquality().equals(
                    other.applyToExistingConversations,
                    applyToExistingConversations)) &&
            (identical(other.zeroRetentionMode, zeroRetentionMode) ||
                const DeepCollectionEquality()
                    .equals(other.zeroRetentionMode, zeroRetentionMode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(recordVoice) ^
      const DeepCollectionEquality().hash(retentionDays) ^
      const DeepCollectionEquality().hash(deleteTranscriptAndPii) ^
      const DeepCollectionEquality().hash(deleteAudio) ^
      const DeepCollectionEquality().hash(applyToExistingConversations) ^
      const DeepCollectionEquality().hash(zeroRetentionMode) ^
      runtimeType.hashCode;
}

extension $PrivacyConfigExtension on PrivacyConfig {
  PrivacyConfig copyWith(
      {bool? recordVoice,
      int? retentionDays,
      bool? deleteTranscriptAndPii,
      bool? deleteAudio,
      bool? applyToExistingConversations,
      bool? zeroRetentionMode}) {
    return PrivacyConfig(
        recordVoice: recordVoice ?? this.recordVoice,
        retentionDays: retentionDays ?? this.retentionDays,
        deleteTranscriptAndPii:
            deleteTranscriptAndPii ?? this.deleteTranscriptAndPii,
        deleteAudio: deleteAudio ?? this.deleteAudio,
        applyToExistingConversations:
            applyToExistingConversations ?? this.applyToExistingConversations,
        zeroRetentionMode: zeroRetentionMode ?? this.zeroRetentionMode);
  }

  PrivacyConfig copyWithWrapped(
      {Wrapped<bool?>? recordVoice,
      Wrapped<int?>? retentionDays,
      Wrapped<bool?>? deleteTranscriptAndPii,
      Wrapped<bool?>? deleteAudio,
      Wrapped<bool?>? applyToExistingConversations,
      Wrapped<bool?>? zeroRetentionMode}) {
    return PrivacyConfig(
        recordVoice:
            (recordVoice != null ? recordVoice.value : this.recordVoice),
        retentionDays:
            (retentionDays != null ? retentionDays.value : this.retentionDays),
        deleteTranscriptAndPii: (deleteTranscriptAndPii != null
            ? deleteTranscriptAndPii.value
            : this.deleteTranscriptAndPii),
        deleteAudio:
            (deleteAudio != null ? deleteAudio.value : this.deleteAudio),
        applyToExistingConversations: (applyToExistingConversations != null
            ? applyToExistingConversations.value
            : this.applyToExistingConversations),
        zeroRetentionMode: (zeroRetentionMode != null
            ? zeroRetentionMode.value
            : this.zeroRetentionMode));
  }
}

@JsonSerializable(explicitToJson: true)
class ProjectCreationMetaResponseModel {
  const ProjectCreationMetaResponseModel({
    required this.creationProgress,
    required this.status,
    required this.type,
  });

  factory ProjectCreationMetaResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$ProjectCreationMetaResponseModelFromJson(json);

  static const toJsonFactory = _$ProjectCreationMetaResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$ProjectCreationMetaResponseModelToJson(this);

  @JsonKey(name: 'creation_progress')
  final double creationProgress;
  @JsonKey(
    name: 'status',
    toJson: projectCreationMetaResponseModelStatusToJson,
    fromJson: projectCreationMetaResponseModelStatusFromJson,
  )
  final enums.ProjectCreationMetaResponseModelStatus status;
  @JsonKey(
    name: 'type',
    toJson: projectCreationMetaResponseModelTypeToJson,
    fromJson: projectCreationMetaResponseModelTypeFromJson,
  )
  final enums.ProjectCreationMetaResponseModelType type;
  static const fromJsonFactory = _$ProjectCreationMetaResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ProjectCreationMetaResponseModel &&
            (identical(other.creationProgress, creationProgress) ||
                const DeepCollectionEquality()
                    .equals(other.creationProgress, creationProgress)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(creationProgress) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $ProjectCreationMetaResponseModelExtension
    on ProjectCreationMetaResponseModel {
  ProjectCreationMetaResponseModel copyWith(
      {double? creationProgress,
      enums.ProjectCreationMetaResponseModelStatus? status,
      enums.ProjectCreationMetaResponseModelType? type}) {
    return ProjectCreationMetaResponseModel(
        creationProgress: creationProgress ?? this.creationProgress,
        status: status ?? this.status,
        type: type ?? this.type);
  }

  ProjectCreationMetaResponseModel copyWithWrapped(
      {Wrapped<double>? creationProgress,
      Wrapped<enums.ProjectCreationMetaResponseModelStatus>? status,
      Wrapped<enums.ProjectCreationMetaResponseModelType>? type}) {
    return ProjectCreationMetaResponseModel(
        creationProgress: (creationProgress != null
            ? creationProgress.value
            : this.creationProgress),
        status: (status != null ? status.value : this.status),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class ProjectExtendedResponseModel {
  const ProjectExtendedResponseModel({
    required this.projectId,
    required this.name,
    required this.createDateUnix,
    required this.defaultTitleVoiceId,
    required this.defaultParagraphVoiceId,
    required this.defaultModelId,
    this.lastConversionDateUnix,
    required this.canBeDownloaded,
    this.title,
    this.author,
    this.description,
    this.genres,
    this.coverImageUrl,
    this.targetAudience,
    this.language,
    this.contentType,
    this.originalPublicationDate,
    this.matureContent,
    this.isbnNumber,
    required this.volumeNormalization,
    required this.state,
    required this.accessLevel,
    this.fiction,
    required this.qualityCheckOn,
    required this.qualityCheckOnWhenBulkConvert,
    this.creationMeta,
    this.sourceType,
    this.chaptersEnabled,
    required this.qualityPreset,
    required this.chapters,
    required this.pronunciationDictionaryVersions,
    required this.pronunciationDictionaryLocators,
    required this.applyTextNormalization,
    required this.experimental,
  });

  factory ProjectExtendedResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ProjectExtendedResponseModelFromJson(json);

  static const toJsonFactory = _$ProjectExtendedResponseModelToJson;
  Map<String, dynamic> toJson() => _$ProjectExtendedResponseModelToJson(this);

  @JsonKey(name: 'project_id')
  final String projectId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'create_date_unix')
  final int createDateUnix;
  @JsonKey(name: 'default_title_voice_id')
  final String defaultTitleVoiceId;
  @JsonKey(name: 'default_paragraph_voice_id')
  final String defaultParagraphVoiceId;
  @JsonKey(name: 'default_model_id')
  final String defaultModelId;
  @JsonKey(name: 'last_conversion_date_unix')
  final dynamic lastConversionDateUnix;
  @JsonKey(name: 'can_be_downloaded')
  final bool canBeDownloaded;
  @JsonKey(name: 'title')
  final dynamic title;
  @JsonKey(name: 'author')
  final dynamic author;
  @JsonKey(name: 'description')
  final dynamic description;
  @JsonKey(name: 'genres')
  final dynamic genres;
  @JsonKey(name: 'cover_image_url')
  final dynamic coverImageUrl;
  @JsonKey(name: 'target_audience')
  final dynamic targetAudience;
  @JsonKey(name: 'language')
  final dynamic language;
  @JsonKey(name: 'content_type')
  final dynamic contentType;
  @JsonKey(name: 'original_publication_date')
  final dynamic originalPublicationDate;
  @JsonKey(name: 'mature_content')
  final dynamic matureContent;
  @JsonKey(name: 'isbn_number')
  final dynamic isbnNumber;
  @JsonKey(name: 'volume_normalization')
  final bool volumeNormalization;
  @JsonKey(
    name: 'state',
    toJson: projectExtendedResponseModelStateToJson,
    fromJson: projectExtendedResponseModelStateFromJson,
  )
  final enums.ProjectExtendedResponseModelState state;
  @JsonKey(
    name: 'access_level',
    toJson: projectExtendedResponseModelAccessLevelToJson,
    fromJson: projectExtendedResponseModelAccessLevelFromJson,
  )
  final enums.ProjectExtendedResponseModelAccessLevel accessLevel;
  @JsonKey(name: 'fiction')
  final dynamic fiction;
  @JsonKey(name: 'quality_check_on')
  @deprecated
  final bool qualityCheckOn;
  @JsonKey(name: 'quality_check_on_when_bulk_convert')
  @deprecated
  final bool qualityCheckOnWhenBulkConvert;
  @JsonKey(name: 'creation_meta')
  final dynamic creationMeta;
  @JsonKey(name: 'source_type')
  final dynamic sourceType;
  @JsonKey(name: 'chapters_enabled')
  final dynamic chaptersEnabled;
  @JsonKey(
    name: 'quality_preset',
    toJson: projectExtendedResponseModelQualityPresetToJson,
    fromJson: projectExtendedResponseModelQualityPresetFromJson,
  )
  final enums.ProjectExtendedResponseModelQualityPreset qualityPreset;
  @JsonKey(name: 'chapters', defaultValue: <ChapterResponseModel>[])
  final List<ChapterResponseModel> chapters;
  @JsonKey(
      name: 'pronunciation_dictionary_versions',
      defaultValue: <PronunciationDictionaryVersionResponseModel>[])
  final List<PronunciationDictionaryVersionResponseModel>
      pronunciationDictionaryVersions;
  @JsonKey(
      name: 'pronunciation_dictionary_locators',
      defaultValue: <PronunciationDictionaryLocatorResponseModel>[])
  final List<PronunciationDictionaryLocatorResponseModel>
      pronunciationDictionaryLocators;
  @JsonKey(
    name: 'apply_text_normalization',
    toJson: projectExtendedResponseModelApplyTextNormalizationToJson,
    fromJson: projectExtendedResponseModelApplyTextNormalizationFromJson,
  )
  final enums.ProjectExtendedResponseModelApplyTextNormalization
      applyTextNormalization;
  @JsonKey(name: 'experimental')
  final Object experimental;
  static const fromJsonFactory = _$ProjectExtendedResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ProjectExtendedResponseModel &&
            (identical(other.projectId, projectId) ||
                const DeepCollectionEquality()
                    .equals(other.projectId, projectId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.createDateUnix, createDateUnix) ||
                const DeepCollectionEquality()
                    .equals(other.createDateUnix, createDateUnix)) &&
            (identical(other.defaultTitleVoiceId, defaultTitleVoiceId) ||
                const DeepCollectionEquality()
                    .equals(other.defaultTitleVoiceId, defaultTitleVoiceId)) &&
            (identical(other.defaultParagraphVoiceId, defaultParagraphVoiceId) ||
                const DeepCollectionEquality().equals(
                    other.defaultParagraphVoiceId, defaultParagraphVoiceId)) &&
            (identical(other.defaultModelId, defaultModelId) ||
                const DeepCollectionEquality()
                    .equals(other.defaultModelId, defaultModelId)) &&
            (identical(other.lastConversionDateUnix, lastConversionDateUnix) ||
                const DeepCollectionEquality().equals(
                    other.lastConversionDateUnix, lastConversionDateUnix)) &&
            (identical(other.canBeDownloaded, canBeDownloaded) ||
                const DeepCollectionEquality()
                    .equals(other.canBeDownloaded, canBeDownloaded)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.author, author) ||
                const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.genres, genres) ||
                const DeepCollectionEquality().equals(other.genres, genres)) &&
            (identical(other.coverImageUrl, coverImageUrl) ||
                const DeepCollectionEquality()
                    .equals(other.coverImageUrl, coverImageUrl)) &&
            (identical(other.targetAudience, targetAudience) ||
                const DeepCollectionEquality()
                    .equals(other.targetAudience, targetAudience)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality()
                    .equals(other.contentType, contentType)) &&
            (identical(other.originalPublicationDate, originalPublicationDate) ||
                const DeepCollectionEquality().equals(
                    other.originalPublicationDate, originalPublicationDate)) &&
            (identical(other.matureContent, matureContent) ||
                const DeepCollectionEquality()
                    .equals(other.matureContent, matureContent)) &&
            (identical(other.isbnNumber, isbnNumber) || const DeepCollectionEquality().equals(other.isbnNumber, isbnNumber)) &&
            (identical(other.volumeNormalization, volumeNormalization) || const DeepCollectionEquality().equals(other.volumeNormalization, volumeNormalization)) &&
            (identical(other.state, state) || const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.accessLevel, accessLevel) || const DeepCollectionEquality().equals(other.accessLevel, accessLevel)) &&
            (identical(other.fiction, fiction) || const DeepCollectionEquality().equals(other.fiction, fiction)) &&
            (identical(other.qualityCheckOn, qualityCheckOn) || const DeepCollectionEquality().equals(other.qualityCheckOn, qualityCheckOn)) &&
            (identical(other.qualityCheckOnWhenBulkConvert, qualityCheckOnWhenBulkConvert) || const DeepCollectionEquality().equals(other.qualityCheckOnWhenBulkConvert, qualityCheckOnWhenBulkConvert)) &&
            (identical(other.creationMeta, creationMeta) || const DeepCollectionEquality().equals(other.creationMeta, creationMeta)) &&
            (identical(other.sourceType, sourceType) || const DeepCollectionEquality().equals(other.sourceType, sourceType)) &&
            (identical(other.chaptersEnabled, chaptersEnabled) || const DeepCollectionEquality().equals(other.chaptersEnabled, chaptersEnabled)) &&
            (identical(other.qualityPreset, qualityPreset) || const DeepCollectionEquality().equals(other.qualityPreset, qualityPreset)) &&
            (identical(other.chapters, chapters) || const DeepCollectionEquality().equals(other.chapters, chapters)) &&
            (identical(other.pronunciationDictionaryVersions, pronunciationDictionaryVersions) || const DeepCollectionEquality().equals(other.pronunciationDictionaryVersions, pronunciationDictionaryVersions)) &&
            (identical(other.pronunciationDictionaryLocators, pronunciationDictionaryLocators) || const DeepCollectionEquality().equals(other.pronunciationDictionaryLocators, pronunciationDictionaryLocators)) &&
            (identical(other.applyTextNormalization, applyTextNormalization) || const DeepCollectionEquality().equals(other.applyTextNormalization, applyTextNormalization)) &&
            (identical(other.experimental, experimental) || const DeepCollectionEquality().equals(other.experimental, experimental)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(projectId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(createDateUnix) ^
      const DeepCollectionEquality().hash(defaultTitleVoiceId) ^
      const DeepCollectionEquality().hash(defaultParagraphVoiceId) ^
      const DeepCollectionEquality().hash(defaultModelId) ^
      const DeepCollectionEquality().hash(lastConversionDateUnix) ^
      const DeepCollectionEquality().hash(canBeDownloaded) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(genres) ^
      const DeepCollectionEquality().hash(coverImageUrl) ^
      const DeepCollectionEquality().hash(targetAudience) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(originalPublicationDate) ^
      const DeepCollectionEquality().hash(matureContent) ^
      const DeepCollectionEquality().hash(isbnNumber) ^
      const DeepCollectionEquality().hash(volumeNormalization) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(accessLevel) ^
      const DeepCollectionEquality().hash(fiction) ^
      const DeepCollectionEquality().hash(qualityCheckOn) ^
      const DeepCollectionEquality().hash(qualityCheckOnWhenBulkConvert) ^
      const DeepCollectionEquality().hash(creationMeta) ^
      const DeepCollectionEquality().hash(sourceType) ^
      const DeepCollectionEquality().hash(chaptersEnabled) ^
      const DeepCollectionEquality().hash(qualityPreset) ^
      const DeepCollectionEquality().hash(chapters) ^
      const DeepCollectionEquality().hash(pronunciationDictionaryVersions) ^
      const DeepCollectionEquality().hash(pronunciationDictionaryLocators) ^
      const DeepCollectionEquality().hash(applyTextNormalization) ^
      const DeepCollectionEquality().hash(experimental) ^
      runtimeType.hashCode;
}

extension $ProjectExtendedResponseModelExtension
    on ProjectExtendedResponseModel {
  ProjectExtendedResponseModel copyWith(
      {String? projectId,
      String? name,
      int? createDateUnix,
      String? defaultTitleVoiceId,
      String? defaultParagraphVoiceId,
      String? defaultModelId,
      dynamic lastConversionDateUnix,
      bool? canBeDownloaded,
      dynamic title,
      dynamic author,
      dynamic description,
      dynamic genres,
      dynamic coverImageUrl,
      dynamic targetAudience,
      dynamic language,
      dynamic contentType,
      dynamic originalPublicationDate,
      dynamic matureContent,
      dynamic isbnNumber,
      bool? volumeNormalization,
      enums.ProjectExtendedResponseModelState? state,
      enums.ProjectExtendedResponseModelAccessLevel? accessLevel,
      dynamic fiction,
      bool? qualityCheckOn,
      bool? qualityCheckOnWhenBulkConvert,
      dynamic creationMeta,
      dynamic sourceType,
      dynamic chaptersEnabled,
      enums.ProjectExtendedResponseModelQualityPreset? qualityPreset,
      List<ChapterResponseModel>? chapters,
      List<PronunciationDictionaryVersionResponseModel>?
          pronunciationDictionaryVersions,
      List<PronunciationDictionaryLocatorResponseModel>?
          pronunciationDictionaryLocators,
      enums.ProjectExtendedResponseModelApplyTextNormalization?
          applyTextNormalization,
      Object? experimental}) {
    return ProjectExtendedResponseModel(
        projectId: projectId ?? this.projectId,
        name: name ?? this.name,
        createDateUnix: createDateUnix ?? this.createDateUnix,
        defaultTitleVoiceId: defaultTitleVoiceId ?? this.defaultTitleVoiceId,
        defaultParagraphVoiceId:
            defaultParagraphVoiceId ?? this.defaultParagraphVoiceId,
        defaultModelId: defaultModelId ?? this.defaultModelId,
        lastConversionDateUnix:
            lastConversionDateUnix ?? this.lastConversionDateUnix,
        canBeDownloaded: canBeDownloaded ?? this.canBeDownloaded,
        title: title ?? this.title,
        author: author ?? this.author,
        description: description ?? this.description,
        genres: genres ?? this.genres,
        coverImageUrl: coverImageUrl ?? this.coverImageUrl,
        targetAudience: targetAudience ?? this.targetAudience,
        language: language ?? this.language,
        contentType: contentType ?? this.contentType,
        originalPublicationDate:
            originalPublicationDate ?? this.originalPublicationDate,
        matureContent: matureContent ?? this.matureContent,
        isbnNumber: isbnNumber ?? this.isbnNumber,
        volumeNormalization: volumeNormalization ?? this.volumeNormalization,
        state: state ?? this.state,
        accessLevel: accessLevel ?? this.accessLevel,
        fiction: fiction ?? this.fiction,
        qualityCheckOn: qualityCheckOn ?? this.qualityCheckOn,
        qualityCheckOnWhenBulkConvert:
            qualityCheckOnWhenBulkConvert ?? this.qualityCheckOnWhenBulkConvert,
        creationMeta: creationMeta ?? this.creationMeta,
        sourceType: sourceType ?? this.sourceType,
        chaptersEnabled: chaptersEnabled ?? this.chaptersEnabled,
        qualityPreset: qualityPreset ?? this.qualityPreset,
        chapters: chapters ?? this.chapters,
        pronunciationDictionaryVersions: pronunciationDictionaryVersions ??
            this.pronunciationDictionaryVersions,
        pronunciationDictionaryLocators: pronunciationDictionaryLocators ??
            this.pronunciationDictionaryLocators,
        applyTextNormalization:
            applyTextNormalization ?? this.applyTextNormalization,
        experimental: experimental ?? this.experimental);
  }

  ProjectExtendedResponseModel copyWithWrapped(
      {Wrapped<String>? projectId,
      Wrapped<String>? name,
      Wrapped<int>? createDateUnix,
      Wrapped<String>? defaultTitleVoiceId,
      Wrapped<String>? defaultParagraphVoiceId,
      Wrapped<String>? defaultModelId,
      Wrapped<dynamic>? lastConversionDateUnix,
      Wrapped<bool>? canBeDownloaded,
      Wrapped<dynamic>? title,
      Wrapped<dynamic>? author,
      Wrapped<dynamic>? description,
      Wrapped<dynamic>? genres,
      Wrapped<dynamic>? coverImageUrl,
      Wrapped<dynamic>? targetAudience,
      Wrapped<dynamic>? language,
      Wrapped<dynamic>? contentType,
      Wrapped<dynamic>? originalPublicationDate,
      Wrapped<dynamic>? matureContent,
      Wrapped<dynamic>? isbnNumber,
      Wrapped<bool>? volumeNormalization,
      Wrapped<enums.ProjectExtendedResponseModelState>? state,
      Wrapped<enums.ProjectExtendedResponseModelAccessLevel>? accessLevel,
      Wrapped<dynamic>? fiction,
      Wrapped<bool>? qualityCheckOn,
      Wrapped<bool>? qualityCheckOnWhenBulkConvert,
      Wrapped<dynamic>? creationMeta,
      Wrapped<dynamic>? sourceType,
      Wrapped<dynamic>? chaptersEnabled,
      Wrapped<enums.ProjectExtendedResponseModelQualityPreset>? qualityPreset,
      Wrapped<List<ChapterResponseModel>>? chapters,
      Wrapped<List<PronunciationDictionaryVersionResponseModel>>?
          pronunciationDictionaryVersions,
      Wrapped<List<PronunciationDictionaryLocatorResponseModel>>?
          pronunciationDictionaryLocators,
      Wrapped<enums.ProjectExtendedResponseModelApplyTextNormalization>?
          applyTextNormalization,
      Wrapped<Object>? experimental}) {
    return ProjectExtendedResponseModel(
        projectId: (projectId != null ? projectId.value : this.projectId),
        name: (name != null ? name.value : this.name),
        createDateUnix: (createDateUnix != null
            ? createDateUnix.value
            : this.createDateUnix),
        defaultTitleVoiceId: (defaultTitleVoiceId != null
            ? defaultTitleVoiceId.value
            : this.defaultTitleVoiceId),
        defaultParagraphVoiceId: (defaultParagraphVoiceId != null
            ? defaultParagraphVoiceId.value
            : this.defaultParagraphVoiceId),
        defaultModelId: (defaultModelId != null
            ? defaultModelId.value
            : this.defaultModelId),
        lastConversionDateUnix: (lastConversionDateUnix != null
            ? lastConversionDateUnix.value
            : this.lastConversionDateUnix),
        canBeDownloaded: (canBeDownloaded != null
            ? canBeDownloaded.value
            : this.canBeDownloaded),
        title: (title != null ? title.value : this.title),
        author: (author != null ? author.value : this.author),
        description:
            (description != null ? description.value : this.description),
        genres: (genres != null ? genres.value : this.genres),
        coverImageUrl:
            (coverImageUrl != null ? coverImageUrl.value : this.coverImageUrl),
        targetAudience: (targetAudience != null
            ? targetAudience.value
            : this.targetAudience),
        language: (language != null ? language.value : this.language),
        contentType:
            (contentType != null ? contentType.value : this.contentType),
        originalPublicationDate: (originalPublicationDate != null
            ? originalPublicationDate.value
            : this.originalPublicationDate),
        matureContent:
            (matureContent != null ? matureContent.value : this.matureContent),
        isbnNumber: (isbnNumber != null ? isbnNumber.value : this.isbnNumber),
        volumeNormalization: (volumeNormalization != null
            ? volumeNormalization.value
            : this.volumeNormalization),
        state: (state != null ? state.value : this.state),
        accessLevel:
            (accessLevel != null ? accessLevel.value : this.accessLevel),
        fiction: (fiction != null ? fiction.value : this.fiction),
        qualityCheckOn: (qualityCheckOn != null
            ? qualityCheckOn.value
            : this.qualityCheckOn),
        qualityCheckOnWhenBulkConvert: (qualityCheckOnWhenBulkConvert != null
            ? qualityCheckOnWhenBulkConvert.value
            : this.qualityCheckOnWhenBulkConvert),
        creationMeta:
            (creationMeta != null ? creationMeta.value : this.creationMeta),
        sourceType: (sourceType != null ? sourceType.value : this.sourceType),
        chaptersEnabled: (chaptersEnabled != null
            ? chaptersEnabled.value
            : this.chaptersEnabled),
        qualityPreset:
            (qualityPreset != null ? qualityPreset.value : this.qualityPreset),
        chapters: (chapters != null ? chapters.value : this.chapters),
        pronunciationDictionaryVersions:
            (pronunciationDictionaryVersions != null
                ? pronunciationDictionaryVersions.value
                : this.pronunciationDictionaryVersions),
        pronunciationDictionaryLocators:
            (pronunciationDictionaryLocators != null
                ? pronunciationDictionaryLocators.value
                : this.pronunciationDictionaryLocators),
        applyTextNormalization: (applyTextNormalization != null
            ? applyTextNormalization.value
            : this.applyTextNormalization),
        experimental:
            (experimental != null ? experimental.value : this.experimental));
  }
}

@JsonSerializable(explicitToJson: true)
class ProjectResponseModel {
  const ProjectResponseModel({
    required this.projectId,
    required this.name,
    required this.createDateUnix,
    required this.defaultTitleVoiceId,
    required this.defaultParagraphVoiceId,
    required this.defaultModelId,
    this.lastConversionDateUnix,
    required this.canBeDownloaded,
    this.title,
    this.author,
    this.description,
    this.genres,
    this.coverImageUrl,
    this.targetAudience,
    this.language,
    this.contentType,
    this.originalPublicationDate,
    this.matureContent,
    this.isbnNumber,
    required this.volumeNormalization,
    required this.state,
    required this.accessLevel,
    this.fiction,
    required this.qualityCheckOn,
    required this.qualityCheckOnWhenBulkConvert,
    this.creationMeta,
    this.sourceType,
    this.chaptersEnabled,
  });

  factory ProjectResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ProjectResponseModelFromJson(json);

  static const toJsonFactory = _$ProjectResponseModelToJson;
  Map<String, dynamic> toJson() => _$ProjectResponseModelToJson(this);

  @JsonKey(name: 'project_id')
  final String projectId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'create_date_unix')
  final int createDateUnix;
  @JsonKey(name: 'default_title_voice_id')
  final String defaultTitleVoiceId;
  @JsonKey(name: 'default_paragraph_voice_id')
  final String defaultParagraphVoiceId;
  @JsonKey(name: 'default_model_id')
  final String defaultModelId;
  @JsonKey(name: 'last_conversion_date_unix')
  final dynamic lastConversionDateUnix;
  @JsonKey(name: 'can_be_downloaded')
  final bool canBeDownloaded;
  @JsonKey(name: 'title')
  final dynamic title;
  @JsonKey(name: 'author')
  final dynamic author;
  @JsonKey(name: 'description')
  final dynamic description;
  @JsonKey(name: 'genres')
  final dynamic genres;
  @JsonKey(name: 'cover_image_url')
  final dynamic coverImageUrl;
  @JsonKey(name: 'target_audience')
  final dynamic targetAudience;
  @JsonKey(name: 'language')
  final dynamic language;
  @JsonKey(name: 'content_type')
  final dynamic contentType;
  @JsonKey(name: 'original_publication_date')
  final dynamic originalPublicationDate;
  @JsonKey(name: 'mature_content')
  final dynamic matureContent;
  @JsonKey(name: 'isbn_number')
  final dynamic isbnNumber;
  @JsonKey(name: 'volume_normalization')
  final bool volumeNormalization;
  @JsonKey(
    name: 'state',
    toJson: projectResponseModelStateToJson,
    fromJson: projectResponseModelStateFromJson,
  )
  final enums.ProjectResponseModelState state;
  @JsonKey(
    name: 'access_level',
    toJson: projectResponseModelAccessLevelToJson,
    fromJson: projectResponseModelAccessLevelFromJson,
  )
  final enums.ProjectResponseModelAccessLevel accessLevel;
  @JsonKey(name: 'fiction')
  final dynamic fiction;
  @JsonKey(name: 'quality_check_on')
  @deprecated
  final bool qualityCheckOn;
  @JsonKey(name: 'quality_check_on_when_bulk_convert')
  @deprecated
  final bool qualityCheckOnWhenBulkConvert;
  @JsonKey(name: 'creation_meta')
  final dynamic creationMeta;
  @JsonKey(name: 'source_type')
  final dynamic sourceType;
  @JsonKey(name: 'chapters_enabled')
  final dynamic chaptersEnabled;
  static const fromJsonFactory = _$ProjectResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ProjectResponseModel &&
            (identical(other.projectId, projectId) ||
                const DeepCollectionEquality()
                    .equals(other.projectId, projectId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.createDateUnix, createDateUnix) ||
                const DeepCollectionEquality()
                    .equals(other.createDateUnix, createDateUnix)) &&
            (identical(other.defaultTitleVoiceId, defaultTitleVoiceId) ||
                const DeepCollectionEquality()
                    .equals(other.defaultTitleVoiceId, defaultTitleVoiceId)) &&
            (identical(other.defaultParagraphVoiceId, defaultParagraphVoiceId) ||
                const DeepCollectionEquality().equals(
                    other.defaultParagraphVoiceId, defaultParagraphVoiceId)) &&
            (identical(other.defaultModelId, defaultModelId) ||
                const DeepCollectionEquality()
                    .equals(other.defaultModelId, defaultModelId)) &&
            (identical(other.lastConversionDateUnix, lastConversionDateUnix) ||
                const DeepCollectionEquality().equals(
                    other.lastConversionDateUnix, lastConversionDateUnix)) &&
            (identical(other.canBeDownloaded, canBeDownloaded) ||
                const DeepCollectionEquality()
                    .equals(other.canBeDownloaded, canBeDownloaded)) &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.author, author) ||
                const DeepCollectionEquality().equals(other.author, author)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.genres, genres) ||
                const DeepCollectionEquality().equals(other.genres, genres)) &&
            (identical(other.coverImageUrl, coverImageUrl) ||
                const DeepCollectionEquality()
                    .equals(other.coverImageUrl, coverImageUrl)) &&
            (identical(other.targetAudience, targetAudience) ||
                const DeepCollectionEquality()
                    .equals(other.targetAudience, targetAudience)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality()
                    .equals(other.contentType, contentType)) &&
            (identical(other.originalPublicationDate, originalPublicationDate) ||
                const DeepCollectionEquality().equals(
                    other.originalPublicationDate, originalPublicationDate)) &&
            (identical(other.matureContent, matureContent) ||
                const DeepCollectionEquality()
                    .equals(other.matureContent, matureContent)) &&
            (identical(other.isbnNumber, isbnNumber) || const DeepCollectionEquality().equals(other.isbnNumber, isbnNumber)) &&
            (identical(other.volumeNormalization, volumeNormalization) || const DeepCollectionEquality().equals(other.volumeNormalization, volumeNormalization)) &&
            (identical(other.state, state) || const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.accessLevel, accessLevel) || const DeepCollectionEquality().equals(other.accessLevel, accessLevel)) &&
            (identical(other.fiction, fiction) || const DeepCollectionEquality().equals(other.fiction, fiction)) &&
            (identical(other.qualityCheckOn, qualityCheckOn) || const DeepCollectionEquality().equals(other.qualityCheckOn, qualityCheckOn)) &&
            (identical(other.qualityCheckOnWhenBulkConvert, qualityCheckOnWhenBulkConvert) || const DeepCollectionEquality().equals(other.qualityCheckOnWhenBulkConvert, qualityCheckOnWhenBulkConvert)) &&
            (identical(other.creationMeta, creationMeta) || const DeepCollectionEquality().equals(other.creationMeta, creationMeta)) &&
            (identical(other.sourceType, sourceType) || const DeepCollectionEquality().equals(other.sourceType, sourceType)) &&
            (identical(other.chaptersEnabled, chaptersEnabled) || const DeepCollectionEquality().equals(other.chaptersEnabled, chaptersEnabled)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(projectId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(createDateUnix) ^
      const DeepCollectionEquality().hash(defaultTitleVoiceId) ^
      const DeepCollectionEquality().hash(defaultParagraphVoiceId) ^
      const DeepCollectionEquality().hash(defaultModelId) ^
      const DeepCollectionEquality().hash(lastConversionDateUnix) ^
      const DeepCollectionEquality().hash(canBeDownloaded) ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(author) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(genres) ^
      const DeepCollectionEquality().hash(coverImageUrl) ^
      const DeepCollectionEquality().hash(targetAudience) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(originalPublicationDate) ^
      const DeepCollectionEquality().hash(matureContent) ^
      const DeepCollectionEquality().hash(isbnNumber) ^
      const DeepCollectionEquality().hash(volumeNormalization) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(accessLevel) ^
      const DeepCollectionEquality().hash(fiction) ^
      const DeepCollectionEquality().hash(qualityCheckOn) ^
      const DeepCollectionEquality().hash(qualityCheckOnWhenBulkConvert) ^
      const DeepCollectionEquality().hash(creationMeta) ^
      const DeepCollectionEquality().hash(sourceType) ^
      const DeepCollectionEquality().hash(chaptersEnabled) ^
      runtimeType.hashCode;
}

extension $ProjectResponseModelExtension on ProjectResponseModel {
  ProjectResponseModel copyWith(
      {String? projectId,
      String? name,
      int? createDateUnix,
      String? defaultTitleVoiceId,
      String? defaultParagraphVoiceId,
      String? defaultModelId,
      dynamic lastConversionDateUnix,
      bool? canBeDownloaded,
      dynamic title,
      dynamic author,
      dynamic description,
      dynamic genres,
      dynamic coverImageUrl,
      dynamic targetAudience,
      dynamic language,
      dynamic contentType,
      dynamic originalPublicationDate,
      dynamic matureContent,
      dynamic isbnNumber,
      bool? volumeNormalization,
      enums.ProjectResponseModelState? state,
      enums.ProjectResponseModelAccessLevel? accessLevel,
      dynamic fiction,
      bool? qualityCheckOn,
      bool? qualityCheckOnWhenBulkConvert,
      dynamic creationMeta,
      dynamic sourceType,
      dynamic chaptersEnabled}) {
    return ProjectResponseModel(
        projectId: projectId ?? this.projectId,
        name: name ?? this.name,
        createDateUnix: createDateUnix ?? this.createDateUnix,
        defaultTitleVoiceId: defaultTitleVoiceId ?? this.defaultTitleVoiceId,
        defaultParagraphVoiceId:
            defaultParagraphVoiceId ?? this.defaultParagraphVoiceId,
        defaultModelId: defaultModelId ?? this.defaultModelId,
        lastConversionDateUnix:
            lastConversionDateUnix ?? this.lastConversionDateUnix,
        canBeDownloaded: canBeDownloaded ?? this.canBeDownloaded,
        title: title ?? this.title,
        author: author ?? this.author,
        description: description ?? this.description,
        genres: genres ?? this.genres,
        coverImageUrl: coverImageUrl ?? this.coverImageUrl,
        targetAudience: targetAudience ?? this.targetAudience,
        language: language ?? this.language,
        contentType: contentType ?? this.contentType,
        originalPublicationDate:
            originalPublicationDate ?? this.originalPublicationDate,
        matureContent: matureContent ?? this.matureContent,
        isbnNumber: isbnNumber ?? this.isbnNumber,
        volumeNormalization: volumeNormalization ?? this.volumeNormalization,
        state: state ?? this.state,
        accessLevel: accessLevel ?? this.accessLevel,
        fiction: fiction ?? this.fiction,
        qualityCheckOn: qualityCheckOn ?? this.qualityCheckOn,
        qualityCheckOnWhenBulkConvert:
            qualityCheckOnWhenBulkConvert ?? this.qualityCheckOnWhenBulkConvert,
        creationMeta: creationMeta ?? this.creationMeta,
        sourceType: sourceType ?? this.sourceType,
        chaptersEnabled: chaptersEnabled ?? this.chaptersEnabled);
  }

  ProjectResponseModel copyWithWrapped(
      {Wrapped<String>? projectId,
      Wrapped<String>? name,
      Wrapped<int>? createDateUnix,
      Wrapped<String>? defaultTitleVoiceId,
      Wrapped<String>? defaultParagraphVoiceId,
      Wrapped<String>? defaultModelId,
      Wrapped<dynamic>? lastConversionDateUnix,
      Wrapped<bool>? canBeDownloaded,
      Wrapped<dynamic>? title,
      Wrapped<dynamic>? author,
      Wrapped<dynamic>? description,
      Wrapped<dynamic>? genres,
      Wrapped<dynamic>? coverImageUrl,
      Wrapped<dynamic>? targetAudience,
      Wrapped<dynamic>? language,
      Wrapped<dynamic>? contentType,
      Wrapped<dynamic>? originalPublicationDate,
      Wrapped<dynamic>? matureContent,
      Wrapped<dynamic>? isbnNumber,
      Wrapped<bool>? volumeNormalization,
      Wrapped<enums.ProjectResponseModelState>? state,
      Wrapped<enums.ProjectResponseModelAccessLevel>? accessLevel,
      Wrapped<dynamic>? fiction,
      Wrapped<bool>? qualityCheckOn,
      Wrapped<bool>? qualityCheckOnWhenBulkConvert,
      Wrapped<dynamic>? creationMeta,
      Wrapped<dynamic>? sourceType,
      Wrapped<dynamic>? chaptersEnabled}) {
    return ProjectResponseModel(
        projectId: (projectId != null ? projectId.value : this.projectId),
        name: (name != null ? name.value : this.name),
        createDateUnix: (createDateUnix != null
            ? createDateUnix.value
            : this.createDateUnix),
        defaultTitleVoiceId: (defaultTitleVoiceId != null
            ? defaultTitleVoiceId.value
            : this.defaultTitleVoiceId),
        defaultParagraphVoiceId: (defaultParagraphVoiceId != null
            ? defaultParagraphVoiceId.value
            : this.defaultParagraphVoiceId),
        defaultModelId: (defaultModelId != null
            ? defaultModelId.value
            : this.defaultModelId),
        lastConversionDateUnix: (lastConversionDateUnix != null
            ? lastConversionDateUnix.value
            : this.lastConversionDateUnix),
        canBeDownloaded: (canBeDownloaded != null
            ? canBeDownloaded.value
            : this.canBeDownloaded),
        title: (title != null ? title.value : this.title),
        author: (author != null ? author.value : this.author),
        description:
            (description != null ? description.value : this.description),
        genres: (genres != null ? genres.value : this.genres),
        coverImageUrl:
            (coverImageUrl != null ? coverImageUrl.value : this.coverImageUrl),
        targetAudience: (targetAudience != null
            ? targetAudience.value
            : this.targetAudience),
        language: (language != null ? language.value : this.language),
        contentType:
            (contentType != null ? contentType.value : this.contentType),
        originalPublicationDate: (originalPublicationDate != null
            ? originalPublicationDate.value
            : this.originalPublicationDate),
        matureContent:
            (matureContent != null ? matureContent.value : this.matureContent),
        isbnNumber: (isbnNumber != null ? isbnNumber.value : this.isbnNumber),
        volumeNormalization: (volumeNormalization != null
            ? volumeNormalization.value
            : this.volumeNormalization),
        state: (state != null ? state.value : this.state),
        accessLevel:
            (accessLevel != null ? accessLevel.value : this.accessLevel),
        fiction: (fiction != null ? fiction.value : this.fiction),
        qualityCheckOn: (qualityCheckOn != null
            ? qualityCheckOn.value
            : this.qualityCheckOn),
        qualityCheckOnWhenBulkConvert: (qualityCheckOnWhenBulkConvert != null
            ? qualityCheckOnWhenBulkConvert.value
            : this.qualityCheckOnWhenBulkConvert),
        creationMeta:
            (creationMeta != null ? creationMeta.value : this.creationMeta),
        sourceType: (sourceType != null ? sourceType.value : this.sourceType),
        chaptersEnabled: (chaptersEnabled != null
            ? chaptersEnabled.value
            : this.chaptersEnabled));
  }
}

@JsonSerializable(explicitToJson: true)
class ProjectSnapshotExtendedResponseModel {
  const ProjectSnapshotExtendedResponseModel({
    required this.projectSnapshotId,
    required this.projectId,
    required this.createdAtUnix,
    required this.name,
    this.audioUpload,
    this.zipUpload,
    required this.characterAlignments,
  });

  factory ProjectSnapshotExtendedResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$ProjectSnapshotExtendedResponseModelFromJson(json);

  static const toJsonFactory = _$ProjectSnapshotExtendedResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$ProjectSnapshotExtendedResponseModelToJson(this);

  @JsonKey(name: 'project_snapshot_id')
  final String projectSnapshotId;
  @JsonKey(name: 'project_id')
  final String projectId;
  @JsonKey(name: 'created_at_unix')
  final int createdAtUnix;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'audio_upload')
  final dynamic audioUpload;
  @JsonKey(name: 'zip_upload')
  final dynamic zipUpload;
  @JsonKey(
      name: 'character_alignments', defaultValue: <CharacterAlignmentModel>[])
  final List<CharacterAlignmentModel> characterAlignments;
  static const fromJsonFactory = _$ProjectSnapshotExtendedResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ProjectSnapshotExtendedResponseModel &&
            (identical(other.projectSnapshotId, projectSnapshotId) ||
                const DeepCollectionEquality()
                    .equals(other.projectSnapshotId, projectSnapshotId)) &&
            (identical(other.projectId, projectId) ||
                const DeepCollectionEquality()
                    .equals(other.projectId, projectId)) &&
            (identical(other.createdAtUnix, createdAtUnix) ||
                const DeepCollectionEquality()
                    .equals(other.createdAtUnix, createdAtUnix)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.audioUpload, audioUpload) ||
                const DeepCollectionEquality()
                    .equals(other.audioUpload, audioUpload)) &&
            (identical(other.zipUpload, zipUpload) ||
                const DeepCollectionEquality()
                    .equals(other.zipUpload, zipUpload)) &&
            (identical(other.characterAlignments, characterAlignments) ||
                const DeepCollectionEquality()
                    .equals(other.characterAlignments, characterAlignments)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(projectSnapshotId) ^
      const DeepCollectionEquality().hash(projectId) ^
      const DeepCollectionEquality().hash(createdAtUnix) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(audioUpload) ^
      const DeepCollectionEquality().hash(zipUpload) ^
      const DeepCollectionEquality().hash(characterAlignments) ^
      runtimeType.hashCode;
}

extension $ProjectSnapshotExtendedResponseModelExtension
    on ProjectSnapshotExtendedResponseModel {
  ProjectSnapshotExtendedResponseModel copyWith(
      {String? projectSnapshotId,
      String? projectId,
      int? createdAtUnix,
      String? name,
      dynamic audioUpload,
      dynamic zipUpload,
      List<CharacterAlignmentModel>? characterAlignments}) {
    return ProjectSnapshotExtendedResponseModel(
        projectSnapshotId: projectSnapshotId ?? this.projectSnapshotId,
        projectId: projectId ?? this.projectId,
        createdAtUnix: createdAtUnix ?? this.createdAtUnix,
        name: name ?? this.name,
        audioUpload: audioUpload ?? this.audioUpload,
        zipUpload: zipUpload ?? this.zipUpload,
        characterAlignments: characterAlignments ?? this.characterAlignments);
  }

  ProjectSnapshotExtendedResponseModel copyWithWrapped(
      {Wrapped<String>? projectSnapshotId,
      Wrapped<String>? projectId,
      Wrapped<int>? createdAtUnix,
      Wrapped<String>? name,
      Wrapped<dynamic>? audioUpload,
      Wrapped<dynamic>? zipUpload,
      Wrapped<List<CharacterAlignmentModel>>? characterAlignments}) {
    return ProjectSnapshotExtendedResponseModel(
        projectSnapshotId: (projectSnapshotId != null
            ? projectSnapshotId.value
            : this.projectSnapshotId),
        projectId: (projectId != null ? projectId.value : this.projectId),
        createdAtUnix:
            (createdAtUnix != null ? createdAtUnix.value : this.createdAtUnix),
        name: (name != null ? name.value : this.name),
        audioUpload:
            (audioUpload != null ? audioUpload.value : this.audioUpload),
        zipUpload: (zipUpload != null ? zipUpload.value : this.zipUpload),
        characterAlignments: (characterAlignments != null
            ? characterAlignments.value
            : this.characterAlignments));
  }
}

@JsonSerializable(explicitToJson: true)
class ProjectSnapshotResponseModel {
  const ProjectSnapshotResponseModel({
    required this.projectSnapshotId,
    required this.projectId,
    required this.createdAtUnix,
    required this.name,
    this.audioUpload,
    this.zipUpload,
  });

  factory ProjectSnapshotResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ProjectSnapshotResponseModelFromJson(json);

  static const toJsonFactory = _$ProjectSnapshotResponseModelToJson;
  Map<String, dynamic> toJson() => _$ProjectSnapshotResponseModelToJson(this);

  @JsonKey(name: 'project_snapshot_id')
  final String projectSnapshotId;
  @JsonKey(name: 'project_id')
  final String projectId;
  @JsonKey(name: 'created_at_unix')
  final int createdAtUnix;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'audio_upload')
  final dynamic audioUpload;
  @JsonKey(name: 'zip_upload')
  final dynamic zipUpload;
  static const fromJsonFactory = _$ProjectSnapshotResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ProjectSnapshotResponseModel &&
            (identical(other.projectSnapshotId, projectSnapshotId) ||
                const DeepCollectionEquality()
                    .equals(other.projectSnapshotId, projectSnapshotId)) &&
            (identical(other.projectId, projectId) ||
                const DeepCollectionEquality()
                    .equals(other.projectId, projectId)) &&
            (identical(other.createdAtUnix, createdAtUnix) ||
                const DeepCollectionEquality()
                    .equals(other.createdAtUnix, createdAtUnix)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.audioUpload, audioUpload) ||
                const DeepCollectionEquality()
                    .equals(other.audioUpload, audioUpload)) &&
            (identical(other.zipUpload, zipUpload) ||
                const DeepCollectionEquality()
                    .equals(other.zipUpload, zipUpload)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(projectSnapshotId) ^
      const DeepCollectionEquality().hash(projectId) ^
      const DeepCollectionEquality().hash(createdAtUnix) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(audioUpload) ^
      const DeepCollectionEquality().hash(zipUpload) ^
      runtimeType.hashCode;
}

extension $ProjectSnapshotResponseModelExtension
    on ProjectSnapshotResponseModel {
  ProjectSnapshotResponseModel copyWith(
      {String? projectSnapshotId,
      String? projectId,
      int? createdAtUnix,
      String? name,
      dynamic audioUpload,
      dynamic zipUpload}) {
    return ProjectSnapshotResponseModel(
        projectSnapshotId: projectSnapshotId ?? this.projectSnapshotId,
        projectId: projectId ?? this.projectId,
        createdAtUnix: createdAtUnix ?? this.createdAtUnix,
        name: name ?? this.name,
        audioUpload: audioUpload ?? this.audioUpload,
        zipUpload: zipUpload ?? this.zipUpload);
  }

  ProjectSnapshotResponseModel copyWithWrapped(
      {Wrapped<String>? projectSnapshotId,
      Wrapped<String>? projectId,
      Wrapped<int>? createdAtUnix,
      Wrapped<String>? name,
      Wrapped<dynamic>? audioUpload,
      Wrapped<dynamic>? zipUpload}) {
    return ProjectSnapshotResponseModel(
        projectSnapshotId: (projectSnapshotId != null
            ? projectSnapshotId.value
            : this.projectSnapshotId),
        projectId: (projectId != null ? projectId.value : this.projectId),
        createdAtUnix:
            (createdAtUnix != null ? createdAtUnix.value : this.createdAtUnix),
        name: (name != null ? name.value : this.name),
        audioUpload:
            (audioUpload != null ? audioUpload.value : this.audioUpload),
        zipUpload: (zipUpload != null ? zipUpload.value : this.zipUpload));
  }
}

@JsonSerializable(explicitToJson: true)
class ProjectSnapshotsResponseModel {
  const ProjectSnapshotsResponseModel({
    required this.snapshots,
  });

  factory ProjectSnapshotsResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ProjectSnapshotsResponseModelFromJson(json);

  static const toJsonFactory = _$ProjectSnapshotsResponseModelToJson;
  Map<String, dynamic> toJson() => _$ProjectSnapshotsResponseModelToJson(this);

  @JsonKey(name: 'snapshots', defaultValue: <ProjectSnapshotResponseModel>[])
  final List<ProjectSnapshotResponseModel> snapshots;
  static const fromJsonFactory = _$ProjectSnapshotsResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ProjectSnapshotsResponseModel &&
            (identical(other.snapshots, snapshots) ||
                const DeepCollectionEquality()
                    .equals(other.snapshots, snapshots)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(snapshots) ^ runtimeType.hashCode;
}

extension $ProjectSnapshotsResponseModelExtension
    on ProjectSnapshotsResponseModel {
  ProjectSnapshotsResponseModel copyWith(
      {List<ProjectSnapshotResponseModel>? snapshots}) {
    return ProjectSnapshotsResponseModel(
        snapshots: snapshots ?? this.snapshots);
  }

  ProjectSnapshotsResponseModel copyWithWrapped(
      {Wrapped<List<ProjectSnapshotResponseModel>>? snapshots}) {
    return ProjectSnapshotsResponseModel(
        snapshots: (snapshots != null ? snapshots.value : this.snapshots));
  }
}

@JsonSerializable(explicitToJson: true)
class PromptAgentInput {
  const PromptAgentInput({
    this.prompt,
    this.llm,
    this.temperature,
    this.maxTokens,
    this.tools,
    this.toolIds,
    this.mcpServerIds,
    this.nativeMcpServerIds,
    this.knowledgeBase,
    this.customLlm,
    this.ignoreDefaultPersonality,
    this.rag,
  });

  factory PromptAgentInput.fromJson(Map<String, dynamic> json) =>
      _$PromptAgentInputFromJson(json);

  static const toJsonFactory = _$PromptAgentInputToJson;
  Map<String, dynamic> toJson() => _$PromptAgentInputToJson(this);

  @JsonKey(name: 'prompt')
  final String? prompt;
  @JsonKey(
    name: 'llm',
    toJson: llmNullableToJson,
    fromJson: llmLlmNullableFromJson,
  )
  final enums.Llm? llm;
  static enums.Llm? llmLlmNullableFromJson(Object? value) =>
      llmNullableFromJson(value, enums.Llm.gemini20Flash001);

  @JsonKey(name: 'temperature')
  final double? temperature;
  @JsonKey(name: 'max_tokens')
  final int? maxTokens;
  @JsonKey(name: 'tools', defaultValue: <Object>[])
  final List<Object>? tools;
  @JsonKey(name: 'tool_ids', defaultValue: <String>[])
  final List<String>? toolIds;
  @JsonKey(name: 'mcp_server_ids', defaultValue: <String>[])
  final List<String>? mcpServerIds;
  @JsonKey(name: 'native_mcp_server_ids', defaultValue: <String>[])
  final List<String>? nativeMcpServerIds;
  @JsonKey(name: 'knowledge_base', defaultValue: <KnowledgeBaseLocator>[])
  final List<KnowledgeBaseLocator>? knowledgeBase;
  @JsonKey(name: 'custom_llm')
  final dynamic customLlm;
  @JsonKey(name: 'ignore_default_personality')
  final dynamic ignoreDefaultPersonality;
  @JsonKey(name: 'rag')
  final RagConfig? rag;
  static const fromJsonFactory = _$PromptAgentInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PromptAgentInput &&
            (identical(other.prompt, prompt) ||
                const DeepCollectionEquality().equals(other.prompt, prompt)) &&
            (identical(other.llm, llm) ||
                const DeepCollectionEquality().equals(other.llm, llm)) &&
            (identical(other.temperature, temperature) ||
                const DeepCollectionEquality()
                    .equals(other.temperature, temperature)) &&
            (identical(other.maxTokens, maxTokens) ||
                const DeepCollectionEquality()
                    .equals(other.maxTokens, maxTokens)) &&
            (identical(other.tools, tools) ||
                const DeepCollectionEquality().equals(other.tools, tools)) &&
            (identical(other.toolIds, toolIds) ||
                const DeepCollectionEquality()
                    .equals(other.toolIds, toolIds)) &&
            (identical(other.mcpServerIds, mcpServerIds) ||
                const DeepCollectionEquality()
                    .equals(other.mcpServerIds, mcpServerIds)) &&
            (identical(other.nativeMcpServerIds, nativeMcpServerIds) ||
                const DeepCollectionEquality()
                    .equals(other.nativeMcpServerIds, nativeMcpServerIds)) &&
            (identical(other.knowledgeBase, knowledgeBase) ||
                const DeepCollectionEquality()
                    .equals(other.knowledgeBase, knowledgeBase)) &&
            (identical(other.customLlm, customLlm) ||
                const DeepCollectionEquality()
                    .equals(other.customLlm, customLlm)) &&
            (identical(
                    other.ignoreDefaultPersonality, ignoreDefaultPersonality) ||
                const DeepCollectionEquality().equals(
                    other.ignoreDefaultPersonality,
                    ignoreDefaultPersonality)) &&
            (identical(other.rag, rag) ||
                const DeepCollectionEquality().equals(other.rag, rag)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(prompt) ^
      const DeepCollectionEquality().hash(llm) ^
      const DeepCollectionEquality().hash(temperature) ^
      const DeepCollectionEquality().hash(maxTokens) ^
      const DeepCollectionEquality().hash(tools) ^
      const DeepCollectionEquality().hash(toolIds) ^
      const DeepCollectionEquality().hash(mcpServerIds) ^
      const DeepCollectionEquality().hash(nativeMcpServerIds) ^
      const DeepCollectionEquality().hash(knowledgeBase) ^
      const DeepCollectionEquality().hash(customLlm) ^
      const DeepCollectionEquality().hash(ignoreDefaultPersonality) ^
      const DeepCollectionEquality().hash(rag) ^
      runtimeType.hashCode;
}

extension $PromptAgentInputExtension on PromptAgentInput {
  PromptAgentInput copyWith(
      {String? prompt,
      enums.Llm? llm,
      double? temperature,
      int? maxTokens,
      List<Object>? tools,
      List<String>? toolIds,
      List<String>? mcpServerIds,
      List<String>? nativeMcpServerIds,
      List<KnowledgeBaseLocator>? knowledgeBase,
      dynamic customLlm,
      dynamic ignoreDefaultPersonality,
      RagConfig? rag}) {
    return PromptAgentInput(
        prompt: prompt ?? this.prompt,
        llm: llm ?? this.llm,
        temperature: temperature ?? this.temperature,
        maxTokens: maxTokens ?? this.maxTokens,
        tools: tools ?? this.tools,
        toolIds: toolIds ?? this.toolIds,
        mcpServerIds: mcpServerIds ?? this.mcpServerIds,
        nativeMcpServerIds: nativeMcpServerIds ?? this.nativeMcpServerIds,
        knowledgeBase: knowledgeBase ?? this.knowledgeBase,
        customLlm: customLlm ?? this.customLlm,
        ignoreDefaultPersonality:
            ignoreDefaultPersonality ?? this.ignoreDefaultPersonality,
        rag: rag ?? this.rag);
  }

  PromptAgentInput copyWithWrapped(
      {Wrapped<String?>? prompt,
      Wrapped<enums.Llm?>? llm,
      Wrapped<double?>? temperature,
      Wrapped<int?>? maxTokens,
      Wrapped<List<Object>?>? tools,
      Wrapped<List<String>?>? toolIds,
      Wrapped<List<String>?>? mcpServerIds,
      Wrapped<List<String>?>? nativeMcpServerIds,
      Wrapped<List<KnowledgeBaseLocator>?>? knowledgeBase,
      Wrapped<dynamic>? customLlm,
      Wrapped<dynamic>? ignoreDefaultPersonality,
      Wrapped<RagConfig?>? rag}) {
    return PromptAgentInput(
        prompt: (prompt != null ? prompt.value : this.prompt),
        llm: (llm != null ? llm.value : this.llm),
        temperature:
            (temperature != null ? temperature.value : this.temperature),
        maxTokens: (maxTokens != null ? maxTokens.value : this.maxTokens),
        tools: (tools != null ? tools.value : this.tools),
        toolIds: (toolIds != null ? toolIds.value : this.toolIds),
        mcpServerIds:
            (mcpServerIds != null ? mcpServerIds.value : this.mcpServerIds),
        nativeMcpServerIds: (nativeMcpServerIds != null
            ? nativeMcpServerIds.value
            : this.nativeMcpServerIds),
        knowledgeBase:
            (knowledgeBase != null ? knowledgeBase.value : this.knowledgeBase),
        customLlm: (customLlm != null ? customLlm.value : this.customLlm),
        ignoreDefaultPersonality: (ignoreDefaultPersonality != null
            ? ignoreDefaultPersonality.value
            : this.ignoreDefaultPersonality),
        rag: (rag != null ? rag.value : this.rag));
  }
}

@JsonSerializable(explicitToJson: true)
class PromptAgentOutput {
  const PromptAgentOutput({
    this.prompt,
    this.llm,
    this.temperature,
    this.maxTokens,
    this.tools,
    this.toolIds,
    this.mcpServerIds,
    this.nativeMcpServerIds,
    this.knowledgeBase,
    this.customLlm,
    this.ignoreDefaultPersonality,
    this.rag,
  });

  factory PromptAgentOutput.fromJson(Map<String, dynamic> json) =>
      _$PromptAgentOutputFromJson(json);

  static const toJsonFactory = _$PromptAgentOutputToJson;
  Map<String, dynamic> toJson() => _$PromptAgentOutputToJson(this);

  @JsonKey(name: 'prompt')
  final String? prompt;
  @JsonKey(
    name: 'llm',
    toJson: llmNullableToJson,
    fromJson: llmLlmNullableFromJson,
  )
  final enums.Llm? llm;
  static enums.Llm? llmLlmNullableFromJson(Object? value) =>
      llmNullableFromJson(value, enums.Llm.gemini20Flash001);

  @JsonKey(name: 'temperature')
  final double? temperature;
  @JsonKey(name: 'max_tokens')
  final int? maxTokens;
  @JsonKey(name: 'tools', defaultValue: <Object>[])
  final List<Object>? tools;
  @JsonKey(name: 'tool_ids', defaultValue: <String>[])
  final List<String>? toolIds;
  @JsonKey(name: 'mcp_server_ids', defaultValue: <String>[])
  final List<String>? mcpServerIds;
  @JsonKey(name: 'native_mcp_server_ids', defaultValue: <String>[])
  final List<String>? nativeMcpServerIds;
  @JsonKey(name: 'knowledge_base', defaultValue: <KnowledgeBaseLocator>[])
  final List<KnowledgeBaseLocator>? knowledgeBase;
  @JsonKey(name: 'custom_llm')
  final dynamic customLlm;
  @JsonKey(name: 'ignore_default_personality')
  final dynamic ignoreDefaultPersonality;
  @JsonKey(name: 'rag')
  final RagConfig? rag;
  static const fromJsonFactory = _$PromptAgentOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PromptAgentOutput &&
            (identical(other.prompt, prompt) ||
                const DeepCollectionEquality().equals(other.prompt, prompt)) &&
            (identical(other.llm, llm) ||
                const DeepCollectionEquality().equals(other.llm, llm)) &&
            (identical(other.temperature, temperature) ||
                const DeepCollectionEquality()
                    .equals(other.temperature, temperature)) &&
            (identical(other.maxTokens, maxTokens) ||
                const DeepCollectionEquality()
                    .equals(other.maxTokens, maxTokens)) &&
            (identical(other.tools, tools) ||
                const DeepCollectionEquality().equals(other.tools, tools)) &&
            (identical(other.toolIds, toolIds) ||
                const DeepCollectionEquality()
                    .equals(other.toolIds, toolIds)) &&
            (identical(other.mcpServerIds, mcpServerIds) ||
                const DeepCollectionEquality()
                    .equals(other.mcpServerIds, mcpServerIds)) &&
            (identical(other.nativeMcpServerIds, nativeMcpServerIds) ||
                const DeepCollectionEquality()
                    .equals(other.nativeMcpServerIds, nativeMcpServerIds)) &&
            (identical(other.knowledgeBase, knowledgeBase) ||
                const DeepCollectionEquality()
                    .equals(other.knowledgeBase, knowledgeBase)) &&
            (identical(other.customLlm, customLlm) ||
                const DeepCollectionEquality()
                    .equals(other.customLlm, customLlm)) &&
            (identical(
                    other.ignoreDefaultPersonality, ignoreDefaultPersonality) ||
                const DeepCollectionEquality().equals(
                    other.ignoreDefaultPersonality,
                    ignoreDefaultPersonality)) &&
            (identical(other.rag, rag) ||
                const DeepCollectionEquality().equals(other.rag, rag)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(prompt) ^
      const DeepCollectionEquality().hash(llm) ^
      const DeepCollectionEquality().hash(temperature) ^
      const DeepCollectionEquality().hash(maxTokens) ^
      const DeepCollectionEquality().hash(tools) ^
      const DeepCollectionEquality().hash(toolIds) ^
      const DeepCollectionEquality().hash(mcpServerIds) ^
      const DeepCollectionEquality().hash(nativeMcpServerIds) ^
      const DeepCollectionEquality().hash(knowledgeBase) ^
      const DeepCollectionEquality().hash(customLlm) ^
      const DeepCollectionEquality().hash(ignoreDefaultPersonality) ^
      const DeepCollectionEquality().hash(rag) ^
      runtimeType.hashCode;
}

extension $PromptAgentOutputExtension on PromptAgentOutput {
  PromptAgentOutput copyWith(
      {String? prompt,
      enums.Llm? llm,
      double? temperature,
      int? maxTokens,
      List<Object>? tools,
      List<String>? toolIds,
      List<String>? mcpServerIds,
      List<String>? nativeMcpServerIds,
      List<KnowledgeBaseLocator>? knowledgeBase,
      dynamic customLlm,
      dynamic ignoreDefaultPersonality,
      RagConfig? rag}) {
    return PromptAgentOutput(
        prompt: prompt ?? this.prompt,
        llm: llm ?? this.llm,
        temperature: temperature ?? this.temperature,
        maxTokens: maxTokens ?? this.maxTokens,
        tools: tools ?? this.tools,
        toolIds: toolIds ?? this.toolIds,
        mcpServerIds: mcpServerIds ?? this.mcpServerIds,
        nativeMcpServerIds: nativeMcpServerIds ?? this.nativeMcpServerIds,
        knowledgeBase: knowledgeBase ?? this.knowledgeBase,
        customLlm: customLlm ?? this.customLlm,
        ignoreDefaultPersonality:
            ignoreDefaultPersonality ?? this.ignoreDefaultPersonality,
        rag: rag ?? this.rag);
  }

  PromptAgentOutput copyWithWrapped(
      {Wrapped<String?>? prompt,
      Wrapped<enums.Llm?>? llm,
      Wrapped<double?>? temperature,
      Wrapped<int?>? maxTokens,
      Wrapped<List<Object>?>? tools,
      Wrapped<List<String>?>? toolIds,
      Wrapped<List<String>?>? mcpServerIds,
      Wrapped<List<String>?>? nativeMcpServerIds,
      Wrapped<List<KnowledgeBaseLocator>?>? knowledgeBase,
      Wrapped<dynamic>? customLlm,
      Wrapped<dynamic>? ignoreDefaultPersonality,
      Wrapped<RagConfig?>? rag}) {
    return PromptAgentOutput(
        prompt: (prompt != null ? prompt.value : this.prompt),
        llm: (llm != null ? llm.value : this.llm),
        temperature:
            (temperature != null ? temperature.value : this.temperature),
        maxTokens: (maxTokens != null ? maxTokens.value : this.maxTokens),
        tools: (tools != null ? tools.value : this.tools),
        toolIds: (toolIds != null ? toolIds.value : this.toolIds),
        mcpServerIds:
            (mcpServerIds != null ? mcpServerIds.value : this.mcpServerIds),
        nativeMcpServerIds: (nativeMcpServerIds != null
            ? nativeMcpServerIds.value
            : this.nativeMcpServerIds),
        knowledgeBase:
            (knowledgeBase != null ? knowledgeBase.value : this.knowledgeBase),
        customLlm: (customLlm != null ? customLlm.value : this.customLlm),
        ignoreDefaultPersonality: (ignoreDefaultPersonality != null
            ? ignoreDefaultPersonality.value
            : this.ignoreDefaultPersonality),
        rag: (rag != null ? rag.value : this.rag));
  }
}

@JsonSerializable(explicitToJson: true)
class PromptAgentDBModel {
  const PromptAgentDBModel({
    this.prompt,
    this.llm,
    this.temperature,
    this.maxTokens,
    this.tools,
    this.toolIds,
    this.mcpServerIds,
    this.nativeMcpServerIds,
    this.knowledgeBase,
    this.customLlm,
    this.ignoreDefaultPersonality,
    this.rag,
    this.knowledgeBaseDocumentIds,
  });

  factory PromptAgentDBModel.fromJson(Map<String, dynamic> json) =>
      _$PromptAgentDBModelFromJson(json);

  static const toJsonFactory = _$PromptAgentDBModelToJson;
  Map<String, dynamic> toJson() => _$PromptAgentDBModelToJson(this);

  @JsonKey(name: 'prompt')
  final String? prompt;
  @JsonKey(
    name: 'llm',
    toJson: llmNullableToJson,
    fromJson: llmLlmNullableFromJson,
  )
  final enums.Llm? llm;
  static enums.Llm? llmLlmNullableFromJson(Object? value) =>
      llmNullableFromJson(value, enums.Llm.gemini20Flash001);

  @JsonKey(name: 'temperature')
  final double? temperature;
  @JsonKey(name: 'max_tokens')
  final int? maxTokens;
  @JsonKey(name: 'tools', defaultValue: <Object>[])
  final List<Object>? tools;
  @JsonKey(name: 'tool_ids', defaultValue: <String>[])
  final List<String>? toolIds;
  @JsonKey(name: 'mcp_server_ids', defaultValue: <String>[])
  final List<String>? mcpServerIds;
  @JsonKey(name: 'native_mcp_server_ids', defaultValue: <String>[])
  final List<String>? nativeMcpServerIds;
  @JsonKey(name: 'knowledge_base', defaultValue: <KnowledgeBaseLocator>[])
  final List<KnowledgeBaseLocator>? knowledgeBase;
  @JsonKey(name: 'custom_llm')
  final dynamic customLlm;
  @JsonKey(name: 'ignore_default_personality')
  final dynamic ignoreDefaultPersonality;
  @JsonKey(name: 'rag')
  final RagConfig? rag;
  @JsonKey(name: 'knowledge_base_document_ids', defaultValue: <String>[])
  final List<String>? knowledgeBaseDocumentIds;
  static const fromJsonFactory = _$PromptAgentDBModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PromptAgentDBModel &&
            (identical(other.prompt, prompt) ||
                const DeepCollectionEquality().equals(other.prompt, prompt)) &&
            (identical(other.llm, llm) ||
                const DeepCollectionEquality().equals(other.llm, llm)) &&
            (identical(other.temperature, temperature) ||
                const DeepCollectionEquality()
                    .equals(other.temperature, temperature)) &&
            (identical(other.maxTokens, maxTokens) ||
                const DeepCollectionEquality()
                    .equals(other.maxTokens, maxTokens)) &&
            (identical(other.tools, tools) ||
                const DeepCollectionEquality().equals(other.tools, tools)) &&
            (identical(other.toolIds, toolIds) ||
                const DeepCollectionEquality()
                    .equals(other.toolIds, toolIds)) &&
            (identical(other.mcpServerIds, mcpServerIds) ||
                const DeepCollectionEquality()
                    .equals(other.mcpServerIds, mcpServerIds)) &&
            (identical(other.nativeMcpServerIds, nativeMcpServerIds) ||
                const DeepCollectionEquality()
                    .equals(other.nativeMcpServerIds, nativeMcpServerIds)) &&
            (identical(other.knowledgeBase, knowledgeBase) ||
                const DeepCollectionEquality()
                    .equals(other.knowledgeBase, knowledgeBase)) &&
            (identical(other.customLlm, customLlm) ||
                const DeepCollectionEquality()
                    .equals(other.customLlm, customLlm)) &&
            (identical(
                    other.ignoreDefaultPersonality, ignoreDefaultPersonality) ||
                const DeepCollectionEquality().equals(
                    other.ignoreDefaultPersonality,
                    ignoreDefaultPersonality)) &&
            (identical(other.rag, rag) ||
                const DeepCollectionEquality().equals(other.rag, rag)) &&
            (identical(
                    other.knowledgeBaseDocumentIds, knowledgeBaseDocumentIds) ||
                const DeepCollectionEquality().equals(
                    other.knowledgeBaseDocumentIds, knowledgeBaseDocumentIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(prompt) ^
      const DeepCollectionEquality().hash(llm) ^
      const DeepCollectionEquality().hash(temperature) ^
      const DeepCollectionEquality().hash(maxTokens) ^
      const DeepCollectionEquality().hash(tools) ^
      const DeepCollectionEquality().hash(toolIds) ^
      const DeepCollectionEquality().hash(mcpServerIds) ^
      const DeepCollectionEquality().hash(nativeMcpServerIds) ^
      const DeepCollectionEquality().hash(knowledgeBase) ^
      const DeepCollectionEquality().hash(customLlm) ^
      const DeepCollectionEquality().hash(ignoreDefaultPersonality) ^
      const DeepCollectionEquality().hash(rag) ^
      const DeepCollectionEquality().hash(knowledgeBaseDocumentIds) ^
      runtimeType.hashCode;
}

extension $PromptAgentDBModelExtension on PromptAgentDBModel {
  PromptAgentDBModel copyWith(
      {String? prompt,
      enums.Llm? llm,
      double? temperature,
      int? maxTokens,
      List<Object>? tools,
      List<String>? toolIds,
      List<String>? mcpServerIds,
      List<String>? nativeMcpServerIds,
      List<KnowledgeBaseLocator>? knowledgeBase,
      dynamic customLlm,
      dynamic ignoreDefaultPersonality,
      RagConfig? rag,
      List<String>? knowledgeBaseDocumentIds}) {
    return PromptAgentDBModel(
        prompt: prompt ?? this.prompt,
        llm: llm ?? this.llm,
        temperature: temperature ?? this.temperature,
        maxTokens: maxTokens ?? this.maxTokens,
        tools: tools ?? this.tools,
        toolIds: toolIds ?? this.toolIds,
        mcpServerIds: mcpServerIds ?? this.mcpServerIds,
        nativeMcpServerIds: nativeMcpServerIds ?? this.nativeMcpServerIds,
        knowledgeBase: knowledgeBase ?? this.knowledgeBase,
        customLlm: customLlm ?? this.customLlm,
        ignoreDefaultPersonality:
            ignoreDefaultPersonality ?? this.ignoreDefaultPersonality,
        rag: rag ?? this.rag,
        knowledgeBaseDocumentIds:
            knowledgeBaseDocumentIds ?? this.knowledgeBaseDocumentIds);
  }

  PromptAgentDBModel copyWithWrapped(
      {Wrapped<String?>? prompt,
      Wrapped<enums.Llm?>? llm,
      Wrapped<double?>? temperature,
      Wrapped<int?>? maxTokens,
      Wrapped<List<Object>?>? tools,
      Wrapped<List<String>?>? toolIds,
      Wrapped<List<String>?>? mcpServerIds,
      Wrapped<List<String>?>? nativeMcpServerIds,
      Wrapped<List<KnowledgeBaseLocator>?>? knowledgeBase,
      Wrapped<dynamic>? customLlm,
      Wrapped<dynamic>? ignoreDefaultPersonality,
      Wrapped<RagConfig?>? rag,
      Wrapped<List<String>?>? knowledgeBaseDocumentIds}) {
    return PromptAgentDBModel(
        prompt: (prompt != null ? prompt.value : this.prompt),
        llm: (llm != null ? llm.value : this.llm),
        temperature:
            (temperature != null ? temperature.value : this.temperature),
        maxTokens: (maxTokens != null ? maxTokens.value : this.maxTokens),
        tools: (tools != null ? tools.value : this.tools),
        toolIds: (toolIds != null ? toolIds.value : this.toolIds),
        mcpServerIds:
            (mcpServerIds != null ? mcpServerIds.value : this.mcpServerIds),
        nativeMcpServerIds: (nativeMcpServerIds != null
            ? nativeMcpServerIds.value
            : this.nativeMcpServerIds),
        knowledgeBase:
            (knowledgeBase != null ? knowledgeBase.value : this.knowledgeBase),
        customLlm: (customLlm != null ? customLlm.value : this.customLlm),
        ignoreDefaultPersonality: (ignoreDefaultPersonality != null
            ? ignoreDefaultPersonality.value
            : this.ignoreDefaultPersonality),
        rag: (rag != null ? rag.value : this.rag),
        knowledgeBaseDocumentIds: (knowledgeBaseDocumentIds != null
            ? knowledgeBaseDocumentIds.value
            : this.knowledgeBaseDocumentIds));
  }
}

@JsonSerializable(explicitToJson: true)
class PromptAgentOverride {
  const PromptAgentOverride({
    this.prompt,
  });

  factory PromptAgentOverride.fromJson(Map<String, dynamic> json) =>
      _$PromptAgentOverrideFromJson(json);

  static const toJsonFactory = _$PromptAgentOverrideToJson;
  Map<String, dynamic> toJson() => _$PromptAgentOverrideToJson(this);

  @JsonKey(name: 'prompt')
  final dynamic prompt;
  static const fromJsonFactory = _$PromptAgentOverrideFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PromptAgentOverride &&
            (identical(other.prompt, prompt) ||
                const DeepCollectionEquality().equals(other.prompt, prompt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(prompt) ^ runtimeType.hashCode;
}

extension $PromptAgentOverrideExtension on PromptAgentOverride {
  PromptAgentOverride copyWith({dynamic prompt}) {
    return PromptAgentOverride(prompt: prompt ?? this.prompt);
  }

  PromptAgentOverride copyWithWrapped({Wrapped<dynamic>? prompt}) {
    return PromptAgentOverride(
        prompt: (prompt != null ? prompt.value : this.prompt));
  }
}

@JsonSerializable(explicitToJson: true)
class PromptAgentOverrideConfig {
  const PromptAgentOverrideConfig({
    this.prompt,
  });

  factory PromptAgentOverrideConfig.fromJson(Map<String, dynamic> json) =>
      _$PromptAgentOverrideConfigFromJson(json);

  static const toJsonFactory = _$PromptAgentOverrideConfigToJson;
  Map<String, dynamic> toJson() => _$PromptAgentOverrideConfigToJson(this);

  @JsonKey(name: 'prompt', defaultValue: false)
  final bool? prompt;
  static const fromJsonFactory = _$PromptAgentOverrideConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PromptAgentOverrideConfig &&
            (identical(other.prompt, prompt) ||
                const DeepCollectionEquality().equals(other.prompt, prompt)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(prompt) ^ runtimeType.hashCode;
}

extension $PromptAgentOverrideConfigExtension on PromptAgentOverrideConfig {
  PromptAgentOverrideConfig copyWith({bool? prompt}) {
    return PromptAgentOverrideConfig(prompt: prompt ?? this.prompt);
  }

  PromptAgentOverrideConfig copyWithWrapped({Wrapped<bool?>? prompt}) {
    return PromptAgentOverrideConfig(
        prompt: (prompt != null ? prompt.value : this.prompt));
  }
}

@JsonSerializable(explicitToJson: true)
class PromptEvaluationCriteria {
  const PromptEvaluationCriteria({
    required this.id,
    required this.name,
    this.type,
    required this.conversationGoalPrompt,
    this.useKnowledgeBase,
  });

  factory PromptEvaluationCriteria.fromJson(Map<String, dynamic> json) =>
      _$PromptEvaluationCriteriaFromJson(json);

  static const toJsonFactory = _$PromptEvaluationCriteriaToJson;
  Map<String, dynamic> toJson() => _$PromptEvaluationCriteriaToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'conversation_goal_prompt')
  final String conversationGoalPrompt;
  @JsonKey(name: 'use_knowledge_base', defaultValue: false)
  final bool? useKnowledgeBase;
  static const fromJsonFactory = _$PromptEvaluationCriteriaFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PromptEvaluationCriteria &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.conversationGoalPrompt, conversationGoalPrompt) ||
                const DeepCollectionEquality().equals(
                    other.conversationGoalPrompt, conversationGoalPrompt)) &&
            (identical(other.useKnowledgeBase, useKnowledgeBase) ||
                const DeepCollectionEquality()
                    .equals(other.useKnowledgeBase, useKnowledgeBase)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(conversationGoalPrompt) ^
      const DeepCollectionEquality().hash(useKnowledgeBase) ^
      runtimeType.hashCode;
}

extension $PromptEvaluationCriteriaExtension on PromptEvaluationCriteria {
  PromptEvaluationCriteria copyWith(
      {String? id,
      String? name,
      String? type,
      String? conversationGoalPrompt,
      bool? useKnowledgeBase}) {
    return PromptEvaluationCriteria(
        id: id ?? this.id,
        name: name ?? this.name,
        type: type ?? this.type,
        conversationGoalPrompt:
            conversationGoalPrompt ?? this.conversationGoalPrompt,
        useKnowledgeBase: useKnowledgeBase ?? this.useKnowledgeBase);
  }

  PromptEvaluationCriteria copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? name,
      Wrapped<String?>? type,
      Wrapped<String>? conversationGoalPrompt,
      Wrapped<bool?>? useKnowledgeBase}) {
    return PromptEvaluationCriteria(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        type: (type != null ? type.value : this.type),
        conversationGoalPrompt: (conversationGoalPrompt != null
            ? conversationGoalPrompt.value
            : this.conversationGoalPrompt),
        useKnowledgeBase: (useKnowledgeBase != null
            ? useKnowledgeBase.value
            : this.useKnowledgeBase));
  }
}

@JsonSerializable(explicitToJson: true)
class PronunciationDictionaryAliasRuleRequestModel {
  const PronunciationDictionaryAliasRuleRequestModel({
    required this.stringToReplace,
    required this.type,
    required this.alias,
  });

  factory PronunciationDictionaryAliasRuleRequestModel.fromJson(
          Map<String, dynamic> json) =>
      _$PronunciationDictionaryAliasRuleRequestModelFromJson(json);

  static const toJsonFactory =
      _$PronunciationDictionaryAliasRuleRequestModelToJson;
  Map<String, dynamic> toJson() =>
      _$PronunciationDictionaryAliasRuleRequestModelToJson(this);

  @JsonKey(name: 'string_to_replace')
  final String stringToReplace;
  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'alias')
  final String alias;
  static const fromJsonFactory =
      _$PronunciationDictionaryAliasRuleRequestModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PronunciationDictionaryAliasRuleRequestModel &&
            (identical(other.stringToReplace, stringToReplace) ||
                const DeepCollectionEquality()
                    .equals(other.stringToReplace, stringToReplace)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.alias, alias) ||
                const DeepCollectionEquality().equals(other.alias, alias)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(stringToReplace) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(alias) ^
      runtimeType.hashCode;
}

extension $PronunciationDictionaryAliasRuleRequestModelExtension
    on PronunciationDictionaryAliasRuleRequestModel {
  PronunciationDictionaryAliasRuleRequestModel copyWith(
      {String? stringToReplace, String? type, String? alias}) {
    return PronunciationDictionaryAliasRuleRequestModel(
        stringToReplace: stringToReplace ?? this.stringToReplace,
        type: type ?? this.type,
        alias: alias ?? this.alias);
  }

  PronunciationDictionaryAliasRuleRequestModel copyWithWrapped(
      {Wrapped<String>? stringToReplace,
      Wrapped<String>? type,
      Wrapped<String>? alias}) {
    return PronunciationDictionaryAliasRuleRequestModel(
        stringToReplace: (stringToReplace != null
            ? stringToReplace.value
            : this.stringToReplace),
        type: (type != null ? type.value : this.type),
        alias: (alias != null ? alias.value : this.alias));
  }
}

@JsonSerializable(explicitToJson: true)
class PronunciationDictionaryLocatorResponseModel {
  const PronunciationDictionaryLocatorResponseModel({
    required this.pronunciationDictionaryId,
    required this.versionId,
  });

  factory PronunciationDictionaryLocatorResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$PronunciationDictionaryLocatorResponseModelFromJson(json);

  static const toJsonFactory =
      _$PronunciationDictionaryLocatorResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$PronunciationDictionaryLocatorResponseModelToJson(this);

  @JsonKey(name: 'pronunciation_dictionary_id')
  final String pronunciationDictionaryId;
  @JsonKey(name: 'version_id')
  final dynamic versionId;
  static const fromJsonFactory =
      _$PronunciationDictionaryLocatorResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PronunciationDictionaryLocatorResponseModel &&
            (identical(other.pronunciationDictionaryId,
                    pronunciationDictionaryId) ||
                const DeepCollectionEquality().equals(
                    other.pronunciationDictionaryId,
                    pronunciationDictionaryId)) &&
            (identical(other.versionId, versionId) ||
                const DeepCollectionEquality()
                    .equals(other.versionId, versionId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(pronunciationDictionaryId) ^
      const DeepCollectionEquality().hash(versionId) ^
      runtimeType.hashCode;
}

extension $PronunciationDictionaryLocatorResponseModelExtension
    on PronunciationDictionaryLocatorResponseModel {
  PronunciationDictionaryLocatorResponseModel copyWith(
      {String? pronunciationDictionaryId, dynamic versionId}) {
    return PronunciationDictionaryLocatorResponseModel(
        pronunciationDictionaryId:
            pronunciationDictionaryId ?? this.pronunciationDictionaryId,
        versionId: versionId ?? this.versionId);
  }

  PronunciationDictionaryLocatorResponseModel copyWithWrapped(
      {Wrapped<String>? pronunciationDictionaryId,
      Wrapped<dynamic>? versionId}) {
    return PronunciationDictionaryLocatorResponseModel(
        pronunciationDictionaryId: (pronunciationDictionaryId != null
            ? pronunciationDictionaryId.value
            : this.pronunciationDictionaryId),
        versionId: (versionId != null ? versionId.value : this.versionId));
  }
}

@JsonSerializable(explicitToJson: true)
class PronunciationDictionaryPhonemeRuleRequestModel {
  const PronunciationDictionaryPhonemeRuleRequestModel({
    required this.stringToReplace,
    required this.type,
    required this.phoneme,
    required this.alphabet,
  });

  factory PronunciationDictionaryPhonemeRuleRequestModel.fromJson(
          Map<String, dynamic> json) =>
      _$PronunciationDictionaryPhonemeRuleRequestModelFromJson(json);

  static const toJsonFactory =
      _$PronunciationDictionaryPhonemeRuleRequestModelToJson;
  Map<String, dynamic> toJson() =>
      _$PronunciationDictionaryPhonemeRuleRequestModelToJson(this);

  @JsonKey(name: 'string_to_replace')
  final String stringToReplace;
  @JsonKey(name: 'type')
  final String type;
  @JsonKey(name: 'phoneme')
  final String phoneme;
  @JsonKey(name: 'alphabet')
  final String alphabet;
  static const fromJsonFactory =
      _$PronunciationDictionaryPhonemeRuleRequestModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PronunciationDictionaryPhonemeRuleRequestModel &&
            (identical(other.stringToReplace, stringToReplace) ||
                const DeepCollectionEquality()
                    .equals(other.stringToReplace, stringToReplace)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.phoneme, phoneme) ||
                const DeepCollectionEquality()
                    .equals(other.phoneme, phoneme)) &&
            (identical(other.alphabet, alphabet) ||
                const DeepCollectionEquality()
                    .equals(other.alphabet, alphabet)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(stringToReplace) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(phoneme) ^
      const DeepCollectionEquality().hash(alphabet) ^
      runtimeType.hashCode;
}

extension $PronunciationDictionaryPhonemeRuleRequestModelExtension
    on PronunciationDictionaryPhonemeRuleRequestModel {
  PronunciationDictionaryPhonemeRuleRequestModel copyWith(
      {String? stringToReplace,
      String? type,
      String? phoneme,
      String? alphabet}) {
    return PronunciationDictionaryPhonemeRuleRequestModel(
        stringToReplace: stringToReplace ?? this.stringToReplace,
        type: type ?? this.type,
        phoneme: phoneme ?? this.phoneme,
        alphabet: alphabet ?? this.alphabet);
  }

  PronunciationDictionaryPhonemeRuleRequestModel copyWithWrapped(
      {Wrapped<String>? stringToReplace,
      Wrapped<String>? type,
      Wrapped<String>? phoneme,
      Wrapped<String>? alphabet}) {
    return PronunciationDictionaryPhonemeRuleRequestModel(
        stringToReplace: (stringToReplace != null
            ? stringToReplace.value
            : this.stringToReplace),
        type: (type != null ? type.value : this.type),
        phoneme: (phoneme != null ? phoneme.value : this.phoneme),
        alphabet: (alphabet != null ? alphabet.value : this.alphabet));
  }
}

@JsonSerializable(explicitToJson: true)
class PronunciationDictionaryRulesResponseModel {
  const PronunciationDictionaryRulesResponseModel({
    required this.id,
    required this.versionId,
    required this.versionRulesNum,
  });

  factory PronunciationDictionaryRulesResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$PronunciationDictionaryRulesResponseModelFromJson(json);

  static const toJsonFactory =
      _$PronunciationDictionaryRulesResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$PronunciationDictionaryRulesResponseModelToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'version_id')
  final String versionId;
  @JsonKey(name: 'version_rules_num')
  final int versionRulesNum;
  static const fromJsonFactory =
      _$PronunciationDictionaryRulesResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PronunciationDictionaryRulesResponseModel &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.versionId, versionId) ||
                const DeepCollectionEquality()
                    .equals(other.versionId, versionId)) &&
            (identical(other.versionRulesNum, versionRulesNum) ||
                const DeepCollectionEquality()
                    .equals(other.versionRulesNum, versionRulesNum)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(versionId) ^
      const DeepCollectionEquality().hash(versionRulesNum) ^
      runtimeType.hashCode;
}

extension $PronunciationDictionaryRulesResponseModelExtension
    on PronunciationDictionaryRulesResponseModel {
  PronunciationDictionaryRulesResponseModel copyWith(
      {String? id, String? versionId, int? versionRulesNum}) {
    return PronunciationDictionaryRulesResponseModel(
        id: id ?? this.id,
        versionId: versionId ?? this.versionId,
        versionRulesNum: versionRulesNum ?? this.versionRulesNum);
  }

  PronunciationDictionaryRulesResponseModel copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<String>? versionId,
      Wrapped<int>? versionRulesNum}) {
    return PronunciationDictionaryRulesResponseModel(
        id: (id != null ? id.value : this.id),
        versionId: (versionId != null ? versionId.value : this.versionId),
        versionRulesNum: (versionRulesNum != null
            ? versionRulesNum.value
            : this.versionRulesNum));
  }
}

@JsonSerializable(explicitToJson: true)
class PronunciationDictionaryVersionLocatorDBModel {
  const PronunciationDictionaryVersionLocatorDBModel({
    required this.pronunciationDictionaryId,
    required this.versionId,
  });

  factory PronunciationDictionaryVersionLocatorDBModel.fromJson(
          Map<String, dynamic> json) =>
      _$PronunciationDictionaryVersionLocatorDBModelFromJson(json);

  static const toJsonFactory =
      _$PronunciationDictionaryVersionLocatorDBModelToJson;
  Map<String, dynamic> toJson() =>
      _$PronunciationDictionaryVersionLocatorDBModelToJson(this);

  @JsonKey(name: 'pronunciation_dictionary_id')
  final String pronunciationDictionaryId;
  @JsonKey(name: 'version_id')
  final dynamic versionId;
  static const fromJsonFactory =
      _$PronunciationDictionaryVersionLocatorDBModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PronunciationDictionaryVersionLocatorDBModel &&
            (identical(other.pronunciationDictionaryId,
                    pronunciationDictionaryId) ||
                const DeepCollectionEquality().equals(
                    other.pronunciationDictionaryId,
                    pronunciationDictionaryId)) &&
            (identical(other.versionId, versionId) ||
                const DeepCollectionEquality()
                    .equals(other.versionId, versionId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(pronunciationDictionaryId) ^
      const DeepCollectionEquality().hash(versionId) ^
      runtimeType.hashCode;
}

extension $PronunciationDictionaryVersionLocatorDBModelExtension
    on PronunciationDictionaryVersionLocatorDBModel {
  PronunciationDictionaryVersionLocatorDBModel copyWith(
      {String? pronunciationDictionaryId, dynamic versionId}) {
    return PronunciationDictionaryVersionLocatorDBModel(
        pronunciationDictionaryId:
            pronunciationDictionaryId ?? this.pronunciationDictionaryId,
        versionId: versionId ?? this.versionId);
  }

  PronunciationDictionaryVersionLocatorDBModel copyWithWrapped(
      {Wrapped<String>? pronunciationDictionaryId,
      Wrapped<dynamic>? versionId}) {
    return PronunciationDictionaryVersionLocatorDBModel(
        pronunciationDictionaryId: (pronunciationDictionaryId != null
            ? pronunciationDictionaryId.value
            : this.pronunciationDictionaryId),
        versionId: (versionId != null ? versionId.value : this.versionId));
  }
}

@JsonSerializable(explicitToJson: true)
class PronunciationDictionaryVersionLocatorRequestModel {
  const PronunciationDictionaryVersionLocatorRequestModel({
    required this.pronunciationDictionaryId,
    this.versionId,
  });

  factory PronunciationDictionaryVersionLocatorRequestModel.fromJson(
          Map<String, dynamic> json) =>
      _$PronunciationDictionaryVersionLocatorRequestModelFromJson(json);

  static const toJsonFactory =
      _$PronunciationDictionaryVersionLocatorRequestModelToJson;
  Map<String, dynamic> toJson() =>
      _$PronunciationDictionaryVersionLocatorRequestModelToJson(this);

  @JsonKey(name: 'pronunciation_dictionary_id')
  final String pronunciationDictionaryId;
  @JsonKey(name: 'version_id')
  final dynamic versionId;
  static const fromJsonFactory =
      _$PronunciationDictionaryVersionLocatorRequestModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PronunciationDictionaryVersionLocatorRequestModel &&
            (identical(other.pronunciationDictionaryId,
                    pronunciationDictionaryId) ||
                const DeepCollectionEquality().equals(
                    other.pronunciationDictionaryId,
                    pronunciationDictionaryId)) &&
            (identical(other.versionId, versionId) ||
                const DeepCollectionEquality()
                    .equals(other.versionId, versionId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(pronunciationDictionaryId) ^
      const DeepCollectionEquality().hash(versionId) ^
      runtimeType.hashCode;
}

extension $PronunciationDictionaryVersionLocatorRequestModelExtension
    on PronunciationDictionaryVersionLocatorRequestModel {
  PronunciationDictionaryVersionLocatorRequestModel copyWith(
      {String? pronunciationDictionaryId, dynamic versionId}) {
    return PronunciationDictionaryVersionLocatorRequestModel(
        pronunciationDictionaryId:
            pronunciationDictionaryId ?? this.pronunciationDictionaryId,
        versionId: versionId ?? this.versionId);
  }

  PronunciationDictionaryVersionLocatorRequestModel copyWithWrapped(
      {Wrapped<String>? pronunciationDictionaryId,
      Wrapped<dynamic>? versionId}) {
    return PronunciationDictionaryVersionLocatorRequestModel(
        pronunciationDictionaryId: (pronunciationDictionaryId != null
            ? pronunciationDictionaryId.value
            : this.pronunciationDictionaryId),
        versionId: (versionId != null ? versionId.value : this.versionId));
  }
}

@JsonSerializable(explicitToJson: true)
class PronunciationDictionaryVersionResponseModel {
  const PronunciationDictionaryVersionResponseModel({
    required this.versionId,
    required this.versionRulesNum,
    required this.pronunciationDictionaryId,
    required this.dictionaryName,
    required this.versionName,
    required this.permissionOnResource,
    required this.createdBy,
    required this.creationTimeUnix,
    this.archivedTimeUnix,
  });

  factory PronunciationDictionaryVersionResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$PronunciationDictionaryVersionResponseModelFromJson(json);

  static const toJsonFactory =
      _$PronunciationDictionaryVersionResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$PronunciationDictionaryVersionResponseModelToJson(this);

  @JsonKey(name: 'version_id')
  final String versionId;
  @JsonKey(name: 'version_rules_num')
  final int versionRulesNum;
  @JsonKey(name: 'pronunciation_dictionary_id')
  final String pronunciationDictionaryId;
  @JsonKey(name: 'dictionary_name')
  final String dictionaryName;
  @JsonKey(name: 'version_name')
  final String versionName;
  @JsonKey(name: 'permission_on_resource')
  final dynamic permissionOnResource;
  @JsonKey(name: 'created_by')
  final String createdBy;
  @JsonKey(name: 'creation_time_unix')
  final int creationTimeUnix;
  @JsonKey(name: 'archived_time_unix')
  final dynamic archivedTimeUnix;
  static const fromJsonFactory =
      _$PronunciationDictionaryVersionResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PronunciationDictionaryVersionResponseModel &&
            (identical(other.versionId, versionId) ||
                const DeepCollectionEquality()
                    .equals(other.versionId, versionId)) &&
            (identical(other.versionRulesNum, versionRulesNum) ||
                const DeepCollectionEquality()
                    .equals(other.versionRulesNum, versionRulesNum)) &&
            (identical(other.pronunciationDictionaryId,
                    pronunciationDictionaryId) ||
                const DeepCollectionEquality().equals(
                    other.pronunciationDictionaryId,
                    pronunciationDictionaryId)) &&
            (identical(other.dictionaryName, dictionaryName) ||
                const DeepCollectionEquality()
                    .equals(other.dictionaryName, dictionaryName)) &&
            (identical(other.versionName, versionName) ||
                const DeepCollectionEquality()
                    .equals(other.versionName, versionName)) &&
            (identical(other.permissionOnResource, permissionOnResource) ||
                const DeepCollectionEquality().equals(
                    other.permissionOnResource, permissionOnResource)) &&
            (identical(other.createdBy, createdBy) ||
                const DeepCollectionEquality()
                    .equals(other.createdBy, createdBy)) &&
            (identical(other.creationTimeUnix, creationTimeUnix) ||
                const DeepCollectionEquality()
                    .equals(other.creationTimeUnix, creationTimeUnix)) &&
            (identical(other.archivedTimeUnix, archivedTimeUnix) ||
                const DeepCollectionEquality()
                    .equals(other.archivedTimeUnix, archivedTimeUnix)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(versionId) ^
      const DeepCollectionEquality().hash(versionRulesNum) ^
      const DeepCollectionEquality().hash(pronunciationDictionaryId) ^
      const DeepCollectionEquality().hash(dictionaryName) ^
      const DeepCollectionEquality().hash(versionName) ^
      const DeepCollectionEquality().hash(permissionOnResource) ^
      const DeepCollectionEquality().hash(createdBy) ^
      const DeepCollectionEquality().hash(creationTimeUnix) ^
      const DeepCollectionEquality().hash(archivedTimeUnix) ^
      runtimeType.hashCode;
}

extension $PronunciationDictionaryVersionResponseModelExtension
    on PronunciationDictionaryVersionResponseModel {
  PronunciationDictionaryVersionResponseModel copyWith(
      {String? versionId,
      int? versionRulesNum,
      String? pronunciationDictionaryId,
      String? dictionaryName,
      String? versionName,
      dynamic permissionOnResource,
      String? createdBy,
      int? creationTimeUnix,
      dynamic archivedTimeUnix}) {
    return PronunciationDictionaryVersionResponseModel(
        versionId: versionId ?? this.versionId,
        versionRulesNum: versionRulesNum ?? this.versionRulesNum,
        pronunciationDictionaryId:
            pronunciationDictionaryId ?? this.pronunciationDictionaryId,
        dictionaryName: dictionaryName ?? this.dictionaryName,
        versionName: versionName ?? this.versionName,
        permissionOnResource: permissionOnResource ?? this.permissionOnResource,
        createdBy: createdBy ?? this.createdBy,
        creationTimeUnix: creationTimeUnix ?? this.creationTimeUnix,
        archivedTimeUnix: archivedTimeUnix ?? this.archivedTimeUnix);
  }

  PronunciationDictionaryVersionResponseModel copyWithWrapped(
      {Wrapped<String>? versionId,
      Wrapped<int>? versionRulesNum,
      Wrapped<String>? pronunciationDictionaryId,
      Wrapped<String>? dictionaryName,
      Wrapped<String>? versionName,
      Wrapped<dynamic>? permissionOnResource,
      Wrapped<String>? createdBy,
      Wrapped<int>? creationTimeUnix,
      Wrapped<dynamic>? archivedTimeUnix}) {
    return PronunciationDictionaryVersionResponseModel(
        versionId: (versionId != null ? versionId.value : this.versionId),
        versionRulesNum: (versionRulesNum != null
            ? versionRulesNum.value
            : this.versionRulesNum),
        pronunciationDictionaryId: (pronunciationDictionaryId != null
            ? pronunciationDictionaryId.value
            : this.pronunciationDictionaryId),
        dictionaryName: (dictionaryName != null
            ? dictionaryName.value
            : this.dictionaryName),
        versionName:
            (versionName != null ? versionName.value : this.versionName),
        permissionOnResource: (permissionOnResource != null
            ? permissionOnResource.value
            : this.permissionOnResource),
        createdBy: (createdBy != null ? createdBy.value : this.createdBy),
        creationTimeUnix: (creationTimeUnix != null
            ? creationTimeUnix.value
            : this.creationTimeUnix),
        archivedTimeUnix: (archivedTimeUnix != null
            ? archivedTimeUnix.value
            : this.archivedTimeUnix));
  }
}

@JsonSerializable(explicitToJson: true)
class PydanticPronunciationDictionaryVersionLocator {
  const PydanticPronunciationDictionaryVersionLocator({
    required this.pronunciationDictionaryId,
    required this.versionId,
  });

  factory PydanticPronunciationDictionaryVersionLocator.fromJson(
          Map<String, dynamic> json) =>
      _$PydanticPronunciationDictionaryVersionLocatorFromJson(json);

  static const toJsonFactory =
      _$PydanticPronunciationDictionaryVersionLocatorToJson;
  Map<String, dynamic> toJson() =>
      _$PydanticPronunciationDictionaryVersionLocatorToJson(this);

  @JsonKey(name: 'pronunciation_dictionary_id')
  final String pronunciationDictionaryId;
  @JsonKey(name: 'version_id')
  final dynamic versionId;
  static const fromJsonFactory =
      _$PydanticPronunciationDictionaryVersionLocatorFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is PydanticPronunciationDictionaryVersionLocator &&
            (identical(other.pronunciationDictionaryId,
                    pronunciationDictionaryId) ||
                const DeepCollectionEquality().equals(
                    other.pronunciationDictionaryId,
                    pronunciationDictionaryId)) &&
            (identical(other.versionId, versionId) ||
                const DeepCollectionEquality()
                    .equals(other.versionId, versionId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(pronunciationDictionaryId) ^
      const DeepCollectionEquality().hash(versionId) ^
      runtimeType.hashCode;
}

extension $PydanticPronunciationDictionaryVersionLocatorExtension
    on PydanticPronunciationDictionaryVersionLocator {
  PydanticPronunciationDictionaryVersionLocator copyWith(
      {String? pronunciationDictionaryId, dynamic versionId}) {
    return PydanticPronunciationDictionaryVersionLocator(
        pronunciationDictionaryId:
            pronunciationDictionaryId ?? this.pronunciationDictionaryId,
        versionId: versionId ?? this.versionId);
  }

  PydanticPronunciationDictionaryVersionLocator copyWithWrapped(
      {Wrapped<String>? pronunciationDictionaryId,
      Wrapped<dynamic>? versionId}) {
    return PydanticPronunciationDictionaryVersionLocator(
        pronunciationDictionaryId: (pronunciationDictionaryId != null
            ? pronunciationDictionaryId.value
            : this.pronunciationDictionaryId),
        versionId: (versionId != null ? versionId.value : this.versionId));
  }
}

@JsonSerializable(explicitToJson: true)
class QueryParamsJsonSchema {
  const QueryParamsJsonSchema({
    required this.properties,
    this.required,
  });

  factory QueryParamsJsonSchema.fromJson(Map<String, dynamic> json) =>
      _$QueryParamsJsonSchemaFromJson(json);

  static const toJsonFactory = _$QueryParamsJsonSchemaToJson;
  Map<String, dynamic> toJson() => _$QueryParamsJsonSchemaToJson(this);

  @JsonKey(name: 'properties')
  final Map<String, dynamic> properties;
  @JsonKey(name: 'required', defaultValue: <String>[])
  final List<String>? required;
  static const fromJsonFactory = _$QueryParamsJsonSchemaFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is QueryParamsJsonSchema &&
            (identical(other.properties, properties) ||
                const DeepCollectionEquality()
                    .equals(other.properties, properties)) &&
            (identical(other.required, required) ||
                const DeepCollectionEquality()
                    .equals(other.required, required)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(properties) ^
      const DeepCollectionEquality().hash(required) ^
      runtimeType.hashCode;
}

extension $QueryParamsJsonSchemaExtension on QueryParamsJsonSchema {
  QueryParamsJsonSchema copyWith(
      {Map<String, dynamic>? properties, List<String>? required}) {
    return QueryParamsJsonSchema(
        properties: properties ?? this.properties,
        required: required ?? this.required);
  }

  QueryParamsJsonSchema copyWithWrapped(
      {Wrapped<Map<String, dynamic>>? properties,
      Wrapped<List<String>?>? required}) {
    return QueryParamsJsonSchema(
        properties: (properties != null ? properties.value : this.properties),
        required: (required != null ? required.value : this.required));
  }
}

@JsonSerializable(explicitToJson: true)
class RAGIndexRequestModel {
  const RAGIndexRequestModel({
    required this.model,
  });

  factory RAGIndexRequestModel.fromJson(Map<String, dynamic> json) =>
      _$RAGIndexRequestModelFromJson(json);

  static const toJsonFactory = _$RAGIndexRequestModelToJson;
  Map<String, dynamic> toJson() => _$RAGIndexRequestModelToJson(this);

  @JsonKey(
    name: 'model',
    toJson: embeddingModelEnumToJson,
    fromJson: embeddingModelEnumFromJson,
  )
  final enums.EmbeddingModelEnum model;
  static const fromJsonFactory = _$RAGIndexRequestModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RAGIndexRequestModel &&
            (identical(other.model, model) ||
                const DeepCollectionEquality().equals(other.model, model)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(model) ^ runtimeType.hashCode;
}

extension $RAGIndexRequestModelExtension on RAGIndexRequestModel {
  RAGIndexRequestModel copyWith({enums.EmbeddingModelEnum? model}) {
    return RAGIndexRequestModel(model: model ?? this.model);
  }

  RAGIndexRequestModel copyWithWrapped(
      {Wrapped<enums.EmbeddingModelEnum>? model}) {
    return RAGIndexRequestModel(
        model: (model != null ? model.value : this.model));
  }
}

@JsonSerializable(explicitToJson: true)
class RAGIndexResponseModel {
  const RAGIndexResponseModel({
    required this.status,
    required this.progressPercentage,
  });

  factory RAGIndexResponseModel.fromJson(Map<String, dynamic> json) =>
      _$RAGIndexResponseModelFromJson(json);

  static const toJsonFactory = _$RAGIndexResponseModelToJson;
  Map<String, dynamic> toJson() => _$RAGIndexResponseModelToJson(this);

  @JsonKey(
    name: 'status',
    toJson: rAGIndexStatusToJson,
    fromJson: rAGIndexStatusFromJson,
  )
  final enums.RAGIndexStatus status;
  @JsonKey(name: 'progress_percentage')
  final double progressPercentage;
  static const fromJsonFactory = _$RAGIndexResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RAGIndexResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.progressPercentage, progressPercentage) ||
                const DeepCollectionEquality()
                    .equals(other.progressPercentage, progressPercentage)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(progressPercentage) ^
      runtimeType.hashCode;
}

extension $RAGIndexResponseModelExtension on RAGIndexResponseModel {
  RAGIndexResponseModel copyWith(
      {enums.RAGIndexStatus? status, double? progressPercentage}) {
    return RAGIndexResponseModel(
        status: status ?? this.status,
        progressPercentage: progressPercentage ?? this.progressPercentage);
  }

  RAGIndexResponseModel copyWithWrapped(
      {Wrapped<enums.RAGIndexStatus>? status,
      Wrapped<double>? progressPercentage}) {
    return RAGIndexResponseModel(
        status: (status != null ? status.value : this.status),
        progressPercentage: (progressPercentage != null
            ? progressPercentage.value
            : this.progressPercentage));
  }
}

@JsonSerializable(explicitToJson: true)
class RagChunkMetadata {
  const RagChunkMetadata({
    required this.documentId,
    required this.chunkId,
    required this.vectorDistance,
  });

  factory RagChunkMetadata.fromJson(Map<String, dynamic> json) =>
      _$RagChunkMetadataFromJson(json);

  static const toJsonFactory = _$RagChunkMetadataToJson;
  Map<String, dynamic> toJson() => _$RagChunkMetadataToJson(this);

  @JsonKey(name: 'document_id')
  final String documentId;
  @JsonKey(name: 'chunk_id')
  final String chunkId;
  @JsonKey(name: 'vector_distance')
  final double vectorDistance;
  static const fromJsonFactory = _$RagChunkMetadataFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RagChunkMetadata &&
            (identical(other.documentId, documentId) ||
                const DeepCollectionEquality()
                    .equals(other.documentId, documentId)) &&
            (identical(other.chunkId, chunkId) ||
                const DeepCollectionEquality()
                    .equals(other.chunkId, chunkId)) &&
            (identical(other.vectorDistance, vectorDistance) ||
                const DeepCollectionEquality()
                    .equals(other.vectorDistance, vectorDistance)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(documentId) ^
      const DeepCollectionEquality().hash(chunkId) ^
      const DeepCollectionEquality().hash(vectorDistance) ^
      runtimeType.hashCode;
}

extension $RagChunkMetadataExtension on RagChunkMetadata {
  RagChunkMetadata copyWith(
      {String? documentId, String? chunkId, double? vectorDistance}) {
    return RagChunkMetadata(
        documentId: documentId ?? this.documentId,
        chunkId: chunkId ?? this.chunkId,
        vectorDistance: vectorDistance ?? this.vectorDistance);
  }

  RagChunkMetadata copyWithWrapped(
      {Wrapped<String>? documentId,
      Wrapped<String>? chunkId,
      Wrapped<double>? vectorDistance}) {
    return RagChunkMetadata(
        documentId: (documentId != null ? documentId.value : this.documentId),
        chunkId: (chunkId != null ? chunkId.value : this.chunkId),
        vectorDistance: (vectorDistance != null
            ? vectorDistance.value
            : this.vectorDistance));
  }
}

@JsonSerializable(explicitToJson: true)
class RagConfig {
  const RagConfig({
    this.enabled,
    this.embeddingModel,
    this.maxVectorDistance,
    this.maxDocumentsLength,
    this.maxRetrievedRagChunksCount,
  });

  factory RagConfig.fromJson(Map<String, dynamic> json) =>
      _$RagConfigFromJson(json);

  static const toJsonFactory = _$RagConfigToJson;
  Map<String, dynamic> toJson() => _$RagConfigToJson(this);

  @JsonKey(name: 'enabled', defaultValue: false)
  final bool? enabled;
  @JsonKey(
    name: 'embedding_model',
    toJson: embeddingModelEnumNullableToJson,
    fromJson: embeddingModelEnumEmbeddingModelNullableFromJson,
  )
  final enums.EmbeddingModelEnum? embeddingModel;
  static enums.EmbeddingModelEnum?
      embeddingModelEnumEmbeddingModelNullableFromJson(Object? value) =>
          embeddingModelEnumNullableFromJson(
              value, enums.EmbeddingModelEnum.e5Mistral7bInstruct);

  @JsonKey(name: 'max_vector_distance')
  final double? maxVectorDistance;
  @JsonKey(name: 'max_documents_length')
  final int? maxDocumentsLength;
  @JsonKey(name: 'max_retrieved_rag_chunks_count')
  final int? maxRetrievedRagChunksCount;
  static const fromJsonFactory = _$RagConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RagConfig &&
            (identical(other.enabled, enabled) ||
                const DeepCollectionEquality()
                    .equals(other.enabled, enabled)) &&
            (identical(other.embeddingModel, embeddingModel) ||
                const DeepCollectionEquality()
                    .equals(other.embeddingModel, embeddingModel)) &&
            (identical(other.maxVectorDistance, maxVectorDistance) ||
                const DeepCollectionEquality()
                    .equals(other.maxVectorDistance, maxVectorDistance)) &&
            (identical(other.maxDocumentsLength, maxDocumentsLength) ||
                const DeepCollectionEquality()
                    .equals(other.maxDocumentsLength, maxDocumentsLength)) &&
            (identical(other.maxRetrievedRagChunksCount,
                    maxRetrievedRagChunksCount) ||
                const DeepCollectionEquality().equals(
                    other.maxRetrievedRagChunksCount,
                    maxRetrievedRagChunksCount)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(enabled) ^
      const DeepCollectionEquality().hash(embeddingModel) ^
      const DeepCollectionEquality().hash(maxVectorDistance) ^
      const DeepCollectionEquality().hash(maxDocumentsLength) ^
      const DeepCollectionEquality().hash(maxRetrievedRagChunksCount) ^
      runtimeType.hashCode;
}

extension $RagConfigExtension on RagConfig {
  RagConfig copyWith(
      {bool? enabled,
      enums.EmbeddingModelEnum? embeddingModel,
      double? maxVectorDistance,
      int? maxDocumentsLength,
      int? maxRetrievedRagChunksCount}) {
    return RagConfig(
        enabled: enabled ?? this.enabled,
        embeddingModel: embeddingModel ?? this.embeddingModel,
        maxVectorDistance: maxVectorDistance ?? this.maxVectorDistance,
        maxDocumentsLength: maxDocumentsLength ?? this.maxDocumentsLength,
        maxRetrievedRagChunksCount:
            maxRetrievedRagChunksCount ?? this.maxRetrievedRagChunksCount);
  }

  RagConfig copyWithWrapped(
      {Wrapped<bool?>? enabled,
      Wrapped<enums.EmbeddingModelEnum?>? embeddingModel,
      Wrapped<double?>? maxVectorDistance,
      Wrapped<int?>? maxDocumentsLength,
      Wrapped<int?>? maxRetrievedRagChunksCount}) {
    return RagConfig(
        enabled: (enabled != null ? enabled.value : this.enabled),
        embeddingModel: (embeddingModel != null
            ? embeddingModel.value
            : this.embeddingModel),
        maxVectorDistance: (maxVectorDistance != null
            ? maxVectorDistance.value
            : this.maxVectorDistance),
        maxDocumentsLength: (maxDocumentsLength != null
            ? maxDocumentsLength.value
            : this.maxDocumentsLength),
        maxRetrievedRagChunksCount: (maxRetrievedRagChunksCount != null
            ? maxRetrievedRagChunksCount.value
            : this.maxRetrievedRagChunksCount));
  }
}

@JsonSerializable(explicitToJson: true)
class RagRetrievalInfo {
  const RagRetrievalInfo({
    required this.chunks,
    required this.embeddingModel,
    required this.retrievalQuery,
    required this.ragLatencySecs,
  });

  factory RagRetrievalInfo.fromJson(Map<String, dynamic> json) =>
      _$RagRetrievalInfoFromJson(json);

  static const toJsonFactory = _$RagRetrievalInfoToJson;
  Map<String, dynamic> toJson() => _$RagRetrievalInfoToJson(this);

  @JsonKey(name: 'chunks', defaultValue: <RagChunkMetadata>[])
  final List<RagChunkMetadata> chunks;
  @JsonKey(
    name: 'embedding_model',
    toJson: embeddingModelEnumToJson,
    fromJson: embeddingModelEnumFromJson,
  )
  final enums.EmbeddingModelEnum embeddingModel;
  @JsonKey(name: 'retrieval_query')
  final String retrievalQuery;
  @JsonKey(name: 'rag_latency_secs')
  final double ragLatencySecs;
  static const fromJsonFactory = _$RagRetrievalInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RagRetrievalInfo &&
            (identical(other.chunks, chunks) ||
                const DeepCollectionEquality().equals(other.chunks, chunks)) &&
            (identical(other.embeddingModel, embeddingModel) ||
                const DeepCollectionEquality()
                    .equals(other.embeddingModel, embeddingModel)) &&
            (identical(other.retrievalQuery, retrievalQuery) ||
                const DeepCollectionEquality()
                    .equals(other.retrievalQuery, retrievalQuery)) &&
            (identical(other.ragLatencySecs, ragLatencySecs) ||
                const DeepCollectionEquality()
                    .equals(other.ragLatencySecs, ragLatencySecs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(chunks) ^
      const DeepCollectionEquality().hash(embeddingModel) ^
      const DeepCollectionEquality().hash(retrievalQuery) ^
      const DeepCollectionEquality().hash(ragLatencySecs) ^
      runtimeType.hashCode;
}

extension $RagRetrievalInfoExtension on RagRetrievalInfo {
  RagRetrievalInfo copyWith(
      {List<RagChunkMetadata>? chunks,
      enums.EmbeddingModelEnum? embeddingModel,
      String? retrievalQuery,
      double? ragLatencySecs}) {
    return RagRetrievalInfo(
        chunks: chunks ?? this.chunks,
        embeddingModel: embeddingModel ?? this.embeddingModel,
        retrievalQuery: retrievalQuery ?? this.retrievalQuery,
        ragLatencySecs: ragLatencySecs ?? this.ragLatencySecs);
  }

  RagRetrievalInfo copyWithWrapped(
      {Wrapped<List<RagChunkMetadata>>? chunks,
      Wrapped<enums.EmbeddingModelEnum>? embeddingModel,
      Wrapped<String>? retrievalQuery,
      Wrapped<double>? ragLatencySecs}) {
    return RagRetrievalInfo(
        chunks: (chunks != null ? chunks.value : this.chunks),
        embeddingModel: (embeddingModel != null
            ? embeddingModel.value
            : this.embeddingModel),
        retrievalQuery: (retrievalQuery != null
            ? retrievalQuery.value
            : this.retrievalQuery),
        ragLatencySecs: (ragLatencySecs != null
            ? ragLatencySecs.value
            : this.ragLatencySecs));
  }
}

@JsonSerializable(explicitToJson: true)
class ReaderResourceResponseModel {
  const ReaderResourceResponseModel({
    required this.resourceType,
    required this.resourceId,
  });

  factory ReaderResourceResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ReaderResourceResponseModelFromJson(json);

  static const toJsonFactory = _$ReaderResourceResponseModelToJson;
  Map<String, dynamic> toJson() => _$ReaderResourceResponseModelToJson(this);

  @JsonKey(
    name: 'resource_type',
    toJson: readerResourceResponseModelResourceTypeToJson,
    fromJson: readerResourceResponseModelResourceTypeFromJson,
  )
  final enums.ReaderResourceResponseModelResourceType resourceType;
  @JsonKey(name: 'resource_id')
  final String resourceId;
  static const fromJsonFactory = _$ReaderResourceResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ReaderResourceResponseModel &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.resourceId, resourceId) ||
                const DeepCollectionEquality()
                    .equals(other.resourceId, resourceId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(resourceId) ^
      runtimeType.hashCode;
}

extension $ReaderResourceResponseModelExtension on ReaderResourceResponseModel {
  ReaderResourceResponseModel copyWith(
      {enums.ReaderResourceResponseModelResourceType? resourceType,
      String? resourceId}) {
    return ReaderResourceResponseModel(
        resourceType: resourceType ?? this.resourceType,
        resourceId: resourceId ?? this.resourceId);
  }

  ReaderResourceResponseModel copyWithWrapped(
      {Wrapped<enums.ReaderResourceResponseModelResourceType>? resourceType,
      Wrapped<String>? resourceId}) {
    return ReaderResourceResponseModel(
        resourceType:
            (resourceType != null ? resourceType.value : this.resourceType),
        resourceId: (resourceId != null ? resourceId.value : this.resourceId));
  }
}

@JsonSerializable(explicitToJson: true)
class RecordingResponseModel {
  const RecordingResponseModel({
    required this.recordingId,
    required this.mimeType,
    required this.sizeBytes,
    required this.uploadDateUnix,
    required this.transcription,
  });

  factory RecordingResponseModel.fromJson(Map<String, dynamic> json) =>
      _$RecordingResponseModelFromJson(json);

  static const toJsonFactory = _$RecordingResponseModelToJson;
  Map<String, dynamic> toJson() => _$RecordingResponseModelToJson(this);

  @JsonKey(name: 'recording_id')
  final String recordingId;
  @JsonKey(name: 'mime_type')
  final String mimeType;
  @JsonKey(name: 'size_bytes')
  final int sizeBytes;
  @JsonKey(name: 'upload_date_unix')
  final int uploadDateUnix;
  @JsonKey(name: 'transcription')
  final String transcription;
  static const fromJsonFactory = _$RecordingResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RecordingResponseModel &&
            (identical(other.recordingId, recordingId) ||
                const DeepCollectionEquality()
                    .equals(other.recordingId, recordingId)) &&
            (identical(other.mimeType, mimeType) ||
                const DeepCollectionEquality()
                    .equals(other.mimeType, mimeType)) &&
            (identical(other.sizeBytes, sizeBytes) ||
                const DeepCollectionEquality()
                    .equals(other.sizeBytes, sizeBytes)) &&
            (identical(other.uploadDateUnix, uploadDateUnix) ||
                const DeepCollectionEquality()
                    .equals(other.uploadDateUnix, uploadDateUnix)) &&
            (identical(other.transcription, transcription) ||
                const DeepCollectionEquality()
                    .equals(other.transcription, transcription)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(recordingId) ^
      const DeepCollectionEquality().hash(mimeType) ^
      const DeepCollectionEquality().hash(sizeBytes) ^
      const DeepCollectionEquality().hash(uploadDateUnix) ^
      const DeepCollectionEquality().hash(transcription) ^
      runtimeType.hashCode;
}

extension $RecordingResponseModelExtension on RecordingResponseModel {
  RecordingResponseModel copyWith(
      {String? recordingId,
      String? mimeType,
      int? sizeBytes,
      int? uploadDateUnix,
      String? transcription}) {
    return RecordingResponseModel(
        recordingId: recordingId ?? this.recordingId,
        mimeType: mimeType ?? this.mimeType,
        sizeBytes: sizeBytes ?? this.sizeBytes,
        uploadDateUnix: uploadDateUnix ?? this.uploadDateUnix,
        transcription: transcription ?? this.transcription);
  }

  RecordingResponseModel copyWithWrapped(
      {Wrapped<String>? recordingId,
      Wrapped<String>? mimeType,
      Wrapped<int>? sizeBytes,
      Wrapped<int>? uploadDateUnix,
      Wrapped<String>? transcription}) {
    return RecordingResponseModel(
        recordingId:
            (recordingId != null ? recordingId.value : this.recordingId),
        mimeType: (mimeType != null ? mimeType.value : this.mimeType),
        sizeBytes: (sizeBytes != null ? sizeBytes.value : this.sizeBytes),
        uploadDateUnix: (uploadDateUnix != null
            ? uploadDateUnix.value
            : this.uploadDateUnix),
        transcription:
            (transcription != null ? transcription.value : this.transcription));
  }
}

@JsonSerializable(explicitToJson: true)
class Render {
  const Render({
    required this.id,
    required this.version,
    required this.language,
    required this.type,
    required this.mediaRef,
    required this.status,
  });

  factory Render.fromJson(Map<String, dynamic> json) => _$RenderFromJson(json);

  static const toJsonFactory = _$RenderToJson;
  Map<String, dynamic> toJson() => _$RenderToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'version')
  final int version;
  @JsonKey(name: 'language')
  final dynamic language;
  @JsonKey(name: 'type')
  final dynamic type;
  @JsonKey(name: 'media_ref')
  final dynamic mediaRef;
  @JsonKey(
    name: 'status',
    toJson: renderStatusToJson,
    fromJson: renderStatusFromJson,
  )
  final enums.RenderStatus status;
  static const fromJsonFactory = _$RenderFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is Render &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.mediaRef, mediaRef) ||
                const DeepCollectionEquality()
                    .equals(other.mediaRef, mediaRef)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(mediaRef) ^
      const DeepCollectionEquality().hash(status) ^
      runtimeType.hashCode;
}

extension $RenderExtension on Render {
  Render copyWith(
      {String? id,
      int? version,
      dynamic language,
      dynamic type,
      dynamic mediaRef,
      enums.RenderStatus? status}) {
    return Render(
        id: id ?? this.id,
        version: version ?? this.version,
        language: language ?? this.language,
        type: type ?? this.type,
        mediaRef: mediaRef ?? this.mediaRef,
        status: status ?? this.status);
  }

  Render copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<int>? version,
      Wrapped<dynamic>? language,
      Wrapped<dynamic>? type,
      Wrapped<dynamic>? mediaRef,
      Wrapped<enums.RenderStatus>? status}) {
    return Render(
        id: (id != null ? id.value : this.id),
        version: (version != null ? version.value : this.version),
        language: (language != null ? language.value : this.language),
        type: (type != null ? type.value : this.type),
        mediaRef: (mediaRef != null ? mediaRef.value : this.mediaRef),
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class RequestPVCManualVerificationResponseModel {
  const RequestPVCManualVerificationResponseModel({
    required this.status,
  });

  factory RequestPVCManualVerificationResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$RequestPVCManualVerificationResponseModelFromJson(json);

  static const toJsonFactory =
      _$RequestPVCManualVerificationResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$RequestPVCManualVerificationResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory =
      _$RequestPVCManualVerificationResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is RequestPVCManualVerificationResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $RequestPVCManualVerificationResponseModelExtension
    on RequestPVCManualVerificationResponseModel {
  RequestPVCManualVerificationResponseModel copyWith({String? status}) {
    return RequestPVCManualVerificationResponseModel(
        status: status ?? this.status);
  }

  RequestPVCManualVerificationResponseModel copyWithWrapped(
      {Wrapped<String>? status}) {
    return RequestPVCManualVerificationResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class ResourceAccessInfo {
  const ResourceAccessInfo({
    required this.isCreator,
    required this.creatorName,
    required this.creatorEmail,
    required this.role,
  });

  factory ResourceAccessInfo.fromJson(Map<String, dynamic> json) =>
      _$ResourceAccessInfoFromJson(json);

  static const toJsonFactory = _$ResourceAccessInfoToJson;
  Map<String, dynamic> toJson() => _$ResourceAccessInfoToJson(this);

  @JsonKey(name: 'is_creator')
  final bool isCreator;
  @JsonKey(name: 'creator_name')
  final String creatorName;
  @JsonKey(name: 'creator_email')
  final String creatorEmail;
  @JsonKey(
    name: 'role',
    toJson: resourceAccessInfoRoleToJson,
    fromJson: resourceAccessInfoRoleFromJson,
  )
  final enums.ResourceAccessInfoRole role;
  static const fromJsonFactory = _$ResourceAccessInfoFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ResourceAccessInfo &&
            (identical(other.isCreator, isCreator) ||
                const DeepCollectionEquality()
                    .equals(other.isCreator, isCreator)) &&
            (identical(other.creatorName, creatorName) ||
                const DeepCollectionEquality()
                    .equals(other.creatorName, creatorName)) &&
            (identical(other.creatorEmail, creatorEmail) ||
                const DeepCollectionEquality()
                    .equals(other.creatorEmail, creatorEmail)) &&
            (identical(other.role, role) ||
                const DeepCollectionEquality().equals(other.role, role)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isCreator) ^
      const DeepCollectionEquality().hash(creatorName) ^
      const DeepCollectionEquality().hash(creatorEmail) ^
      const DeepCollectionEquality().hash(role) ^
      runtimeType.hashCode;
}

extension $ResourceAccessInfoExtension on ResourceAccessInfo {
  ResourceAccessInfo copyWith(
      {bool? isCreator,
      String? creatorName,
      String? creatorEmail,
      enums.ResourceAccessInfoRole? role}) {
    return ResourceAccessInfo(
        isCreator: isCreator ?? this.isCreator,
        creatorName: creatorName ?? this.creatorName,
        creatorEmail: creatorEmail ?? this.creatorEmail,
        role: role ?? this.role);
  }

  ResourceAccessInfo copyWithWrapped(
      {Wrapped<bool>? isCreator,
      Wrapped<String>? creatorName,
      Wrapped<String>? creatorEmail,
      Wrapped<enums.ResourceAccessInfoRole>? role}) {
    return ResourceAccessInfo(
        isCreator: (isCreator != null ? isCreator.value : this.isCreator),
        creatorName:
            (creatorName != null ? creatorName.value : this.creatorName),
        creatorEmail:
            (creatorEmail != null ? creatorEmail.value : this.creatorEmail),
        role: (role != null ? role.value : this.role));
  }
}

@JsonSerializable(explicitToJson: true)
class ResourceMetadataResponseModel {
  const ResourceMetadataResponseModel({
    required this.resourceId,
    required this.resourceType,
    required this.creatorUserId,
    required this.roleToGroupIds,
    required this.shareOptions,
  });

  factory ResourceMetadataResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ResourceMetadataResponseModelFromJson(json);

  static const toJsonFactory = _$ResourceMetadataResponseModelToJson;
  Map<String, dynamic> toJson() => _$ResourceMetadataResponseModelToJson(this);

  @JsonKey(name: 'resource_id')
  final String resourceId;
  @JsonKey(
    name: 'resource_type',
    toJson: workspaceResourceTypeToJson,
    fromJson: workspaceResourceTypeFromJson,
  )
  final enums.WorkspaceResourceType resourceType;
  @JsonKey(name: 'creator_user_id')
  final dynamic creatorUserId;
  @JsonKey(name: 'role_to_group_ids')
  final Map<String, dynamic> roleToGroupIds;
  @JsonKey(name: 'share_options', defaultValue: <ShareOptionResponseModel>[])
  final List<ShareOptionResponseModel> shareOptions;
  static const fromJsonFactory = _$ResourceMetadataResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ResourceMetadataResponseModel &&
            (identical(other.resourceId, resourceId) ||
                const DeepCollectionEquality()
                    .equals(other.resourceId, resourceId)) &&
            (identical(other.resourceType, resourceType) ||
                const DeepCollectionEquality()
                    .equals(other.resourceType, resourceType)) &&
            (identical(other.creatorUserId, creatorUserId) ||
                const DeepCollectionEquality()
                    .equals(other.creatorUserId, creatorUserId)) &&
            (identical(other.roleToGroupIds, roleToGroupIds) ||
                const DeepCollectionEquality()
                    .equals(other.roleToGroupIds, roleToGroupIds)) &&
            (identical(other.shareOptions, shareOptions) ||
                const DeepCollectionEquality()
                    .equals(other.shareOptions, shareOptions)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(resourceId) ^
      const DeepCollectionEquality().hash(resourceType) ^
      const DeepCollectionEquality().hash(creatorUserId) ^
      const DeepCollectionEquality().hash(roleToGroupIds) ^
      const DeepCollectionEquality().hash(shareOptions) ^
      runtimeType.hashCode;
}

extension $ResourceMetadataResponseModelExtension
    on ResourceMetadataResponseModel {
  ResourceMetadataResponseModel copyWith(
      {String? resourceId,
      enums.WorkspaceResourceType? resourceType,
      dynamic creatorUserId,
      Map<String, dynamic>? roleToGroupIds,
      List<ShareOptionResponseModel>? shareOptions}) {
    return ResourceMetadataResponseModel(
        resourceId: resourceId ?? this.resourceId,
        resourceType: resourceType ?? this.resourceType,
        creatorUserId: creatorUserId ?? this.creatorUserId,
        roleToGroupIds: roleToGroupIds ?? this.roleToGroupIds,
        shareOptions: shareOptions ?? this.shareOptions);
  }

  ResourceMetadataResponseModel copyWithWrapped(
      {Wrapped<String>? resourceId,
      Wrapped<enums.WorkspaceResourceType>? resourceType,
      Wrapped<dynamic>? creatorUserId,
      Wrapped<Map<String, dynamic>>? roleToGroupIds,
      Wrapped<List<ShareOptionResponseModel>>? shareOptions}) {
    return ResourceMetadataResponseModel(
        resourceId: (resourceId != null ? resourceId.value : this.resourceId),
        resourceType:
            (resourceType != null ? resourceType.value : this.resourceType),
        creatorUserId:
            (creatorUserId != null ? creatorUserId.value : this.creatorUserId),
        roleToGroupIds: (roleToGroupIds != null
            ? roleToGroupIds.value
            : this.roleToGroupIds),
        shareOptions:
            (shareOptions != null ? shareOptions.value : this.shareOptions));
  }
}

@JsonSerializable(explicitToJson: true)
class SIPTrunkConfigResponseModel {
  const SIPTrunkConfigResponseModel({
    required this.address,
    required this.transport,
    required this.mediaEncryption,
    this.headers,
    required this.hasAuthCredentials,
    this.username,
    this.hasOutboundTrunk,
  });

  factory SIPTrunkConfigResponseModel.fromJson(Map<String, dynamic> json) =>
      _$SIPTrunkConfigResponseModelFromJson(json);

  static const toJsonFactory = _$SIPTrunkConfigResponseModelToJson;
  Map<String, dynamic> toJson() => _$SIPTrunkConfigResponseModelToJson(this);

  @JsonKey(name: 'address')
  final String address;
  @JsonKey(
    name: 'transport',
    toJson: sIPTrunkTransportEnumToJson,
    fromJson: sIPTrunkTransportEnumFromJson,
  )
  final enums.SIPTrunkTransportEnum transport;
  @JsonKey(
    name: 'media_encryption',
    toJson: sIPMediaEncryptionEnumToJson,
    fromJson: sIPMediaEncryptionEnumFromJson,
  )
  final enums.SIPMediaEncryptionEnum mediaEncryption;
  @JsonKey(name: 'headers')
  final Map<String, dynamic>? headers;
  @JsonKey(name: 'has_auth_credentials')
  final bool hasAuthCredentials;
  @JsonKey(name: 'username')
  final dynamic username;
  @JsonKey(name: 'has_outbound_trunk', defaultValue: false)
  final bool? hasOutboundTrunk;
  static const fromJsonFactory = _$SIPTrunkConfigResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SIPTrunkConfigResponseModel &&
            (identical(other.address, address) ||
                const DeepCollectionEquality()
                    .equals(other.address, address)) &&
            (identical(other.transport, transport) ||
                const DeepCollectionEquality()
                    .equals(other.transport, transport)) &&
            (identical(other.mediaEncryption, mediaEncryption) ||
                const DeepCollectionEquality()
                    .equals(other.mediaEncryption, mediaEncryption)) &&
            (identical(other.headers, headers) ||
                const DeepCollectionEquality()
                    .equals(other.headers, headers)) &&
            (identical(other.hasAuthCredentials, hasAuthCredentials) ||
                const DeepCollectionEquality()
                    .equals(other.hasAuthCredentials, hasAuthCredentials)) &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.hasOutboundTrunk, hasOutboundTrunk) ||
                const DeepCollectionEquality()
                    .equals(other.hasOutboundTrunk, hasOutboundTrunk)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(address) ^
      const DeepCollectionEquality().hash(transport) ^
      const DeepCollectionEquality().hash(mediaEncryption) ^
      const DeepCollectionEquality().hash(headers) ^
      const DeepCollectionEquality().hash(hasAuthCredentials) ^
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(hasOutboundTrunk) ^
      runtimeType.hashCode;
}

extension $SIPTrunkConfigResponseModelExtension on SIPTrunkConfigResponseModel {
  SIPTrunkConfigResponseModel copyWith(
      {String? address,
      enums.SIPTrunkTransportEnum? transport,
      enums.SIPMediaEncryptionEnum? mediaEncryption,
      Map<String, dynamic>? headers,
      bool? hasAuthCredentials,
      dynamic username,
      bool? hasOutboundTrunk}) {
    return SIPTrunkConfigResponseModel(
        address: address ?? this.address,
        transport: transport ?? this.transport,
        mediaEncryption: mediaEncryption ?? this.mediaEncryption,
        headers: headers ?? this.headers,
        hasAuthCredentials: hasAuthCredentials ?? this.hasAuthCredentials,
        username: username ?? this.username,
        hasOutboundTrunk: hasOutboundTrunk ?? this.hasOutboundTrunk);
  }

  SIPTrunkConfigResponseModel copyWithWrapped(
      {Wrapped<String>? address,
      Wrapped<enums.SIPTrunkTransportEnum>? transport,
      Wrapped<enums.SIPMediaEncryptionEnum>? mediaEncryption,
      Wrapped<Map<String, dynamic>?>? headers,
      Wrapped<bool>? hasAuthCredentials,
      Wrapped<dynamic>? username,
      Wrapped<bool?>? hasOutboundTrunk}) {
    return SIPTrunkConfigResponseModel(
        address: (address != null ? address.value : this.address),
        transport: (transport != null ? transport.value : this.transport),
        mediaEncryption: (mediaEncryption != null
            ? mediaEncryption.value
            : this.mediaEncryption),
        headers: (headers != null ? headers.value : this.headers),
        hasAuthCredentials: (hasAuthCredentials != null
            ? hasAuthCredentials.value
            : this.hasAuthCredentials),
        username: (username != null ? username.value : this.username),
        hasOutboundTrunk: (hasOutboundTrunk != null
            ? hasOutboundTrunk.value
            : this.hasOutboundTrunk));
  }
}

@JsonSerializable(explicitToJson: true)
class SIPTrunkCredentials {
  const SIPTrunkCredentials({
    required this.username,
    required this.password,
  });

  factory SIPTrunkCredentials.fromJson(Map<String, dynamic> json) =>
      _$SIPTrunkCredentialsFromJson(json);

  static const toJsonFactory = _$SIPTrunkCredentialsToJson;
  Map<String, dynamic> toJson() => _$SIPTrunkCredentialsToJson(this);

  @JsonKey(name: 'username')
  final String username;
  @JsonKey(name: 'password')
  final String password;
  static const fromJsonFactory = _$SIPTrunkCredentialsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SIPTrunkCredentials &&
            (identical(other.username, username) ||
                const DeepCollectionEquality()
                    .equals(other.username, username)) &&
            (identical(other.password, password) ||
                const DeepCollectionEquality()
                    .equals(other.password, password)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(username) ^
      const DeepCollectionEquality().hash(password) ^
      runtimeType.hashCode;
}

extension $SIPTrunkCredentialsExtension on SIPTrunkCredentials {
  SIPTrunkCredentials copyWith({String? username, String? password}) {
    return SIPTrunkCredentials(
        username: username ?? this.username,
        password: password ?? this.password);
  }

  SIPTrunkCredentials copyWithWrapped(
      {Wrapped<String>? username, Wrapped<String>? password}) {
    return SIPTrunkCredentials(
        username: (username != null ? username.value : this.username),
        password: (password != null ? password.value : this.password));
  }
}

@JsonSerializable(explicitToJson: true)
class SIPTrunkOutboundCallResponse {
  const SIPTrunkOutboundCallResponse({
    required this.success,
    required this.message,
    required this.conversationId,
    required this.sipCallId,
  });

  factory SIPTrunkOutboundCallResponse.fromJson(Map<String, dynamic> json) =>
      _$SIPTrunkOutboundCallResponseFromJson(json);

  static const toJsonFactory = _$SIPTrunkOutboundCallResponseToJson;
  Map<String, dynamic> toJson() => _$SIPTrunkOutboundCallResponseToJson(this);

  @JsonKey(name: 'success')
  final bool success;
  @JsonKey(name: 'message')
  final String message;
  @JsonKey(name: 'conversation_id')
  final dynamic conversationId;
  @JsonKey(name: 'sip_call_id')
  final dynamic sipCallId;
  static const fromJsonFactory = _$SIPTrunkOutboundCallResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SIPTrunkOutboundCallResponse &&
            (identical(other.success, success) ||
                const DeepCollectionEquality()
                    .equals(other.success, success)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.conversationId, conversationId) ||
                const DeepCollectionEquality()
                    .equals(other.conversationId, conversationId)) &&
            (identical(other.sipCallId, sipCallId) ||
                const DeepCollectionEquality()
                    .equals(other.sipCallId, sipCallId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(success) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(conversationId) ^
      const DeepCollectionEquality().hash(sipCallId) ^
      runtimeType.hashCode;
}

extension $SIPTrunkOutboundCallResponseExtension
    on SIPTrunkOutboundCallResponse {
  SIPTrunkOutboundCallResponse copyWith(
      {bool? success,
      String? message,
      dynamic conversationId,
      dynamic sipCallId}) {
    return SIPTrunkOutboundCallResponse(
        success: success ?? this.success,
        message: message ?? this.message,
        conversationId: conversationId ?? this.conversationId,
        sipCallId: sipCallId ?? this.sipCallId);
  }

  SIPTrunkOutboundCallResponse copyWithWrapped(
      {Wrapped<bool>? success,
      Wrapped<String>? message,
      Wrapped<dynamic>? conversationId,
      Wrapped<dynamic>? sipCallId}) {
    return SIPTrunkOutboundCallResponse(
        success: (success != null ? success.value : this.success),
        message: (message != null ? message.value : this.message),
        conversationId: (conversationId != null
            ? conversationId.value
            : this.conversationId),
        sipCallId: (sipCallId != null ? sipCallId.value : this.sipCallId));
  }
}

@JsonSerializable(explicitToJson: true)
class SafetyCommonModel {
  const SafetyCommonModel({
    this.ivc,
    this.nonIvc,
  });

  factory SafetyCommonModel.fromJson(Map<String, dynamic> json) =>
      _$SafetyCommonModelFromJson(json);

  static const toJsonFactory = _$SafetyCommonModelToJson;
  Map<String, dynamic> toJson() => _$SafetyCommonModelToJson(this);

  @JsonKey(name: 'ivc')
  final SafetyEvaluation? ivc;
  @JsonKey(name: 'non_ivc')
  final SafetyEvaluation? nonIvc;
  static const fromJsonFactory = _$SafetyCommonModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SafetyCommonModel &&
            (identical(other.ivc, ivc) ||
                const DeepCollectionEquality().equals(other.ivc, ivc)) &&
            (identical(other.nonIvc, nonIvc) ||
                const DeepCollectionEquality().equals(other.nonIvc, nonIvc)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(ivc) ^
      const DeepCollectionEquality().hash(nonIvc) ^
      runtimeType.hashCode;
}

extension $SafetyCommonModelExtension on SafetyCommonModel {
  SafetyCommonModel copyWith(
      {SafetyEvaluation? ivc, SafetyEvaluation? nonIvc}) {
    return SafetyCommonModel(
        ivc: ivc ?? this.ivc, nonIvc: nonIvc ?? this.nonIvc);
  }

  SafetyCommonModel copyWithWrapped(
      {Wrapped<SafetyEvaluation?>? ivc, Wrapped<SafetyEvaluation?>? nonIvc}) {
    return SafetyCommonModel(
        ivc: (ivc != null ? ivc.value : this.ivc),
        nonIvc: (nonIvc != null ? nonIvc.value : this.nonIvc));
  }
}

@JsonSerializable(explicitToJson: true)
class SafetyEvaluation {
  const SafetyEvaluation({
    this.isUnsafe,
    this.llmReason,
    this.safetyPromptVersion,
    this.matchedRuleId,
  });

  factory SafetyEvaluation.fromJson(Map<String, dynamic> json) =>
      _$SafetyEvaluationFromJson(json);

  static const toJsonFactory = _$SafetyEvaluationToJson;
  Map<String, dynamic> toJson() => _$SafetyEvaluationToJson(this);

  @JsonKey(name: 'is_unsafe', defaultValue: false)
  final bool? isUnsafe;
  @JsonKey(name: 'llm_reason')
  final String? llmReason;
  @JsonKey(name: 'safety_prompt_version')
  final int? safetyPromptVersion;
  @JsonKey(
    name: 'matched_rule_id',
    toJson: safetyRuleListToJson,
    fromJson: safetyRuleListFromJson,
  )
  final List<enums.SafetyRule>? matchedRuleId;
  static const fromJsonFactory = _$SafetyEvaluationFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SafetyEvaluation &&
            (identical(other.isUnsafe, isUnsafe) ||
                const DeepCollectionEquality()
                    .equals(other.isUnsafe, isUnsafe)) &&
            (identical(other.llmReason, llmReason) ||
                const DeepCollectionEquality()
                    .equals(other.llmReason, llmReason)) &&
            (identical(other.safetyPromptVersion, safetyPromptVersion) ||
                const DeepCollectionEquality()
                    .equals(other.safetyPromptVersion, safetyPromptVersion)) &&
            (identical(other.matchedRuleId, matchedRuleId) ||
                const DeepCollectionEquality()
                    .equals(other.matchedRuleId, matchedRuleId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isUnsafe) ^
      const DeepCollectionEquality().hash(llmReason) ^
      const DeepCollectionEquality().hash(safetyPromptVersion) ^
      const DeepCollectionEquality().hash(matchedRuleId) ^
      runtimeType.hashCode;
}

extension $SafetyEvaluationExtension on SafetyEvaluation {
  SafetyEvaluation copyWith(
      {bool? isUnsafe,
      String? llmReason,
      int? safetyPromptVersion,
      List<enums.SafetyRule>? matchedRuleId}) {
    return SafetyEvaluation(
        isUnsafe: isUnsafe ?? this.isUnsafe,
        llmReason: llmReason ?? this.llmReason,
        safetyPromptVersion: safetyPromptVersion ?? this.safetyPromptVersion,
        matchedRuleId: matchedRuleId ?? this.matchedRuleId);
  }

  SafetyEvaluation copyWithWrapped(
      {Wrapped<bool?>? isUnsafe,
      Wrapped<String?>? llmReason,
      Wrapped<int?>? safetyPromptVersion,
      Wrapped<List<enums.SafetyRule>?>? matchedRuleId}) {
    return SafetyEvaluation(
        isUnsafe: (isUnsafe != null ? isUnsafe.value : this.isUnsafe),
        llmReason: (llmReason != null ? llmReason.value : this.llmReason),
        safetyPromptVersion: (safetyPromptVersion != null
            ? safetyPromptVersion.value
            : this.safetyPromptVersion),
        matchedRuleId:
            (matchedRuleId != null ? matchedRuleId.value : this.matchedRuleId));
  }
}

@JsonSerializable(explicitToJson: true)
class SafetyResponseModel {
  const SafetyResponseModel({
    this.isBlockedIvc,
    this.isBlockedNonIvc,
    this.ignoreSafetyEvaluation,
  });

  factory SafetyResponseModel.fromJson(Map<String, dynamic> json) =>
      _$SafetyResponseModelFromJson(json);

  static const toJsonFactory = _$SafetyResponseModelToJson;
  Map<String, dynamic> toJson() => _$SafetyResponseModelToJson(this);

  @JsonKey(name: 'is_blocked_ivc', defaultValue: false)
  final bool? isBlockedIvc;
  @JsonKey(name: 'is_blocked_non_ivc', defaultValue: false)
  final bool? isBlockedNonIvc;
  @JsonKey(name: 'ignore_safety_evaluation', defaultValue: false)
  final bool? ignoreSafetyEvaluation;
  static const fromJsonFactory = _$SafetyResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SafetyResponseModel &&
            (identical(other.isBlockedIvc, isBlockedIvc) ||
                const DeepCollectionEquality()
                    .equals(other.isBlockedIvc, isBlockedIvc)) &&
            (identical(other.isBlockedNonIvc, isBlockedNonIvc) ||
                const DeepCollectionEquality()
                    .equals(other.isBlockedNonIvc, isBlockedNonIvc)) &&
            (identical(other.ignoreSafetyEvaluation, ignoreSafetyEvaluation) ||
                const DeepCollectionEquality().equals(
                    other.ignoreSafetyEvaluation, ignoreSafetyEvaluation)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(isBlockedIvc) ^
      const DeepCollectionEquality().hash(isBlockedNonIvc) ^
      const DeepCollectionEquality().hash(ignoreSafetyEvaluation) ^
      runtimeType.hashCode;
}

extension $SafetyResponseModelExtension on SafetyResponseModel {
  SafetyResponseModel copyWith(
      {bool? isBlockedIvc,
      bool? isBlockedNonIvc,
      bool? ignoreSafetyEvaluation}) {
    return SafetyResponseModel(
        isBlockedIvc: isBlockedIvc ?? this.isBlockedIvc,
        isBlockedNonIvc: isBlockedNonIvc ?? this.isBlockedNonIvc,
        ignoreSafetyEvaluation:
            ignoreSafetyEvaluation ?? this.ignoreSafetyEvaluation);
  }

  SafetyResponseModel copyWithWrapped(
      {Wrapped<bool?>? isBlockedIvc,
      Wrapped<bool?>? isBlockedNonIvc,
      Wrapped<bool?>? ignoreSafetyEvaluation}) {
    return SafetyResponseModel(
        isBlockedIvc:
            (isBlockedIvc != null ? isBlockedIvc.value : this.isBlockedIvc),
        isBlockedNonIvc: (isBlockedNonIvc != null
            ? isBlockedNonIvc.value
            : this.isBlockedNonIvc),
        ignoreSafetyEvaluation: (ignoreSafetyEvaluation != null
            ? ignoreSafetyEvaluation.value
            : this.ignoreSafetyEvaluation));
  }
}

@JsonSerializable(explicitToJson: true)
class SampleResponseModel {
  const SampleResponseModel({
    required this.sampleId,
    required this.fileName,
    required this.mimeType,
    required this.sizeBytes,
    required this.hash,
    this.durationSecs,
    this.removeBackgroundNoise,
    this.hasIsolatedAudio,
    this.hasIsolatedAudioPreview,
    this.speakerSeparation,
    this.trimStart,
    this.trimEnd,
  });

  factory SampleResponseModel.fromJson(Map<String, dynamic> json) =>
      _$SampleResponseModelFromJson(json);

  static const toJsonFactory = _$SampleResponseModelToJson;
  Map<String, dynamic> toJson() => _$SampleResponseModelToJson(this);

  @JsonKey(name: 'sample_id')
  final String sampleId;
  @JsonKey(name: 'file_name')
  final String fileName;
  @JsonKey(name: 'mime_type')
  final String mimeType;
  @JsonKey(name: 'size_bytes')
  final int sizeBytes;
  @JsonKey(name: 'hash')
  final String hash;
  @JsonKey(name: 'duration_secs')
  final dynamic durationSecs;
  @JsonKey(name: 'remove_background_noise')
  final dynamic removeBackgroundNoise;
  @JsonKey(name: 'has_isolated_audio')
  final dynamic hasIsolatedAudio;
  @JsonKey(name: 'has_isolated_audio_preview')
  final dynamic hasIsolatedAudioPreview;
  @JsonKey(name: 'speaker_separation')
  final dynamic speakerSeparation;
  @JsonKey(name: 'trim_start')
  final dynamic trimStart;
  @JsonKey(name: 'trim_end')
  final dynamic trimEnd;
  static const fromJsonFactory = _$SampleResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SampleResponseModel &&
            (identical(other.sampleId, sampleId) ||
                const DeepCollectionEquality()
                    .equals(other.sampleId, sampleId)) &&
            (identical(other.fileName, fileName) ||
                const DeepCollectionEquality()
                    .equals(other.fileName, fileName)) &&
            (identical(other.mimeType, mimeType) ||
                const DeepCollectionEquality()
                    .equals(other.mimeType, mimeType)) &&
            (identical(other.sizeBytes, sizeBytes) ||
                const DeepCollectionEquality()
                    .equals(other.sizeBytes, sizeBytes)) &&
            (identical(other.hash, hash) ||
                const DeepCollectionEquality().equals(other.hash, hash)) &&
            (identical(other.durationSecs, durationSecs) ||
                const DeepCollectionEquality()
                    .equals(other.durationSecs, durationSecs)) &&
            (identical(other.removeBackgroundNoise, removeBackgroundNoise) ||
                const DeepCollectionEquality().equals(
                    other.removeBackgroundNoise, removeBackgroundNoise)) &&
            (identical(other.hasIsolatedAudio, hasIsolatedAudio) ||
                const DeepCollectionEquality()
                    .equals(other.hasIsolatedAudio, hasIsolatedAudio)) &&
            (identical(
                    other.hasIsolatedAudioPreview, hasIsolatedAudioPreview) ||
                const DeepCollectionEquality().equals(
                    other.hasIsolatedAudioPreview, hasIsolatedAudioPreview)) &&
            (identical(other.speakerSeparation, speakerSeparation) ||
                const DeepCollectionEquality()
                    .equals(other.speakerSeparation, speakerSeparation)) &&
            (identical(other.trimStart, trimStart) ||
                const DeepCollectionEquality()
                    .equals(other.trimStart, trimStart)) &&
            (identical(other.trimEnd, trimEnd) ||
                const DeepCollectionEquality().equals(other.trimEnd, trimEnd)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sampleId) ^
      const DeepCollectionEquality().hash(fileName) ^
      const DeepCollectionEquality().hash(mimeType) ^
      const DeepCollectionEquality().hash(sizeBytes) ^
      const DeepCollectionEquality().hash(hash) ^
      const DeepCollectionEquality().hash(durationSecs) ^
      const DeepCollectionEquality().hash(removeBackgroundNoise) ^
      const DeepCollectionEquality().hash(hasIsolatedAudio) ^
      const DeepCollectionEquality().hash(hasIsolatedAudioPreview) ^
      const DeepCollectionEquality().hash(speakerSeparation) ^
      const DeepCollectionEquality().hash(trimStart) ^
      const DeepCollectionEquality().hash(trimEnd) ^
      runtimeType.hashCode;
}

extension $SampleResponseModelExtension on SampleResponseModel {
  SampleResponseModel copyWith(
      {String? sampleId,
      String? fileName,
      String? mimeType,
      int? sizeBytes,
      String? hash,
      dynamic durationSecs,
      dynamic removeBackgroundNoise,
      dynamic hasIsolatedAudio,
      dynamic hasIsolatedAudioPreview,
      dynamic speakerSeparation,
      dynamic trimStart,
      dynamic trimEnd}) {
    return SampleResponseModel(
        sampleId: sampleId ?? this.sampleId,
        fileName: fileName ?? this.fileName,
        mimeType: mimeType ?? this.mimeType,
        sizeBytes: sizeBytes ?? this.sizeBytes,
        hash: hash ?? this.hash,
        durationSecs: durationSecs ?? this.durationSecs,
        removeBackgroundNoise:
            removeBackgroundNoise ?? this.removeBackgroundNoise,
        hasIsolatedAudio: hasIsolatedAudio ?? this.hasIsolatedAudio,
        hasIsolatedAudioPreview:
            hasIsolatedAudioPreview ?? this.hasIsolatedAudioPreview,
        speakerSeparation: speakerSeparation ?? this.speakerSeparation,
        trimStart: trimStart ?? this.trimStart,
        trimEnd: trimEnd ?? this.trimEnd);
  }

  SampleResponseModel copyWithWrapped(
      {Wrapped<String>? sampleId,
      Wrapped<String>? fileName,
      Wrapped<String>? mimeType,
      Wrapped<int>? sizeBytes,
      Wrapped<String>? hash,
      Wrapped<dynamic>? durationSecs,
      Wrapped<dynamic>? removeBackgroundNoise,
      Wrapped<dynamic>? hasIsolatedAudio,
      Wrapped<dynamic>? hasIsolatedAudioPreview,
      Wrapped<dynamic>? speakerSeparation,
      Wrapped<dynamic>? trimStart,
      Wrapped<dynamic>? trimEnd}) {
    return SampleResponseModel(
        sampleId: (sampleId != null ? sampleId.value : this.sampleId),
        fileName: (fileName != null ? fileName.value : this.fileName),
        mimeType: (mimeType != null ? mimeType.value : this.mimeType),
        sizeBytes: (sizeBytes != null ? sizeBytes.value : this.sizeBytes),
        hash: (hash != null ? hash.value : this.hash),
        durationSecs:
            (durationSecs != null ? durationSecs.value : this.durationSecs),
        removeBackgroundNoise: (removeBackgroundNoise != null
            ? removeBackgroundNoise.value
            : this.removeBackgroundNoise),
        hasIsolatedAudio: (hasIsolatedAudio != null
            ? hasIsolatedAudio.value
            : this.hasIsolatedAudio),
        hasIsolatedAudioPreview: (hasIsolatedAudioPreview != null
            ? hasIsolatedAudioPreview.value
            : this.hasIsolatedAudioPreview),
        speakerSeparation: (speakerSeparation != null
            ? speakerSeparation.value
            : this.speakerSeparation),
        trimStart: (trimStart != null ? trimStart.value : this.trimStart),
        trimEnd: (trimEnd != null ? trimEnd.value : this.trimEnd));
  }
}

@JsonSerializable(explicitToJson: true)
class SegmentCreatePayload {
  const SegmentCreatePayload({
    required this.startTime,
    required this.endTime,
    this.text,
    this.translations,
  });

  factory SegmentCreatePayload.fromJson(Map<String, dynamic> json) =>
      _$SegmentCreatePayloadFromJson(json);

  static const toJsonFactory = _$SegmentCreatePayloadToJson;
  Map<String, dynamic> toJson() => _$SegmentCreatePayloadToJson(this);

  @JsonKey(name: 'start_time')
  final double startTime;
  @JsonKey(name: 'end_time')
  final double endTime;
  @JsonKey(name: 'text')
  final dynamic text;
  @JsonKey(name: 'translations')
  final dynamic translations;
  static const fromJsonFactory = _$SegmentCreatePayloadFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SegmentCreatePayload &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality()
                    .equals(other.startTime, startTime)) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality()
                    .equals(other.endTime, endTime)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.translations, translations) ||
                const DeepCollectionEquality()
                    .equals(other.translations, translations)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(translations) ^
      runtimeType.hashCode;
}

extension $SegmentCreatePayloadExtension on SegmentCreatePayload {
  SegmentCreatePayload copyWith(
      {double? startTime,
      double? endTime,
      dynamic text,
      dynamic translations}) {
    return SegmentCreatePayload(
        startTime: startTime ?? this.startTime,
        endTime: endTime ?? this.endTime,
        text: text ?? this.text,
        translations: translations ?? this.translations);
  }

  SegmentCreatePayload copyWithWrapped(
      {Wrapped<double>? startTime,
      Wrapped<double>? endTime,
      Wrapped<dynamic>? text,
      Wrapped<dynamic>? translations}) {
    return SegmentCreatePayload(
        startTime: (startTime != null ? startTime.value : this.startTime),
        endTime: (endTime != null ? endTime.value : this.endTime),
        text: (text != null ? text.value : this.text),
        translations:
            (translations != null ? translations.value : this.translations));
  }
}

@JsonSerializable(explicitToJson: true)
class SegmentCreateResponse {
  const SegmentCreateResponse({
    required this.version,
    required this.newSegment,
  });

  factory SegmentCreateResponse.fromJson(Map<String, dynamic> json) =>
      _$SegmentCreateResponseFromJson(json);

  static const toJsonFactory = _$SegmentCreateResponseToJson;
  Map<String, dynamic> toJson() => _$SegmentCreateResponseToJson(this);

  @JsonKey(name: 'version')
  final int version;
  @JsonKey(name: 'new_segment')
  final String newSegment;
  static const fromJsonFactory = _$SegmentCreateResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SegmentCreateResponse &&
            (identical(other.version, version) ||
                const DeepCollectionEquality()
                    .equals(other.version, version)) &&
            (identical(other.newSegment, newSegment) ||
                const DeepCollectionEquality()
                    .equals(other.newSegment, newSegment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(version) ^
      const DeepCollectionEquality().hash(newSegment) ^
      runtimeType.hashCode;
}

extension $SegmentCreateResponseExtension on SegmentCreateResponse {
  SegmentCreateResponse copyWith({int? version, String? newSegment}) {
    return SegmentCreateResponse(
        version: version ?? this.version,
        newSegment: newSegment ?? this.newSegment);
  }

  SegmentCreateResponse copyWithWrapped(
      {Wrapped<int>? version, Wrapped<String>? newSegment}) {
    return SegmentCreateResponse(
        version: (version != null ? version.value : this.version),
        newSegment: (newSegment != null ? newSegment.value : this.newSegment));
  }
}

@JsonSerializable(explicitToJson: true)
class SegmentDeleteResponse {
  const SegmentDeleteResponse({
    required this.version,
  });

  factory SegmentDeleteResponse.fromJson(Map<String, dynamic> json) =>
      _$SegmentDeleteResponseFromJson(json);

  static const toJsonFactory = _$SegmentDeleteResponseToJson;
  Map<String, dynamic> toJson() => _$SegmentDeleteResponseToJson(this);

  @JsonKey(name: 'version')
  final int version;
  static const fromJsonFactory = _$SegmentDeleteResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SegmentDeleteResponse &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(version) ^ runtimeType.hashCode;
}

extension $SegmentDeleteResponseExtension on SegmentDeleteResponse {
  SegmentDeleteResponse copyWith({int? version}) {
    return SegmentDeleteResponse(version: version ?? this.version);
  }

  SegmentDeleteResponse copyWithWrapped({Wrapped<int>? version}) {
    return SegmentDeleteResponse(
        version: (version != null ? version.value : this.version));
  }
}

@JsonSerializable(explicitToJson: true)
class SegmentDubResponse {
  const SegmentDubResponse({
    required this.version,
  });

  factory SegmentDubResponse.fromJson(Map<String, dynamic> json) =>
      _$SegmentDubResponseFromJson(json);

  static const toJsonFactory = _$SegmentDubResponseToJson;
  Map<String, dynamic> toJson() => _$SegmentDubResponseToJson(this);

  @JsonKey(name: 'version')
  final int version;
  static const fromJsonFactory = _$SegmentDubResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SegmentDubResponse &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(version) ^ runtimeType.hashCode;
}

extension $SegmentDubResponseExtension on SegmentDubResponse {
  SegmentDubResponse copyWith({int? version}) {
    return SegmentDubResponse(version: version ?? this.version);
  }

  SegmentDubResponse copyWithWrapped({Wrapped<int>? version}) {
    return SegmentDubResponse(
        version: (version != null ? version.value : this.version));
  }
}

@JsonSerializable(explicitToJson: true)
class SegmentTranscriptionResponse {
  const SegmentTranscriptionResponse({
    required this.version,
  });

  factory SegmentTranscriptionResponse.fromJson(Map<String, dynamic> json) =>
      _$SegmentTranscriptionResponseFromJson(json);

  static const toJsonFactory = _$SegmentTranscriptionResponseToJson;
  Map<String, dynamic> toJson() => _$SegmentTranscriptionResponseToJson(this);

  @JsonKey(name: 'version')
  final int version;
  static const fromJsonFactory = _$SegmentTranscriptionResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SegmentTranscriptionResponse &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(version) ^ runtimeType.hashCode;
}

extension $SegmentTranscriptionResponseExtension
    on SegmentTranscriptionResponse {
  SegmentTranscriptionResponse copyWith({int? version}) {
    return SegmentTranscriptionResponse(version: version ?? this.version);
  }

  SegmentTranscriptionResponse copyWithWrapped({Wrapped<int>? version}) {
    return SegmentTranscriptionResponse(
        version: (version != null ? version.value : this.version));
  }
}

@JsonSerializable(explicitToJson: true)
class SegmentTranslationResponse {
  const SegmentTranslationResponse({
    required this.version,
  });

  factory SegmentTranslationResponse.fromJson(Map<String, dynamic> json) =>
      _$SegmentTranslationResponseFromJson(json);

  static const toJsonFactory = _$SegmentTranslationResponseToJson;
  Map<String, dynamic> toJson() => _$SegmentTranslationResponseToJson(this);

  @JsonKey(name: 'version')
  final int version;
  static const fromJsonFactory = _$SegmentTranslationResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SegmentTranslationResponse &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(version) ^ runtimeType.hashCode;
}

extension $SegmentTranslationResponseExtension on SegmentTranslationResponse {
  SegmentTranslationResponse copyWith({int? version}) {
    return SegmentTranslationResponse(version: version ?? this.version);
  }

  SegmentTranslationResponse copyWithWrapped({Wrapped<int>? version}) {
    return SegmentTranslationResponse(
        version: (version != null ? version.value : this.version));
  }
}

@JsonSerializable(explicitToJson: true)
class SegmentUpdatePayload {
  const SegmentUpdatePayload({
    this.startTime,
    this.endTime,
    this.text,
  });

  factory SegmentUpdatePayload.fromJson(Map<String, dynamic> json) =>
      _$SegmentUpdatePayloadFromJson(json);

  static const toJsonFactory = _$SegmentUpdatePayloadToJson;
  Map<String, dynamic> toJson() => _$SegmentUpdatePayloadToJson(this);

  @JsonKey(name: 'start_time')
  final dynamic startTime;
  @JsonKey(name: 'end_time')
  final dynamic endTime;
  @JsonKey(name: 'text')
  final dynamic text;
  static const fromJsonFactory = _$SegmentUpdatePayloadFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SegmentUpdatePayload &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality()
                    .equals(other.startTime, startTime)) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality()
                    .equals(other.endTime, endTime)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(text) ^
      runtimeType.hashCode;
}

extension $SegmentUpdatePayloadExtension on SegmentUpdatePayload {
  SegmentUpdatePayload copyWith(
      {dynamic startTime, dynamic endTime, dynamic text}) {
    return SegmentUpdatePayload(
        startTime: startTime ?? this.startTime,
        endTime: endTime ?? this.endTime,
        text: text ?? this.text);
  }

  SegmentUpdatePayload copyWithWrapped(
      {Wrapped<dynamic>? startTime,
      Wrapped<dynamic>? endTime,
      Wrapped<dynamic>? text}) {
    return SegmentUpdatePayload(
        startTime: (startTime != null ? startTime.value : this.startTime),
        endTime: (endTime != null ? endTime.value : this.endTime),
        text: (text != null ? text.value : this.text));
  }
}

@JsonSerializable(explicitToJson: true)
class SegmentUpdateResponse {
  const SegmentUpdateResponse({
    required this.version,
  });

  factory SegmentUpdateResponse.fromJson(Map<String, dynamic> json) =>
      _$SegmentUpdateResponseFromJson(json);

  static const toJsonFactory = _$SegmentUpdateResponseToJson;
  Map<String, dynamic> toJson() => _$SegmentUpdateResponseToJson(this);

  @JsonKey(name: 'version')
  final int version;
  static const fromJsonFactory = _$SegmentUpdateResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SegmentUpdateResponse &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(version) ^ runtimeType.hashCode;
}

extension $SegmentUpdateResponseExtension on SegmentUpdateResponse {
  SegmentUpdateResponse copyWith({int? version}) {
    return SegmentUpdateResponse(version: version ?? this.version);
  }

  SegmentUpdateResponse copyWithWrapped({Wrapped<int>? version}) {
    return SegmentUpdateResponse(
        version: (version != null ? version.value : this.version));
  }
}

@JsonSerializable(explicitToJson: true)
class SegmentedJsonExportOptions {
  const SegmentedJsonExportOptions({
    this.includeSpeakers,
    this.includeTimestamps,
    required this.format,
    this.segmentOnSilenceLongerThanS,
    this.maxSegmentDurationS,
    this.maxSegmentChars,
  });

  factory SegmentedJsonExportOptions.fromJson(Map<String, dynamic> json) =>
      _$SegmentedJsonExportOptionsFromJson(json);

  static const toJsonFactory = _$SegmentedJsonExportOptionsToJson;
  Map<String, dynamic> toJson() => _$SegmentedJsonExportOptionsToJson(this);

  @JsonKey(name: 'include_speakers', defaultValue: true)
  final bool? includeSpeakers;
  @JsonKey(name: 'include_timestamps', defaultValue: true)
  final bool? includeTimestamps;
  @JsonKey(name: 'format')
  final String format;
  @JsonKey(name: 'segment_on_silence_longer_than_s')
  final dynamic segmentOnSilenceLongerThanS;
  @JsonKey(name: 'max_segment_duration_s')
  final dynamic maxSegmentDurationS;
  @JsonKey(name: 'max_segment_chars')
  final dynamic maxSegmentChars;
  static const fromJsonFactory = _$SegmentedJsonExportOptionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SegmentedJsonExportOptions &&
            (identical(other.includeSpeakers, includeSpeakers) ||
                const DeepCollectionEquality()
                    .equals(other.includeSpeakers, includeSpeakers)) &&
            (identical(other.includeTimestamps, includeTimestamps) ||
                const DeepCollectionEquality()
                    .equals(other.includeTimestamps, includeTimestamps)) &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)) &&
            (identical(other.segmentOnSilenceLongerThanS,
                    segmentOnSilenceLongerThanS) ||
                const DeepCollectionEquality().equals(
                    other.segmentOnSilenceLongerThanS,
                    segmentOnSilenceLongerThanS)) &&
            (identical(other.maxSegmentDurationS, maxSegmentDurationS) ||
                const DeepCollectionEquality()
                    .equals(other.maxSegmentDurationS, maxSegmentDurationS)) &&
            (identical(other.maxSegmentChars, maxSegmentChars) ||
                const DeepCollectionEquality()
                    .equals(other.maxSegmentChars, maxSegmentChars)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(includeSpeakers) ^
      const DeepCollectionEquality().hash(includeTimestamps) ^
      const DeepCollectionEquality().hash(format) ^
      const DeepCollectionEquality().hash(segmentOnSilenceLongerThanS) ^
      const DeepCollectionEquality().hash(maxSegmentDurationS) ^
      const DeepCollectionEquality().hash(maxSegmentChars) ^
      runtimeType.hashCode;
}

extension $SegmentedJsonExportOptionsExtension on SegmentedJsonExportOptions {
  SegmentedJsonExportOptions copyWith(
      {bool? includeSpeakers,
      bool? includeTimestamps,
      String? format,
      dynamic segmentOnSilenceLongerThanS,
      dynamic maxSegmentDurationS,
      dynamic maxSegmentChars}) {
    return SegmentedJsonExportOptions(
        includeSpeakers: includeSpeakers ?? this.includeSpeakers,
        includeTimestamps: includeTimestamps ?? this.includeTimestamps,
        format: format ?? this.format,
        segmentOnSilenceLongerThanS:
            segmentOnSilenceLongerThanS ?? this.segmentOnSilenceLongerThanS,
        maxSegmentDurationS: maxSegmentDurationS ?? this.maxSegmentDurationS,
        maxSegmentChars: maxSegmentChars ?? this.maxSegmentChars);
  }

  SegmentedJsonExportOptions copyWithWrapped(
      {Wrapped<bool?>? includeSpeakers,
      Wrapped<bool?>? includeTimestamps,
      Wrapped<String>? format,
      Wrapped<dynamic>? segmentOnSilenceLongerThanS,
      Wrapped<dynamic>? maxSegmentDurationS,
      Wrapped<dynamic>? maxSegmentChars}) {
    return SegmentedJsonExportOptions(
        includeSpeakers: (includeSpeakers != null
            ? includeSpeakers.value
            : this.includeSpeakers),
        includeTimestamps: (includeTimestamps != null
            ? includeTimestamps.value
            : this.includeTimestamps),
        format: (format != null ? format.value : this.format),
        segmentOnSilenceLongerThanS: (segmentOnSilenceLongerThanS != null
            ? segmentOnSilenceLongerThanS.value
            : this.segmentOnSilenceLongerThanS),
        maxSegmentDurationS: (maxSegmentDurationS != null
            ? maxSegmentDurationS.value
            : this.maxSegmentDurationS),
        maxSegmentChars: (maxSegmentChars != null
            ? maxSegmentChars.value
            : this.maxSegmentChars));
  }
}

@JsonSerializable(explicitToJson: true)
class ShareOptionResponseModel {
  const ShareOptionResponseModel({
    required this.name,
    required this.id,
    required this.type,
  });

  factory ShareOptionResponseModel.fromJson(Map<String, dynamic> json) =>
      _$ShareOptionResponseModelFromJson(json);

  static const toJsonFactory = _$ShareOptionResponseModelToJson;
  Map<String, dynamic> toJson() => _$ShareOptionResponseModelToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(
    name: 'type',
    toJson: shareOptionResponseModelTypeToJson,
    fromJson: shareOptionResponseModelTypeFromJson,
  )
  final enums.ShareOptionResponseModelType type;
  static const fromJsonFactory = _$ShareOptionResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ShareOptionResponseModel &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $ShareOptionResponseModelExtension on ShareOptionResponseModel {
  ShareOptionResponseModel copyWith(
      {String? name, String? id, enums.ShareOptionResponseModelType? type}) {
    return ShareOptionResponseModel(
        name: name ?? this.name, id: id ?? this.id, type: type ?? this.type);
  }

  ShareOptionResponseModel copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String>? id,
      Wrapped<enums.ShareOptionResponseModelType>? type}) {
    return ShareOptionResponseModel(
        name: (name != null ? name.value : this.name),
        id: (id != null ? id.value : this.id),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class SimilarVoice {
  const SimilarVoice({
    required this.voiceId,
    required this.name,
    required this.category,
    this.description,
    this.previewUrl,
  });

  factory SimilarVoice.fromJson(Map<String, dynamic> json) =>
      _$SimilarVoiceFromJson(json);

  static const toJsonFactory = _$SimilarVoiceToJson;
  Map<String, dynamic> toJson() => _$SimilarVoiceToJson(this);

  @JsonKey(name: 'voice_id')
  final String voiceId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(
    name: 'category',
    toJson: similarVoiceCategoryToJson,
    fromJson: similarVoiceCategoryFromJson,
  )
  final enums.SimilarVoiceCategory category;
  @JsonKey(name: 'description')
  final dynamic description;
  @JsonKey(name: 'preview_url')
  final dynamic previewUrl;
  static const fromJsonFactory = _$SimilarVoiceFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SimilarVoice &&
            (identical(other.voiceId, voiceId) ||
                const DeepCollectionEquality()
                    .equals(other.voiceId, voiceId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.previewUrl, previewUrl) ||
                const DeepCollectionEquality()
                    .equals(other.previewUrl, previewUrl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(voiceId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(previewUrl) ^
      runtimeType.hashCode;
}

extension $SimilarVoiceExtension on SimilarVoice {
  SimilarVoice copyWith(
      {String? voiceId,
      String? name,
      enums.SimilarVoiceCategory? category,
      dynamic description,
      dynamic previewUrl}) {
    return SimilarVoice(
        voiceId: voiceId ?? this.voiceId,
        name: name ?? this.name,
        category: category ?? this.category,
        description: description ?? this.description,
        previewUrl: previewUrl ?? this.previewUrl);
  }

  SimilarVoice copyWithWrapped(
      {Wrapped<String>? voiceId,
      Wrapped<String>? name,
      Wrapped<enums.SimilarVoiceCategory>? category,
      Wrapped<dynamic>? description,
      Wrapped<dynamic>? previewUrl}) {
    return SimilarVoice(
        voiceId: (voiceId != null ? voiceId.value : this.voiceId),
        name: (name != null ? name.value : this.name),
        category: (category != null ? category.value : this.category),
        description:
            (description != null ? description.value : this.description),
        previewUrl: (previewUrl != null ? previewUrl.value : this.previewUrl));
  }
}

@JsonSerializable(explicitToJson: true)
class SimilarVoicesForSpeakerResponse {
  const SimilarVoicesForSpeakerResponse({
    required this.voices,
  });

  factory SimilarVoicesForSpeakerResponse.fromJson(Map<String, dynamic> json) =>
      _$SimilarVoicesForSpeakerResponseFromJson(json);

  static const toJsonFactory = _$SimilarVoicesForSpeakerResponseToJson;
  Map<String, dynamic> toJson() =>
      _$SimilarVoicesForSpeakerResponseToJson(this);

  @JsonKey(name: 'voices', defaultValue: <SimilarVoice>[])
  final List<SimilarVoice> voices;
  static const fromJsonFactory = _$SimilarVoicesForSpeakerResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SimilarVoicesForSpeakerResponse &&
            (identical(other.voices, voices) ||
                const DeepCollectionEquality().equals(other.voices, voices)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(voices) ^ runtimeType.hashCode;
}

extension $SimilarVoicesForSpeakerResponseExtension
    on SimilarVoicesForSpeakerResponse {
  SimilarVoicesForSpeakerResponse copyWith({List<SimilarVoice>? voices}) {
    return SimilarVoicesForSpeakerResponse(voices: voices ?? this.voices);
  }

  SimilarVoicesForSpeakerResponse copyWithWrapped(
      {Wrapped<List<SimilarVoice>>? voices}) {
    return SimilarVoicesForSpeakerResponse(
        voices: (voices != null ? voices.value : this.voices));
  }
}

@JsonSerializable(explicitToJson: true)
class SkipTurnToolConfig {
  const SkipTurnToolConfig({
    this.systemToolType,
  });

  factory SkipTurnToolConfig.fromJson(Map<String, dynamic> json) =>
      _$SkipTurnToolConfigFromJson(json);

  static const toJsonFactory = _$SkipTurnToolConfigToJson;
  Map<String, dynamic> toJson() => _$SkipTurnToolConfigToJson(this);

  @JsonKey(name: 'system_tool_type')
  final String? systemToolType;
  static const fromJsonFactory = _$SkipTurnToolConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SkipTurnToolConfig &&
            (identical(other.systemToolType, systemToolType) ||
                const DeepCollectionEquality()
                    .equals(other.systemToolType, systemToolType)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(systemToolType) ^
      runtimeType.hashCode;
}

extension $SkipTurnToolConfigExtension on SkipTurnToolConfig {
  SkipTurnToolConfig copyWith({String? systemToolType}) {
    return SkipTurnToolConfig(
        systemToolType: systemToolType ?? this.systemToolType);
  }

  SkipTurnToolConfig copyWithWrapped({Wrapped<String?>? systemToolType}) {
    return SkipTurnToolConfig(
        systemToolType: (systemToolType != null
            ? systemToolType.value
            : this.systemToolType));
  }
}

@JsonSerializable(explicitToJson: true)
class SpeakerAudioResponseModel {
  const SpeakerAudioResponseModel({
    required this.audioBase64,
    required this.mediaType,
    required this.durationSecs,
  });

  factory SpeakerAudioResponseModel.fromJson(Map<String, dynamic> json) =>
      _$SpeakerAudioResponseModelFromJson(json);

  static const toJsonFactory = _$SpeakerAudioResponseModelToJson;
  Map<String, dynamic> toJson() => _$SpeakerAudioResponseModelToJson(this);

  @JsonKey(name: 'audio_base_64')
  final String audioBase64;
  @JsonKey(name: 'media_type')
  final String mediaType;
  @JsonKey(name: 'duration_secs')
  final double durationSecs;
  static const fromJsonFactory = _$SpeakerAudioResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SpeakerAudioResponseModel &&
            (identical(other.audioBase64, audioBase64) ||
                const DeepCollectionEquality()
                    .equals(other.audioBase64, audioBase64)) &&
            (identical(other.mediaType, mediaType) ||
                const DeepCollectionEquality()
                    .equals(other.mediaType, mediaType)) &&
            (identical(other.durationSecs, durationSecs) ||
                const DeepCollectionEquality()
                    .equals(other.durationSecs, durationSecs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(audioBase64) ^
      const DeepCollectionEquality().hash(mediaType) ^
      const DeepCollectionEquality().hash(durationSecs) ^
      runtimeType.hashCode;
}

extension $SpeakerAudioResponseModelExtension on SpeakerAudioResponseModel {
  SpeakerAudioResponseModel copyWith(
      {String? audioBase64, String? mediaType, double? durationSecs}) {
    return SpeakerAudioResponseModel(
        audioBase64: audioBase64 ?? this.audioBase64,
        mediaType: mediaType ?? this.mediaType,
        durationSecs: durationSecs ?? this.durationSecs);
  }

  SpeakerAudioResponseModel copyWithWrapped(
      {Wrapped<String>? audioBase64,
      Wrapped<String>? mediaType,
      Wrapped<double>? durationSecs}) {
    return SpeakerAudioResponseModel(
        audioBase64:
            (audioBase64 != null ? audioBase64.value : this.audioBase64),
        mediaType: (mediaType != null ? mediaType.value : this.mediaType),
        durationSecs:
            (durationSecs != null ? durationSecs.value : this.durationSecs));
  }
}

@JsonSerializable(explicitToJson: true)
class SpeakerResponseModel {
  const SpeakerResponseModel({
    required this.speakerId,
    required this.durationSecs,
    this.utterances,
  });

  factory SpeakerResponseModel.fromJson(Map<String, dynamic> json) =>
      _$SpeakerResponseModelFromJson(json);

  static const toJsonFactory = _$SpeakerResponseModelToJson;
  Map<String, dynamic> toJson() => _$SpeakerResponseModelToJson(this);

  @JsonKey(name: 'speaker_id')
  final String speakerId;
  @JsonKey(name: 'duration_secs')
  final double durationSecs;
  @JsonKey(name: 'utterances')
  final dynamic utterances;
  static const fromJsonFactory = _$SpeakerResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SpeakerResponseModel &&
            (identical(other.speakerId, speakerId) ||
                const DeepCollectionEquality()
                    .equals(other.speakerId, speakerId)) &&
            (identical(other.durationSecs, durationSecs) ||
                const DeepCollectionEquality()
                    .equals(other.durationSecs, durationSecs)) &&
            (identical(other.utterances, utterances) ||
                const DeepCollectionEquality()
                    .equals(other.utterances, utterances)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(speakerId) ^
      const DeepCollectionEquality().hash(durationSecs) ^
      const DeepCollectionEquality().hash(utterances) ^
      runtimeType.hashCode;
}

extension $SpeakerResponseModelExtension on SpeakerResponseModel {
  SpeakerResponseModel copyWith(
      {String? speakerId, double? durationSecs, dynamic utterances}) {
    return SpeakerResponseModel(
        speakerId: speakerId ?? this.speakerId,
        durationSecs: durationSecs ?? this.durationSecs,
        utterances: utterances ?? this.utterances);
  }

  SpeakerResponseModel copyWithWrapped(
      {Wrapped<String>? speakerId,
      Wrapped<double>? durationSecs,
      Wrapped<dynamic>? utterances}) {
    return SpeakerResponseModel(
        speakerId: (speakerId != null ? speakerId.value : this.speakerId),
        durationSecs:
            (durationSecs != null ? durationSecs.value : this.durationSecs),
        utterances: (utterances != null ? utterances.value : this.utterances));
  }
}

@JsonSerializable(explicitToJson: true)
class SpeakerSegment {
  const SpeakerSegment({
    required this.id,
    required this.startTime,
    required this.endTime,
    required this.text,
    required this.dubs,
  });

  factory SpeakerSegment.fromJson(Map<String, dynamic> json) =>
      _$SpeakerSegmentFromJson(json);

  static const toJsonFactory = _$SpeakerSegmentToJson;
  Map<String, dynamic> toJson() => _$SpeakerSegmentToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'start_time')
  final double startTime;
  @JsonKey(name: 'end_time')
  final double endTime;
  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'dubs')
  final Map<String, dynamic> dubs;
  static const fromJsonFactory = _$SpeakerSegmentFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SpeakerSegment &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.startTime, startTime) ||
                const DeepCollectionEquality()
                    .equals(other.startTime, startTime)) &&
            (identical(other.endTime, endTime) ||
                const DeepCollectionEquality()
                    .equals(other.endTime, endTime)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.dubs, dubs) ||
                const DeepCollectionEquality().equals(other.dubs, dubs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(startTime) ^
      const DeepCollectionEquality().hash(endTime) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(dubs) ^
      runtimeType.hashCode;
}

extension $SpeakerSegmentExtension on SpeakerSegment {
  SpeakerSegment copyWith(
      {String? id,
      double? startTime,
      double? endTime,
      String? text,
      Map<String, dynamic>? dubs}) {
    return SpeakerSegment(
        id: id ?? this.id,
        startTime: startTime ?? this.startTime,
        endTime: endTime ?? this.endTime,
        text: text ?? this.text,
        dubs: dubs ?? this.dubs);
  }

  SpeakerSegment copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<double>? startTime,
      Wrapped<double>? endTime,
      Wrapped<String>? text,
      Wrapped<Map<String, dynamic>>? dubs}) {
    return SpeakerSegment(
        id: (id != null ? id.value : this.id),
        startTime: (startTime != null ? startTime.value : this.startTime),
        endTime: (endTime != null ? endTime.value : this.endTime),
        text: (text != null ? text.value : this.text),
        dubs: (dubs != null ? dubs.value : this.dubs));
  }
}

@JsonSerializable(explicitToJson: true)
class SpeakerSeparationResponseModel {
  const SpeakerSeparationResponseModel({
    required this.voiceId,
    required this.sampleId,
    required this.status,
    this.speakers,
    this.selectedSpeakerIds,
  });

  factory SpeakerSeparationResponseModel.fromJson(Map<String, dynamic> json) =>
      _$SpeakerSeparationResponseModelFromJson(json);

  static const toJsonFactory = _$SpeakerSeparationResponseModelToJson;
  Map<String, dynamic> toJson() => _$SpeakerSeparationResponseModelToJson(this);

  @JsonKey(name: 'voice_id')
  final String voiceId;
  @JsonKey(name: 'sample_id')
  final String sampleId;
  @JsonKey(
    name: 'status',
    toJson: speakerSeparationResponseModelStatusToJson,
    fromJson: speakerSeparationResponseModelStatusFromJson,
  )
  final enums.SpeakerSeparationResponseModelStatus status;
  @JsonKey(name: 'speakers')
  final dynamic speakers;
  @JsonKey(name: 'selected_speaker_ids')
  final dynamic selectedSpeakerIds;
  static const fromJsonFactory = _$SpeakerSeparationResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SpeakerSeparationResponseModel &&
            (identical(other.voiceId, voiceId) ||
                const DeepCollectionEquality()
                    .equals(other.voiceId, voiceId)) &&
            (identical(other.sampleId, sampleId) ||
                const DeepCollectionEquality()
                    .equals(other.sampleId, sampleId)) &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.speakers, speakers) ||
                const DeepCollectionEquality()
                    .equals(other.speakers, speakers)) &&
            (identical(other.selectedSpeakerIds, selectedSpeakerIds) ||
                const DeepCollectionEquality()
                    .equals(other.selectedSpeakerIds, selectedSpeakerIds)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(voiceId) ^
      const DeepCollectionEquality().hash(sampleId) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(speakers) ^
      const DeepCollectionEquality().hash(selectedSpeakerIds) ^
      runtimeType.hashCode;
}

extension $SpeakerSeparationResponseModelExtension
    on SpeakerSeparationResponseModel {
  SpeakerSeparationResponseModel copyWith(
      {String? voiceId,
      String? sampleId,
      enums.SpeakerSeparationResponseModelStatus? status,
      dynamic speakers,
      dynamic selectedSpeakerIds}) {
    return SpeakerSeparationResponseModel(
        voiceId: voiceId ?? this.voiceId,
        sampleId: sampleId ?? this.sampleId,
        status: status ?? this.status,
        speakers: speakers ?? this.speakers,
        selectedSpeakerIds: selectedSpeakerIds ?? this.selectedSpeakerIds);
  }

  SpeakerSeparationResponseModel copyWithWrapped(
      {Wrapped<String>? voiceId,
      Wrapped<String>? sampleId,
      Wrapped<enums.SpeakerSeparationResponseModelStatus>? status,
      Wrapped<dynamic>? speakers,
      Wrapped<dynamic>? selectedSpeakerIds}) {
    return SpeakerSeparationResponseModel(
        voiceId: (voiceId != null ? voiceId.value : this.voiceId),
        sampleId: (sampleId != null ? sampleId.value : this.sampleId),
        status: (status != null ? status.value : this.status),
        speakers: (speakers != null ? speakers.value : this.speakers),
        selectedSpeakerIds: (selectedSpeakerIds != null
            ? selectedSpeakerIds.value
            : this.selectedSpeakerIds));
  }
}

@JsonSerializable(explicitToJson: true)
class SpeakerTrack {
  const SpeakerTrack({
    required this.id,
    required this.mediaRef,
    required this.speakerName,
    required this.voices,
    required this.segments,
  });

  factory SpeakerTrack.fromJson(Map<String, dynamic> json) =>
      _$SpeakerTrackFromJson(json);

  static const toJsonFactory = _$SpeakerTrackToJson;
  Map<String, dynamic> toJson() => _$SpeakerTrackToJson(this);

  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'media_ref')
  final DubbingMediaReference mediaRef;
  @JsonKey(name: 'speaker_name')
  final String speakerName;
  @JsonKey(name: 'voices')
  final Map<String, dynamic> voices;
  @JsonKey(name: 'segments', defaultValue: <String>[])
  final List<String> segments;
  static const fromJsonFactory = _$SpeakerTrackFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SpeakerTrack &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.mediaRef, mediaRef) ||
                const DeepCollectionEquality()
                    .equals(other.mediaRef, mediaRef)) &&
            (identical(other.speakerName, speakerName) ||
                const DeepCollectionEquality()
                    .equals(other.speakerName, speakerName)) &&
            (identical(other.voices, voices) ||
                const DeepCollectionEquality().equals(other.voices, voices)) &&
            (identical(other.segments, segments) ||
                const DeepCollectionEquality()
                    .equals(other.segments, segments)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(mediaRef) ^
      const DeepCollectionEquality().hash(speakerName) ^
      const DeepCollectionEquality().hash(voices) ^
      const DeepCollectionEquality().hash(segments) ^
      runtimeType.hashCode;
}

extension $SpeakerTrackExtension on SpeakerTrack {
  SpeakerTrack copyWith(
      {String? id,
      DubbingMediaReference? mediaRef,
      String? speakerName,
      Map<String, dynamic>? voices,
      List<String>? segments}) {
    return SpeakerTrack(
        id: id ?? this.id,
        mediaRef: mediaRef ?? this.mediaRef,
        speakerName: speakerName ?? this.speakerName,
        voices: voices ?? this.voices,
        segments: segments ?? this.segments);
  }

  SpeakerTrack copyWithWrapped(
      {Wrapped<String>? id,
      Wrapped<DubbingMediaReference>? mediaRef,
      Wrapped<String>? speakerName,
      Wrapped<Map<String, dynamic>>? voices,
      Wrapped<List<String>>? segments}) {
    return SpeakerTrack(
        id: (id != null ? id.value : this.id),
        mediaRef: (mediaRef != null ? mediaRef.value : this.mediaRef),
        speakerName:
            (speakerName != null ? speakerName.value : this.speakerName),
        voices: (voices != null ? voices.value : this.voices),
        segments: (segments != null ? segments.value : this.segments));
  }
}

@JsonSerializable(explicitToJson: true)
class SpeakerUpdatedResponse {
  const SpeakerUpdatedResponse({
    required this.version,
  });

  factory SpeakerUpdatedResponse.fromJson(Map<String, dynamic> json) =>
      _$SpeakerUpdatedResponseFromJson(json);

  static const toJsonFactory = _$SpeakerUpdatedResponseToJson;
  Map<String, dynamic> toJson() => _$SpeakerUpdatedResponseToJson(this);

  @JsonKey(name: 'version')
  final int version;
  static const fromJsonFactory = _$SpeakerUpdatedResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SpeakerUpdatedResponse &&
            (identical(other.version, version) ||
                const DeepCollectionEquality().equals(other.version, version)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(version) ^ runtimeType.hashCode;
}

extension $SpeakerUpdatedResponseExtension on SpeakerUpdatedResponse {
  SpeakerUpdatedResponse copyWith({int? version}) {
    return SpeakerUpdatedResponse(version: version ?? this.version);
  }

  SpeakerUpdatedResponse copyWithWrapped({Wrapped<int>? version}) {
    return SpeakerUpdatedResponse(
        version: (version != null ? version.value : this.version));
  }
}

@JsonSerializable(explicitToJson: true)
class SpeechHistoryItemResponseModel {
  const SpeechHistoryItemResponseModel({
    required this.historyItemId,
    this.requestId,
    this.voiceId,
    this.modelId,
    this.voiceName,
    this.voiceCategory,
    this.text,
    required this.dateUnix,
    required this.characterCountChangeFrom,
    required this.characterCountChangeTo,
    required this.contentType,
    required this.state,
    this.settings,
    this.feedback,
    this.shareLinkId,
    this.source,
    this.alignments,
    this.dialogue,
  });

  factory SpeechHistoryItemResponseModel.fromJson(Map<String, dynamic> json) =>
      _$SpeechHistoryItemResponseModelFromJson(json);

  static const toJsonFactory = _$SpeechHistoryItemResponseModelToJson;
  Map<String, dynamic> toJson() => _$SpeechHistoryItemResponseModelToJson(this);

  @JsonKey(name: 'history_item_id')
  final String historyItemId;
  @JsonKey(name: 'request_id')
  final dynamic requestId;
  @JsonKey(name: 'voice_id')
  final dynamic voiceId;
  @JsonKey(name: 'model_id')
  final dynamic modelId;
  @JsonKey(name: 'voice_name')
  final dynamic voiceName;
  @JsonKey(name: 'voice_category')
  final dynamic voiceCategory;
  @JsonKey(name: 'text')
  final dynamic text;
  @JsonKey(name: 'date_unix')
  final int dateUnix;
  @JsonKey(name: 'character_count_change_from')
  final int characterCountChangeFrom;
  @JsonKey(name: 'character_count_change_to')
  final int characterCountChangeTo;
  @JsonKey(name: 'content_type')
  final String contentType;
  @JsonKey(
    name: 'state',
    toJson: speechHistoryItemResponseModelStateToJson,
    fromJson: speechHistoryItemResponseModelStateFromJson,
  )
  final enums.SpeechHistoryItemResponseModelState state;
  @JsonKey(name: 'settings')
  final dynamic settings;
  @JsonKey(name: 'feedback')
  final dynamic feedback;
  @JsonKey(name: 'share_link_id')
  final dynamic shareLinkId;
  @JsonKey(name: 'source')
  final dynamic source;
  @JsonKey(name: 'alignments')
  final dynamic alignments;
  @JsonKey(name: 'dialogue')
  final dynamic dialogue;
  static const fromJsonFactory = _$SpeechHistoryItemResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SpeechHistoryItemResponseModel &&
            (identical(other.historyItemId, historyItemId) ||
                const DeepCollectionEquality()
                    .equals(other.historyItemId, historyItemId)) &&
            (identical(other.requestId, requestId) ||
                const DeepCollectionEquality()
                    .equals(other.requestId, requestId)) &&
            (identical(other.voiceId, voiceId) ||
                const DeepCollectionEquality()
                    .equals(other.voiceId, voiceId)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.voiceName, voiceName) ||
                const DeepCollectionEquality()
                    .equals(other.voiceName, voiceName)) &&
            (identical(other.voiceCategory, voiceCategory) ||
                const DeepCollectionEquality()
                    .equals(other.voiceCategory, voiceCategory)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.dateUnix, dateUnix) ||
                const DeepCollectionEquality()
                    .equals(other.dateUnix, dateUnix)) &&
            (identical(
                    other.characterCountChangeFrom, characterCountChangeFrom) ||
                const DeepCollectionEquality().equals(
                    other.characterCountChangeFrom,
                    characterCountChangeFrom)) &&
            (identical(other.characterCountChangeTo, characterCountChangeTo) ||
                const DeepCollectionEquality().equals(
                    other.characterCountChangeTo, characterCountChangeTo)) &&
            (identical(other.contentType, contentType) ||
                const DeepCollectionEquality()
                    .equals(other.contentType, contentType)) &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)) &&
            (identical(other.settings, settings) ||
                const DeepCollectionEquality()
                    .equals(other.settings, settings)) &&
            (identical(other.feedback, feedback) ||
                const DeepCollectionEquality()
                    .equals(other.feedback, feedback)) &&
            (identical(other.shareLinkId, shareLinkId) ||
                const DeepCollectionEquality()
                    .equals(other.shareLinkId, shareLinkId)) &&
            (identical(other.source, source) ||
                const DeepCollectionEquality().equals(other.source, source)) &&
            (identical(other.alignments, alignments) ||
                const DeepCollectionEquality()
                    .equals(other.alignments, alignments)) &&
            (identical(other.dialogue, dialogue) ||
                const DeepCollectionEquality()
                    .equals(other.dialogue, dialogue)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(historyItemId) ^
      const DeepCollectionEquality().hash(requestId) ^
      const DeepCollectionEquality().hash(voiceId) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(voiceName) ^
      const DeepCollectionEquality().hash(voiceCategory) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(dateUnix) ^
      const DeepCollectionEquality().hash(characterCountChangeFrom) ^
      const DeepCollectionEquality().hash(characterCountChangeTo) ^
      const DeepCollectionEquality().hash(contentType) ^
      const DeepCollectionEquality().hash(state) ^
      const DeepCollectionEquality().hash(settings) ^
      const DeepCollectionEquality().hash(feedback) ^
      const DeepCollectionEquality().hash(shareLinkId) ^
      const DeepCollectionEquality().hash(source) ^
      const DeepCollectionEquality().hash(alignments) ^
      const DeepCollectionEquality().hash(dialogue) ^
      runtimeType.hashCode;
}

extension $SpeechHistoryItemResponseModelExtension
    on SpeechHistoryItemResponseModel {
  SpeechHistoryItemResponseModel copyWith(
      {String? historyItemId,
      dynamic requestId,
      dynamic voiceId,
      dynamic modelId,
      dynamic voiceName,
      dynamic voiceCategory,
      dynamic text,
      int? dateUnix,
      int? characterCountChangeFrom,
      int? characterCountChangeTo,
      String? contentType,
      enums.SpeechHistoryItemResponseModelState? state,
      dynamic settings,
      dynamic feedback,
      dynamic shareLinkId,
      dynamic source,
      dynamic alignments,
      dynamic dialogue}) {
    return SpeechHistoryItemResponseModel(
        historyItemId: historyItemId ?? this.historyItemId,
        requestId: requestId ?? this.requestId,
        voiceId: voiceId ?? this.voiceId,
        modelId: modelId ?? this.modelId,
        voiceName: voiceName ?? this.voiceName,
        voiceCategory: voiceCategory ?? this.voiceCategory,
        text: text ?? this.text,
        dateUnix: dateUnix ?? this.dateUnix,
        characterCountChangeFrom:
            characterCountChangeFrom ?? this.characterCountChangeFrom,
        characterCountChangeTo:
            characterCountChangeTo ?? this.characterCountChangeTo,
        contentType: contentType ?? this.contentType,
        state: state ?? this.state,
        settings: settings ?? this.settings,
        feedback: feedback ?? this.feedback,
        shareLinkId: shareLinkId ?? this.shareLinkId,
        source: source ?? this.source,
        alignments: alignments ?? this.alignments,
        dialogue: dialogue ?? this.dialogue);
  }

  SpeechHistoryItemResponseModel copyWithWrapped(
      {Wrapped<String>? historyItemId,
      Wrapped<dynamic>? requestId,
      Wrapped<dynamic>? voiceId,
      Wrapped<dynamic>? modelId,
      Wrapped<dynamic>? voiceName,
      Wrapped<dynamic>? voiceCategory,
      Wrapped<dynamic>? text,
      Wrapped<int>? dateUnix,
      Wrapped<int>? characterCountChangeFrom,
      Wrapped<int>? characterCountChangeTo,
      Wrapped<String>? contentType,
      Wrapped<enums.SpeechHistoryItemResponseModelState>? state,
      Wrapped<dynamic>? settings,
      Wrapped<dynamic>? feedback,
      Wrapped<dynamic>? shareLinkId,
      Wrapped<dynamic>? source,
      Wrapped<dynamic>? alignments,
      Wrapped<dynamic>? dialogue}) {
    return SpeechHistoryItemResponseModel(
        historyItemId:
            (historyItemId != null ? historyItemId.value : this.historyItemId),
        requestId: (requestId != null ? requestId.value : this.requestId),
        voiceId: (voiceId != null ? voiceId.value : this.voiceId),
        modelId: (modelId != null ? modelId.value : this.modelId),
        voiceName: (voiceName != null ? voiceName.value : this.voiceName),
        voiceCategory:
            (voiceCategory != null ? voiceCategory.value : this.voiceCategory),
        text: (text != null ? text.value : this.text),
        dateUnix: (dateUnix != null ? dateUnix.value : this.dateUnix),
        characterCountChangeFrom: (characterCountChangeFrom != null
            ? characterCountChangeFrom.value
            : this.characterCountChangeFrom),
        characterCountChangeTo: (characterCountChangeTo != null
            ? characterCountChangeTo.value
            : this.characterCountChangeTo),
        contentType:
            (contentType != null ? contentType.value : this.contentType),
        state: (state != null ? state.value : this.state),
        settings: (settings != null ? settings.value : this.settings),
        feedback: (feedback != null ? feedback.value : this.feedback),
        shareLinkId:
            (shareLinkId != null ? shareLinkId.value : this.shareLinkId),
        source: (source != null ? source.value : this.source),
        alignments: (alignments != null ? alignments.value : this.alignments),
        dialogue: (dialogue != null ? dialogue.value : this.dialogue));
  }
}

@JsonSerializable(explicitToJson: true)
class SpeechToTextCharacterResponseModel {
  const SpeechToTextCharacterResponseModel({
    required this.text,
    this.start,
    this.end,
  });

  factory SpeechToTextCharacterResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$SpeechToTextCharacterResponseModelFromJson(json);

  static const toJsonFactory = _$SpeechToTextCharacterResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$SpeechToTextCharacterResponseModelToJson(this);

  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'start')
  final dynamic start;
  @JsonKey(name: 'end')
  final dynamic end;
  static const fromJsonFactory = _$SpeechToTextCharacterResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SpeechToTextCharacterResponseModel &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.start, start) ||
                const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) ||
                const DeepCollectionEquality().equals(other.end, end)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      runtimeType.hashCode;
}

extension $SpeechToTextCharacterResponseModelExtension
    on SpeechToTextCharacterResponseModel {
  SpeechToTextCharacterResponseModel copyWith(
      {String? text, dynamic start, dynamic end}) {
    return SpeechToTextCharacterResponseModel(
        text: text ?? this.text,
        start: start ?? this.start,
        end: end ?? this.end);
  }

  SpeechToTextCharacterResponseModel copyWithWrapped(
      {Wrapped<String>? text, Wrapped<dynamic>? start, Wrapped<dynamic>? end}) {
    return SpeechToTextCharacterResponseModel(
        text: (text != null ? text.value : this.text),
        start: (start != null ? start.value : this.start),
        end: (end != null ? end.value : this.end));
  }
}

@JsonSerializable(explicitToJson: true)
class SpeechToTextChunkResponseModel {
  const SpeechToTextChunkResponseModel({
    required this.languageCode,
    required this.languageProbability,
    required this.text,
    required this.words,
    this.additionalFormats,
  });

  factory SpeechToTextChunkResponseModel.fromJson(Map<String, dynamic> json) =>
      _$SpeechToTextChunkResponseModelFromJson(json);

  static const toJsonFactory = _$SpeechToTextChunkResponseModelToJson;
  Map<String, dynamic> toJson() => _$SpeechToTextChunkResponseModelToJson(this);

  @JsonKey(name: 'language_code')
  final String languageCode;
  @JsonKey(name: 'language_probability')
  final double languageProbability;
  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'words', defaultValue: <SpeechToTextWordResponseModel>[])
  final List<SpeechToTextWordResponseModel> words;
  @JsonKey(name: 'additional_formats')
  final dynamic additionalFormats;
  static const fromJsonFactory = _$SpeechToTextChunkResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SpeechToTextChunkResponseModel &&
            (identical(other.languageCode, languageCode) ||
                const DeepCollectionEquality()
                    .equals(other.languageCode, languageCode)) &&
            (identical(other.languageProbability, languageProbability) ||
                const DeepCollectionEquality()
                    .equals(other.languageProbability, languageProbability)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.words, words) ||
                const DeepCollectionEquality().equals(other.words, words)) &&
            (identical(other.additionalFormats, additionalFormats) ||
                const DeepCollectionEquality()
                    .equals(other.additionalFormats, additionalFormats)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(languageCode) ^
      const DeepCollectionEquality().hash(languageProbability) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(words) ^
      const DeepCollectionEquality().hash(additionalFormats) ^
      runtimeType.hashCode;
}

extension $SpeechToTextChunkResponseModelExtension
    on SpeechToTextChunkResponseModel {
  SpeechToTextChunkResponseModel copyWith(
      {String? languageCode,
      double? languageProbability,
      String? text,
      List<SpeechToTextWordResponseModel>? words,
      dynamic additionalFormats}) {
    return SpeechToTextChunkResponseModel(
        languageCode: languageCode ?? this.languageCode,
        languageProbability: languageProbability ?? this.languageProbability,
        text: text ?? this.text,
        words: words ?? this.words,
        additionalFormats: additionalFormats ?? this.additionalFormats);
  }

  SpeechToTextChunkResponseModel copyWithWrapped(
      {Wrapped<String>? languageCode,
      Wrapped<double>? languageProbability,
      Wrapped<String>? text,
      Wrapped<List<SpeechToTextWordResponseModel>>? words,
      Wrapped<dynamic>? additionalFormats}) {
    return SpeechToTextChunkResponseModel(
        languageCode:
            (languageCode != null ? languageCode.value : this.languageCode),
        languageProbability: (languageProbability != null
            ? languageProbability.value
            : this.languageProbability),
        text: (text != null ? text.value : this.text),
        words: (words != null ? words.value : this.words),
        additionalFormats: (additionalFormats != null
            ? additionalFormats.value
            : this.additionalFormats));
  }
}

@JsonSerializable(explicitToJson: true)
class SpeechToTextWordResponseModel {
  const SpeechToTextWordResponseModel({
    required this.text,
    this.start,
    this.end,
    required this.type,
    this.speakerId,
    required this.logprob,
    this.characters,
  });

  factory SpeechToTextWordResponseModel.fromJson(Map<String, dynamic> json) =>
      _$SpeechToTextWordResponseModelFromJson(json);

  static const toJsonFactory = _$SpeechToTextWordResponseModelToJson;
  Map<String, dynamic> toJson() => _$SpeechToTextWordResponseModelToJson(this);

  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'start')
  final dynamic start;
  @JsonKey(name: 'end')
  final dynamic end;
  @JsonKey(
    name: 'type',
    toJson: speechToTextWordResponseModelTypeToJson,
    fromJson: speechToTextWordResponseModelTypeFromJson,
  )
  final enums.SpeechToTextWordResponseModelType type;
  @JsonKey(name: 'speaker_id')
  final dynamic speakerId;
  @JsonKey(name: 'logprob')
  final double logprob;
  @JsonKey(name: 'characters')
  final dynamic characters;
  static const fromJsonFactory = _$SpeechToTextWordResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SpeechToTextWordResponseModel &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.start, start) ||
                const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) ||
                const DeepCollectionEquality().equals(other.end, end)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.speakerId, speakerId) ||
                const DeepCollectionEquality()
                    .equals(other.speakerId, speakerId)) &&
            (identical(other.logprob, logprob) ||
                const DeepCollectionEquality()
                    .equals(other.logprob, logprob)) &&
            (identical(other.characters, characters) ||
                const DeepCollectionEquality()
                    .equals(other.characters, characters)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(speakerId) ^
      const DeepCollectionEquality().hash(logprob) ^
      const DeepCollectionEquality().hash(characters) ^
      runtimeType.hashCode;
}

extension $SpeechToTextWordResponseModelExtension
    on SpeechToTextWordResponseModel {
  SpeechToTextWordResponseModel copyWith(
      {String? text,
      dynamic start,
      dynamic end,
      enums.SpeechToTextWordResponseModelType? type,
      dynamic speakerId,
      double? logprob,
      dynamic characters}) {
    return SpeechToTextWordResponseModel(
        text: text ?? this.text,
        start: start ?? this.start,
        end: end ?? this.end,
        type: type ?? this.type,
        speakerId: speakerId ?? this.speakerId,
        logprob: logprob ?? this.logprob,
        characters: characters ?? this.characters);
  }

  SpeechToTextWordResponseModel copyWithWrapped(
      {Wrapped<String>? text,
      Wrapped<dynamic>? start,
      Wrapped<dynamic>? end,
      Wrapped<enums.SpeechToTextWordResponseModelType>? type,
      Wrapped<dynamic>? speakerId,
      Wrapped<double>? logprob,
      Wrapped<dynamic>? characters}) {
    return SpeechToTextWordResponseModel(
        text: (text != null ? text.value : this.text),
        start: (start != null ? start.value : this.start),
        end: (end != null ? end.value : this.end),
        type: (type != null ? type.value : this.type),
        speakerId: (speakerId != null ? speakerId.value : this.speakerId),
        logprob: (logprob != null ? logprob.value : this.logprob),
        characters: (characters != null ? characters.value : this.characters));
  }
}

@JsonSerializable(explicitToJson: true)
class SrtExportOptions {
  const SrtExportOptions({
    this.maxCharactersPerLine,
    this.includeSpeakers,
    this.includeTimestamps,
    required this.format,
    this.segmentOnSilenceLongerThanS,
    this.maxSegmentDurationS,
    this.maxSegmentChars,
  });

  factory SrtExportOptions.fromJson(Map<String, dynamic> json) =>
      _$SrtExportOptionsFromJson(json);

  static const toJsonFactory = _$SrtExportOptionsToJson;
  Map<String, dynamic> toJson() => _$SrtExportOptionsToJson(this);

  @JsonKey(name: 'max_characters_per_line')
  final dynamic maxCharactersPerLine;
  @JsonKey(name: 'include_speakers', defaultValue: false)
  final bool? includeSpeakers;
  @JsonKey(name: 'include_timestamps', defaultValue: true)
  final bool? includeTimestamps;
  @JsonKey(name: 'format')
  final String format;
  @JsonKey(name: 'segment_on_silence_longer_than_s')
  final dynamic segmentOnSilenceLongerThanS;
  @JsonKey(name: 'max_segment_duration_s')
  final dynamic maxSegmentDurationS;
  @JsonKey(name: 'max_segment_chars')
  final dynamic maxSegmentChars;
  static const fromJsonFactory = _$SrtExportOptionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SrtExportOptions &&
            (identical(other.maxCharactersPerLine, maxCharactersPerLine) ||
                const DeepCollectionEquality().equals(
                    other.maxCharactersPerLine, maxCharactersPerLine)) &&
            (identical(other.includeSpeakers, includeSpeakers) ||
                const DeepCollectionEquality()
                    .equals(other.includeSpeakers, includeSpeakers)) &&
            (identical(other.includeTimestamps, includeTimestamps) ||
                const DeepCollectionEquality()
                    .equals(other.includeTimestamps, includeTimestamps)) &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)) &&
            (identical(other.segmentOnSilenceLongerThanS,
                    segmentOnSilenceLongerThanS) ||
                const DeepCollectionEquality().equals(
                    other.segmentOnSilenceLongerThanS,
                    segmentOnSilenceLongerThanS)) &&
            (identical(other.maxSegmentDurationS, maxSegmentDurationS) ||
                const DeepCollectionEquality()
                    .equals(other.maxSegmentDurationS, maxSegmentDurationS)) &&
            (identical(other.maxSegmentChars, maxSegmentChars) ||
                const DeepCollectionEquality()
                    .equals(other.maxSegmentChars, maxSegmentChars)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(maxCharactersPerLine) ^
      const DeepCollectionEquality().hash(includeSpeakers) ^
      const DeepCollectionEquality().hash(includeTimestamps) ^
      const DeepCollectionEquality().hash(format) ^
      const DeepCollectionEquality().hash(segmentOnSilenceLongerThanS) ^
      const DeepCollectionEquality().hash(maxSegmentDurationS) ^
      const DeepCollectionEquality().hash(maxSegmentChars) ^
      runtimeType.hashCode;
}

extension $SrtExportOptionsExtension on SrtExportOptions {
  SrtExportOptions copyWith(
      {dynamic maxCharactersPerLine,
      bool? includeSpeakers,
      bool? includeTimestamps,
      String? format,
      dynamic segmentOnSilenceLongerThanS,
      dynamic maxSegmentDurationS,
      dynamic maxSegmentChars}) {
    return SrtExportOptions(
        maxCharactersPerLine: maxCharactersPerLine ?? this.maxCharactersPerLine,
        includeSpeakers: includeSpeakers ?? this.includeSpeakers,
        includeTimestamps: includeTimestamps ?? this.includeTimestamps,
        format: format ?? this.format,
        segmentOnSilenceLongerThanS:
            segmentOnSilenceLongerThanS ?? this.segmentOnSilenceLongerThanS,
        maxSegmentDurationS: maxSegmentDurationS ?? this.maxSegmentDurationS,
        maxSegmentChars: maxSegmentChars ?? this.maxSegmentChars);
  }

  SrtExportOptions copyWithWrapped(
      {Wrapped<dynamic>? maxCharactersPerLine,
      Wrapped<bool?>? includeSpeakers,
      Wrapped<bool?>? includeTimestamps,
      Wrapped<String>? format,
      Wrapped<dynamic>? segmentOnSilenceLongerThanS,
      Wrapped<dynamic>? maxSegmentDurationS,
      Wrapped<dynamic>? maxSegmentChars}) {
    return SrtExportOptions(
        maxCharactersPerLine: (maxCharactersPerLine != null
            ? maxCharactersPerLine.value
            : this.maxCharactersPerLine),
        includeSpeakers: (includeSpeakers != null
            ? includeSpeakers.value
            : this.includeSpeakers),
        includeTimestamps: (includeTimestamps != null
            ? includeTimestamps.value
            : this.includeTimestamps),
        format: (format != null ? format.value : this.format),
        segmentOnSilenceLongerThanS: (segmentOnSilenceLongerThanS != null
            ? segmentOnSilenceLongerThanS.value
            : this.segmentOnSilenceLongerThanS),
        maxSegmentDurationS: (maxSegmentDurationS != null
            ? maxSegmentDurationS.value
            : this.maxSegmentDurationS),
        maxSegmentChars: (maxSegmentChars != null
            ? maxSegmentChars.value
            : this.maxSegmentChars));
  }
}

@JsonSerializable(explicitToJson: true)
class StartPVCVoiceTrainingResponseModel {
  const StartPVCVoiceTrainingResponseModel({
    required this.status,
  });

  factory StartPVCVoiceTrainingResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$StartPVCVoiceTrainingResponseModelFromJson(json);

  static const toJsonFactory = _$StartPVCVoiceTrainingResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$StartPVCVoiceTrainingResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$StartPVCVoiceTrainingResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StartPVCVoiceTrainingResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $StartPVCVoiceTrainingResponseModelExtension
    on StartPVCVoiceTrainingResponseModel {
  StartPVCVoiceTrainingResponseModel copyWith({String? status}) {
    return StartPVCVoiceTrainingResponseModel(status: status ?? this.status);
  }

  StartPVCVoiceTrainingResponseModel copyWithWrapped(
      {Wrapped<String>? status}) {
    return StartPVCVoiceTrainingResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class StartSpeakerSeparationResponseModel {
  const StartSpeakerSeparationResponseModel({
    required this.status,
  });

  factory StartSpeakerSeparationResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$StartSpeakerSeparationResponseModelFromJson(json);

  static const toJsonFactory = _$StartSpeakerSeparationResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$StartSpeakerSeparationResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$StartSpeakerSeparationResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StartSpeakerSeparationResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $StartSpeakerSeparationResponseModelExtension
    on StartSpeakerSeparationResponseModel {
  StartSpeakerSeparationResponseModel copyWith({String? status}) {
    return StartSpeakerSeparationResponseModel(status: status ?? this.status);
  }

  StartSpeakerSeparationResponseModel copyWithWrapped(
      {Wrapped<String>? status}) {
    return StartSpeakerSeparationResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class StreamingAudioChunkWithTimestampsResponseModel {
  const StreamingAudioChunkWithTimestampsResponseModel({
    required this.audioBase64,
    this.alignment,
    this.normalizedAlignment,
  });

  factory StreamingAudioChunkWithTimestampsResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$StreamingAudioChunkWithTimestampsResponseModelFromJson(json);

  static const toJsonFactory =
      _$StreamingAudioChunkWithTimestampsResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$StreamingAudioChunkWithTimestampsResponseModelToJson(this);

  @JsonKey(name: 'audio_base64')
  final String audioBase64;
  @JsonKey(name: 'alignment')
  final dynamic alignment;
  @JsonKey(name: 'normalized_alignment')
  final dynamic normalizedAlignment;
  static const fromJsonFactory =
      _$StreamingAudioChunkWithTimestampsResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is StreamingAudioChunkWithTimestampsResponseModel &&
            (identical(other.audioBase64, audioBase64) ||
                const DeepCollectionEquality()
                    .equals(other.audioBase64, audioBase64)) &&
            (identical(other.alignment, alignment) ||
                const DeepCollectionEquality()
                    .equals(other.alignment, alignment)) &&
            (identical(other.normalizedAlignment, normalizedAlignment) ||
                const DeepCollectionEquality()
                    .equals(other.normalizedAlignment, normalizedAlignment)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(audioBase64) ^
      const DeepCollectionEquality().hash(alignment) ^
      const DeepCollectionEquality().hash(normalizedAlignment) ^
      runtimeType.hashCode;
}

extension $StreamingAudioChunkWithTimestampsResponseModelExtension
    on StreamingAudioChunkWithTimestampsResponseModel {
  StreamingAudioChunkWithTimestampsResponseModel copyWith(
      {String? audioBase64, dynamic alignment, dynamic normalizedAlignment}) {
    return StreamingAudioChunkWithTimestampsResponseModel(
        audioBase64: audioBase64 ?? this.audioBase64,
        alignment: alignment ?? this.alignment,
        normalizedAlignment: normalizedAlignment ?? this.normalizedAlignment);
  }

  StreamingAudioChunkWithTimestampsResponseModel copyWithWrapped(
      {Wrapped<String>? audioBase64,
      Wrapped<dynamic>? alignment,
      Wrapped<dynamic>? normalizedAlignment}) {
    return StreamingAudioChunkWithTimestampsResponseModel(
        audioBase64:
            (audioBase64 != null ? audioBase64.value : this.audioBase64),
        alignment: (alignment != null ? alignment.value : this.alignment),
        normalizedAlignment: (normalizedAlignment != null
            ? normalizedAlignment.value
            : this.normalizedAlignment));
  }
}

@JsonSerializable(explicitToJson: true)
class SubscriptionExtrasResponseModel {
  const SubscriptionExtrasResponseModel({
    required this.concurrency,
    required this.convaiConcurrency,
    this.convaiCharsPerMinute,
    this.convaiAsrCharsPerMinute,
    required this.forceLoggingDisabled,
    required this.canRequestManualProVoiceVerification,
    required this.canBypassVoiceCaptcha,
    required this.moderation,
    this.unusedCharactersRolledOverFromPreviousPeriod,
    this.overusedCharactersRolledOverFromPreviousPeriod,
    this.usage,
  });

  factory SubscriptionExtrasResponseModel.fromJson(Map<String, dynamic> json) =>
      _$SubscriptionExtrasResponseModelFromJson(json);

  static const toJsonFactory = _$SubscriptionExtrasResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$SubscriptionExtrasResponseModelToJson(this);

  @JsonKey(name: 'concurrency')
  final int concurrency;
  @JsonKey(name: 'convai_concurrency')
  final int convaiConcurrency;
  @JsonKey(name: 'convai_chars_per_minute')
  final dynamic convaiCharsPerMinute;
  @JsonKey(name: 'convai_asr_chars_per_minute')
  final dynamic convaiAsrCharsPerMinute;
  @JsonKey(name: 'force_logging_disabled')
  final bool forceLoggingDisabled;
  @JsonKey(name: 'can_request_manual_pro_voice_verification')
  final bool canRequestManualProVoiceVerification;
  @JsonKey(name: 'can_bypass_voice_captcha')
  final bool canBypassVoiceCaptcha;
  @JsonKey(name: 'moderation')
  final ModerationStatusResponseModel moderation;
  @JsonKey(name: 'unused_characters_rolled_over_from_previous_period')
  final dynamic unusedCharactersRolledOverFromPreviousPeriod;
  @JsonKey(name: 'overused_characters_rolled_over_from_previous_period')
  final dynamic overusedCharactersRolledOverFromPreviousPeriod;
  @JsonKey(name: 'usage')
  final dynamic usage;
  static const fromJsonFactory = _$SubscriptionExtrasResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SubscriptionExtrasResponseModel &&
            (identical(other.concurrency, concurrency) ||
                const DeepCollectionEquality()
                    .equals(other.concurrency, concurrency)) &&
            (identical(other.convaiConcurrency, convaiConcurrency) ||
                const DeepCollectionEquality()
                    .equals(other.convaiConcurrency, convaiConcurrency)) &&
            (identical(other.convaiCharsPerMinute, convaiCharsPerMinute) ||
                const DeepCollectionEquality().equals(
                    other.convaiCharsPerMinute, convaiCharsPerMinute)) &&
            (identical(other.convaiAsrCharsPerMinute, convaiAsrCharsPerMinute) ||
                const DeepCollectionEquality().equals(
                    other.convaiAsrCharsPerMinute, convaiAsrCharsPerMinute)) &&
            (identical(other.forceLoggingDisabled, forceLoggingDisabled) ||
                const DeepCollectionEquality().equals(
                    other.forceLoggingDisabled, forceLoggingDisabled)) &&
            (identical(other.canRequestManualProVoiceVerification, canRequestManualProVoiceVerification) ||
                const DeepCollectionEquality().equals(
                    other.canRequestManualProVoiceVerification,
                    canRequestManualProVoiceVerification)) &&
            (identical(other.canBypassVoiceCaptcha, canBypassVoiceCaptcha) ||
                const DeepCollectionEquality().equals(
                    other.canBypassVoiceCaptcha, canBypassVoiceCaptcha)) &&
            (identical(other.moderation, moderation) ||
                const DeepCollectionEquality()
                    .equals(other.moderation, moderation)) &&
            (identical(other.unusedCharactersRolledOverFromPreviousPeriod, unusedCharactersRolledOverFromPreviousPeriod) ||
                const DeepCollectionEquality().equals(
                    other.unusedCharactersRolledOverFromPreviousPeriod,
                    unusedCharactersRolledOverFromPreviousPeriod)) &&
            (identical(other.overusedCharactersRolledOverFromPreviousPeriod,
                    overusedCharactersRolledOverFromPreviousPeriod) ||
                const DeepCollectionEquality().equals(
                    other.overusedCharactersRolledOverFromPreviousPeriod,
                    overusedCharactersRolledOverFromPreviousPeriod)) &&
            (identical(other.usage, usage) ||
                const DeepCollectionEquality().equals(other.usage, usage)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(concurrency) ^
      const DeepCollectionEquality().hash(convaiConcurrency) ^
      const DeepCollectionEquality().hash(convaiCharsPerMinute) ^
      const DeepCollectionEquality().hash(convaiAsrCharsPerMinute) ^
      const DeepCollectionEquality().hash(forceLoggingDisabled) ^
      const DeepCollectionEquality()
          .hash(canRequestManualProVoiceVerification) ^
      const DeepCollectionEquality().hash(canBypassVoiceCaptcha) ^
      const DeepCollectionEquality().hash(moderation) ^
      const DeepCollectionEquality()
          .hash(unusedCharactersRolledOverFromPreviousPeriod) ^
      const DeepCollectionEquality()
          .hash(overusedCharactersRolledOverFromPreviousPeriod) ^
      const DeepCollectionEquality().hash(usage) ^
      runtimeType.hashCode;
}

extension $SubscriptionExtrasResponseModelExtension
    on SubscriptionExtrasResponseModel {
  SubscriptionExtrasResponseModel copyWith(
      {int? concurrency,
      int? convaiConcurrency,
      dynamic convaiCharsPerMinute,
      dynamic convaiAsrCharsPerMinute,
      bool? forceLoggingDisabled,
      bool? canRequestManualProVoiceVerification,
      bool? canBypassVoiceCaptcha,
      ModerationStatusResponseModel? moderation,
      dynamic unusedCharactersRolledOverFromPreviousPeriod,
      dynamic overusedCharactersRolledOverFromPreviousPeriod,
      dynamic usage}) {
    return SubscriptionExtrasResponseModel(
        concurrency: concurrency ?? this.concurrency,
        convaiConcurrency: convaiConcurrency ?? this.convaiConcurrency,
        convaiCharsPerMinute: convaiCharsPerMinute ?? this.convaiCharsPerMinute,
        convaiAsrCharsPerMinute:
            convaiAsrCharsPerMinute ?? this.convaiAsrCharsPerMinute,
        forceLoggingDisabled: forceLoggingDisabled ?? this.forceLoggingDisabled,
        canRequestManualProVoiceVerification:
            canRequestManualProVoiceVerification ??
                this.canRequestManualProVoiceVerification,
        canBypassVoiceCaptcha:
            canBypassVoiceCaptcha ?? this.canBypassVoiceCaptcha,
        moderation: moderation ?? this.moderation,
        unusedCharactersRolledOverFromPreviousPeriod:
            unusedCharactersRolledOverFromPreviousPeriod ??
                this.unusedCharactersRolledOverFromPreviousPeriod,
        overusedCharactersRolledOverFromPreviousPeriod:
            overusedCharactersRolledOverFromPreviousPeriod ??
                this.overusedCharactersRolledOverFromPreviousPeriod,
        usage: usage ?? this.usage);
  }

  SubscriptionExtrasResponseModel copyWithWrapped(
      {Wrapped<int>? concurrency,
      Wrapped<int>? convaiConcurrency,
      Wrapped<dynamic>? convaiCharsPerMinute,
      Wrapped<dynamic>? convaiAsrCharsPerMinute,
      Wrapped<bool>? forceLoggingDisabled,
      Wrapped<bool>? canRequestManualProVoiceVerification,
      Wrapped<bool>? canBypassVoiceCaptcha,
      Wrapped<ModerationStatusResponseModel>? moderation,
      Wrapped<dynamic>? unusedCharactersRolledOverFromPreviousPeriod,
      Wrapped<dynamic>? overusedCharactersRolledOverFromPreviousPeriod,
      Wrapped<dynamic>? usage}) {
    return SubscriptionExtrasResponseModel(
        concurrency:
            (concurrency != null ? concurrency.value : this.concurrency),
        convaiConcurrency: (convaiConcurrency != null
            ? convaiConcurrency.value
            : this.convaiConcurrency),
        convaiCharsPerMinute: (convaiCharsPerMinute != null
            ? convaiCharsPerMinute.value
            : this.convaiCharsPerMinute),
        convaiAsrCharsPerMinute: (convaiAsrCharsPerMinute != null
            ? convaiAsrCharsPerMinute.value
            : this.convaiAsrCharsPerMinute),
        forceLoggingDisabled: (forceLoggingDisabled != null
            ? forceLoggingDisabled.value
            : this.forceLoggingDisabled),
        canRequestManualProVoiceVerification:
            (canRequestManualProVoiceVerification != null
                ? canRequestManualProVoiceVerification.value
                : this.canRequestManualProVoiceVerification),
        canBypassVoiceCaptcha: (canBypassVoiceCaptcha != null
            ? canBypassVoiceCaptcha.value
            : this.canBypassVoiceCaptcha),
        moderation: (moderation != null ? moderation.value : this.moderation),
        unusedCharactersRolledOverFromPreviousPeriod:
            (unusedCharactersRolledOverFromPreviousPeriod != null
                ? unusedCharactersRolledOverFromPreviousPeriod.value
                : this.unusedCharactersRolledOverFromPreviousPeriod),
        overusedCharactersRolledOverFromPreviousPeriod:
            (overusedCharactersRolledOverFromPreviousPeriod != null
                ? overusedCharactersRolledOverFromPreviousPeriod.value
                : this.overusedCharactersRolledOverFromPreviousPeriod),
        usage: (usage != null ? usage.value : this.usage));
  }
}

@JsonSerializable(explicitToJson: true)
class SubscriptionResponseModel {
  const SubscriptionResponseModel({
    required this.tier,
    required this.characterCount,
    required this.characterLimit,
    required this.maxCharacterLimitExtension,
    required this.canExtendCharacterLimit,
    required this.allowedToExtendCharacterLimit,
    this.nextCharacterCountResetUnix,
    required this.voiceSlotsUsed,
    required this.professionalVoiceSlotsUsed,
    required this.voiceLimit,
    this.maxVoiceAddEdits,
    required this.voiceAddEditCounter,
    required this.professionalVoiceLimit,
    required this.canExtendVoiceLimit,
    required this.canUseInstantVoiceCloning,
    required this.canUseProfessionalVoiceCloning,
    this.currency,
    required this.status,
    this.billingPeriod,
    this.characterRefreshPeriod,
  });

  factory SubscriptionResponseModel.fromJson(Map<String, dynamic> json) =>
      _$SubscriptionResponseModelFromJson(json);

  static const toJsonFactory = _$SubscriptionResponseModelToJson;
  Map<String, dynamic> toJson() => _$SubscriptionResponseModelToJson(this);

  @JsonKey(name: 'tier')
  final String tier;
  @JsonKey(name: 'character_count')
  final int characterCount;
  @JsonKey(name: 'character_limit')
  final int characterLimit;
  @JsonKey(name: 'max_character_limit_extension')
  final dynamic maxCharacterLimitExtension;
  @JsonKey(name: 'can_extend_character_limit')
  final bool canExtendCharacterLimit;
  @JsonKey(name: 'allowed_to_extend_character_limit')
  final bool allowedToExtendCharacterLimit;
  @JsonKey(name: 'next_character_count_reset_unix')
  final dynamic nextCharacterCountResetUnix;
  @JsonKey(name: 'voice_slots_used')
  final int voiceSlotsUsed;
  @JsonKey(name: 'professional_voice_slots_used')
  final int professionalVoiceSlotsUsed;
  @JsonKey(name: 'voice_limit')
  final int voiceLimit;
  @JsonKey(name: 'max_voice_add_edits')
  final dynamic maxVoiceAddEdits;
  @JsonKey(name: 'voice_add_edit_counter')
  final int voiceAddEditCounter;
  @JsonKey(name: 'professional_voice_limit')
  final int professionalVoiceLimit;
  @JsonKey(name: 'can_extend_voice_limit')
  final bool canExtendVoiceLimit;
  @JsonKey(name: 'can_use_instant_voice_cloning')
  final bool canUseInstantVoiceCloning;
  @JsonKey(name: 'can_use_professional_voice_cloning')
  final bool canUseProfessionalVoiceCloning;
  @JsonKey(name: 'currency')
  final dynamic currency;
  @JsonKey(
    name: 'status',
    toJson: subscriptionResponseModelStatusToJson,
    fromJson: subscriptionResponseModelStatusFromJson,
  )
  final enums.SubscriptionResponseModelStatus status;
  @JsonKey(name: 'billing_period')
  final dynamic billingPeriod;
  @JsonKey(name: 'character_refresh_period')
  final dynamic characterRefreshPeriod;
  static const fromJsonFactory = _$SubscriptionResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SubscriptionResponseModel &&
            (identical(other.tier, tier) ||
                const DeepCollectionEquality().equals(other.tier, tier)) &&
            (identical(other.characterCount, characterCount) ||
                const DeepCollectionEquality()
                    .equals(other.characterCount, characterCount)) &&
            (identical(other.characterLimit, characterLimit) ||
                const DeepCollectionEquality()
                    .equals(other.characterLimit, characterLimit)) &&
            (identical(other.maxCharacterLimitExtension, maxCharacterLimitExtension) ||
                const DeepCollectionEquality().equals(
                    other.maxCharacterLimitExtension,
                    maxCharacterLimitExtension)) &&
            (identical(other.canExtendCharacterLimit, canExtendCharacterLimit) ||
                const DeepCollectionEquality().equals(
                    other.canExtendCharacterLimit, canExtendCharacterLimit)) &&
            (identical(other.allowedToExtendCharacterLimit, allowedToExtendCharacterLimit) ||
                const DeepCollectionEquality().equals(
                    other.allowedToExtendCharacterLimit,
                    allowedToExtendCharacterLimit)) &&
            (identical(other.nextCharacterCountResetUnix, nextCharacterCountResetUnix) ||
                const DeepCollectionEquality().equals(
                    other.nextCharacterCountResetUnix,
                    nextCharacterCountResetUnix)) &&
            (identical(other.voiceSlotsUsed, voiceSlotsUsed) ||
                const DeepCollectionEquality()
                    .equals(other.voiceSlotsUsed, voiceSlotsUsed)) &&
            (identical(other.professionalVoiceSlotsUsed, professionalVoiceSlotsUsed) ||
                const DeepCollectionEquality().equals(
                    other.professionalVoiceSlotsUsed,
                    professionalVoiceSlotsUsed)) &&
            (identical(other.voiceLimit, voiceLimit) ||
                const DeepCollectionEquality()
                    .equals(other.voiceLimit, voiceLimit)) &&
            (identical(other.maxVoiceAddEdits, maxVoiceAddEdits) ||
                const DeepCollectionEquality().equals(other.maxVoiceAddEdits, maxVoiceAddEdits)) &&
            (identical(other.voiceAddEditCounter, voiceAddEditCounter) || const DeepCollectionEquality().equals(other.voiceAddEditCounter, voiceAddEditCounter)) &&
            (identical(other.professionalVoiceLimit, professionalVoiceLimit) || const DeepCollectionEquality().equals(other.professionalVoiceLimit, professionalVoiceLimit)) &&
            (identical(other.canExtendVoiceLimit, canExtendVoiceLimit) || const DeepCollectionEquality().equals(other.canExtendVoiceLimit, canExtendVoiceLimit)) &&
            (identical(other.canUseInstantVoiceCloning, canUseInstantVoiceCloning) || const DeepCollectionEquality().equals(other.canUseInstantVoiceCloning, canUseInstantVoiceCloning)) &&
            (identical(other.canUseProfessionalVoiceCloning, canUseProfessionalVoiceCloning) || const DeepCollectionEquality().equals(other.canUseProfessionalVoiceCloning, canUseProfessionalVoiceCloning)) &&
            (identical(other.currency, currency) || const DeepCollectionEquality().equals(other.currency, currency)) &&
            (identical(other.status, status) || const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.billingPeriod, billingPeriod) || const DeepCollectionEquality().equals(other.billingPeriod, billingPeriod)) &&
            (identical(other.characterRefreshPeriod, characterRefreshPeriod) || const DeepCollectionEquality().equals(other.characterRefreshPeriod, characterRefreshPeriod)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(tier) ^
      const DeepCollectionEquality().hash(characterCount) ^
      const DeepCollectionEquality().hash(characterLimit) ^
      const DeepCollectionEquality().hash(maxCharacterLimitExtension) ^
      const DeepCollectionEquality().hash(canExtendCharacterLimit) ^
      const DeepCollectionEquality().hash(allowedToExtendCharacterLimit) ^
      const DeepCollectionEquality().hash(nextCharacterCountResetUnix) ^
      const DeepCollectionEquality().hash(voiceSlotsUsed) ^
      const DeepCollectionEquality().hash(professionalVoiceSlotsUsed) ^
      const DeepCollectionEquality().hash(voiceLimit) ^
      const DeepCollectionEquality().hash(maxVoiceAddEdits) ^
      const DeepCollectionEquality().hash(voiceAddEditCounter) ^
      const DeepCollectionEquality().hash(professionalVoiceLimit) ^
      const DeepCollectionEquality().hash(canExtendVoiceLimit) ^
      const DeepCollectionEquality().hash(canUseInstantVoiceCloning) ^
      const DeepCollectionEquality().hash(canUseProfessionalVoiceCloning) ^
      const DeepCollectionEquality().hash(currency) ^
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(billingPeriod) ^
      const DeepCollectionEquality().hash(characterRefreshPeriod) ^
      runtimeType.hashCode;
}

extension $SubscriptionResponseModelExtension on SubscriptionResponseModel {
  SubscriptionResponseModel copyWith(
      {String? tier,
      int? characterCount,
      int? characterLimit,
      dynamic maxCharacterLimitExtension,
      bool? canExtendCharacterLimit,
      bool? allowedToExtendCharacterLimit,
      dynamic nextCharacterCountResetUnix,
      int? voiceSlotsUsed,
      int? professionalVoiceSlotsUsed,
      int? voiceLimit,
      dynamic maxVoiceAddEdits,
      int? voiceAddEditCounter,
      int? professionalVoiceLimit,
      bool? canExtendVoiceLimit,
      bool? canUseInstantVoiceCloning,
      bool? canUseProfessionalVoiceCloning,
      dynamic currency,
      enums.SubscriptionResponseModelStatus? status,
      dynamic billingPeriod,
      dynamic characterRefreshPeriod}) {
    return SubscriptionResponseModel(
        tier: tier ?? this.tier,
        characterCount: characterCount ?? this.characterCount,
        characterLimit: characterLimit ?? this.characterLimit,
        maxCharacterLimitExtension:
            maxCharacterLimitExtension ?? this.maxCharacterLimitExtension,
        canExtendCharacterLimit:
            canExtendCharacterLimit ?? this.canExtendCharacterLimit,
        allowedToExtendCharacterLimit:
            allowedToExtendCharacterLimit ?? this.allowedToExtendCharacterLimit,
        nextCharacterCountResetUnix:
            nextCharacterCountResetUnix ?? this.nextCharacterCountResetUnix,
        voiceSlotsUsed: voiceSlotsUsed ?? this.voiceSlotsUsed,
        professionalVoiceSlotsUsed:
            professionalVoiceSlotsUsed ?? this.professionalVoiceSlotsUsed,
        voiceLimit: voiceLimit ?? this.voiceLimit,
        maxVoiceAddEdits: maxVoiceAddEdits ?? this.maxVoiceAddEdits,
        voiceAddEditCounter: voiceAddEditCounter ?? this.voiceAddEditCounter,
        professionalVoiceLimit:
            professionalVoiceLimit ?? this.professionalVoiceLimit,
        canExtendVoiceLimit: canExtendVoiceLimit ?? this.canExtendVoiceLimit,
        canUseInstantVoiceCloning:
            canUseInstantVoiceCloning ?? this.canUseInstantVoiceCloning,
        canUseProfessionalVoiceCloning: canUseProfessionalVoiceCloning ??
            this.canUseProfessionalVoiceCloning,
        currency: currency ?? this.currency,
        status: status ?? this.status,
        billingPeriod: billingPeriod ?? this.billingPeriod,
        characterRefreshPeriod:
            characterRefreshPeriod ?? this.characterRefreshPeriod);
  }

  SubscriptionResponseModel copyWithWrapped(
      {Wrapped<String>? tier,
      Wrapped<int>? characterCount,
      Wrapped<int>? characterLimit,
      Wrapped<dynamic>? maxCharacterLimitExtension,
      Wrapped<bool>? canExtendCharacterLimit,
      Wrapped<bool>? allowedToExtendCharacterLimit,
      Wrapped<dynamic>? nextCharacterCountResetUnix,
      Wrapped<int>? voiceSlotsUsed,
      Wrapped<int>? professionalVoiceSlotsUsed,
      Wrapped<int>? voiceLimit,
      Wrapped<dynamic>? maxVoiceAddEdits,
      Wrapped<int>? voiceAddEditCounter,
      Wrapped<int>? professionalVoiceLimit,
      Wrapped<bool>? canExtendVoiceLimit,
      Wrapped<bool>? canUseInstantVoiceCloning,
      Wrapped<bool>? canUseProfessionalVoiceCloning,
      Wrapped<dynamic>? currency,
      Wrapped<enums.SubscriptionResponseModelStatus>? status,
      Wrapped<dynamic>? billingPeriod,
      Wrapped<dynamic>? characterRefreshPeriod}) {
    return SubscriptionResponseModel(
        tier: (tier != null ? tier.value : this.tier),
        characterCount: (characterCount != null
            ? characterCount.value
            : this.characterCount),
        characterLimit: (characterLimit != null
            ? characterLimit.value
            : this.characterLimit),
        maxCharacterLimitExtension: (maxCharacterLimitExtension != null
            ? maxCharacterLimitExtension.value
            : this.maxCharacterLimitExtension),
        canExtendCharacterLimit: (canExtendCharacterLimit != null
            ? canExtendCharacterLimit.value
            : this.canExtendCharacterLimit),
        allowedToExtendCharacterLimit: (allowedToExtendCharacterLimit != null
            ? allowedToExtendCharacterLimit.value
            : this.allowedToExtendCharacterLimit),
        nextCharacterCountResetUnix: (nextCharacterCountResetUnix != null
            ? nextCharacterCountResetUnix.value
            : this.nextCharacterCountResetUnix),
        voiceSlotsUsed: (voiceSlotsUsed != null
            ? voiceSlotsUsed.value
            : this.voiceSlotsUsed),
        professionalVoiceSlotsUsed: (professionalVoiceSlotsUsed != null
            ? professionalVoiceSlotsUsed.value
            : this.professionalVoiceSlotsUsed),
        voiceLimit: (voiceLimit != null ? voiceLimit.value : this.voiceLimit),
        maxVoiceAddEdits: (maxVoiceAddEdits != null
            ? maxVoiceAddEdits.value
            : this.maxVoiceAddEdits),
        voiceAddEditCounter: (voiceAddEditCounter != null
            ? voiceAddEditCounter.value
            : this.voiceAddEditCounter),
        professionalVoiceLimit: (professionalVoiceLimit != null
            ? professionalVoiceLimit.value
            : this.professionalVoiceLimit),
        canExtendVoiceLimit: (canExtendVoiceLimit != null
            ? canExtendVoiceLimit.value
            : this.canExtendVoiceLimit),
        canUseInstantVoiceCloning: (canUseInstantVoiceCloning != null
            ? canUseInstantVoiceCloning.value
            : this.canUseInstantVoiceCloning),
        canUseProfessionalVoiceCloning: (canUseProfessionalVoiceCloning != null
            ? canUseProfessionalVoiceCloning.value
            : this.canUseProfessionalVoiceCloning),
        currency: (currency != null ? currency.value : this.currency),
        status: (status != null ? status.value : this.status),
        billingPeriod:
            (billingPeriod != null ? billingPeriod.value : this.billingPeriod),
        characterRefreshPeriod: (characterRefreshPeriod != null
            ? characterRefreshPeriod.value
            : this.characterRefreshPeriod));
  }
}

@JsonSerializable(explicitToJson: true)
class SubscriptionUsageResponseModel {
  const SubscriptionUsageResponseModel({
    required this.rolloverCreditsQuota,
    required this.subscriptionCycleCreditsQuota,
    required this.manuallyGiftedCreditsQuota,
    required this.rolloverCreditsUsed,
    required this.subscriptionCycleCreditsUsed,
    required this.manuallyGiftedCreditsUsed,
    required this.paidUsageBasedCreditsUsed,
    required this.actualReportedCredits,
  });

  factory SubscriptionUsageResponseModel.fromJson(Map<String, dynamic> json) =>
      _$SubscriptionUsageResponseModelFromJson(json);

  static const toJsonFactory = _$SubscriptionUsageResponseModelToJson;
  Map<String, dynamic> toJson() => _$SubscriptionUsageResponseModelToJson(this);

  @JsonKey(name: 'rollover_credits_quota')
  final int rolloverCreditsQuota;
  @JsonKey(name: 'subscription_cycle_credits_quota')
  final int subscriptionCycleCreditsQuota;
  @JsonKey(name: 'manually_gifted_credits_quota')
  final int manuallyGiftedCreditsQuota;
  @JsonKey(name: 'rollover_credits_used')
  final int rolloverCreditsUsed;
  @JsonKey(name: 'subscription_cycle_credits_used')
  final int subscriptionCycleCreditsUsed;
  @JsonKey(name: 'manually_gifted_credits_used')
  final int manuallyGiftedCreditsUsed;
  @JsonKey(name: 'paid_usage_based_credits_used')
  final int paidUsageBasedCreditsUsed;
  @JsonKey(name: 'actual_reported_credits')
  final int actualReportedCredits;
  static const fromJsonFactory = _$SubscriptionUsageResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SubscriptionUsageResponseModel &&
            (identical(other.rolloverCreditsQuota, rolloverCreditsQuota) ||
                const DeepCollectionEquality().equals(
                    other.rolloverCreditsQuota, rolloverCreditsQuota)) &&
            (identical(other.subscriptionCycleCreditsQuota,
                    subscriptionCycleCreditsQuota) ||
                const DeepCollectionEquality().equals(
                    other.subscriptionCycleCreditsQuota,
                    subscriptionCycleCreditsQuota)) &&
            (identical(other.manuallyGiftedCreditsQuota, manuallyGiftedCreditsQuota) ||
                const DeepCollectionEquality().equals(
                    other.manuallyGiftedCreditsQuota,
                    manuallyGiftedCreditsQuota)) &&
            (identical(other.rolloverCreditsUsed, rolloverCreditsUsed) ||
                const DeepCollectionEquality()
                    .equals(other.rolloverCreditsUsed, rolloverCreditsUsed)) &&
            (identical(other.subscriptionCycleCreditsUsed, subscriptionCycleCreditsUsed) ||
                const DeepCollectionEquality().equals(
                    other.subscriptionCycleCreditsUsed,
                    subscriptionCycleCreditsUsed)) &&
            (identical(other.manuallyGiftedCreditsUsed, manuallyGiftedCreditsUsed) ||
                const DeepCollectionEquality().equals(
                    other.manuallyGiftedCreditsUsed,
                    manuallyGiftedCreditsUsed)) &&
            (identical(other.paidUsageBasedCreditsUsed, paidUsageBasedCreditsUsed) ||
                const DeepCollectionEquality().equals(
                    other.paidUsageBasedCreditsUsed,
                    paidUsageBasedCreditsUsed)) &&
            (identical(other.actualReportedCredits, actualReportedCredits) ||
                const DeepCollectionEquality().equals(
                    other.actualReportedCredits, actualReportedCredits)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(rolloverCreditsQuota) ^
      const DeepCollectionEquality().hash(subscriptionCycleCreditsQuota) ^
      const DeepCollectionEquality().hash(manuallyGiftedCreditsQuota) ^
      const DeepCollectionEquality().hash(rolloverCreditsUsed) ^
      const DeepCollectionEquality().hash(subscriptionCycleCreditsUsed) ^
      const DeepCollectionEquality().hash(manuallyGiftedCreditsUsed) ^
      const DeepCollectionEquality().hash(paidUsageBasedCreditsUsed) ^
      const DeepCollectionEquality().hash(actualReportedCredits) ^
      runtimeType.hashCode;
}

extension $SubscriptionUsageResponseModelExtension
    on SubscriptionUsageResponseModel {
  SubscriptionUsageResponseModel copyWith(
      {int? rolloverCreditsQuota,
      int? subscriptionCycleCreditsQuota,
      int? manuallyGiftedCreditsQuota,
      int? rolloverCreditsUsed,
      int? subscriptionCycleCreditsUsed,
      int? manuallyGiftedCreditsUsed,
      int? paidUsageBasedCreditsUsed,
      int? actualReportedCredits}) {
    return SubscriptionUsageResponseModel(
        rolloverCreditsQuota: rolloverCreditsQuota ?? this.rolloverCreditsQuota,
        subscriptionCycleCreditsQuota:
            subscriptionCycleCreditsQuota ?? this.subscriptionCycleCreditsQuota,
        manuallyGiftedCreditsQuota:
            manuallyGiftedCreditsQuota ?? this.manuallyGiftedCreditsQuota,
        rolloverCreditsUsed: rolloverCreditsUsed ?? this.rolloverCreditsUsed,
        subscriptionCycleCreditsUsed:
            subscriptionCycleCreditsUsed ?? this.subscriptionCycleCreditsUsed,
        manuallyGiftedCreditsUsed:
            manuallyGiftedCreditsUsed ?? this.manuallyGiftedCreditsUsed,
        paidUsageBasedCreditsUsed:
            paidUsageBasedCreditsUsed ?? this.paidUsageBasedCreditsUsed,
        actualReportedCredits:
            actualReportedCredits ?? this.actualReportedCredits);
  }

  SubscriptionUsageResponseModel copyWithWrapped(
      {Wrapped<int>? rolloverCreditsQuota,
      Wrapped<int>? subscriptionCycleCreditsQuota,
      Wrapped<int>? manuallyGiftedCreditsQuota,
      Wrapped<int>? rolloverCreditsUsed,
      Wrapped<int>? subscriptionCycleCreditsUsed,
      Wrapped<int>? manuallyGiftedCreditsUsed,
      Wrapped<int>? paidUsageBasedCreditsUsed,
      Wrapped<int>? actualReportedCredits}) {
    return SubscriptionUsageResponseModel(
        rolloverCreditsQuota: (rolloverCreditsQuota != null
            ? rolloverCreditsQuota.value
            : this.rolloverCreditsQuota),
        subscriptionCycleCreditsQuota: (subscriptionCycleCreditsQuota != null
            ? subscriptionCycleCreditsQuota.value
            : this.subscriptionCycleCreditsQuota),
        manuallyGiftedCreditsQuota: (manuallyGiftedCreditsQuota != null
            ? manuallyGiftedCreditsQuota.value
            : this.manuallyGiftedCreditsQuota),
        rolloverCreditsUsed: (rolloverCreditsUsed != null
            ? rolloverCreditsUsed.value
            : this.rolloverCreditsUsed),
        subscriptionCycleCreditsUsed: (subscriptionCycleCreditsUsed != null
            ? subscriptionCycleCreditsUsed.value
            : this.subscriptionCycleCreditsUsed),
        manuallyGiftedCreditsUsed: (manuallyGiftedCreditsUsed != null
            ? manuallyGiftedCreditsUsed.value
            : this.manuallyGiftedCreditsUsed),
        paidUsageBasedCreditsUsed: (paidUsageBasedCreditsUsed != null
            ? paidUsageBasedCreditsUsed.value
            : this.paidUsageBasedCreditsUsed),
        actualReportedCredits: (actualReportedCredits != null
            ? actualReportedCredits.value
            : this.actualReportedCredits));
  }
}

@JsonSerializable(explicitToJson: true)
class SystemToolConfigInput {
  const SystemToolConfigInput({
    this.id,
    required this.name,
    required this.description,
    this.responseTimeoutSecs,
    this.type,
    required this.params,
  });

  factory SystemToolConfigInput.fromJson(Map<String, dynamic> json) =>
      _$SystemToolConfigInputFromJson(json);

  static const toJsonFactory = _$SystemToolConfigInputToJson;
  Map<String, dynamic> toJson() => _$SystemToolConfigInputToJson(this);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'response_timeout_secs')
  final int? responseTimeoutSecs;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'params')
  final dynamic params;
  static const fromJsonFactory = _$SystemToolConfigInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SystemToolConfigInput &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.responseTimeoutSecs, responseTimeoutSecs) ||
                const DeepCollectionEquality()
                    .equals(other.responseTimeoutSecs, responseTimeoutSecs)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.params, params) ||
                const DeepCollectionEquality().equals(other.params, params)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(responseTimeoutSecs) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(params) ^
      runtimeType.hashCode;
}

extension $SystemToolConfigInputExtension on SystemToolConfigInput {
  SystemToolConfigInput copyWith(
      {String? id,
      String? name,
      String? description,
      int? responseTimeoutSecs,
      String? type,
      dynamic params}) {
    return SystemToolConfigInput(
        id: id ?? this.id,
        name: name ?? this.name,
        description: description ?? this.description,
        responseTimeoutSecs: responseTimeoutSecs ?? this.responseTimeoutSecs,
        type: type ?? this.type,
        params: params ?? this.params);
  }

  SystemToolConfigInput copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String>? name,
      Wrapped<String>? description,
      Wrapped<int?>? responseTimeoutSecs,
      Wrapped<String?>? type,
      Wrapped<dynamic>? params}) {
    return SystemToolConfigInput(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        responseTimeoutSecs: (responseTimeoutSecs != null
            ? responseTimeoutSecs.value
            : this.responseTimeoutSecs),
        type: (type != null ? type.value : this.type),
        params: (params != null ? params.value : this.params));
  }
}

@JsonSerializable(explicitToJson: true)
class SystemToolConfigOutput {
  const SystemToolConfigOutput({
    this.id,
    required this.name,
    required this.description,
    this.responseTimeoutSecs,
    this.type,
    required this.params,
  });

  factory SystemToolConfigOutput.fromJson(Map<String, dynamic> json) =>
      _$SystemToolConfigOutputFromJson(json);

  static const toJsonFactory = _$SystemToolConfigOutputToJson;
  Map<String, dynamic> toJson() => _$SystemToolConfigOutputToJson(this);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'response_timeout_secs')
  final int? responseTimeoutSecs;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'params')
  final dynamic params;
  static const fromJsonFactory = _$SystemToolConfigOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is SystemToolConfigOutput &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.responseTimeoutSecs, responseTimeoutSecs) ||
                const DeepCollectionEquality()
                    .equals(other.responseTimeoutSecs, responseTimeoutSecs)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.params, params) ||
                const DeepCollectionEquality().equals(other.params, params)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(responseTimeoutSecs) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(params) ^
      runtimeType.hashCode;
}

extension $SystemToolConfigOutputExtension on SystemToolConfigOutput {
  SystemToolConfigOutput copyWith(
      {String? id,
      String? name,
      String? description,
      int? responseTimeoutSecs,
      String? type,
      dynamic params}) {
    return SystemToolConfigOutput(
        id: id ?? this.id,
        name: name ?? this.name,
        description: description ?? this.description,
        responseTimeoutSecs: responseTimeoutSecs ?? this.responseTimeoutSecs,
        type: type ?? this.type,
        params: params ?? this.params);
  }

  SystemToolConfigOutput copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String>? name,
      Wrapped<String>? description,
      Wrapped<int?>? responseTimeoutSecs,
      Wrapped<String?>? type,
      Wrapped<dynamic>? params}) {
    return SystemToolConfigOutput(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        responseTimeoutSecs: (responseTimeoutSecs != null
            ? responseTimeoutSecs.value
            : this.responseTimeoutSecs),
        type: (type != null ? type.value : this.type),
        params: (params != null ? params.value : this.params));
  }
}

@JsonSerializable(explicitToJson: true)
class TTSConversationalConfig {
  const TTSConversationalConfig({
    this.modelId,
    this.voiceId,
    this.agentOutputAudioFormat,
    this.optimizeStreamingLatency,
    this.stability,
    this.speed,
    this.similarityBoost,
    this.pronunciationDictionaryLocators,
  });

  factory TTSConversationalConfig.fromJson(Map<String, dynamic> json) =>
      _$TTSConversationalConfigFromJson(json);

  static const toJsonFactory = _$TTSConversationalConfigToJson;
  Map<String, dynamic> toJson() => _$TTSConversationalConfigToJson(this);

  @JsonKey(
    name: 'model_id',
    toJson: tTSConversationalModelNullableToJson,
    fromJson: tTSConversationalModelModelIdNullableFromJson,
  )
  final enums.TTSConversationalModel? modelId;
  static enums.TTSConversationalModel?
      tTSConversationalModelModelIdNullableFromJson(Object? value) =>
          tTSConversationalModelNullableFromJson(
              value, enums.TTSConversationalModel.elevenTurboV2);

  @JsonKey(name: 'voice_id')
  final String? voiceId;
  @JsonKey(
    name: 'agent_output_audio_format',
    toJson: tTSOutputFormatNullableToJson,
    fromJson: tTSOutputFormatAgentOutputAudioFormatNullableFromJson,
  )
  final enums.TTSOutputFormat? agentOutputAudioFormat;
  static enums.TTSOutputFormat?
      tTSOutputFormatAgentOutputAudioFormatNullableFromJson(Object? value) =>
          tTSOutputFormatNullableFromJson(
              value, enums.TTSOutputFormat.pcm16000);

  @JsonKey(
    name: 'optimize_streaming_latency',
    toJson: tTSOptimizeStreamingLatencyNullableToJson,
    fromJson:
        tTSOptimizeStreamingLatencyOptimizeStreamingLatencyNullableFromJson,
  )
  final enums.TTSOptimizeStreamingLatency? optimizeStreamingLatency;
  static enums.TTSOptimizeStreamingLatency?
      tTSOptimizeStreamingLatencyOptimizeStreamingLatencyNullableFromJson(
              Object? value) =>
          tTSOptimizeStreamingLatencyNullableFromJson(
              value, enums.TTSOptimizeStreamingLatency.value_3);

  @JsonKey(name: 'stability')
  final double? stability;
  @JsonKey(name: 'speed')
  final double? speed;
  @JsonKey(name: 'similarity_boost')
  final double? similarityBoost;
  @JsonKey(
      name: 'pronunciation_dictionary_locators',
      defaultValue: <PydanticPronunciationDictionaryVersionLocator>[])
  final List<PydanticPronunciationDictionaryVersionLocator>?
      pronunciationDictionaryLocators;
  static const fromJsonFactory = _$TTSConversationalConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TTSConversationalConfig &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.voiceId, voiceId) ||
                const DeepCollectionEquality()
                    .equals(other.voiceId, voiceId)) &&
            (identical(other.agentOutputAudioFormat, agentOutputAudioFormat) ||
                const DeepCollectionEquality().equals(
                    other.agentOutputAudioFormat, agentOutputAudioFormat)) &&
            (identical(
                    other.optimizeStreamingLatency, optimizeStreamingLatency) ||
                const DeepCollectionEquality().equals(
                    other.optimizeStreamingLatency,
                    optimizeStreamingLatency)) &&
            (identical(other.stability, stability) ||
                const DeepCollectionEquality()
                    .equals(other.stability, stability)) &&
            (identical(other.speed, speed) ||
                const DeepCollectionEquality().equals(other.speed, speed)) &&
            (identical(other.similarityBoost, similarityBoost) ||
                const DeepCollectionEquality()
                    .equals(other.similarityBoost, similarityBoost)) &&
            (identical(other.pronunciationDictionaryLocators,
                    pronunciationDictionaryLocators) ||
                const DeepCollectionEquality().equals(
                    other.pronunciationDictionaryLocators,
                    pronunciationDictionaryLocators)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(voiceId) ^
      const DeepCollectionEquality().hash(agentOutputAudioFormat) ^
      const DeepCollectionEquality().hash(optimizeStreamingLatency) ^
      const DeepCollectionEquality().hash(stability) ^
      const DeepCollectionEquality().hash(speed) ^
      const DeepCollectionEquality().hash(similarityBoost) ^
      const DeepCollectionEquality().hash(pronunciationDictionaryLocators) ^
      runtimeType.hashCode;
}

extension $TTSConversationalConfigExtension on TTSConversationalConfig {
  TTSConversationalConfig copyWith(
      {enums.TTSConversationalModel? modelId,
      String? voiceId,
      enums.TTSOutputFormat? agentOutputAudioFormat,
      enums.TTSOptimizeStreamingLatency? optimizeStreamingLatency,
      double? stability,
      double? speed,
      double? similarityBoost,
      List<PydanticPronunciationDictionaryVersionLocator>?
          pronunciationDictionaryLocators}) {
    return TTSConversationalConfig(
        modelId: modelId ?? this.modelId,
        voiceId: voiceId ?? this.voiceId,
        agentOutputAudioFormat:
            agentOutputAudioFormat ?? this.agentOutputAudioFormat,
        optimizeStreamingLatency:
            optimizeStreamingLatency ?? this.optimizeStreamingLatency,
        stability: stability ?? this.stability,
        speed: speed ?? this.speed,
        similarityBoost: similarityBoost ?? this.similarityBoost,
        pronunciationDictionaryLocators: pronunciationDictionaryLocators ??
            this.pronunciationDictionaryLocators);
  }

  TTSConversationalConfig copyWithWrapped(
      {Wrapped<enums.TTSConversationalModel?>? modelId,
      Wrapped<String?>? voiceId,
      Wrapped<enums.TTSOutputFormat?>? agentOutputAudioFormat,
      Wrapped<enums.TTSOptimizeStreamingLatency?>? optimizeStreamingLatency,
      Wrapped<double?>? stability,
      Wrapped<double?>? speed,
      Wrapped<double?>? similarityBoost,
      Wrapped<List<PydanticPronunciationDictionaryVersionLocator>?>?
          pronunciationDictionaryLocators}) {
    return TTSConversationalConfig(
        modelId: (modelId != null ? modelId.value : this.modelId),
        voiceId: (voiceId != null ? voiceId.value : this.voiceId),
        agentOutputAudioFormat: (agentOutputAudioFormat != null
            ? agentOutputAudioFormat.value
            : this.agentOutputAudioFormat),
        optimizeStreamingLatency: (optimizeStreamingLatency != null
            ? optimizeStreamingLatency.value
            : this.optimizeStreamingLatency),
        stability: (stability != null ? stability.value : this.stability),
        speed: (speed != null ? speed.value : this.speed),
        similarityBoost: (similarityBoost != null
            ? similarityBoost.value
            : this.similarityBoost),
        pronunciationDictionaryLocators:
            (pronunciationDictionaryLocators != null
                ? pronunciationDictionaryLocators.value
                : this.pronunciationDictionaryLocators));
  }
}

@JsonSerializable(explicitToJson: true)
class TTSConversationalConfigOverride {
  const TTSConversationalConfigOverride({
    this.voiceId,
  });

  factory TTSConversationalConfigOverride.fromJson(Map<String, dynamic> json) =>
      _$TTSConversationalConfigOverrideFromJson(json);

  static const toJsonFactory = _$TTSConversationalConfigOverrideToJson;
  Map<String, dynamic> toJson() =>
      _$TTSConversationalConfigOverrideToJson(this);

  @JsonKey(name: 'voice_id')
  final dynamic voiceId;
  static const fromJsonFactory = _$TTSConversationalConfigOverrideFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TTSConversationalConfigOverride &&
            (identical(other.voiceId, voiceId) ||
                const DeepCollectionEquality().equals(other.voiceId, voiceId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(voiceId) ^ runtimeType.hashCode;
}

extension $TTSConversationalConfigOverrideExtension
    on TTSConversationalConfigOverride {
  TTSConversationalConfigOverride copyWith({dynamic voiceId}) {
    return TTSConversationalConfigOverride(voiceId: voiceId ?? this.voiceId);
  }

  TTSConversationalConfigOverride copyWithWrapped({Wrapped<dynamic>? voiceId}) {
    return TTSConversationalConfigOverride(
        voiceId: (voiceId != null ? voiceId.value : this.voiceId));
  }
}

@JsonSerializable(explicitToJson: true)
class TTSConversationalConfigOverrideConfig {
  const TTSConversationalConfigOverrideConfig({
    this.voiceId,
  });

  factory TTSConversationalConfigOverrideConfig.fromJson(
          Map<String, dynamic> json) =>
      _$TTSConversationalConfigOverrideConfigFromJson(json);

  static const toJsonFactory = _$TTSConversationalConfigOverrideConfigToJson;
  Map<String, dynamic> toJson() =>
      _$TTSConversationalConfigOverrideConfigToJson(this);

  @JsonKey(name: 'voice_id', defaultValue: false)
  final bool? voiceId;
  static const fromJsonFactory =
      _$TTSConversationalConfigOverrideConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TTSConversationalConfigOverrideConfig &&
            (identical(other.voiceId, voiceId) ||
                const DeepCollectionEquality().equals(other.voiceId, voiceId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(voiceId) ^ runtimeType.hashCode;
}

extension $TTSConversationalConfigOverrideConfigExtension
    on TTSConversationalConfigOverrideConfig {
  TTSConversationalConfigOverrideConfig copyWith({bool? voiceId}) {
    return TTSConversationalConfigOverrideConfig(
        voiceId: voiceId ?? this.voiceId);
  }

  TTSConversationalConfigOverrideConfig copyWithWrapped(
      {Wrapped<bool?>? voiceId}) {
    return TTSConversationalConfigOverrideConfig(
        voiceId: (voiceId != null ? voiceId.value : this.voiceId));
  }
}

@JsonSerializable(explicitToJson: true)
class ToolMockConfig {
  const ToolMockConfig({
    this.defaultReturnValue,
    this.defaultIsError,
  });

  factory ToolMockConfig.fromJson(Map<String, dynamic> json) =>
      _$ToolMockConfigFromJson(json);

  static const toJsonFactory = _$ToolMockConfigToJson;
  Map<String, dynamic> toJson() => _$ToolMockConfigToJson(this);

  @JsonKey(name: 'default_return_value')
  final String? defaultReturnValue;
  @JsonKey(name: 'default_is_error', defaultValue: false)
  final bool? defaultIsError;
  static const fromJsonFactory = _$ToolMockConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ToolMockConfig &&
            (identical(other.defaultReturnValue, defaultReturnValue) ||
                const DeepCollectionEquality()
                    .equals(other.defaultReturnValue, defaultReturnValue)) &&
            (identical(other.defaultIsError, defaultIsError) ||
                const DeepCollectionEquality()
                    .equals(other.defaultIsError, defaultIsError)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(defaultReturnValue) ^
      const DeepCollectionEquality().hash(defaultIsError) ^
      runtimeType.hashCode;
}

extension $ToolMockConfigExtension on ToolMockConfig {
  ToolMockConfig copyWith({String? defaultReturnValue, bool? defaultIsError}) {
    return ToolMockConfig(
        defaultReturnValue: defaultReturnValue ?? this.defaultReturnValue,
        defaultIsError: defaultIsError ?? this.defaultIsError);
  }

  ToolMockConfig copyWithWrapped(
      {Wrapped<String?>? defaultReturnValue, Wrapped<bool?>? defaultIsError}) {
    return ToolMockConfig(
        defaultReturnValue: (defaultReturnValue != null
            ? defaultReturnValue.value
            : this.defaultReturnValue),
        defaultIsError: (defaultIsError != null
            ? defaultIsError.value
            : this.defaultIsError));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferToAgentToolConfig {
  const TransferToAgentToolConfig({
    this.systemToolType,
    required this.transfers,
  });

  factory TransferToAgentToolConfig.fromJson(Map<String, dynamic> json) =>
      _$TransferToAgentToolConfigFromJson(json);

  static const toJsonFactory = _$TransferToAgentToolConfigToJson;
  Map<String, dynamic> toJson() => _$TransferToAgentToolConfigToJson(this);

  @JsonKey(name: 'system_tool_type')
  final String? systemToolType;
  @JsonKey(name: 'transfers', defaultValue: <AgentTransfer>[])
  final List<AgentTransfer> transfers;
  static const fromJsonFactory = _$TransferToAgentToolConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TransferToAgentToolConfig &&
            (identical(other.systemToolType, systemToolType) ||
                const DeepCollectionEquality()
                    .equals(other.systemToolType, systemToolType)) &&
            (identical(other.transfers, transfers) ||
                const DeepCollectionEquality()
                    .equals(other.transfers, transfers)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(systemToolType) ^
      const DeepCollectionEquality().hash(transfers) ^
      runtimeType.hashCode;
}

extension $TransferToAgentToolConfigExtension on TransferToAgentToolConfig {
  TransferToAgentToolConfig copyWith(
      {String? systemToolType, List<AgentTransfer>? transfers}) {
    return TransferToAgentToolConfig(
        systemToolType: systemToolType ?? this.systemToolType,
        transfers: transfers ?? this.transfers);
  }

  TransferToAgentToolConfig copyWithWrapped(
      {Wrapped<String?>? systemToolType,
      Wrapped<List<AgentTransfer>>? transfers}) {
    return TransferToAgentToolConfig(
        systemToolType: (systemToolType != null
            ? systemToolType.value
            : this.systemToolType),
        transfers: (transfers != null ? transfers.value : this.transfers));
  }
}

@JsonSerializable(explicitToJson: true)
class TransferToNumberToolConfig {
  const TransferToNumberToolConfig({
    this.systemToolType,
    required this.transfers,
  });

  factory TransferToNumberToolConfig.fromJson(Map<String, dynamic> json) =>
      _$TransferToNumberToolConfigFromJson(json);

  static const toJsonFactory = _$TransferToNumberToolConfigToJson;
  Map<String, dynamic> toJson() => _$TransferToNumberToolConfigToJson(this);

  @JsonKey(name: 'system_tool_type')
  final String? systemToolType;
  @JsonKey(name: 'transfers', defaultValue: <PhoneNumberTransfer>[])
  final List<PhoneNumberTransfer> transfers;
  static const fromJsonFactory = _$TransferToNumberToolConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TransferToNumberToolConfig &&
            (identical(other.systemToolType, systemToolType) ||
                const DeepCollectionEquality()
                    .equals(other.systemToolType, systemToolType)) &&
            (identical(other.transfers, transfers) ||
                const DeepCollectionEquality()
                    .equals(other.transfers, transfers)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(systemToolType) ^
      const DeepCollectionEquality().hash(transfers) ^
      runtimeType.hashCode;
}

extension $TransferToNumberToolConfigExtension on TransferToNumberToolConfig {
  TransferToNumberToolConfig copyWith(
      {String? systemToolType, List<PhoneNumberTransfer>? transfers}) {
    return TransferToNumberToolConfig(
        systemToolType: systemToolType ?? this.systemToolType,
        transfers: transfers ?? this.transfers);
  }

  TransferToNumberToolConfig copyWithWrapped(
      {Wrapped<String?>? systemToolType,
      Wrapped<List<PhoneNumberTransfer>>? transfers}) {
    return TransferToNumberToolConfig(
        systemToolType: (systemToolType != null
            ? systemToolType.value
            : this.systemToolType),
        transfers: (transfers != null ? transfers.value : this.transfers));
  }
}

@JsonSerializable(explicitToJson: true)
class TurnConfig {
  const TurnConfig({
    this.turnTimeout,
    this.silenceEndCallTimeout,
    this.mode,
  });

  factory TurnConfig.fromJson(Map<String, dynamic> json) =>
      _$TurnConfigFromJson(json);

  static const toJsonFactory = _$TurnConfigToJson;
  Map<String, dynamic> toJson() => _$TurnConfigToJson(this);

  @JsonKey(name: 'turn_timeout')
  final double? turnTimeout;
  @JsonKey(name: 'silence_end_call_timeout')
  final double? silenceEndCallTimeout;
  @JsonKey(
    name: 'mode',
    toJson: turnModeNullableToJson,
    fromJson: turnModeModeNullableFromJson,
  )
  final enums.TurnMode? mode;
  static enums.TurnMode? turnModeModeNullableFromJson(Object? value) =>
      turnModeNullableFromJson(value, enums.TurnMode.turn);

  static const fromJsonFactory = _$TurnConfigFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TurnConfig &&
            (identical(other.turnTimeout, turnTimeout) ||
                const DeepCollectionEquality()
                    .equals(other.turnTimeout, turnTimeout)) &&
            (identical(other.silenceEndCallTimeout, silenceEndCallTimeout) ||
                const DeepCollectionEquality().equals(
                    other.silenceEndCallTimeout, silenceEndCallTimeout)) &&
            (identical(other.mode, mode) ||
                const DeepCollectionEquality().equals(other.mode, mode)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(turnTimeout) ^
      const DeepCollectionEquality().hash(silenceEndCallTimeout) ^
      const DeepCollectionEquality().hash(mode) ^
      runtimeType.hashCode;
}

extension $TurnConfigExtension on TurnConfig {
  TurnConfig copyWith(
      {double? turnTimeout,
      double? silenceEndCallTimeout,
      enums.TurnMode? mode}) {
    return TurnConfig(
        turnTimeout: turnTimeout ?? this.turnTimeout,
        silenceEndCallTimeout:
            silenceEndCallTimeout ?? this.silenceEndCallTimeout,
        mode: mode ?? this.mode);
  }

  TurnConfig copyWithWrapped(
      {Wrapped<double?>? turnTimeout,
      Wrapped<double?>? silenceEndCallTimeout,
      Wrapped<enums.TurnMode?>? mode}) {
    return TurnConfig(
        turnTimeout:
            (turnTimeout != null ? turnTimeout.value : this.turnTimeout),
        silenceEndCallTimeout: (silenceEndCallTimeout != null
            ? silenceEndCallTimeout.value
            : this.silenceEndCallTimeout),
        mode: (mode != null ? mode.value : this.mode));
  }
}

@JsonSerializable(explicitToJson: true)
class TwilioOutboundCallResponse {
  const TwilioOutboundCallResponse({
    required this.success,
    required this.message,
    required this.conversationId,
    required this.callSid,
  });

  factory TwilioOutboundCallResponse.fromJson(Map<String, dynamic> json) =>
      _$TwilioOutboundCallResponseFromJson(json);

  static const toJsonFactory = _$TwilioOutboundCallResponseToJson;
  Map<String, dynamic> toJson() => _$TwilioOutboundCallResponseToJson(this);

  @JsonKey(name: 'success')
  final bool success;
  @JsonKey(name: 'message')
  final String message;
  @JsonKey(name: 'conversation_id')
  final dynamic conversationId;
  @JsonKey(name: 'callSid')
  final dynamic callSid;
  static const fromJsonFactory = _$TwilioOutboundCallResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TwilioOutboundCallResponse &&
            (identical(other.success, success) ||
                const DeepCollectionEquality()
                    .equals(other.success, success)) &&
            (identical(other.message, message) ||
                const DeepCollectionEquality()
                    .equals(other.message, message)) &&
            (identical(other.conversationId, conversationId) ||
                const DeepCollectionEquality()
                    .equals(other.conversationId, conversationId)) &&
            (identical(other.callSid, callSid) ||
                const DeepCollectionEquality().equals(other.callSid, callSid)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(success) ^
      const DeepCollectionEquality().hash(message) ^
      const DeepCollectionEquality().hash(conversationId) ^
      const DeepCollectionEquality().hash(callSid) ^
      runtimeType.hashCode;
}

extension $TwilioOutboundCallResponseExtension on TwilioOutboundCallResponse {
  TwilioOutboundCallResponse copyWith(
      {bool? success,
      String? message,
      dynamic conversationId,
      dynamic callSid}) {
    return TwilioOutboundCallResponse(
        success: success ?? this.success,
        message: message ?? this.message,
        conversationId: conversationId ?? this.conversationId,
        callSid: callSid ?? this.callSid);
  }

  TwilioOutboundCallResponse copyWithWrapped(
      {Wrapped<bool>? success,
      Wrapped<String>? message,
      Wrapped<dynamic>? conversationId,
      Wrapped<dynamic>? callSid}) {
    return TwilioOutboundCallResponse(
        success: (success != null ? success.value : this.success),
        message: (message != null ? message.value : this.message),
        conversationId: (conversationId != null
            ? conversationId.value
            : this.conversationId),
        callSid: (callSid != null ? callSid.value : this.callSid));
  }
}

@JsonSerializable(explicitToJson: true)
class TxtExportOptions {
  const TxtExportOptions({
    this.maxCharactersPerLine,
    this.includeSpeakers,
    this.includeTimestamps,
    required this.format,
    this.segmentOnSilenceLongerThanS,
    this.maxSegmentDurationS,
    this.maxSegmentChars,
  });

  factory TxtExportOptions.fromJson(Map<String, dynamic> json) =>
      _$TxtExportOptionsFromJson(json);

  static const toJsonFactory = _$TxtExportOptionsToJson;
  Map<String, dynamic> toJson() => _$TxtExportOptionsToJson(this);

  @JsonKey(name: 'max_characters_per_line')
  final dynamic maxCharactersPerLine;
  @JsonKey(name: 'include_speakers', defaultValue: true)
  final bool? includeSpeakers;
  @JsonKey(name: 'include_timestamps', defaultValue: true)
  final bool? includeTimestamps;
  @JsonKey(name: 'format')
  final String format;
  @JsonKey(name: 'segment_on_silence_longer_than_s')
  final dynamic segmentOnSilenceLongerThanS;
  @JsonKey(name: 'max_segment_duration_s')
  final dynamic maxSegmentDurationS;
  @JsonKey(name: 'max_segment_chars')
  final dynamic maxSegmentChars;
  static const fromJsonFactory = _$TxtExportOptionsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is TxtExportOptions &&
            (identical(other.maxCharactersPerLine, maxCharactersPerLine) ||
                const DeepCollectionEquality().equals(
                    other.maxCharactersPerLine, maxCharactersPerLine)) &&
            (identical(other.includeSpeakers, includeSpeakers) ||
                const DeepCollectionEquality()
                    .equals(other.includeSpeakers, includeSpeakers)) &&
            (identical(other.includeTimestamps, includeTimestamps) ||
                const DeepCollectionEquality()
                    .equals(other.includeTimestamps, includeTimestamps)) &&
            (identical(other.format, format) ||
                const DeepCollectionEquality().equals(other.format, format)) &&
            (identical(other.segmentOnSilenceLongerThanS,
                    segmentOnSilenceLongerThanS) ||
                const DeepCollectionEquality().equals(
                    other.segmentOnSilenceLongerThanS,
                    segmentOnSilenceLongerThanS)) &&
            (identical(other.maxSegmentDurationS, maxSegmentDurationS) ||
                const DeepCollectionEquality()
                    .equals(other.maxSegmentDurationS, maxSegmentDurationS)) &&
            (identical(other.maxSegmentChars, maxSegmentChars) ||
                const DeepCollectionEquality()
                    .equals(other.maxSegmentChars, maxSegmentChars)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(maxCharactersPerLine) ^
      const DeepCollectionEquality().hash(includeSpeakers) ^
      const DeepCollectionEquality().hash(includeTimestamps) ^
      const DeepCollectionEquality().hash(format) ^
      const DeepCollectionEquality().hash(segmentOnSilenceLongerThanS) ^
      const DeepCollectionEquality().hash(maxSegmentDurationS) ^
      const DeepCollectionEquality().hash(maxSegmentChars) ^
      runtimeType.hashCode;
}

extension $TxtExportOptionsExtension on TxtExportOptions {
  TxtExportOptions copyWith(
      {dynamic maxCharactersPerLine,
      bool? includeSpeakers,
      bool? includeTimestamps,
      String? format,
      dynamic segmentOnSilenceLongerThanS,
      dynamic maxSegmentDurationS,
      dynamic maxSegmentChars}) {
    return TxtExportOptions(
        maxCharactersPerLine: maxCharactersPerLine ?? this.maxCharactersPerLine,
        includeSpeakers: includeSpeakers ?? this.includeSpeakers,
        includeTimestamps: includeTimestamps ?? this.includeTimestamps,
        format: format ?? this.format,
        segmentOnSilenceLongerThanS:
            segmentOnSilenceLongerThanS ?? this.segmentOnSilenceLongerThanS,
        maxSegmentDurationS: maxSegmentDurationS ?? this.maxSegmentDurationS,
        maxSegmentChars: maxSegmentChars ?? this.maxSegmentChars);
  }

  TxtExportOptions copyWithWrapped(
      {Wrapped<dynamic>? maxCharactersPerLine,
      Wrapped<bool?>? includeSpeakers,
      Wrapped<bool?>? includeTimestamps,
      Wrapped<String>? format,
      Wrapped<dynamic>? segmentOnSilenceLongerThanS,
      Wrapped<dynamic>? maxSegmentDurationS,
      Wrapped<dynamic>? maxSegmentChars}) {
    return TxtExportOptions(
        maxCharactersPerLine: (maxCharactersPerLine != null
            ? maxCharactersPerLine.value
            : this.maxCharactersPerLine),
        includeSpeakers: (includeSpeakers != null
            ? includeSpeakers.value
            : this.includeSpeakers),
        includeTimestamps: (includeTimestamps != null
            ? includeTimestamps.value
            : this.includeTimestamps),
        format: (format != null ? format.value : this.format),
        segmentOnSilenceLongerThanS: (segmentOnSilenceLongerThanS != null
            ? segmentOnSilenceLongerThanS.value
            : this.segmentOnSilenceLongerThanS),
        maxSegmentDurationS: (maxSegmentDurationS != null
            ? maxSegmentDurationS.value
            : this.maxSegmentDurationS),
        maxSegmentChars: (maxSegmentChars != null
            ? maxSegmentChars.value
            : this.maxSegmentChars));
  }
}

@JsonSerializable(explicitToJson: true)
class URLAvatar {
  const URLAvatar({
    this.type,
    this.customUrl,
  });

  factory URLAvatar.fromJson(Map<String, dynamic> json) =>
      _$URLAvatarFromJson(json);

  static const toJsonFactory = _$URLAvatarToJson;
  Map<String, dynamic> toJson() => _$URLAvatarToJson(this);

  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'custom_url')
  final String? customUrl;
  static const fromJsonFactory = _$URLAvatarFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is URLAvatar &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.customUrl, customUrl) ||
                const DeepCollectionEquality()
                    .equals(other.customUrl, customUrl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(customUrl) ^
      runtimeType.hashCode;
}

extension $URLAvatarExtension on URLAvatar {
  URLAvatar copyWith({String? type, String? customUrl}) {
    return URLAvatar(
        type: type ?? this.type, customUrl: customUrl ?? this.customUrl);
  }

  URLAvatar copyWithWrapped(
      {Wrapped<String?>? type, Wrapped<String?>? customUrl}) {
    return URLAvatar(
        type: (type != null ? type.value : this.type),
        customUrl: (customUrl != null ? customUrl.value : this.customUrl));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdatePhoneNumberRequest {
  const UpdatePhoneNumberRequest({
    this.agentId,
  });

  factory UpdatePhoneNumberRequest.fromJson(Map<String, dynamic> json) =>
      _$UpdatePhoneNumberRequestFromJson(json);

  static const toJsonFactory = _$UpdatePhoneNumberRequestToJson;
  Map<String, dynamic> toJson() => _$UpdatePhoneNumberRequestToJson(this);

  @JsonKey(name: 'agent_id')
  final dynamic agentId;
  static const fromJsonFactory = _$UpdatePhoneNumberRequestFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdatePhoneNumberRequest &&
            (identical(other.agentId, agentId) ||
                const DeepCollectionEquality().equals(other.agentId, agentId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(agentId) ^ runtimeType.hashCode;
}

extension $UpdatePhoneNumberRequestExtension on UpdatePhoneNumberRequest {
  UpdatePhoneNumberRequest copyWith({dynamic agentId}) {
    return UpdatePhoneNumberRequest(agentId: agentId ?? this.agentId);
  }

  UpdatePhoneNumberRequest copyWithWrapped({Wrapped<dynamic>? agentId}) {
    return UpdatePhoneNumberRequest(
        agentId: (agentId != null ? agentId.value : this.agentId));
  }
}

@JsonSerializable(explicitToJson: true)
class UpdateWorkspaceMemberResponseModel {
  const UpdateWorkspaceMemberResponseModel({
    required this.status,
  });

  factory UpdateWorkspaceMemberResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$UpdateWorkspaceMemberResponseModelFromJson(json);

  static const toJsonFactory = _$UpdateWorkspaceMemberResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$UpdateWorkspaceMemberResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$UpdateWorkspaceMemberResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UpdateWorkspaceMemberResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $UpdateWorkspaceMemberResponseModelExtension
    on UpdateWorkspaceMemberResponseModel {
  UpdateWorkspaceMemberResponseModel copyWith({String? status}) {
    return UpdateWorkspaceMemberResponseModel(status: status ?? this.status);
  }

  UpdateWorkspaceMemberResponseModel copyWithWrapped(
      {Wrapped<String>? status}) {
    return UpdateWorkspaceMemberResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class UsageCharactersResponseModel {
  const UsageCharactersResponseModel({
    required this.time,
    required this.usage,
  });

  factory UsageCharactersResponseModel.fromJson(Map<String, dynamic> json) =>
      _$UsageCharactersResponseModelFromJson(json);

  static const toJsonFactory = _$UsageCharactersResponseModelToJson;
  Map<String, dynamic> toJson() => _$UsageCharactersResponseModelToJson(this);

  @JsonKey(name: 'time', defaultValue: <int>[])
  final List<int> time;
  @JsonKey(name: 'usage')
  final Map<String, dynamic> usage;
  static const fromJsonFactory = _$UsageCharactersResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UsageCharactersResponseModel &&
            (identical(other.time, time) ||
                const DeepCollectionEquality().equals(other.time, time)) &&
            (identical(other.usage, usage) ||
                const DeepCollectionEquality().equals(other.usage, usage)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(time) ^
      const DeepCollectionEquality().hash(usage) ^
      runtimeType.hashCode;
}

extension $UsageCharactersResponseModelExtension
    on UsageCharactersResponseModel {
  UsageCharactersResponseModel copyWith(
      {List<int>? time, Map<String, dynamic>? usage}) {
    return UsageCharactersResponseModel(
        time: time ?? this.time, usage: usage ?? this.usage);
  }

  UsageCharactersResponseModel copyWithWrapped(
      {Wrapped<List<int>>? time, Wrapped<Map<String, dynamic>>? usage}) {
    return UsageCharactersResponseModel(
        time: (time != null ? time.value : this.time),
        usage: (usage != null ? usage.value : this.usage));
  }
}

@JsonSerializable(explicitToJson: true)
class UserFeedback {
  const UserFeedback({
    required this.score,
    required this.timeInCallSecs,
  });

  factory UserFeedback.fromJson(Map<String, dynamic> json) =>
      _$UserFeedbackFromJson(json);

  static const toJsonFactory = _$UserFeedbackToJson;
  Map<String, dynamic> toJson() => _$UserFeedbackToJson(this);

  @JsonKey(
    name: 'score',
    toJson: userFeedbackScoreToJson,
    fromJson: userFeedbackScoreFromJson,
  )
  final enums.UserFeedbackScore score;
  @JsonKey(name: 'time_in_call_secs')
  final int timeInCallSecs;
  static const fromJsonFactory = _$UserFeedbackFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserFeedback &&
            (identical(other.score, score) ||
                const DeepCollectionEquality().equals(other.score, score)) &&
            (identical(other.timeInCallSecs, timeInCallSecs) ||
                const DeepCollectionEquality()
                    .equals(other.timeInCallSecs, timeInCallSecs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(score) ^
      const DeepCollectionEquality().hash(timeInCallSecs) ^
      runtimeType.hashCode;
}

extension $UserFeedbackExtension on UserFeedback {
  UserFeedback copyWith({enums.UserFeedbackScore? score, int? timeInCallSecs}) {
    return UserFeedback(
        score: score ?? this.score,
        timeInCallSecs: timeInCallSecs ?? this.timeInCallSecs);
  }

  UserFeedback copyWithWrapped(
      {Wrapped<enums.UserFeedbackScore>? score, Wrapped<int>? timeInCallSecs}) {
    return UserFeedback(
        score: (score != null ? score.value : this.score),
        timeInCallSecs: (timeInCallSecs != null
            ? timeInCallSecs.value
            : this.timeInCallSecs));
  }
}

@JsonSerializable(explicitToJson: true)
class UserResponseModel {
  const UserResponseModel({
    required this.userId,
    required this.subscription,
    this.subscriptionExtras,
    required this.isNewUser,
    this.xiApiKey,
    required this.canUseDelayedPaymentMethods,
    required this.isOnboardingCompleted,
    required this.isOnboardingChecklistCompleted,
    this.firstName,
    this.isApiKeyHashed,
    this.xiApiKeyPreview,
    this.referralLinkCode,
    this.partnerstackPartnerDefaultLink,
  });

  factory UserResponseModel.fromJson(Map<String, dynamic> json) =>
      _$UserResponseModelFromJson(json);

  static const toJsonFactory = _$UserResponseModelToJson;
  Map<String, dynamic> toJson() => _$UserResponseModelToJson(this);

  @JsonKey(name: 'user_id')
  final String userId;
  @JsonKey(name: 'subscription')
  final SubscriptionResponseModel subscription;
  @JsonKey(name: 'subscription_extras')
  final dynamic subscriptionExtras;
  @JsonKey(name: 'is_new_user')
  final bool isNewUser;
  @JsonKey(name: 'xi_api_key')
  final dynamic xiApiKey;
  @JsonKey(name: 'can_use_delayed_payment_methods')
  final bool canUseDelayedPaymentMethods;
  @JsonKey(name: 'is_onboarding_completed')
  final bool isOnboardingCompleted;
  @JsonKey(name: 'is_onboarding_checklist_completed')
  final bool isOnboardingChecklistCompleted;
  @JsonKey(name: 'first_name')
  final dynamic firstName;
  @JsonKey(name: 'is_api_key_hashed', defaultValue: false)
  final bool? isApiKeyHashed;
  @JsonKey(name: 'xi_api_key_preview')
  final dynamic xiApiKeyPreview;
  @JsonKey(name: 'referral_link_code')
  final dynamic referralLinkCode;
  @JsonKey(name: 'partnerstack_partner_default_link')
  final dynamic partnerstackPartnerDefaultLink;
  static const fromJsonFactory = _$UserResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UserResponseModel &&
            (identical(other.userId, userId) ||
                const DeepCollectionEquality().equals(other.userId, userId)) &&
            (identical(other.subscription, subscription) ||
                const DeepCollectionEquality()
                    .equals(other.subscription, subscription)) &&
            (identical(other.subscriptionExtras, subscriptionExtras) ||
                const DeepCollectionEquality()
                    .equals(other.subscriptionExtras, subscriptionExtras)) &&
            (identical(other.isNewUser, isNewUser) ||
                const DeepCollectionEquality()
                    .equals(other.isNewUser, isNewUser)) &&
            (identical(other.xiApiKey, xiApiKey) ||
                const DeepCollectionEquality()
                    .equals(other.xiApiKey, xiApiKey)) &&
            (identical(other.canUseDelayedPaymentMethods, canUseDelayedPaymentMethods) ||
                const DeepCollectionEquality().equals(
                    other.canUseDelayedPaymentMethods,
                    canUseDelayedPaymentMethods)) &&
            (identical(other.isOnboardingCompleted, isOnboardingCompleted) ||
                const DeepCollectionEquality().equals(
                    other.isOnboardingCompleted, isOnboardingCompleted)) &&
            (identical(other.isOnboardingChecklistCompleted, isOnboardingChecklistCompleted) ||
                const DeepCollectionEquality().equals(
                    other.isOnboardingChecklistCompleted,
                    isOnboardingChecklistCompleted)) &&
            (identical(other.firstName, firstName) ||
                const DeepCollectionEquality()
                    .equals(other.firstName, firstName)) &&
            (identical(other.isApiKeyHashed, isApiKeyHashed) ||
                const DeepCollectionEquality()
                    .equals(other.isApiKeyHashed, isApiKeyHashed)) &&
            (identical(other.xiApiKeyPreview, xiApiKeyPreview) ||
                const DeepCollectionEquality()
                    .equals(other.xiApiKeyPreview, xiApiKeyPreview)) &&
            (identical(other.referralLinkCode, referralLinkCode) ||
                const DeepCollectionEquality()
                    .equals(other.referralLinkCode, referralLinkCode)) &&
            (identical(other.partnerstackPartnerDefaultLink,
                    partnerstackPartnerDefaultLink) ||
                const DeepCollectionEquality().equals(
                    other.partnerstackPartnerDefaultLink,
                    partnerstackPartnerDefaultLink)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(userId) ^
      const DeepCollectionEquality().hash(subscription) ^
      const DeepCollectionEquality().hash(subscriptionExtras) ^
      const DeepCollectionEquality().hash(isNewUser) ^
      const DeepCollectionEquality().hash(xiApiKey) ^
      const DeepCollectionEquality().hash(canUseDelayedPaymentMethods) ^
      const DeepCollectionEquality().hash(isOnboardingCompleted) ^
      const DeepCollectionEquality().hash(isOnboardingChecklistCompleted) ^
      const DeepCollectionEquality().hash(firstName) ^
      const DeepCollectionEquality().hash(isApiKeyHashed) ^
      const DeepCollectionEquality().hash(xiApiKeyPreview) ^
      const DeepCollectionEquality().hash(referralLinkCode) ^
      const DeepCollectionEquality().hash(partnerstackPartnerDefaultLink) ^
      runtimeType.hashCode;
}

extension $UserResponseModelExtension on UserResponseModel {
  UserResponseModel copyWith(
      {String? userId,
      SubscriptionResponseModel? subscription,
      dynamic subscriptionExtras,
      bool? isNewUser,
      dynamic xiApiKey,
      bool? canUseDelayedPaymentMethods,
      bool? isOnboardingCompleted,
      bool? isOnboardingChecklistCompleted,
      dynamic firstName,
      bool? isApiKeyHashed,
      dynamic xiApiKeyPreview,
      dynamic referralLinkCode,
      dynamic partnerstackPartnerDefaultLink}) {
    return UserResponseModel(
        userId: userId ?? this.userId,
        subscription: subscription ?? this.subscription,
        subscriptionExtras: subscriptionExtras ?? this.subscriptionExtras,
        isNewUser: isNewUser ?? this.isNewUser,
        xiApiKey: xiApiKey ?? this.xiApiKey,
        canUseDelayedPaymentMethods:
            canUseDelayedPaymentMethods ?? this.canUseDelayedPaymentMethods,
        isOnboardingCompleted:
            isOnboardingCompleted ?? this.isOnboardingCompleted,
        isOnboardingChecklistCompleted: isOnboardingChecklistCompleted ??
            this.isOnboardingChecklistCompleted,
        firstName: firstName ?? this.firstName,
        isApiKeyHashed: isApiKeyHashed ?? this.isApiKeyHashed,
        xiApiKeyPreview: xiApiKeyPreview ?? this.xiApiKeyPreview,
        referralLinkCode: referralLinkCode ?? this.referralLinkCode,
        partnerstackPartnerDefaultLink: partnerstackPartnerDefaultLink ??
            this.partnerstackPartnerDefaultLink);
  }

  UserResponseModel copyWithWrapped(
      {Wrapped<String>? userId,
      Wrapped<SubscriptionResponseModel>? subscription,
      Wrapped<dynamic>? subscriptionExtras,
      Wrapped<bool>? isNewUser,
      Wrapped<dynamic>? xiApiKey,
      Wrapped<bool>? canUseDelayedPaymentMethods,
      Wrapped<bool>? isOnboardingCompleted,
      Wrapped<bool>? isOnboardingChecklistCompleted,
      Wrapped<dynamic>? firstName,
      Wrapped<bool?>? isApiKeyHashed,
      Wrapped<dynamic>? xiApiKeyPreview,
      Wrapped<dynamic>? referralLinkCode,
      Wrapped<dynamic>? partnerstackPartnerDefaultLink}) {
    return UserResponseModel(
        userId: (userId != null ? userId.value : this.userId),
        subscription:
            (subscription != null ? subscription.value : this.subscription),
        subscriptionExtras: (subscriptionExtras != null
            ? subscriptionExtras.value
            : this.subscriptionExtras),
        isNewUser: (isNewUser != null ? isNewUser.value : this.isNewUser),
        xiApiKey: (xiApiKey != null ? xiApiKey.value : this.xiApiKey),
        canUseDelayedPaymentMethods: (canUseDelayedPaymentMethods != null
            ? canUseDelayedPaymentMethods.value
            : this.canUseDelayedPaymentMethods),
        isOnboardingCompleted: (isOnboardingCompleted != null
            ? isOnboardingCompleted.value
            : this.isOnboardingCompleted),
        isOnboardingChecklistCompleted: (isOnboardingChecklistCompleted != null
            ? isOnboardingChecklistCompleted.value
            : this.isOnboardingChecklistCompleted),
        firstName: (firstName != null ? firstName.value : this.firstName),
        isApiKeyHashed: (isApiKeyHashed != null
            ? isApiKeyHashed.value
            : this.isApiKeyHashed),
        xiApiKeyPreview: (xiApiKeyPreview != null
            ? xiApiKeyPreview.value
            : this.xiApiKeyPreview),
        referralLinkCode: (referralLinkCode != null
            ? referralLinkCode.value
            : this.referralLinkCode),
        partnerstackPartnerDefaultLink: (partnerstackPartnerDefaultLink != null
            ? partnerstackPartnerDefaultLink.value
            : this.partnerstackPartnerDefaultLink));
  }
}

@JsonSerializable(explicitToJson: true)
class UtteranceResponseModel {
  const UtteranceResponseModel({
    required this.start,
    required this.end,
  });

  factory UtteranceResponseModel.fromJson(Map<String, dynamic> json) =>
      _$UtteranceResponseModelFromJson(json);

  static const toJsonFactory = _$UtteranceResponseModelToJson;
  Map<String, dynamic> toJson() => _$UtteranceResponseModelToJson(this);

  @JsonKey(name: 'start')
  final double start;
  @JsonKey(name: 'end')
  final double end;
  static const fromJsonFactory = _$UtteranceResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is UtteranceResponseModel &&
            (identical(other.start, start) ||
                const DeepCollectionEquality().equals(other.start, start)) &&
            (identical(other.end, end) ||
                const DeepCollectionEquality().equals(other.end, end)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(start) ^
      const DeepCollectionEquality().hash(end) ^
      runtimeType.hashCode;
}

extension $UtteranceResponseModelExtension on UtteranceResponseModel {
  UtteranceResponseModel copyWith({double? start, double? end}) {
    return UtteranceResponseModel(
        start: start ?? this.start, end: end ?? this.end);
  }

  UtteranceResponseModel copyWithWrapped(
      {Wrapped<double>? start, Wrapped<double>? end}) {
    return UtteranceResponseModel(
        start: (start != null ? start.value : this.start),
        end: (end != null ? end.value : this.end));
  }
}

@JsonSerializable(explicitToJson: true)
class ValidationError {
  const ValidationError({
    required this.loc,
    required this.msg,
    required this.type,
  });

  factory ValidationError.fromJson(Map<String, dynamic> json) =>
      _$ValidationErrorFromJson(json);

  static const toJsonFactory = _$ValidationErrorToJson;
  Map<String, dynamic> toJson() => _$ValidationErrorToJson(this);

  @JsonKey(name: 'loc', defaultValue: <Object>[])
  final List<Object> loc;
  @JsonKey(name: 'msg')
  final String msg;
  @JsonKey(name: 'type')
  final String type;
  static const fromJsonFactory = _$ValidationErrorFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is ValidationError &&
            (identical(other.loc, loc) ||
                const DeepCollectionEquality().equals(other.loc, loc)) &&
            (identical(other.msg, msg) ||
                const DeepCollectionEquality().equals(other.msg, msg)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(loc) ^
      const DeepCollectionEquality().hash(msg) ^
      const DeepCollectionEquality().hash(type) ^
      runtimeType.hashCode;
}

extension $ValidationErrorExtension on ValidationError {
  ValidationError copyWith({List<Object>? loc, String? msg, String? type}) {
    return ValidationError(
        loc: loc ?? this.loc, msg: msg ?? this.msg, type: type ?? this.type);
  }

  ValidationError copyWithWrapped(
      {Wrapped<List<Object>>? loc,
      Wrapped<String>? msg,
      Wrapped<String>? type}) {
    return ValidationError(
        loc: (loc != null ? loc.value : this.loc),
        msg: (msg != null ? msg.value : this.msg),
        type: (type != null ? type.value : this.type));
  }
}

@JsonSerializable(explicitToJson: true)
class VerificationAttemptResponseModel {
  const VerificationAttemptResponseModel({
    required this.text,
    required this.dateUnix,
    required this.accepted,
    required this.similarity,
    required this.levenshteinDistance,
    this.recording,
  });

  factory VerificationAttemptResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$VerificationAttemptResponseModelFromJson(json);

  static const toJsonFactory = _$VerificationAttemptResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$VerificationAttemptResponseModelToJson(this);

  @JsonKey(name: 'text')
  final String text;
  @JsonKey(name: 'date_unix')
  final int dateUnix;
  @JsonKey(name: 'accepted')
  final bool accepted;
  @JsonKey(name: 'similarity')
  final double similarity;
  @JsonKey(name: 'levenshtein_distance')
  final double levenshteinDistance;
  @JsonKey(name: 'recording')
  final dynamic recording;
  static const fromJsonFactory = _$VerificationAttemptResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VerificationAttemptResponseModel &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.dateUnix, dateUnix) ||
                const DeepCollectionEquality()
                    .equals(other.dateUnix, dateUnix)) &&
            (identical(other.accepted, accepted) ||
                const DeepCollectionEquality()
                    .equals(other.accepted, accepted)) &&
            (identical(other.similarity, similarity) ||
                const DeepCollectionEquality()
                    .equals(other.similarity, similarity)) &&
            (identical(other.levenshteinDistance, levenshteinDistance) ||
                const DeepCollectionEquality()
                    .equals(other.levenshteinDistance, levenshteinDistance)) &&
            (identical(other.recording, recording) ||
                const DeepCollectionEquality()
                    .equals(other.recording, recording)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(dateUnix) ^
      const DeepCollectionEquality().hash(accepted) ^
      const DeepCollectionEquality().hash(similarity) ^
      const DeepCollectionEquality().hash(levenshteinDistance) ^
      const DeepCollectionEquality().hash(recording) ^
      runtimeType.hashCode;
}

extension $VerificationAttemptResponseModelExtension
    on VerificationAttemptResponseModel {
  VerificationAttemptResponseModel copyWith(
      {String? text,
      int? dateUnix,
      bool? accepted,
      double? similarity,
      double? levenshteinDistance,
      dynamic recording}) {
    return VerificationAttemptResponseModel(
        text: text ?? this.text,
        dateUnix: dateUnix ?? this.dateUnix,
        accepted: accepted ?? this.accepted,
        similarity: similarity ?? this.similarity,
        levenshteinDistance: levenshteinDistance ?? this.levenshteinDistance,
        recording: recording ?? this.recording);
  }

  VerificationAttemptResponseModel copyWithWrapped(
      {Wrapped<String>? text,
      Wrapped<int>? dateUnix,
      Wrapped<bool>? accepted,
      Wrapped<double>? similarity,
      Wrapped<double>? levenshteinDistance,
      Wrapped<dynamic>? recording}) {
    return VerificationAttemptResponseModel(
        text: (text != null ? text.value : this.text),
        dateUnix: (dateUnix != null ? dateUnix.value : this.dateUnix),
        accepted: (accepted != null ? accepted.value : this.accepted),
        similarity: (similarity != null ? similarity.value : this.similarity),
        levenshteinDistance: (levenshteinDistance != null
            ? levenshteinDistance.value
            : this.levenshteinDistance),
        recording: (recording != null ? recording.value : this.recording));
  }
}

@JsonSerializable(explicitToJson: true)
class VerifiedVoiceLanguageResponseModel {
  const VerifiedVoiceLanguageResponseModel({
    required this.language,
    required this.modelId,
    this.accent,
    this.locale,
    this.previewUrl,
  });

  factory VerifiedVoiceLanguageResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$VerifiedVoiceLanguageResponseModelFromJson(json);

  static const toJsonFactory = _$VerifiedVoiceLanguageResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$VerifiedVoiceLanguageResponseModelToJson(this);

  @JsonKey(name: 'language')
  final String language;
  @JsonKey(name: 'model_id')
  final String modelId;
  @JsonKey(name: 'accent')
  final dynamic accent;
  @JsonKey(name: 'locale')
  final dynamic locale;
  @JsonKey(name: 'preview_url')
  final dynamic previewUrl;
  static const fromJsonFactory = _$VerifiedVoiceLanguageResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VerifiedVoiceLanguageResponseModel &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.modelId, modelId) ||
                const DeepCollectionEquality()
                    .equals(other.modelId, modelId)) &&
            (identical(other.accent, accent) ||
                const DeepCollectionEquality().equals(other.accent, accent)) &&
            (identical(other.locale, locale) ||
                const DeepCollectionEquality().equals(other.locale, locale)) &&
            (identical(other.previewUrl, previewUrl) ||
                const DeepCollectionEquality()
                    .equals(other.previewUrl, previewUrl)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(modelId) ^
      const DeepCollectionEquality().hash(accent) ^
      const DeepCollectionEquality().hash(locale) ^
      const DeepCollectionEquality().hash(previewUrl) ^
      runtimeType.hashCode;
}

extension $VerifiedVoiceLanguageResponseModelExtension
    on VerifiedVoiceLanguageResponseModel {
  VerifiedVoiceLanguageResponseModel copyWith(
      {String? language,
      String? modelId,
      dynamic accent,
      dynamic locale,
      dynamic previewUrl}) {
    return VerifiedVoiceLanguageResponseModel(
        language: language ?? this.language,
        modelId: modelId ?? this.modelId,
        accent: accent ?? this.accent,
        locale: locale ?? this.locale,
        previewUrl: previewUrl ?? this.previewUrl);
  }

  VerifiedVoiceLanguageResponseModel copyWithWrapped(
      {Wrapped<String>? language,
      Wrapped<String>? modelId,
      Wrapped<dynamic>? accent,
      Wrapped<dynamic>? locale,
      Wrapped<dynamic>? previewUrl}) {
    return VerifiedVoiceLanguageResponseModel(
        language: (language != null ? language.value : this.language),
        modelId: (modelId != null ? modelId.value : this.modelId),
        accent: (accent != null ? accent.value : this.accent),
        locale: (locale != null ? locale.value : this.locale),
        previewUrl: (previewUrl != null ? previewUrl.value : this.previewUrl));
  }
}

@JsonSerializable(explicitToJson: true)
class VerifyPVCVoiceCaptchaResponseModel {
  const VerifyPVCVoiceCaptchaResponseModel({
    required this.status,
  });

  factory VerifyPVCVoiceCaptchaResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$VerifyPVCVoiceCaptchaResponseModelFromJson(json);

  static const toJsonFactory = _$VerifyPVCVoiceCaptchaResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$VerifyPVCVoiceCaptchaResponseModelToJson(this);

  @JsonKey(name: 'status')
  final String status;
  static const fromJsonFactory = _$VerifyPVCVoiceCaptchaResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VerifyPVCVoiceCaptchaResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^ runtimeType.hashCode;
}

extension $VerifyPVCVoiceCaptchaResponseModelExtension
    on VerifyPVCVoiceCaptchaResponseModel {
  VerifyPVCVoiceCaptchaResponseModel copyWith({String? status}) {
    return VerifyPVCVoiceCaptchaResponseModel(status: status ?? this.status);
  }

  VerifyPVCVoiceCaptchaResponseModel copyWithWrapped(
      {Wrapped<String>? status}) {
    return VerifyPVCVoiceCaptchaResponseModel(
        status: (status != null ? status.value : this.status));
  }
}

@JsonSerializable(explicitToJson: true)
class VoiceGenerationParameterOptionResponseModel {
  const VoiceGenerationParameterOptionResponseModel({
    required this.name,
    required this.code,
  });

  factory VoiceGenerationParameterOptionResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$VoiceGenerationParameterOptionResponseModelFromJson(json);

  static const toJsonFactory =
      _$VoiceGenerationParameterOptionResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$VoiceGenerationParameterOptionResponseModelToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'code')
  final String code;
  static const fromJsonFactory =
      _$VoiceGenerationParameterOptionResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VoiceGenerationParameterOptionResponseModel &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.code, code) ||
                const DeepCollectionEquality().equals(other.code, code)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(code) ^
      runtimeType.hashCode;
}

extension $VoiceGenerationParameterOptionResponseModelExtension
    on VoiceGenerationParameterOptionResponseModel {
  VoiceGenerationParameterOptionResponseModel copyWith(
      {String? name, String? code}) {
    return VoiceGenerationParameterOptionResponseModel(
        name: name ?? this.name, code: code ?? this.code);
  }

  VoiceGenerationParameterOptionResponseModel copyWithWrapped(
      {Wrapped<String>? name, Wrapped<String>? code}) {
    return VoiceGenerationParameterOptionResponseModel(
        name: (name != null ? name.value : this.name),
        code: (code != null ? code.value : this.code));
  }
}

@JsonSerializable(explicitToJson: true)
class VoiceGenerationParameterResponseModel {
  const VoiceGenerationParameterResponseModel({
    required this.genders,
    required this.accents,
    required this.ages,
    required this.minimumCharacters,
    required this.maximumCharacters,
    required this.minimumAccentStrength,
    required this.maximumAccentStrength,
  });

  factory VoiceGenerationParameterResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$VoiceGenerationParameterResponseModelFromJson(json);

  static const toJsonFactory = _$VoiceGenerationParameterResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$VoiceGenerationParameterResponseModelToJson(this);

  @JsonKey(
      name: 'genders',
      defaultValue: <VoiceGenerationParameterOptionResponseModel>[])
  final List<VoiceGenerationParameterOptionResponseModel> genders;
  @JsonKey(
      name: 'accents',
      defaultValue: <VoiceGenerationParameterOptionResponseModel>[])
  final List<VoiceGenerationParameterOptionResponseModel> accents;
  @JsonKey(
      name: 'ages',
      defaultValue: <VoiceGenerationParameterOptionResponseModel>[])
  final List<VoiceGenerationParameterOptionResponseModel> ages;
  @JsonKey(name: 'minimum_characters')
  final int minimumCharacters;
  @JsonKey(name: 'maximum_characters')
  final int maximumCharacters;
  @JsonKey(name: 'minimum_accent_strength')
  final double minimumAccentStrength;
  @JsonKey(name: 'maximum_accent_strength')
  final double maximumAccentStrength;
  static const fromJsonFactory =
      _$VoiceGenerationParameterResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VoiceGenerationParameterResponseModel &&
            (identical(other.genders, genders) ||
                const DeepCollectionEquality()
                    .equals(other.genders, genders)) &&
            (identical(other.accents, accents) ||
                const DeepCollectionEquality()
                    .equals(other.accents, accents)) &&
            (identical(other.ages, ages) ||
                const DeepCollectionEquality().equals(other.ages, ages)) &&
            (identical(other.minimumCharacters, minimumCharacters) ||
                const DeepCollectionEquality()
                    .equals(other.minimumCharacters, minimumCharacters)) &&
            (identical(other.maximumCharacters, maximumCharacters) ||
                const DeepCollectionEquality()
                    .equals(other.maximumCharacters, maximumCharacters)) &&
            (identical(other.minimumAccentStrength, minimumAccentStrength) ||
                const DeepCollectionEquality().equals(
                    other.minimumAccentStrength, minimumAccentStrength)) &&
            (identical(other.maximumAccentStrength, maximumAccentStrength) ||
                const DeepCollectionEquality().equals(
                    other.maximumAccentStrength, maximumAccentStrength)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(genders) ^
      const DeepCollectionEquality().hash(accents) ^
      const DeepCollectionEquality().hash(ages) ^
      const DeepCollectionEquality().hash(minimumCharacters) ^
      const DeepCollectionEquality().hash(maximumCharacters) ^
      const DeepCollectionEquality().hash(minimumAccentStrength) ^
      const DeepCollectionEquality().hash(maximumAccentStrength) ^
      runtimeType.hashCode;
}

extension $VoiceGenerationParameterResponseModelExtension
    on VoiceGenerationParameterResponseModel {
  VoiceGenerationParameterResponseModel copyWith(
      {List<VoiceGenerationParameterOptionResponseModel>? genders,
      List<VoiceGenerationParameterOptionResponseModel>? accents,
      List<VoiceGenerationParameterOptionResponseModel>? ages,
      int? minimumCharacters,
      int? maximumCharacters,
      double? minimumAccentStrength,
      double? maximumAccentStrength}) {
    return VoiceGenerationParameterResponseModel(
        genders: genders ?? this.genders,
        accents: accents ?? this.accents,
        ages: ages ?? this.ages,
        minimumCharacters: minimumCharacters ?? this.minimumCharacters,
        maximumCharacters: maximumCharacters ?? this.maximumCharacters,
        minimumAccentStrength:
            minimumAccentStrength ?? this.minimumAccentStrength,
        maximumAccentStrength:
            maximumAccentStrength ?? this.maximumAccentStrength);
  }

  VoiceGenerationParameterResponseModel copyWithWrapped(
      {Wrapped<List<VoiceGenerationParameterOptionResponseModel>>? genders,
      Wrapped<List<VoiceGenerationParameterOptionResponseModel>>? accents,
      Wrapped<List<VoiceGenerationParameterOptionResponseModel>>? ages,
      Wrapped<int>? minimumCharacters,
      Wrapped<int>? maximumCharacters,
      Wrapped<double>? minimumAccentStrength,
      Wrapped<double>? maximumAccentStrength}) {
    return VoiceGenerationParameterResponseModel(
        genders: (genders != null ? genders.value : this.genders),
        accents: (accents != null ? accents.value : this.accents),
        ages: (ages != null ? ages.value : this.ages),
        minimumCharacters: (minimumCharacters != null
            ? minimumCharacters.value
            : this.minimumCharacters),
        maximumCharacters: (maximumCharacters != null
            ? maximumCharacters.value
            : this.maximumCharacters),
        minimumAccentStrength: (minimumAccentStrength != null
            ? minimumAccentStrength.value
            : this.minimumAccentStrength),
        maximumAccentStrength: (maximumAccentStrength != null
            ? maximumAccentStrength.value
            : this.maximumAccentStrength));
  }
}

@JsonSerializable(explicitToJson: true)
class VoicePreviewResponseModel {
  const VoicePreviewResponseModel({
    required this.audioBase64,
    required this.generatedVoiceId,
    required this.mediaType,
    required this.durationSecs,
  });

  factory VoicePreviewResponseModel.fromJson(Map<String, dynamic> json) =>
      _$VoicePreviewResponseModelFromJson(json);

  static const toJsonFactory = _$VoicePreviewResponseModelToJson;
  Map<String, dynamic> toJson() => _$VoicePreviewResponseModelToJson(this);

  @JsonKey(name: 'audio_base_64')
  final String audioBase64;
  @JsonKey(name: 'generated_voice_id')
  final String generatedVoiceId;
  @JsonKey(name: 'media_type')
  final String mediaType;
  @JsonKey(name: 'duration_secs')
  final double durationSecs;
  static const fromJsonFactory = _$VoicePreviewResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VoicePreviewResponseModel &&
            (identical(other.audioBase64, audioBase64) ||
                const DeepCollectionEquality()
                    .equals(other.audioBase64, audioBase64)) &&
            (identical(other.generatedVoiceId, generatedVoiceId) ||
                const DeepCollectionEquality()
                    .equals(other.generatedVoiceId, generatedVoiceId)) &&
            (identical(other.mediaType, mediaType) ||
                const DeepCollectionEquality()
                    .equals(other.mediaType, mediaType)) &&
            (identical(other.durationSecs, durationSecs) ||
                const DeepCollectionEquality()
                    .equals(other.durationSecs, durationSecs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(audioBase64) ^
      const DeepCollectionEquality().hash(generatedVoiceId) ^
      const DeepCollectionEquality().hash(mediaType) ^
      const DeepCollectionEquality().hash(durationSecs) ^
      runtimeType.hashCode;
}

extension $VoicePreviewResponseModelExtension on VoicePreviewResponseModel {
  VoicePreviewResponseModel copyWith(
      {String? audioBase64,
      String? generatedVoiceId,
      String? mediaType,
      double? durationSecs}) {
    return VoicePreviewResponseModel(
        audioBase64: audioBase64 ?? this.audioBase64,
        generatedVoiceId: generatedVoiceId ?? this.generatedVoiceId,
        mediaType: mediaType ?? this.mediaType,
        durationSecs: durationSecs ?? this.durationSecs);
  }

  VoicePreviewResponseModel copyWithWrapped(
      {Wrapped<String>? audioBase64,
      Wrapped<String>? generatedVoiceId,
      Wrapped<String>? mediaType,
      Wrapped<double>? durationSecs}) {
    return VoicePreviewResponseModel(
        audioBase64:
            (audioBase64 != null ? audioBase64.value : this.audioBase64),
        generatedVoiceId: (generatedVoiceId != null
            ? generatedVoiceId.value
            : this.generatedVoiceId),
        mediaType: (mediaType != null ? mediaType.value : this.mediaType),
        durationSecs:
            (durationSecs != null ? durationSecs.value : this.durationSecs));
  }
}

@JsonSerializable(explicitToJson: true)
class VoicePreviewsRequestModel {
  const VoicePreviewsRequestModel({
    required this.voiceDescription,
    this.text,
    this.autoGenerateText,
    this.loudness,
    this.quality,
    this.seed,
    this.guidanceScale,
  });

  factory VoicePreviewsRequestModel.fromJson(Map<String, dynamic> json) =>
      _$VoicePreviewsRequestModelFromJson(json);

  static const toJsonFactory = _$VoicePreviewsRequestModelToJson;
  Map<String, dynamic> toJson() => _$VoicePreviewsRequestModelToJson(this);

  @JsonKey(name: 'voice_description')
  final String voiceDescription;
  @JsonKey(name: 'text')
  final dynamic text;
  @JsonKey(name: 'auto_generate_text', defaultValue: false)
  final bool? autoGenerateText;
  @JsonKey(name: 'loudness')
  final double? loudness;
  @JsonKey(name: 'quality')
  final double? quality;
  @JsonKey(name: 'seed')
  final dynamic seed;
  @JsonKey(name: 'guidance_scale')
  final double? guidanceScale;
  static const fromJsonFactory = _$VoicePreviewsRequestModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VoicePreviewsRequestModel &&
            (identical(other.voiceDescription, voiceDescription) ||
                const DeepCollectionEquality()
                    .equals(other.voiceDescription, voiceDescription)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)) &&
            (identical(other.autoGenerateText, autoGenerateText) ||
                const DeepCollectionEquality()
                    .equals(other.autoGenerateText, autoGenerateText)) &&
            (identical(other.loudness, loudness) ||
                const DeepCollectionEquality()
                    .equals(other.loudness, loudness)) &&
            (identical(other.quality, quality) ||
                const DeepCollectionEquality()
                    .equals(other.quality, quality)) &&
            (identical(other.seed, seed) ||
                const DeepCollectionEquality().equals(other.seed, seed)) &&
            (identical(other.guidanceScale, guidanceScale) ||
                const DeepCollectionEquality()
                    .equals(other.guidanceScale, guidanceScale)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(voiceDescription) ^
      const DeepCollectionEquality().hash(text) ^
      const DeepCollectionEquality().hash(autoGenerateText) ^
      const DeepCollectionEquality().hash(loudness) ^
      const DeepCollectionEquality().hash(quality) ^
      const DeepCollectionEquality().hash(seed) ^
      const DeepCollectionEquality().hash(guidanceScale) ^
      runtimeType.hashCode;
}

extension $VoicePreviewsRequestModelExtension on VoicePreviewsRequestModel {
  VoicePreviewsRequestModel copyWith(
      {String? voiceDescription,
      dynamic text,
      bool? autoGenerateText,
      double? loudness,
      double? quality,
      dynamic seed,
      double? guidanceScale}) {
    return VoicePreviewsRequestModel(
        voiceDescription: voiceDescription ?? this.voiceDescription,
        text: text ?? this.text,
        autoGenerateText: autoGenerateText ?? this.autoGenerateText,
        loudness: loudness ?? this.loudness,
        quality: quality ?? this.quality,
        seed: seed ?? this.seed,
        guidanceScale: guidanceScale ?? this.guidanceScale);
  }

  VoicePreviewsRequestModel copyWithWrapped(
      {Wrapped<String>? voiceDescription,
      Wrapped<dynamic>? text,
      Wrapped<bool?>? autoGenerateText,
      Wrapped<double?>? loudness,
      Wrapped<double?>? quality,
      Wrapped<dynamic>? seed,
      Wrapped<double?>? guidanceScale}) {
    return VoicePreviewsRequestModel(
        voiceDescription: (voiceDescription != null
            ? voiceDescription.value
            : this.voiceDescription),
        text: (text != null ? text.value : this.text),
        autoGenerateText: (autoGenerateText != null
            ? autoGenerateText.value
            : this.autoGenerateText),
        loudness: (loudness != null ? loudness.value : this.loudness),
        quality: (quality != null ? quality.value : this.quality),
        seed: (seed != null ? seed.value : this.seed),
        guidanceScale:
            (guidanceScale != null ? guidanceScale.value : this.guidanceScale));
  }
}

@JsonSerializable(explicitToJson: true)
class VoicePreviewsResponseModel {
  const VoicePreviewsResponseModel({
    required this.previews,
    required this.text,
  });

  factory VoicePreviewsResponseModel.fromJson(Map<String, dynamic> json) =>
      _$VoicePreviewsResponseModelFromJson(json);

  static const toJsonFactory = _$VoicePreviewsResponseModelToJson;
  Map<String, dynamic> toJson() => _$VoicePreviewsResponseModelToJson(this);

  @JsonKey(name: 'previews', defaultValue: <VoicePreviewResponseModel>[])
  final List<VoicePreviewResponseModel> previews;
  @JsonKey(name: 'text')
  final String text;
  static const fromJsonFactory = _$VoicePreviewsResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VoicePreviewsResponseModel &&
            (identical(other.previews, previews) ||
                const DeepCollectionEquality()
                    .equals(other.previews, previews)) &&
            (identical(other.text, text) ||
                const DeepCollectionEquality().equals(other.text, text)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(previews) ^
      const DeepCollectionEquality().hash(text) ^
      runtimeType.hashCode;
}

extension $VoicePreviewsResponseModelExtension on VoicePreviewsResponseModel {
  VoicePreviewsResponseModel copyWith(
      {List<VoicePreviewResponseModel>? previews, String? text}) {
    return VoicePreviewsResponseModel(
        previews: previews ?? this.previews, text: text ?? this.text);
  }

  VoicePreviewsResponseModel copyWithWrapped(
      {Wrapped<List<VoicePreviewResponseModel>>? previews,
      Wrapped<String>? text}) {
    return VoicePreviewsResponseModel(
        previews: (previews != null ? previews.value : this.previews),
        text: (text != null ? text.value : this.text));
  }
}

@JsonSerializable(explicitToJson: true)
class VoiceResponseModel {
  const VoiceResponseModel({
    required this.voiceId,
    required this.name,
    this.samples,
    required this.category,
    this.fineTuning,
    required this.labels,
    this.description,
    this.previewUrl,
    required this.availableForTiers,
    this.settings,
    this.sharing,
    required this.highQualityBaseModelIds,
    this.verifiedLanguages,
    this.safetyControl,
    this.voiceVerification,
    this.permissionOnResource,
    this.isOwner,
    this.isLegacy,
    this.isMixed,
    this.createdAtUnix,
  });

  factory VoiceResponseModel.fromJson(Map<String, dynamic> json) =>
      _$VoiceResponseModelFromJson(json);

  static const toJsonFactory = _$VoiceResponseModelToJson;
  Map<String, dynamic> toJson() => _$VoiceResponseModelToJson(this);

  @JsonKey(name: 'voice_id')
  final String voiceId;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'samples')
  final dynamic samples;
  @JsonKey(
    name: 'category',
    toJson: voiceResponseModelCategoryToJson,
    fromJson: voiceResponseModelCategoryFromJson,
  )
  final enums.VoiceResponseModelCategory category;
  @JsonKey(name: 'fine_tuning')
  final dynamic fineTuning;
  @JsonKey(name: 'labels')
  final Map<String, dynamic> labels;
  @JsonKey(name: 'description')
  final dynamic description;
  @JsonKey(name: 'preview_url')
  final dynamic previewUrl;
  @JsonKey(name: 'available_for_tiers', defaultValue: <String>[])
  final List<String> availableForTiers;
  @JsonKey(name: 'settings')
  final dynamic settings;
  @JsonKey(name: 'sharing')
  final dynamic sharing;
  @JsonKey(name: 'high_quality_base_model_ids', defaultValue: <String>[])
  final List<String> highQualityBaseModelIds;
  @JsonKey(name: 'verified_languages')
  final dynamic verifiedLanguages;
  @JsonKey(name: 'safety_control')
  final dynamic safetyControl;
  @JsonKey(name: 'voice_verification')
  final dynamic voiceVerification;
  @JsonKey(name: 'permission_on_resource')
  final dynamic permissionOnResource;
  @JsonKey(name: 'is_owner')
  final dynamic isOwner;
  @JsonKey(name: 'is_legacy', defaultValue: false)
  final bool? isLegacy;
  @JsonKey(name: 'is_mixed', defaultValue: false)
  final bool? isMixed;
  @JsonKey(name: 'created_at_unix')
  final dynamic createdAtUnix;
  static const fromJsonFactory = _$VoiceResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VoiceResponseModel &&
            (identical(other.voiceId, voiceId) ||
                const DeepCollectionEquality()
                    .equals(other.voiceId, voiceId)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.samples, samples) ||
                const DeepCollectionEquality()
                    .equals(other.samples, samples)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.fineTuning, fineTuning) ||
                const DeepCollectionEquality()
                    .equals(other.fineTuning, fineTuning)) &&
            (identical(other.labels, labels) ||
                const DeepCollectionEquality().equals(other.labels, labels)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.previewUrl, previewUrl) ||
                const DeepCollectionEquality()
                    .equals(other.previewUrl, previewUrl)) &&
            (identical(other.availableForTiers, availableForTiers) ||
                const DeepCollectionEquality()
                    .equals(other.availableForTiers, availableForTiers)) &&
            (identical(other.settings, settings) ||
                const DeepCollectionEquality()
                    .equals(other.settings, settings)) &&
            (identical(other.sharing, sharing) ||
                const DeepCollectionEquality()
                    .equals(other.sharing, sharing)) &&
            (identical(other.highQualityBaseModelIds, highQualityBaseModelIds) ||
                const DeepCollectionEquality().equals(
                    other.highQualityBaseModelIds, highQualityBaseModelIds)) &&
            (identical(other.verifiedLanguages, verifiedLanguages) ||
                const DeepCollectionEquality()
                    .equals(other.verifiedLanguages, verifiedLanguages)) &&
            (identical(other.safetyControl, safetyControl) ||
                const DeepCollectionEquality()
                    .equals(other.safetyControl, safetyControl)) &&
            (identical(other.voiceVerification, voiceVerification) ||
                const DeepCollectionEquality()
                    .equals(other.voiceVerification, voiceVerification)) &&
            (identical(other.permissionOnResource, permissionOnResource) ||
                const DeepCollectionEquality().equals(
                    other.permissionOnResource, permissionOnResource)) &&
            (identical(other.isOwner, isOwner) ||
                const DeepCollectionEquality()
                    .equals(other.isOwner, isOwner)) &&
            (identical(other.isLegacy, isLegacy) ||
                const DeepCollectionEquality()
                    .equals(other.isLegacy, isLegacy)) &&
            (identical(other.isMixed, isMixed) ||
                const DeepCollectionEquality()
                    .equals(other.isMixed, isMixed)) &&
            (identical(other.createdAtUnix, createdAtUnix) ||
                const DeepCollectionEquality()
                    .equals(other.createdAtUnix, createdAtUnix)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(voiceId) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(samples) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(fineTuning) ^
      const DeepCollectionEquality().hash(labels) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(previewUrl) ^
      const DeepCollectionEquality().hash(availableForTiers) ^
      const DeepCollectionEquality().hash(settings) ^
      const DeepCollectionEquality().hash(sharing) ^
      const DeepCollectionEquality().hash(highQualityBaseModelIds) ^
      const DeepCollectionEquality().hash(verifiedLanguages) ^
      const DeepCollectionEquality().hash(safetyControl) ^
      const DeepCollectionEquality().hash(voiceVerification) ^
      const DeepCollectionEquality().hash(permissionOnResource) ^
      const DeepCollectionEquality().hash(isOwner) ^
      const DeepCollectionEquality().hash(isLegacy) ^
      const DeepCollectionEquality().hash(isMixed) ^
      const DeepCollectionEquality().hash(createdAtUnix) ^
      runtimeType.hashCode;
}

extension $VoiceResponseModelExtension on VoiceResponseModel {
  VoiceResponseModel copyWith(
      {String? voiceId,
      String? name,
      dynamic samples,
      enums.VoiceResponseModelCategory? category,
      dynamic fineTuning,
      Map<String, dynamic>? labels,
      dynamic description,
      dynamic previewUrl,
      List<String>? availableForTiers,
      dynamic settings,
      dynamic sharing,
      List<String>? highQualityBaseModelIds,
      dynamic verifiedLanguages,
      dynamic safetyControl,
      dynamic voiceVerification,
      dynamic permissionOnResource,
      dynamic isOwner,
      bool? isLegacy,
      bool? isMixed,
      dynamic createdAtUnix}) {
    return VoiceResponseModel(
        voiceId: voiceId ?? this.voiceId,
        name: name ?? this.name,
        samples: samples ?? this.samples,
        category: category ?? this.category,
        fineTuning: fineTuning ?? this.fineTuning,
        labels: labels ?? this.labels,
        description: description ?? this.description,
        previewUrl: previewUrl ?? this.previewUrl,
        availableForTiers: availableForTiers ?? this.availableForTiers,
        settings: settings ?? this.settings,
        sharing: sharing ?? this.sharing,
        highQualityBaseModelIds:
            highQualityBaseModelIds ?? this.highQualityBaseModelIds,
        verifiedLanguages: verifiedLanguages ?? this.verifiedLanguages,
        safetyControl: safetyControl ?? this.safetyControl,
        voiceVerification: voiceVerification ?? this.voiceVerification,
        permissionOnResource: permissionOnResource ?? this.permissionOnResource,
        isOwner: isOwner ?? this.isOwner,
        isLegacy: isLegacy ?? this.isLegacy,
        isMixed: isMixed ?? this.isMixed,
        createdAtUnix: createdAtUnix ?? this.createdAtUnix);
  }

  VoiceResponseModel copyWithWrapped(
      {Wrapped<String>? voiceId,
      Wrapped<String>? name,
      Wrapped<dynamic>? samples,
      Wrapped<enums.VoiceResponseModelCategory>? category,
      Wrapped<dynamic>? fineTuning,
      Wrapped<Map<String, dynamic>>? labels,
      Wrapped<dynamic>? description,
      Wrapped<dynamic>? previewUrl,
      Wrapped<List<String>>? availableForTiers,
      Wrapped<dynamic>? settings,
      Wrapped<dynamic>? sharing,
      Wrapped<List<String>>? highQualityBaseModelIds,
      Wrapped<dynamic>? verifiedLanguages,
      Wrapped<dynamic>? safetyControl,
      Wrapped<dynamic>? voiceVerification,
      Wrapped<dynamic>? permissionOnResource,
      Wrapped<dynamic>? isOwner,
      Wrapped<bool?>? isLegacy,
      Wrapped<bool?>? isMixed,
      Wrapped<dynamic>? createdAtUnix}) {
    return VoiceResponseModel(
        voiceId: (voiceId != null ? voiceId.value : this.voiceId),
        name: (name != null ? name.value : this.name),
        samples: (samples != null ? samples.value : this.samples),
        category: (category != null ? category.value : this.category),
        fineTuning: (fineTuning != null ? fineTuning.value : this.fineTuning),
        labels: (labels != null ? labels.value : this.labels),
        description:
            (description != null ? description.value : this.description),
        previewUrl: (previewUrl != null ? previewUrl.value : this.previewUrl),
        availableForTiers: (availableForTiers != null
            ? availableForTiers.value
            : this.availableForTiers),
        settings: (settings != null ? settings.value : this.settings),
        sharing: (sharing != null ? sharing.value : this.sharing),
        highQualityBaseModelIds: (highQualityBaseModelIds != null
            ? highQualityBaseModelIds.value
            : this.highQualityBaseModelIds),
        verifiedLanguages: (verifiedLanguages != null
            ? verifiedLanguages.value
            : this.verifiedLanguages),
        safetyControl:
            (safetyControl != null ? safetyControl.value : this.safetyControl),
        voiceVerification: (voiceVerification != null
            ? voiceVerification.value
            : this.voiceVerification),
        permissionOnResource: (permissionOnResource != null
            ? permissionOnResource.value
            : this.permissionOnResource),
        isOwner: (isOwner != null ? isOwner.value : this.isOwner),
        isLegacy: (isLegacy != null ? isLegacy.value : this.isLegacy),
        isMixed: (isMixed != null ? isMixed.value : this.isMixed),
        createdAtUnix:
            (createdAtUnix != null ? createdAtUnix.value : this.createdAtUnix));
  }
}

@JsonSerializable(explicitToJson: true)
class VoiceSamplePreviewResponseModel {
  const VoiceSamplePreviewResponseModel({
    required this.audioBase64,
    required this.voiceId,
    required this.sampleId,
    required this.mediaType,
    this.durationSecs,
  });

  factory VoiceSamplePreviewResponseModel.fromJson(Map<String, dynamic> json) =>
      _$VoiceSamplePreviewResponseModelFromJson(json);

  static const toJsonFactory = _$VoiceSamplePreviewResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$VoiceSamplePreviewResponseModelToJson(this);

  @JsonKey(name: 'audio_base_64')
  final String audioBase64;
  @JsonKey(name: 'voice_id')
  final String voiceId;
  @JsonKey(name: 'sample_id')
  final String sampleId;
  @JsonKey(name: 'media_type')
  final String mediaType;
  @JsonKey(name: 'duration_secs')
  final dynamic durationSecs;
  static const fromJsonFactory = _$VoiceSamplePreviewResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VoiceSamplePreviewResponseModel &&
            (identical(other.audioBase64, audioBase64) ||
                const DeepCollectionEquality()
                    .equals(other.audioBase64, audioBase64)) &&
            (identical(other.voiceId, voiceId) ||
                const DeepCollectionEquality()
                    .equals(other.voiceId, voiceId)) &&
            (identical(other.sampleId, sampleId) ||
                const DeepCollectionEquality()
                    .equals(other.sampleId, sampleId)) &&
            (identical(other.mediaType, mediaType) ||
                const DeepCollectionEquality()
                    .equals(other.mediaType, mediaType)) &&
            (identical(other.durationSecs, durationSecs) ||
                const DeepCollectionEquality()
                    .equals(other.durationSecs, durationSecs)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(audioBase64) ^
      const DeepCollectionEquality().hash(voiceId) ^
      const DeepCollectionEquality().hash(sampleId) ^
      const DeepCollectionEquality().hash(mediaType) ^
      const DeepCollectionEquality().hash(durationSecs) ^
      runtimeType.hashCode;
}

extension $VoiceSamplePreviewResponseModelExtension
    on VoiceSamplePreviewResponseModel {
  VoiceSamplePreviewResponseModel copyWith(
      {String? audioBase64,
      String? voiceId,
      String? sampleId,
      String? mediaType,
      dynamic durationSecs}) {
    return VoiceSamplePreviewResponseModel(
        audioBase64: audioBase64 ?? this.audioBase64,
        voiceId: voiceId ?? this.voiceId,
        sampleId: sampleId ?? this.sampleId,
        mediaType: mediaType ?? this.mediaType,
        durationSecs: durationSecs ?? this.durationSecs);
  }

  VoiceSamplePreviewResponseModel copyWithWrapped(
      {Wrapped<String>? audioBase64,
      Wrapped<String>? voiceId,
      Wrapped<String>? sampleId,
      Wrapped<String>? mediaType,
      Wrapped<dynamic>? durationSecs}) {
    return VoiceSamplePreviewResponseModel(
        audioBase64:
            (audioBase64 != null ? audioBase64.value : this.audioBase64),
        voiceId: (voiceId != null ? voiceId.value : this.voiceId),
        sampleId: (sampleId != null ? sampleId.value : this.sampleId),
        mediaType: (mediaType != null ? mediaType.value : this.mediaType),
        durationSecs:
            (durationSecs != null ? durationSecs.value : this.durationSecs));
  }
}

@JsonSerializable(explicitToJson: true)
class VoiceSampleVisualWaveformResponseModel {
  const VoiceSampleVisualWaveformResponseModel({
    required this.sampleId,
    required this.visualWaveform,
  });

  factory VoiceSampleVisualWaveformResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$VoiceSampleVisualWaveformResponseModelFromJson(json);

  static const toJsonFactory = _$VoiceSampleVisualWaveformResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$VoiceSampleVisualWaveformResponseModelToJson(this);

  @JsonKey(name: 'sample_id')
  final String sampleId;
  @JsonKey(name: 'visual_waveform', defaultValue: <double>[])
  final List<double> visualWaveform;
  static const fromJsonFactory =
      _$VoiceSampleVisualWaveformResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VoiceSampleVisualWaveformResponseModel &&
            (identical(other.sampleId, sampleId) ||
                const DeepCollectionEquality()
                    .equals(other.sampleId, sampleId)) &&
            (identical(other.visualWaveform, visualWaveform) ||
                const DeepCollectionEquality()
                    .equals(other.visualWaveform, visualWaveform)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(sampleId) ^
      const DeepCollectionEquality().hash(visualWaveform) ^
      runtimeType.hashCode;
}

extension $VoiceSampleVisualWaveformResponseModelExtension
    on VoiceSampleVisualWaveformResponseModel {
  VoiceSampleVisualWaveformResponseModel copyWith(
      {String? sampleId, List<double>? visualWaveform}) {
    return VoiceSampleVisualWaveformResponseModel(
        sampleId: sampleId ?? this.sampleId,
        visualWaveform: visualWaveform ?? this.visualWaveform);
  }

  VoiceSampleVisualWaveformResponseModel copyWithWrapped(
      {Wrapped<String>? sampleId, Wrapped<List<double>>? visualWaveform}) {
    return VoiceSampleVisualWaveformResponseModel(
        sampleId: (sampleId != null ? sampleId.value : this.sampleId),
        visualWaveform: (visualWaveform != null
            ? visualWaveform.value
            : this.visualWaveform));
  }
}

@JsonSerializable(explicitToJson: true)
class VoiceSettingsResponseModel {
  const VoiceSettingsResponseModel({
    this.stability,
    this.similarityBoost,
    this.quality,
    this.style,
    this.useSpeakerBoost,
    this.speed,
  });

  factory VoiceSettingsResponseModel.fromJson(Map<String, dynamic> json) =>
      _$VoiceSettingsResponseModelFromJson(json);

  static const toJsonFactory = _$VoiceSettingsResponseModelToJson;
  Map<String, dynamic> toJson() => _$VoiceSettingsResponseModelToJson(this);

  @JsonKey(name: 'stability')
  final dynamic stability;
  @JsonKey(name: 'similarity_boost')
  final dynamic similarityBoost;
  @JsonKey(name: 'quality')
  final dynamic quality;
  @JsonKey(name: 'style')
  final dynamic style;
  @JsonKey(name: 'use_speaker_boost')
  final dynamic useSpeakerBoost;
  @JsonKey(name: 'speed')
  final dynamic speed;
  static const fromJsonFactory = _$VoiceSettingsResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VoiceSettingsResponseModel &&
            (identical(other.stability, stability) ||
                const DeepCollectionEquality()
                    .equals(other.stability, stability)) &&
            (identical(other.similarityBoost, similarityBoost) ||
                const DeepCollectionEquality()
                    .equals(other.similarityBoost, similarityBoost)) &&
            (identical(other.quality, quality) ||
                const DeepCollectionEquality()
                    .equals(other.quality, quality)) &&
            (identical(other.style, style) ||
                const DeepCollectionEquality().equals(other.style, style)) &&
            (identical(other.useSpeakerBoost, useSpeakerBoost) ||
                const DeepCollectionEquality()
                    .equals(other.useSpeakerBoost, useSpeakerBoost)) &&
            (identical(other.speed, speed) ||
                const DeepCollectionEquality().equals(other.speed, speed)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(stability) ^
      const DeepCollectionEquality().hash(similarityBoost) ^
      const DeepCollectionEquality().hash(quality) ^
      const DeepCollectionEquality().hash(style) ^
      const DeepCollectionEquality().hash(useSpeakerBoost) ^
      const DeepCollectionEquality().hash(speed) ^
      runtimeType.hashCode;
}

extension $VoiceSettingsResponseModelExtension on VoiceSettingsResponseModel {
  VoiceSettingsResponseModel copyWith(
      {dynamic stability,
      dynamic similarityBoost,
      dynamic quality,
      dynamic style,
      dynamic useSpeakerBoost,
      dynamic speed}) {
    return VoiceSettingsResponseModel(
        stability: stability ?? this.stability,
        similarityBoost: similarityBoost ?? this.similarityBoost,
        quality: quality ?? this.quality,
        style: style ?? this.style,
        useSpeakerBoost: useSpeakerBoost ?? this.useSpeakerBoost,
        speed: speed ?? this.speed);
  }

  VoiceSettingsResponseModel copyWithWrapped(
      {Wrapped<dynamic>? stability,
      Wrapped<dynamic>? similarityBoost,
      Wrapped<dynamic>? quality,
      Wrapped<dynamic>? style,
      Wrapped<dynamic>? useSpeakerBoost,
      Wrapped<dynamic>? speed}) {
    return VoiceSettingsResponseModel(
        stability: (stability != null ? stability.value : this.stability),
        similarityBoost: (similarityBoost != null
            ? similarityBoost.value
            : this.similarityBoost),
        quality: (quality != null ? quality.value : this.quality),
        style: (style != null ? style.value : this.style),
        useSpeakerBoost: (useSpeakerBoost != null
            ? useSpeakerBoost.value
            : this.useSpeakerBoost),
        speed: (speed != null ? speed.value : this.speed));
  }
}

@JsonSerializable(explicitToJson: true)
class VoiceSharingModerationCheckResponseModel {
  const VoiceSharingModerationCheckResponseModel({
    this.dateCheckedUnix,
    this.nameValue,
    this.nameCheck,
    this.descriptionValue,
    this.descriptionCheck,
    this.sampleIds,
    this.sampleChecks,
    this.captchaIds,
    this.captchaChecks,
  });

  factory VoiceSharingModerationCheckResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$VoiceSharingModerationCheckResponseModelFromJson(json);

  static const toJsonFactory = _$VoiceSharingModerationCheckResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$VoiceSharingModerationCheckResponseModelToJson(this);

  @JsonKey(name: 'date_checked_unix')
  final dynamic dateCheckedUnix;
  @JsonKey(name: 'name_value')
  final dynamic nameValue;
  @JsonKey(name: 'name_check')
  final dynamic nameCheck;
  @JsonKey(name: 'description_value')
  final dynamic descriptionValue;
  @JsonKey(name: 'description_check')
  final dynamic descriptionCheck;
  @JsonKey(name: 'sample_ids')
  final dynamic sampleIds;
  @JsonKey(name: 'sample_checks')
  final dynamic sampleChecks;
  @JsonKey(name: 'captcha_ids')
  final dynamic captchaIds;
  @JsonKey(name: 'captcha_checks')
  final dynamic captchaChecks;
  static const fromJsonFactory =
      _$VoiceSharingModerationCheckResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VoiceSharingModerationCheckResponseModel &&
            (identical(other.dateCheckedUnix, dateCheckedUnix) ||
                const DeepCollectionEquality()
                    .equals(other.dateCheckedUnix, dateCheckedUnix)) &&
            (identical(other.nameValue, nameValue) ||
                const DeepCollectionEquality()
                    .equals(other.nameValue, nameValue)) &&
            (identical(other.nameCheck, nameCheck) ||
                const DeepCollectionEquality()
                    .equals(other.nameCheck, nameCheck)) &&
            (identical(other.descriptionValue, descriptionValue) ||
                const DeepCollectionEquality()
                    .equals(other.descriptionValue, descriptionValue)) &&
            (identical(other.descriptionCheck, descriptionCheck) ||
                const DeepCollectionEquality()
                    .equals(other.descriptionCheck, descriptionCheck)) &&
            (identical(other.sampleIds, sampleIds) ||
                const DeepCollectionEquality()
                    .equals(other.sampleIds, sampleIds)) &&
            (identical(other.sampleChecks, sampleChecks) ||
                const DeepCollectionEquality()
                    .equals(other.sampleChecks, sampleChecks)) &&
            (identical(other.captchaIds, captchaIds) ||
                const DeepCollectionEquality()
                    .equals(other.captchaIds, captchaIds)) &&
            (identical(other.captchaChecks, captchaChecks) ||
                const DeepCollectionEquality()
                    .equals(other.captchaChecks, captchaChecks)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(dateCheckedUnix) ^
      const DeepCollectionEquality().hash(nameValue) ^
      const DeepCollectionEquality().hash(nameCheck) ^
      const DeepCollectionEquality().hash(descriptionValue) ^
      const DeepCollectionEquality().hash(descriptionCheck) ^
      const DeepCollectionEquality().hash(sampleIds) ^
      const DeepCollectionEquality().hash(sampleChecks) ^
      const DeepCollectionEquality().hash(captchaIds) ^
      const DeepCollectionEquality().hash(captchaChecks) ^
      runtimeType.hashCode;
}

extension $VoiceSharingModerationCheckResponseModelExtension
    on VoiceSharingModerationCheckResponseModel {
  VoiceSharingModerationCheckResponseModel copyWith(
      {dynamic dateCheckedUnix,
      dynamic nameValue,
      dynamic nameCheck,
      dynamic descriptionValue,
      dynamic descriptionCheck,
      dynamic sampleIds,
      dynamic sampleChecks,
      dynamic captchaIds,
      dynamic captchaChecks}) {
    return VoiceSharingModerationCheckResponseModel(
        dateCheckedUnix: dateCheckedUnix ?? this.dateCheckedUnix,
        nameValue: nameValue ?? this.nameValue,
        nameCheck: nameCheck ?? this.nameCheck,
        descriptionValue: descriptionValue ?? this.descriptionValue,
        descriptionCheck: descriptionCheck ?? this.descriptionCheck,
        sampleIds: sampleIds ?? this.sampleIds,
        sampleChecks: sampleChecks ?? this.sampleChecks,
        captchaIds: captchaIds ?? this.captchaIds,
        captchaChecks: captchaChecks ?? this.captchaChecks);
  }

  VoiceSharingModerationCheckResponseModel copyWithWrapped(
      {Wrapped<dynamic>? dateCheckedUnix,
      Wrapped<dynamic>? nameValue,
      Wrapped<dynamic>? nameCheck,
      Wrapped<dynamic>? descriptionValue,
      Wrapped<dynamic>? descriptionCheck,
      Wrapped<dynamic>? sampleIds,
      Wrapped<dynamic>? sampleChecks,
      Wrapped<dynamic>? captchaIds,
      Wrapped<dynamic>? captchaChecks}) {
    return VoiceSharingModerationCheckResponseModel(
        dateCheckedUnix: (dateCheckedUnix != null
            ? dateCheckedUnix.value
            : this.dateCheckedUnix),
        nameValue: (nameValue != null ? nameValue.value : this.nameValue),
        nameCheck: (nameCheck != null ? nameCheck.value : this.nameCheck),
        descriptionValue: (descriptionValue != null
            ? descriptionValue.value
            : this.descriptionValue),
        descriptionCheck: (descriptionCheck != null
            ? descriptionCheck.value
            : this.descriptionCheck),
        sampleIds: (sampleIds != null ? sampleIds.value : this.sampleIds),
        sampleChecks:
            (sampleChecks != null ? sampleChecks.value : this.sampleChecks),
        captchaIds: (captchaIds != null ? captchaIds.value : this.captchaIds),
        captchaChecks:
            (captchaChecks != null ? captchaChecks.value : this.captchaChecks));
  }
}

@JsonSerializable(explicitToJson: true)
class VoiceSharingResponseModel {
  const VoiceSharingResponseModel({
    required this.status,
    this.historyItemSampleId,
    required this.dateUnix,
    required this.whitelistedEmails,
    required this.publicOwnerId,
    required this.originalVoiceId,
    required this.financialRewardsEnabled,
    required this.freeUsersAllowed,
    required this.liveModerationEnabled,
    this.rate,
    this.fiatRate,
    required this.noticePeriod,
    this.disableAtUnix,
    required this.voiceMixingAllowed,
    required this.featured,
    required this.category,
    this.readerAppEnabled,
    this.imageUrl,
    this.banReason,
    required this.likedByCount,
    required this.clonedByCount,
    required this.name,
    this.description,
    required this.labels,
    required this.reviewStatus,
    this.reviewMessage,
    required this.enabledInLibrary,
    this.instagramUsername,
    this.twitterUsername,
    this.youtubeUsername,
    this.tiktokUsername,
    this.moderationCheck,
    this.readerRestrictedOn,
  });

  factory VoiceSharingResponseModel.fromJson(Map<String, dynamic> json) =>
      _$VoiceSharingResponseModelFromJson(json);

  static const toJsonFactory = _$VoiceSharingResponseModelToJson;
  Map<String, dynamic> toJson() => _$VoiceSharingResponseModelToJson(this);

  @JsonKey(
    name: 'status',
    toJson: voiceSharingResponseModelStatusToJson,
    fromJson: voiceSharingResponseModelStatusFromJson,
  )
  final enums.VoiceSharingResponseModelStatus status;
  @JsonKey(name: 'history_item_sample_id')
  final dynamic historyItemSampleId;
  @JsonKey(name: 'date_unix')
  final int dateUnix;
  @JsonKey(name: 'whitelisted_emails', defaultValue: <String>[])
  final List<String> whitelistedEmails;
  @JsonKey(name: 'public_owner_id')
  final String publicOwnerId;
  @JsonKey(name: 'original_voice_id')
  final String originalVoiceId;
  @JsonKey(name: 'financial_rewards_enabled')
  final bool financialRewardsEnabled;
  @JsonKey(name: 'free_users_allowed')
  final bool freeUsersAllowed;
  @JsonKey(name: 'live_moderation_enabled')
  final bool liveModerationEnabled;
  @JsonKey(name: 'rate')
  final dynamic rate;
  @JsonKey(name: 'fiat_rate')
  final dynamic fiatRate;
  @JsonKey(name: 'notice_period')
  final int noticePeriod;
  @JsonKey(name: 'disable_at_unix')
  final dynamic disableAtUnix;
  @JsonKey(name: 'voice_mixing_allowed')
  final bool voiceMixingAllowed;
  @JsonKey(name: 'featured')
  final bool featured;
  @JsonKey(
    name: 'category',
    toJson: voiceSharingResponseModelCategoryToJson,
    fromJson: voiceSharingResponseModelCategoryFromJson,
  )
  final enums.VoiceSharingResponseModelCategory category;
  @JsonKey(name: 'reader_app_enabled')
  final dynamic readerAppEnabled;
  @JsonKey(name: 'image_url')
  final dynamic imageUrl;
  @JsonKey(name: 'ban_reason')
  final dynamic banReason;
  @JsonKey(name: 'liked_by_count')
  final int likedByCount;
  @JsonKey(name: 'cloned_by_count')
  final int clonedByCount;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final dynamic description;
  @JsonKey(name: 'labels')
  final Map<String, dynamic> labels;
  @JsonKey(
    name: 'review_status',
    toJson: voiceSharingResponseModelReviewStatusToJson,
    fromJson: voiceSharingResponseModelReviewStatusFromJson,
  )
  final enums.VoiceSharingResponseModelReviewStatus reviewStatus;
  @JsonKey(name: 'review_message')
  final dynamic reviewMessage;
  @JsonKey(name: 'enabled_in_library')
  final bool enabledInLibrary;
  @JsonKey(name: 'instagram_username')
  final dynamic instagramUsername;
  @JsonKey(name: 'twitter_username')
  final dynamic twitterUsername;
  @JsonKey(name: 'youtube_username')
  final dynamic youtubeUsername;
  @JsonKey(name: 'tiktok_username')
  final dynamic tiktokUsername;
  @JsonKey(name: 'moderation_check')
  final dynamic moderationCheck;
  @JsonKey(name: 'reader_restricted_on')
  final dynamic readerRestrictedOn;
  static const fromJsonFactory = _$VoiceSharingResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VoiceSharingResponseModel &&
            (identical(other.status, status) ||
                const DeepCollectionEquality().equals(other.status, status)) &&
            (identical(other.historyItemSampleId, historyItemSampleId) ||
                const DeepCollectionEquality()
                    .equals(other.historyItemSampleId, historyItemSampleId)) &&
            (identical(other.dateUnix, dateUnix) ||
                const DeepCollectionEquality()
                    .equals(other.dateUnix, dateUnix)) &&
            (identical(other.whitelistedEmails, whitelistedEmails) ||
                const DeepCollectionEquality()
                    .equals(other.whitelistedEmails, whitelistedEmails)) &&
            (identical(other.publicOwnerId, publicOwnerId) ||
                const DeepCollectionEquality()
                    .equals(other.publicOwnerId, publicOwnerId)) &&
            (identical(other.originalVoiceId, originalVoiceId) ||
                const DeepCollectionEquality()
                    .equals(other.originalVoiceId, originalVoiceId)) &&
            (identical(other.financialRewardsEnabled, financialRewardsEnabled) ||
                const DeepCollectionEquality().equals(
                    other.financialRewardsEnabled, financialRewardsEnabled)) &&
            (identical(other.freeUsersAllowed, freeUsersAllowed) ||
                const DeepCollectionEquality()
                    .equals(other.freeUsersAllowed, freeUsersAllowed)) &&
            (identical(other.liveModerationEnabled, liveModerationEnabled) ||
                const DeepCollectionEquality().equals(
                    other.liveModerationEnabled, liveModerationEnabled)) &&
            (identical(other.rate, rate) ||
                const DeepCollectionEquality().equals(other.rate, rate)) &&
            (identical(other.fiatRate, fiatRate) ||
                const DeepCollectionEquality()
                    .equals(other.fiatRate, fiatRate)) &&
            (identical(other.noticePeriod, noticePeriod) ||
                const DeepCollectionEquality()
                    .equals(other.noticePeriod, noticePeriod)) &&
            (identical(other.disableAtUnix, disableAtUnix) ||
                const DeepCollectionEquality()
                    .equals(other.disableAtUnix, disableAtUnix)) &&
            (identical(other.voiceMixingAllowed, voiceMixingAllowed) ||
                const DeepCollectionEquality()
                    .equals(other.voiceMixingAllowed, voiceMixingAllowed)) &&
            (identical(other.featured, featured) ||
                const DeepCollectionEquality()
                    .equals(other.featured, featured)) &&
            (identical(other.category, category) ||
                const DeepCollectionEquality()
                    .equals(other.category, category)) &&
            (identical(other.readerAppEnabled, readerAppEnabled) ||
                const DeepCollectionEquality()
                    .equals(other.readerAppEnabled, readerAppEnabled)) &&
            (identical(other.imageUrl, imageUrl) ||
                const DeepCollectionEquality()
                    .equals(other.imageUrl, imageUrl)) &&
            (identical(other.banReason, banReason) || const DeepCollectionEquality().equals(other.banReason, banReason)) &&
            (identical(other.likedByCount, likedByCount) || const DeepCollectionEquality().equals(other.likedByCount, likedByCount)) &&
            (identical(other.clonedByCount, clonedByCount) || const DeepCollectionEquality().equals(other.clonedByCount, clonedByCount)) &&
            (identical(other.name, name) || const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) || const DeepCollectionEquality().equals(other.description, description)) &&
            (identical(other.labels, labels) || const DeepCollectionEquality().equals(other.labels, labels)) &&
            (identical(other.reviewStatus, reviewStatus) || const DeepCollectionEquality().equals(other.reviewStatus, reviewStatus)) &&
            (identical(other.reviewMessage, reviewMessage) || const DeepCollectionEquality().equals(other.reviewMessage, reviewMessage)) &&
            (identical(other.enabledInLibrary, enabledInLibrary) || const DeepCollectionEquality().equals(other.enabledInLibrary, enabledInLibrary)) &&
            (identical(other.instagramUsername, instagramUsername) || const DeepCollectionEquality().equals(other.instagramUsername, instagramUsername)) &&
            (identical(other.twitterUsername, twitterUsername) || const DeepCollectionEquality().equals(other.twitterUsername, twitterUsername)) &&
            (identical(other.youtubeUsername, youtubeUsername) || const DeepCollectionEquality().equals(other.youtubeUsername, youtubeUsername)) &&
            (identical(other.tiktokUsername, tiktokUsername) || const DeepCollectionEquality().equals(other.tiktokUsername, tiktokUsername)) &&
            (identical(other.moderationCheck, moderationCheck) || const DeepCollectionEquality().equals(other.moderationCheck, moderationCheck)) &&
            (identical(other.readerRestrictedOn, readerRestrictedOn) || const DeepCollectionEquality().equals(other.readerRestrictedOn, readerRestrictedOn)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(status) ^
      const DeepCollectionEquality().hash(historyItemSampleId) ^
      const DeepCollectionEquality().hash(dateUnix) ^
      const DeepCollectionEquality().hash(whitelistedEmails) ^
      const DeepCollectionEquality().hash(publicOwnerId) ^
      const DeepCollectionEquality().hash(originalVoiceId) ^
      const DeepCollectionEquality().hash(financialRewardsEnabled) ^
      const DeepCollectionEquality().hash(freeUsersAllowed) ^
      const DeepCollectionEquality().hash(liveModerationEnabled) ^
      const DeepCollectionEquality().hash(rate) ^
      const DeepCollectionEquality().hash(fiatRate) ^
      const DeepCollectionEquality().hash(noticePeriod) ^
      const DeepCollectionEquality().hash(disableAtUnix) ^
      const DeepCollectionEquality().hash(voiceMixingAllowed) ^
      const DeepCollectionEquality().hash(featured) ^
      const DeepCollectionEquality().hash(category) ^
      const DeepCollectionEquality().hash(readerAppEnabled) ^
      const DeepCollectionEquality().hash(imageUrl) ^
      const DeepCollectionEquality().hash(banReason) ^
      const DeepCollectionEquality().hash(likedByCount) ^
      const DeepCollectionEquality().hash(clonedByCount) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(labels) ^
      const DeepCollectionEquality().hash(reviewStatus) ^
      const DeepCollectionEquality().hash(reviewMessage) ^
      const DeepCollectionEquality().hash(enabledInLibrary) ^
      const DeepCollectionEquality().hash(instagramUsername) ^
      const DeepCollectionEquality().hash(twitterUsername) ^
      const DeepCollectionEquality().hash(youtubeUsername) ^
      const DeepCollectionEquality().hash(tiktokUsername) ^
      const DeepCollectionEquality().hash(moderationCheck) ^
      const DeepCollectionEquality().hash(readerRestrictedOn) ^
      runtimeType.hashCode;
}

extension $VoiceSharingResponseModelExtension on VoiceSharingResponseModel {
  VoiceSharingResponseModel copyWith(
      {enums.VoiceSharingResponseModelStatus? status,
      dynamic historyItemSampleId,
      int? dateUnix,
      List<String>? whitelistedEmails,
      String? publicOwnerId,
      String? originalVoiceId,
      bool? financialRewardsEnabled,
      bool? freeUsersAllowed,
      bool? liveModerationEnabled,
      dynamic rate,
      dynamic fiatRate,
      int? noticePeriod,
      dynamic disableAtUnix,
      bool? voiceMixingAllowed,
      bool? featured,
      enums.VoiceSharingResponseModelCategory? category,
      dynamic readerAppEnabled,
      dynamic imageUrl,
      dynamic banReason,
      int? likedByCount,
      int? clonedByCount,
      String? name,
      dynamic description,
      Map<String, dynamic>? labels,
      enums.VoiceSharingResponseModelReviewStatus? reviewStatus,
      dynamic reviewMessage,
      bool? enabledInLibrary,
      dynamic instagramUsername,
      dynamic twitterUsername,
      dynamic youtubeUsername,
      dynamic tiktokUsername,
      dynamic moderationCheck,
      dynamic readerRestrictedOn}) {
    return VoiceSharingResponseModel(
        status: status ?? this.status,
        historyItemSampleId: historyItemSampleId ?? this.historyItemSampleId,
        dateUnix: dateUnix ?? this.dateUnix,
        whitelistedEmails: whitelistedEmails ?? this.whitelistedEmails,
        publicOwnerId: publicOwnerId ?? this.publicOwnerId,
        originalVoiceId: originalVoiceId ?? this.originalVoiceId,
        financialRewardsEnabled:
            financialRewardsEnabled ?? this.financialRewardsEnabled,
        freeUsersAllowed: freeUsersAllowed ?? this.freeUsersAllowed,
        liveModerationEnabled:
            liveModerationEnabled ?? this.liveModerationEnabled,
        rate: rate ?? this.rate,
        fiatRate: fiatRate ?? this.fiatRate,
        noticePeriod: noticePeriod ?? this.noticePeriod,
        disableAtUnix: disableAtUnix ?? this.disableAtUnix,
        voiceMixingAllowed: voiceMixingAllowed ?? this.voiceMixingAllowed,
        featured: featured ?? this.featured,
        category: category ?? this.category,
        readerAppEnabled: readerAppEnabled ?? this.readerAppEnabled,
        imageUrl: imageUrl ?? this.imageUrl,
        banReason: banReason ?? this.banReason,
        likedByCount: likedByCount ?? this.likedByCount,
        clonedByCount: clonedByCount ?? this.clonedByCount,
        name: name ?? this.name,
        description: description ?? this.description,
        labels: labels ?? this.labels,
        reviewStatus: reviewStatus ?? this.reviewStatus,
        reviewMessage: reviewMessage ?? this.reviewMessage,
        enabledInLibrary: enabledInLibrary ?? this.enabledInLibrary,
        instagramUsername: instagramUsername ?? this.instagramUsername,
        twitterUsername: twitterUsername ?? this.twitterUsername,
        youtubeUsername: youtubeUsername ?? this.youtubeUsername,
        tiktokUsername: tiktokUsername ?? this.tiktokUsername,
        moderationCheck: moderationCheck ?? this.moderationCheck,
        readerRestrictedOn: readerRestrictedOn ?? this.readerRestrictedOn);
  }

  VoiceSharingResponseModel copyWithWrapped(
      {Wrapped<enums.VoiceSharingResponseModelStatus>? status,
      Wrapped<dynamic>? historyItemSampleId,
      Wrapped<int>? dateUnix,
      Wrapped<List<String>>? whitelistedEmails,
      Wrapped<String>? publicOwnerId,
      Wrapped<String>? originalVoiceId,
      Wrapped<bool>? financialRewardsEnabled,
      Wrapped<bool>? freeUsersAllowed,
      Wrapped<bool>? liveModerationEnabled,
      Wrapped<dynamic>? rate,
      Wrapped<dynamic>? fiatRate,
      Wrapped<int>? noticePeriod,
      Wrapped<dynamic>? disableAtUnix,
      Wrapped<bool>? voiceMixingAllowed,
      Wrapped<bool>? featured,
      Wrapped<enums.VoiceSharingResponseModelCategory>? category,
      Wrapped<dynamic>? readerAppEnabled,
      Wrapped<dynamic>? imageUrl,
      Wrapped<dynamic>? banReason,
      Wrapped<int>? likedByCount,
      Wrapped<int>? clonedByCount,
      Wrapped<String>? name,
      Wrapped<dynamic>? description,
      Wrapped<Map<String, dynamic>>? labels,
      Wrapped<enums.VoiceSharingResponseModelReviewStatus>? reviewStatus,
      Wrapped<dynamic>? reviewMessage,
      Wrapped<bool>? enabledInLibrary,
      Wrapped<dynamic>? instagramUsername,
      Wrapped<dynamic>? twitterUsername,
      Wrapped<dynamic>? youtubeUsername,
      Wrapped<dynamic>? tiktokUsername,
      Wrapped<dynamic>? moderationCheck,
      Wrapped<dynamic>? readerRestrictedOn}) {
    return VoiceSharingResponseModel(
        status: (status != null ? status.value : this.status),
        historyItemSampleId: (historyItemSampleId != null
            ? historyItemSampleId.value
            : this.historyItemSampleId),
        dateUnix: (dateUnix != null ? dateUnix.value : this.dateUnix),
        whitelistedEmails: (whitelistedEmails != null
            ? whitelistedEmails.value
            : this.whitelistedEmails),
        publicOwnerId:
            (publicOwnerId != null ? publicOwnerId.value : this.publicOwnerId),
        originalVoiceId: (originalVoiceId != null
            ? originalVoiceId.value
            : this.originalVoiceId),
        financialRewardsEnabled: (financialRewardsEnabled != null
            ? financialRewardsEnabled.value
            : this.financialRewardsEnabled),
        freeUsersAllowed: (freeUsersAllowed != null
            ? freeUsersAllowed.value
            : this.freeUsersAllowed),
        liveModerationEnabled: (liveModerationEnabled != null
            ? liveModerationEnabled.value
            : this.liveModerationEnabled),
        rate: (rate != null ? rate.value : this.rate),
        fiatRate: (fiatRate != null ? fiatRate.value : this.fiatRate),
        noticePeriod:
            (noticePeriod != null ? noticePeriod.value : this.noticePeriod),
        disableAtUnix:
            (disableAtUnix != null ? disableAtUnix.value : this.disableAtUnix),
        voiceMixingAllowed: (voiceMixingAllowed != null
            ? voiceMixingAllowed.value
            : this.voiceMixingAllowed),
        featured: (featured != null ? featured.value : this.featured),
        category: (category != null ? category.value : this.category),
        readerAppEnabled: (readerAppEnabled != null
            ? readerAppEnabled.value
            : this.readerAppEnabled),
        imageUrl: (imageUrl != null ? imageUrl.value : this.imageUrl),
        banReason: (banReason != null ? banReason.value : this.banReason),
        likedByCount:
            (likedByCount != null ? likedByCount.value : this.likedByCount),
        clonedByCount:
            (clonedByCount != null ? clonedByCount.value : this.clonedByCount),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        labels: (labels != null ? labels.value : this.labels),
        reviewStatus:
            (reviewStatus != null ? reviewStatus.value : this.reviewStatus),
        reviewMessage:
            (reviewMessage != null ? reviewMessage.value : this.reviewMessage),
        enabledInLibrary: (enabledInLibrary != null
            ? enabledInLibrary.value
            : this.enabledInLibrary),
        instagramUsername: (instagramUsername != null
            ? instagramUsername.value
            : this.instagramUsername),
        twitterUsername: (twitterUsername != null
            ? twitterUsername.value
            : this.twitterUsername),
        youtubeUsername: (youtubeUsername != null
            ? youtubeUsername.value
            : this.youtubeUsername),
        tiktokUsername: (tiktokUsername != null
            ? tiktokUsername.value
            : this.tiktokUsername),
        moderationCheck: (moderationCheck != null
            ? moderationCheck.value
            : this.moderationCheck),
        readerRestrictedOn: (readerRestrictedOn != null
            ? readerRestrictedOn.value
            : this.readerRestrictedOn));
  }
}

@JsonSerializable(explicitToJson: true)
class VoiceVerificationResponseModel {
  const VoiceVerificationResponseModel({
    required this.requiresVerification,
    required this.isVerified,
    required this.verificationFailures,
    required this.verificationAttemptsCount,
    this.language,
    this.verificationAttempts,
  });

  factory VoiceVerificationResponseModel.fromJson(Map<String, dynamic> json) =>
      _$VoiceVerificationResponseModelFromJson(json);

  static const toJsonFactory = _$VoiceVerificationResponseModelToJson;
  Map<String, dynamic> toJson() => _$VoiceVerificationResponseModelToJson(this);

  @JsonKey(name: 'requires_verification')
  final bool requiresVerification;
  @JsonKey(name: 'is_verified')
  final bool isVerified;
  @JsonKey(name: 'verification_failures', defaultValue: <String>[])
  final List<String> verificationFailures;
  @JsonKey(name: 'verification_attempts_count')
  final int verificationAttemptsCount;
  @JsonKey(name: 'language')
  final dynamic language;
  @JsonKey(name: 'verification_attempts')
  final dynamic verificationAttempts;
  static const fromJsonFactory = _$VoiceVerificationResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is VoiceVerificationResponseModel &&
            (identical(other.requiresVerification, requiresVerification) ||
                const DeepCollectionEquality().equals(
                    other.requiresVerification, requiresVerification)) &&
            (identical(other.isVerified, isVerified) ||
                const DeepCollectionEquality()
                    .equals(other.isVerified, isVerified)) &&
            (identical(other.verificationFailures, verificationFailures) ||
                const DeepCollectionEquality().equals(
                    other.verificationFailures, verificationFailures)) &&
            (identical(other.verificationAttemptsCount,
                    verificationAttemptsCount) ||
                const DeepCollectionEquality().equals(
                    other.verificationAttemptsCount,
                    verificationAttemptsCount)) &&
            (identical(other.language, language) ||
                const DeepCollectionEquality()
                    .equals(other.language, language)) &&
            (identical(other.verificationAttempts, verificationAttempts) ||
                const DeepCollectionEquality()
                    .equals(other.verificationAttempts, verificationAttempts)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(requiresVerification) ^
      const DeepCollectionEquality().hash(isVerified) ^
      const DeepCollectionEquality().hash(verificationFailures) ^
      const DeepCollectionEquality().hash(verificationAttemptsCount) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(verificationAttempts) ^
      runtimeType.hashCode;
}

extension $VoiceVerificationResponseModelExtension
    on VoiceVerificationResponseModel {
  VoiceVerificationResponseModel copyWith(
      {bool? requiresVerification,
      bool? isVerified,
      List<String>? verificationFailures,
      int? verificationAttemptsCount,
      dynamic language,
      dynamic verificationAttempts}) {
    return VoiceVerificationResponseModel(
        requiresVerification: requiresVerification ?? this.requiresVerification,
        isVerified: isVerified ?? this.isVerified,
        verificationFailures: verificationFailures ?? this.verificationFailures,
        verificationAttemptsCount:
            verificationAttemptsCount ?? this.verificationAttemptsCount,
        language: language ?? this.language,
        verificationAttempts:
            verificationAttempts ?? this.verificationAttempts);
  }

  VoiceVerificationResponseModel copyWithWrapped(
      {Wrapped<bool>? requiresVerification,
      Wrapped<bool>? isVerified,
      Wrapped<List<String>>? verificationFailures,
      Wrapped<int>? verificationAttemptsCount,
      Wrapped<dynamic>? language,
      Wrapped<dynamic>? verificationAttempts}) {
    return VoiceVerificationResponseModel(
        requiresVerification: (requiresVerification != null
            ? requiresVerification.value
            : this.requiresVerification),
        isVerified: (isVerified != null ? isVerified.value : this.isVerified),
        verificationFailures: (verificationFailures != null
            ? verificationFailures.value
            : this.verificationFailures),
        verificationAttemptsCount: (verificationAttemptsCount != null
            ? verificationAttemptsCount.value
            : this.verificationAttemptsCount),
        language: (language != null ? language.value : this.language),
        verificationAttempts: (verificationAttempts != null
            ? verificationAttempts.value
            : this.verificationAttempts));
  }
}

@JsonSerializable(explicitToJson: true)
class WebhookToolApiSchemaConfigInput {
  const WebhookToolApiSchemaConfigInput({
    required this.url,
    this.method,
    this.pathParamsSchema,
    this.queryParamsSchema,
    this.requestBodySchema,
    this.requestHeaders,
  });

  factory WebhookToolApiSchemaConfigInput.fromJson(Map<String, dynamic> json) =>
      _$WebhookToolApiSchemaConfigInputFromJson(json);

  static const toJsonFactory = _$WebhookToolApiSchemaConfigInputToJson;
  Map<String, dynamic> toJson() =>
      _$WebhookToolApiSchemaConfigInputToJson(this);

  @JsonKey(name: 'url')
  final String url;
  @JsonKey(
    name: 'method',
    toJson: webhookToolApiSchemaConfigInputMethodNullableToJson,
    fromJson: webhookToolApiSchemaConfigInputMethodMethodNullableFromJson,
  )
  final enums.WebhookToolApiSchemaConfigInputMethod? method;
  static enums.WebhookToolApiSchemaConfigInputMethod?
      webhookToolApiSchemaConfigInputMethodMethodNullableFromJson(
              Object? value) =>
          webhookToolApiSchemaConfigInputMethodNullableFromJson(
              value, enums.WebhookToolApiSchemaConfigInputMethod.$get);

  @JsonKey(name: 'path_params_schema')
  final Map<String, dynamic>? pathParamsSchema;
  @JsonKey(name: 'query_params_schema')
  final dynamic queryParamsSchema;
  @JsonKey(name: 'request_body_schema')
  final dynamic requestBodySchema;
  @JsonKey(name: 'request_headers')
  final Map<String, dynamic>? requestHeaders;
  static const fromJsonFactory = _$WebhookToolApiSchemaConfigInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WebhookToolApiSchemaConfigInput &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.method, method) ||
                const DeepCollectionEquality().equals(other.method, method)) &&
            (identical(other.pathParamsSchema, pathParamsSchema) ||
                const DeepCollectionEquality()
                    .equals(other.pathParamsSchema, pathParamsSchema)) &&
            (identical(other.queryParamsSchema, queryParamsSchema) ||
                const DeepCollectionEquality()
                    .equals(other.queryParamsSchema, queryParamsSchema)) &&
            (identical(other.requestBodySchema, requestBodySchema) ||
                const DeepCollectionEquality()
                    .equals(other.requestBodySchema, requestBodySchema)) &&
            (identical(other.requestHeaders, requestHeaders) ||
                const DeepCollectionEquality()
                    .equals(other.requestHeaders, requestHeaders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(method) ^
      const DeepCollectionEquality().hash(pathParamsSchema) ^
      const DeepCollectionEquality().hash(queryParamsSchema) ^
      const DeepCollectionEquality().hash(requestBodySchema) ^
      const DeepCollectionEquality().hash(requestHeaders) ^
      runtimeType.hashCode;
}

extension $WebhookToolApiSchemaConfigInputExtension
    on WebhookToolApiSchemaConfigInput {
  WebhookToolApiSchemaConfigInput copyWith(
      {String? url,
      enums.WebhookToolApiSchemaConfigInputMethod? method,
      Map<String, dynamic>? pathParamsSchema,
      dynamic queryParamsSchema,
      dynamic requestBodySchema,
      Map<String, dynamic>? requestHeaders}) {
    return WebhookToolApiSchemaConfigInput(
        url: url ?? this.url,
        method: method ?? this.method,
        pathParamsSchema: pathParamsSchema ?? this.pathParamsSchema,
        queryParamsSchema: queryParamsSchema ?? this.queryParamsSchema,
        requestBodySchema: requestBodySchema ?? this.requestBodySchema,
        requestHeaders: requestHeaders ?? this.requestHeaders);
  }

  WebhookToolApiSchemaConfigInput copyWithWrapped(
      {Wrapped<String>? url,
      Wrapped<enums.WebhookToolApiSchemaConfigInputMethod?>? method,
      Wrapped<Map<String, dynamic>?>? pathParamsSchema,
      Wrapped<dynamic>? queryParamsSchema,
      Wrapped<dynamic>? requestBodySchema,
      Wrapped<Map<String, dynamic>?>? requestHeaders}) {
    return WebhookToolApiSchemaConfigInput(
        url: (url != null ? url.value : this.url),
        method: (method != null ? method.value : this.method),
        pathParamsSchema: (pathParamsSchema != null
            ? pathParamsSchema.value
            : this.pathParamsSchema),
        queryParamsSchema: (queryParamsSchema != null
            ? queryParamsSchema.value
            : this.queryParamsSchema),
        requestBodySchema: (requestBodySchema != null
            ? requestBodySchema.value
            : this.requestBodySchema),
        requestHeaders: (requestHeaders != null
            ? requestHeaders.value
            : this.requestHeaders));
  }
}

@JsonSerializable(explicitToJson: true)
class WebhookToolApiSchemaConfigOutput {
  const WebhookToolApiSchemaConfigOutput({
    required this.url,
    this.method,
    this.pathParamsSchema,
    this.queryParamsSchema,
    this.requestBodySchema,
    this.requestHeaders,
  });

  factory WebhookToolApiSchemaConfigOutput.fromJson(
          Map<String, dynamic> json) =>
      _$WebhookToolApiSchemaConfigOutputFromJson(json);

  static const toJsonFactory = _$WebhookToolApiSchemaConfigOutputToJson;
  Map<String, dynamic> toJson() =>
      _$WebhookToolApiSchemaConfigOutputToJson(this);

  @JsonKey(name: 'url')
  final String url;
  @JsonKey(
    name: 'method',
    toJson: webhookToolApiSchemaConfigOutputMethodNullableToJson,
    fromJson: webhookToolApiSchemaConfigOutputMethodMethodNullableFromJson,
  )
  final enums.WebhookToolApiSchemaConfigOutputMethod? method;
  static enums.WebhookToolApiSchemaConfigOutputMethod?
      webhookToolApiSchemaConfigOutputMethodMethodNullableFromJson(
              Object? value) =>
          webhookToolApiSchemaConfigOutputMethodNullableFromJson(
              value, enums.WebhookToolApiSchemaConfigOutputMethod.$get);

  @JsonKey(name: 'path_params_schema')
  final Map<String, dynamic>? pathParamsSchema;
  @JsonKey(name: 'query_params_schema')
  final dynamic queryParamsSchema;
  @JsonKey(name: 'request_body_schema')
  final dynamic requestBodySchema;
  @JsonKey(name: 'request_headers')
  final Map<String, dynamic>? requestHeaders;
  static const fromJsonFactory = _$WebhookToolApiSchemaConfigOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WebhookToolApiSchemaConfigOutput &&
            (identical(other.url, url) ||
                const DeepCollectionEquality().equals(other.url, url)) &&
            (identical(other.method, method) ||
                const DeepCollectionEquality().equals(other.method, method)) &&
            (identical(other.pathParamsSchema, pathParamsSchema) ||
                const DeepCollectionEquality()
                    .equals(other.pathParamsSchema, pathParamsSchema)) &&
            (identical(other.queryParamsSchema, queryParamsSchema) ||
                const DeepCollectionEquality()
                    .equals(other.queryParamsSchema, queryParamsSchema)) &&
            (identical(other.requestBodySchema, requestBodySchema) ||
                const DeepCollectionEquality()
                    .equals(other.requestBodySchema, requestBodySchema)) &&
            (identical(other.requestHeaders, requestHeaders) ||
                const DeepCollectionEquality()
                    .equals(other.requestHeaders, requestHeaders)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(url) ^
      const DeepCollectionEquality().hash(method) ^
      const DeepCollectionEquality().hash(pathParamsSchema) ^
      const DeepCollectionEquality().hash(queryParamsSchema) ^
      const DeepCollectionEquality().hash(requestBodySchema) ^
      const DeepCollectionEquality().hash(requestHeaders) ^
      runtimeType.hashCode;
}

extension $WebhookToolApiSchemaConfigOutputExtension
    on WebhookToolApiSchemaConfigOutput {
  WebhookToolApiSchemaConfigOutput copyWith(
      {String? url,
      enums.WebhookToolApiSchemaConfigOutputMethod? method,
      Map<String, dynamic>? pathParamsSchema,
      dynamic queryParamsSchema,
      dynamic requestBodySchema,
      Map<String, dynamic>? requestHeaders}) {
    return WebhookToolApiSchemaConfigOutput(
        url: url ?? this.url,
        method: method ?? this.method,
        pathParamsSchema: pathParamsSchema ?? this.pathParamsSchema,
        queryParamsSchema: queryParamsSchema ?? this.queryParamsSchema,
        requestBodySchema: requestBodySchema ?? this.requestBodySchema,
        requestHeaders: requestHeaders ?? this.requestHeaders);
  }

  WebhookToolApiSchemaConfigOutput copyWithWrapped(
      {Wrapped<String>? url,
      Wrapped<enums.WebhookToolApiSchemaConfigOutputMethod?>? method,
      Wrapped<Map<String, dynamic>?>? pathParamsSchema,
      Wrapped<dynamic>? queryParamsSchema,
      Wrapped<dynamic>? requestBodySchema,
      Wrapped<Map<String, dynamic>?>? requestHeaders}) {
    return WebhookToolApiSchemaConfigOutput(
        url: (url != null ? url.value : this.url),
        method: (method != null ? method.value : this.method),
        pathParamsSchema: (pathParamsSchema != null
            ? pathParamsSchema.value
            : this.pathParamsSchema),
        queryParamsSchema: (queryParamsSchema != null
            ? queryParamsSchema.value
            : this.queryParamsSchema),
        requestBodySchema: (requestBodySchema != null
            ? requestBodySchema.value
            : this.requestBodySchema),
        requestHeaders: (requestHeaders != null
            ? requestHeaders.value
            : this.requestHeaders));
  }
}

@JsonSerializable(explicitToJson: true)
class WebhookToolConfigInput {
  const WebhookToolConfigInput({
    this.id,
    required this.name,
    required this.description,
    this.responseTimeoutSecs,
    this.type,
    required this.apiSchema,
    this.dynamicVariables,
  });

  factory WebhookToolConfigInput.fromJson(Map<String, dynamic> json) =>
      _$WebhookToolConfigInputFromJson(json);

  static const toJsonFactory = _$WebhookToolConfigInputToJson;
  Map<String, dynamic> toJson() => _$WebhookToolConfigInputToJson(this);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'response_timeout_secs')
  final int? responseTimeoutSecs;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'api_schema')
  final WebhookToolApiSchemaConfigInput apiSchema;
  @JsonKey(name: 'dynamic_variables')
  final DynamicVariablesConfig? dynamicVariables;
  static const fromJsonFactory = _$WebhookToolConfigInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WebhookToolConfigInput &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.responseTimeoutSecs, responseTimeoutSecs) ||
                const DeepCollectionEquality()
                    .equals(other.responseTimeoutSecs, responseTimeoutSecs)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.apiSchema, apiSchema) ||
                const DeepCollectionEquality()
                    .equals(other.apiSchema, apiSchema)) &&
            (identical(other.dynamicVariables, dynamicVariables) ||
                const DeepCollectionEquality()
                    .equals(other.dynamicVariables, dynamicVariables)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(responseTimeoutSecs) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(apiSchema) ^
      const DeepCollectionEquality().hash(dynamicVariables) ^
      runtimeType.hashCode;
}

extension $WebhookToolConfigInputExtension on WebhookToolConfigInput {
  WebhookToolConfigInput copyWith(
      {String? id,
      String? name,
      String? description,
      int? responseTimeoutSecs,
      String? type,
      WebhookToolApiSchemaConfigInput? apiSchema,
      DynamicVariablesConfig? dynamicVariables}) {
    return WebhookToolConfigInput(
        id: id ?? this.id,
        name: name ?? this.name,
        description: description ?? this.description,
        responseTimeoutSecs: responseTimeoutSecs ?? this.responseTimeoutSecs,
        type: type ?? this.type,
        apiSchema: apiSchema ?? this.apiSchema,
        dynamicVariables: dynamicVariables ?? this.dynamicVariables);
  }

  WebhookToolConfigInput copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String>? name,
      Wrapped<String>? description,
      Wrapped<int?>? responseTimeoutSecs,
      Wrapped<String?>? type,
      Wrapped<WebhookToolApiSchemaConfigInput>? apiSchema,
      Wrapped<DynamicVariablesConfig?>? dynamicVariables}) {
    return WebhookToolConfigInput(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        responseTimeoutSecs: (responseTimeoutSecs != null
            ? responseTimeoutSecs.value
            : this.responseTimeoutSecs),
        type: (type != null ? type.value : this.type),
        apiSchema: (apiSchema != null ? apiSchema.value : this.apiSchema),
        dynamicVariables: (dynamicVariables != null
            ? dynamicVariables.value
            : this.dynamicVariables));
  }
}

@JsonSerializable(explicitToJson: true)
class WebhookToolConfigOutput {
  const WebhookToolConfigOutput({
    this.id,
    required this.name,
    required this.description,
    this.responseTimeoutSecs,
    this.type,
    required this.apiSchema,
    this.dynamicVariables,
  });

  factory WebhookToolConfigOutput.fromJson(Map<String, dynamic> json) =>
      _$WebhookToolConfigOutputFromJson(json);

  static const toJsonFactory = _$WebhookToolConfigOutputToJson;
  Map<String, dynamic> toJson() => _$WebhookToolConfigOutputToJson(this);

  @JsonKey(name: 'id')
  final String? id;
  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'description')
  final String description;
  @JsonKey(name: 'response_timeout_secs')
  final int? responseTimeoutSecs;
  @JsonKey(name: 'type')
  final String? type;
  @JsonKey(name: 'api_schema')
  final WebhookToolApiSchemaConfigOutput apiSchema;
  @JsonKey(name: 'dynamic_variables')
  final DynamicVariablesConfig? dynamicVariables;
  static const fromJsonFactory = _$WebhookToolConfigOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WebhookToolConfigOutput &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.description, description) ||
                const DeepCollectionEquality()
                    .equals(other.description, description)) &&
            (identical(other.responseTimeoutSecs, responseTimeoutSecs) ||
                const DeepCollectionEquality()
                    .equals(other.responseTimeoutSecs, responseTimeoutSecs)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.apiSchema, apiSchema) ||
                const DeepCollectionEquality()
                    .equals(other.apiSchema, apiSchema)) &&
            (identical(other.dynamicVariables, dynamicVariables) ||
                const DeepCollectionEquality()
                    .equals(other.dynamicVariables, dynamicVariables)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(description) ^
      const DeepCollectionEquality().hash(responseTimeoutSecs) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(apiSchema) ^
      const DeepCollectionEquality().hash(dynamicVariables) ^
      runtimeType.hashCode;
}

extension $WebhookToolConfigOutputExtension on WebhookToolConfigOutput {
  WebhookToolConfigOutput copyWith(
      {String? id,
      String? name,
      String? description,
      int? responseTimeoutSecs,
      String? type,
      WebhookToolApiSchemaConfigOutput? apiSchema,
      DynamicVariablesConfig? dynamicVariables}) {
    return WebhookToolConfigOutput(
        id: id ?? this.id,
        name: name ?? this.name,
        description: description ?? this.description,
        responseTimeoutSecs: responseTimeoutSecs ?? this.responseTimeoutSecs,
        type: type ?? this.type,
        apiSchema: apiSchema ?? this.apiSchema,
        dynamicVariables: dynamicVariables ?? this.dynamicVariables);
  }

  WebhookToolConfigOutput copyWithWrapped(
      {Wrapped<String?>? id,
      Wrapped<String>? name,
      Wrapped<String>? description,
      Wrapped<int?>? responseTimeoutSecs,
      Wrapped<String?>? type,
      Wrapped<WebhookToolApiSchemaConfigOutput>? apiSchema,
      Wrapped<DynamicVariablesConfig?>? dynamicVariables}) {
    return WebhookToolConfigOutput(
        id: (id != null ? id.value : this.id),
        name: (name != null ? name.value : this.name),
        description:
            (description != null ? description.value : this.description),
        responseTimeoutSecs: (responseTimeoutSecs != null
            ? responseTimeoutSecs.value
            : this.responseTimeoutSecs),
        type: (type != null ? type.value : this.type),
        apiSchema: (apiSchema != null ? apiSchema.value : this.apiSchema),
        dynamicVariables: (dynamicVariables != null
            ? dynamicVariables.value
            : this.dynamicVariables));
  }
}

@JsonSerializable(explicitToJson: true)
class WidgetConfigInput {
  const WidgetConfigInput({
    this.variant,
    this.placement,
    this.expandable,
    this.avatar,
    this.feedbackMode,
    this.bgColor,
    this.textColor,
    this.btnColor,
    this.btnTextColor,
    this.borderColor,
    this.focusColor,
    this.borderRadius,
    this.btnRadius,
    this.actionText,
    this.startCallText,
    this.endCallText,
    this.expandText,
    this.listeningText,
    this.speakingText,
    this.shareablePageText,
    this.shareablePageShowTerms,
    this.termsText,
    this.termsHtml,
    this.termsKey,
    this.showAvatarWhenCollapsed,
    this.disableBanner,
    this.overrideLink,
    this.micMutingEnabled,
    this.transcriptEnabled,
    this.textInputEnabled,
    this.textContents,
    this.languageSelector,
    this.supportsTextOnly,
    this.customAvatarPath,
    this.languagePresets,
  });

  factory WidgetConfigInput.fromJson(Map<String, dynamic> json) =>
      _$WidgetConfigInputFromJson(json);

  static const toJsonFactory = _$WidgetConfigInputToJson;
  Map<String, dynamic> toJson() => _$WidgetConfigInputToJson(this);

  @JsonKey(
    name: 'variant',
    toJson: embedVariantNullableToJson,
    fromJson: embedVariantVariantNullableFromJson,
  )
  final enums.EmbedVariant? variant;
  static enums.EmbedVariant? embedVariantVariantNullableFromJson(
          Object? value) =>
      embedVariantNullableFromJson(value, enums.EmbedVariant.full);

  @JsonKey(
    name: 'placement',
    toJson: widgetPlacementNullableToJson,
    fromJson: widgetPlacementPlacementNullableFromJson,
  )
  final enums.WidgetPlacement? placement;
  static enums.WidgetPlacement? widgetPlacementPlacementNullableFromJson(
          Object? value) =>
      widgetPlacementNullableFromJson(value, enums.WidgetPlacement.bottomRight);

  @JsonKey(
    name: 'expandable',
    toJson: widgetExpandableNullableToJson,
    fromJson: widgetExpandableExpandableNullableFromJson,
  )
  final enums.WidgetExpandable? expandable;
  static enums.WidgetExpandable? widgetExpandableExpandableNullableFromJson(
          Object? value) =>
      widgetExpandableNullableFromJson(value, enums.WidgetExpandable.never);

  @JsonKey(name: 'avatar')
  final dynamic avatar;
  @JsonKey(
    name: 'feedback_mode',
    toJson: widgetFeedbackModeNullableToJson,
    fromJson: widgetFeedbackModeFeedbackModeNullableFromJson,
  )
  final enums.WidgetFeedbackMode? feedbackMode;
  static enums.WidgetFeedbackMode?
      widgetFeedbackModeFeedbackModeNullableFromJson(Object? value) =>
          widgetFeedbackModeNullableFromJson(
              value, enums.WidgetFeedbackMode.none);

  @JsonKey(name: 'bg_color')
  final String? bgColor;
  @JsonKey(name: 'text_color')
  final String? textColor;
  @JsonKey(name: 'btn_color')
  final String? btnColor;
  @JsonKey(name: 'btn_text_color')
  final String? btnTextColor;
  @JsonKey(name: 'border_color')
  final String? borderColor;
  @JsonKey(name: 'focus_color')
  final String? focusColor;
  @JsonKey(name: 'border_radius')
  final dynamic borderRadius;
  @JsonKey(name: 'btn_radius')
  final dynamic btnRadius;
  @JsonKey(name: 'action_text')
  final dynamic actionText;
  @JsonKey(name: 'start_call_text')
  final dynamic startCallText;
  @JsonKey(name: 'end_call_text')
  final dynamic endCallText;
  @JsonKey(name: 'expand_text')
  final dynamic expandText;
  @JsonKey(name: 'listening_text')
  final dynamic listeningText;
  @JsonKey(name: 'speaking_text')
  final dynamic speakingText;
  @JsonKey(name: 'shareable_page_text')
  final dynamic shareablePageText;
  @JsonKey(name: 'shareable_page_show_terms', defaultValue: true)
  final bool? shareablePageShowTerms;
  @JsonKey(name: 'terms_text')
  final dynamic termsText;
  @JsonKey(name: 'terms_html')
  final dynamic termsHtml;
  @JsonKey(name: 'terms_key')
  final dynamic termsKey;
  @JsonKey(name: 'show_avatar_when_collapsed')
  final dynamic showAvatarWhenCollapsed;
  @JsonKey(name: 'disable_banner', defaultValue: false)
  final bool? disableBanner;
  @JsonKey(name: 'override_link')
  final dynamic overrideLink;
  @JsonKey(name: 'mic_muting_enabled', defaultValue: false)
  final bool? micMutingEnabled;
  @JsonKey(name: 'transcript_enabled', defaultValue: false)
  final bool? transcriptEnabled;
  @JsonKey(name: 'text_input_enabled', defaultValue: false)
  final bool? textInputEnabled;
  @JsonKey(name: 'text_contents')
  final WidgetTextContents? textContents;
  @JsonKey(name: 'language_selector', defaultValue: false)
  final bool? languageSelector;
  @JsonKey(name: 'supports_text_only', defaultValue: false)
  final bool? supportsTextOnly;
  @JsonKey(name: 'custom_avatar_path')
  final dynamic customAvatarPath;
  @JsonKey(name: 'language_presets')
  final Map<String, dynamic>? languagePresets;
  static const fromJsonFactory = _$WidgetConfigInputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WidgetConfigInput &&
            (identical(other.variant, variant) ||
                const DeepCollectionEquality()
                    .equals(other.variant, variant)) &&
            (identical(other.placement, placement) ||
                const DeepCollectionEquality()
                    .equals(other.placement, placement)) &&
            (identical(other.expandable, expandable) ||
                const DeepCollectionEquality()
                    .equals(other.expandable, expandable)) &&
            (identical(other.avatar, avatar) ||
                const DeepCollectionEquality().equals(other.avatar, avatar)) &&
            (identical(other.feedbackMode, feedbackMode) ||
                const DeepCollectionEquality()
                    .equals(other.feedbackMode, feedbackMode)) &&
            (identical(other.bgColor, bgColor) ||
                const DeepCollectionEquality()
                    .equals(other.bgColor, bgColor)) &&
            (identical(other.textColor, textColor) ||
                const DeepCollectionEquality()
                    .equals(other.textColor, textColor)) &&
            (identical(other.btnColor, btnColor) ||
                const DeepCollectionEquality()
                    .equals(other.btnColor, btnColor)) &&
            (identical(other.btnTextColor, btnTextColor) ||
                const DeepCollectionEquality()
                    .equals(other.btnTextColor, btnTextColor)) &&
            (identical(other.borderColor, borderColor) ||
                const DeepCollectionEquality()
                    .equals(other.borderColor, borderColor)) &&
            (identical(other.focusColor, focusColor) ||
                const DeepCollectionEquality()
                    .equals(other.focusColor, focusColor)) &&
            (identical(other.borderRadius, borderRadius) ||
                const DeepCollectionEquality()
                    .equals(other.borderRadius, borderRadius)) &&
            (identical(other.btnRadius, btnRadius) ||
                const DeepCollectionEquality()
                    .equals(other.btnRadius, btnRadius)) &&
            (identical(other.actionText, actionText) ||
                const DeepCollectionEquality()
                    .equals(other.actionText, actionText)) &&
            (identical(other.startCallText, startCallText) ||
                const DeepCollectionEquality()
                    .equals(other.startCallText, startCallText)) &&
            (identical(other.endCallText, endCallText) ||
                const DeepCollectionEquality()
                    .equals(other.endCallText, endCallText)) &&
            (identical(other.expandText, expandText) ||
                const DeepCollectionEquality()
                    .equals(other.expandText, expandText)) &&
            (identical(other.listeningText, listeningText) ||
                const DeepCollectionEquality()
                    .equals(other.listeningText, listeningText)) &&
            (identical(other.speakingText, speakingText) ||
                const DeepCollectionEquality()
                    .equals(other.speakingText, speakingText)) &&
            (identical(other.shareablePageText, shareablePageText) ||
                const DeepCollectionEquality()
                    .equals(other.shareablePageText, shareablePageText)) &&
            (identical(other.shareablePageShowTerms, shareablePageShowTerms) ||
                const DeepCollectionEquality().equals(
                    other.shareablePageShowTerms, shareablePageShowTerms)) &&
            (identical(other.termsText, termsText) ||
                const DeepCollectionEquality()
                    .equals(other.termsText, termsText)) &&
            (identical(other.termsHtml, termsHtml) || const DeepCollectionEquality().equals(other.termsHtml, termsHtml)) &&
            (identical(other.termsKey, termsKey) || const DeepCollectionEquality().equals(other.termsKey, termsKey)) &&
            (identical(other.showAvatarWhenCollapsed, showAvatarWhenCollapsed) || const DeepCollectionEquality().equals(other.showAvatarWhenCollapsed, showAvatarWhenCollapsed)) &&
            (identical(other.disableBanner, disableBanner) || const DeepCollectionEquality().equals(other.disableBanner, disableBanner)) &&
            (identical(other.overrideLink, overrideLink) || const DeepCollectionEquality().equals(other.overrideLink, overrideLink)) &&
            (identical(other.micMutingEnabled, micMutingEnabled) || const DeepCollectionEquality().equals(other.micMutingEnabled, micMutingEnabled)) &&
            (identical(other.transcriptEnabled, transcriptEnabled) || const DeepCollectionEquality().equals(other.transcriptEnabled, transcriptEnabled)) &&
            (identical(other.textInputEnabled, textInputEnabled) || const DeepCollectionEquality().equals(other.textInputEnabled, textInputEnabled)) &&
            (identical(other.textContents, textContents) || const DeepCollectionEquality().equals(other.textContents, textContents)) &&
            (identical(other.languageSelector, languageSelector) || const DeepCollectionEquality().equals(other.languageSelector, languageSelector)) &&
            (identical(other.supportsTextOnly, supportsTextOnly) || const DeepCollectionEquality().equals(other.supportsTextOnly, supportsTextOnly)) &&
            (identical(other.customAvatarPath, customAvatarPath) || const DeepCollectionEquality().equals(other.customAvatarPath, customAvatarPath)) &&
            (identical(other.languagePresets, languagePresets) || const DeepCollectionEquality().equals(other.languagePresets, languagePresets)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(variant) ^
      const DeepCollectionEquality().hash(placement) ^
      const DeepCollectionEquality().hash(expandable) ^
      const DeepCollectionEquality().hash(avatar) ^
      const DeepCollectionEquality().hash(feedbackMode) ^
      const DeepCollectionEquality().hash(bgColor) ^
      const DeepCollectionEquality().hash(textColor) ^
      const DeepCollectionEquality().hash(btnColor) ^
      const DeepCollectionEquality().hash(btnTextColor) ^
      const DeepCollectionEquality().hash(borderColor) ^
      const DeepCollectionEquality().hash(focusColor) ^
      const DeepCollectionEquality().hash(borderRadius) ^
      const DeepCollectionEquality().hash(btnRadius) ^
      const DeepCollectionEquality().hash(actionText) ^
      const DeepCollectionEquality().hash(startCallText) ^
      const DeepCollectionEquality().hash(endCallText) ^
      const DeepCollectionEquality().hash(expandText) ^
      const DeepCollectionEquality().hash(listeningText) ^
      const DeepCollectionEquality().hash(speakingText) ^
      const DeepCollectionEquality().hash(shareablePageText) ^
      const DeepCollectionEquality().hash(shareablePageShowTerms) ^
      const DeepCollectionEquality().hash(termsText) ^
      const DeepCollectionEquality().hash(termsHtml) ^
      const DeepCollectionEquality().hash(termsKey) ^
      const DeepCollectionEquality().hash(showAvatarWhenCollapsed) ^
      const DeepCollectionEquality().hash(disableBanner) ^
      const DeepCollectionEquality().hash(overrideLink) ^
      const DeepCollectionEquality().hash(micMutingEnabled) ^
      const DeepCollectionEquality().hash(transcriptEnabled) ^
      const DeepCollectionEquality().hash(textInputEnabled) ^
      const DeepCollectionEquality().hash(textContents) ^
      const DeepCollectionEquality().hash(languageSelector) ^
      const DeepCollectionEquality().hash(supportsTextOnly) ^
      const DeepCollectionEquality().hash(customAvatarPath) ^
      const DeepCollectionEquality().hash(languagePresets) ^
      runtimeType.hashCode;
}

extension $WidgetConfigInputExtension on WidgetConfigInput {
  WidgetConfigInput copyWith(
      {enums.EmbedVariant? variant,
      enums.WidgetPlacement? placement,
      enums.WidgetExpandable? expandable,
      dynamic avatar,
      enums.WidgetFeedbackMode? feedbackMode,
      String? bgColor,
      String? textColor,
      String? btnColor,
      String? btnTextColor,
      String? borderColor,
      String? focusColor,
      dynamic borderRadius,
      dynamic btnRadius,
      dynamic actionText,
      dynamic startCallText,
      dynamic endCallText,
      dynamic expandText,
      dynamic listeningText,
      dynamic speakingText,
      dynamic shareablePageText,
      bool? shareablePageShowTerms,
      dynamic termsText,
      dynamic termsHtml,
      dynamic termsKey,
      dynamic showAvatarWhenCollapsed,
      bool? disableBanner,
      dynamic overrideLink,
      bool? micMutingEnabled,
      bool? transcriptEnabled,
      bool? textInputEnabled,
      WidgetTextContents? textContents,
      bool? languageSelector,
      bool? supportsTextOnly,
      dynamic customAvatarPath,
      Map<String, dynamic>? languagePresets}) {
    return WidgetConfigInput(
        variant: variant ?? this.variant,
        placement: placement ?? this.placement,
        expandable: expandable ?? this.expandable,
        avatar: avatar ?? this.avatar,
        feedbackMode: feedbackMode ?? this.feedbackMode,
        bgColor: bgColor ?? this.bgColor,
        textColor: textColor ?? this.textColor,
        btnColor: btnColor ?? this.btnColor,
        btnTextColor: btnTextColor ?? this.btnTextColor,
        borderColor: borderColor ?? this.borderColor,
        focusColor: focusColor ?? this.focusColor,
        borderRadius: borderRadius ?? this.borderRadius,
        btnRadius: btnRadius ?? this.btnRadius,
        actionText: actionText ?? this.actionText,
        startCallText: startCallText ?? this.startCallText,
        endCallText: endCallText ?? this.endCallText,
        expandText: expandText ?? this.expandText,
        listeningText: listeningText ?? this.listeningText,
        speakingText: speakingText ?? this.speakingText,
        shareablePageText: shareablePageText ?? this.shareablePageText,
        shareablePageShowTerms:
            shareablePageShowTerms ?? this.shareablePageShowTerms,
        termsText: termsText ?? this.termsText,
        termsHtml: termsHtml ?? this.termsHtml,
        termsKey: termsKey ?? this.termsKey,
        showAvatarWhenCollapsed:
            showAvatarWhenCollapsed ?? this.showAvatarWhenCollapsed,
        disableBanner: disableBanner ?? this.disableBanner,
        overrideLink: overrideLink ?? this.overrideLink,
        micMutingEnabled: micMutingEnabled ?? this.micMutingEnabled,
        transcriptEnabled: transcriptEnabled ?? this.transcriptEnabled,
        textInputEnabled: textInputEnabled ?? this.textInputEnabled,
        textContents: textContents ?? this.textContents,
        languageSelector: languageSelector ?? this.languageSelector,
        supportsTextOnly: supportsTextOnly ?? this.supportsTextOnly,
        customAvatarPath: customAvatarPath ?? this.customAvatarPath,
        languagePresets: languagePresets ?? this.languagePresets);
  }

  WidgetConfigInput copyWithWrapped(
      {Wrapped<enums.EmbedVariant?>? variant,
      Wrapped<enums.WidgetPlacement?>? placement,
      Wrapped<enums.WidgetExpandable?>? expandable,
      Wrapped<dynamic>? avatar,
      Wrapped<enums.WidgetFeedbackMode?>? feedbackMode,
      Wrapped<String?>? bgColor,
      Wrapped<String?>? textColor,
      Wrapped<String?>? btnColor,
      Wrapped<String?>? btnTextColor,
      Wrapped<String?>? borderColor,
      Wrapped<String?>? focusColor,
      Wrapped<dynamic>? borderRadius,
      Wrapped<dynamic>? btnRadius,
      Wrapped<dynamic>? actionText,
      Wrapped<dynamic>? startCallText,
      Wrapped<dynamic>? endCallText,
      Wrapped<dynamic>? expandText,
      Wrapped<dynamic>? listeningText,
      Wrapped<dynamic>? speakingText,
      Wrapped<dynamic>? shareablePageText,
      Wrapped<bool?>? shareablePageShowTerms,
      Wrapped<dynamic>? termsText,
      Wrapped<dynamic>? termsHtml,
      Wrapped<dynamic>? termsKey,
      Wrapped<dynamic>? showAvatarWhenCollapsed,
      Wrapped<bool?>? disableBanner,
      Wrapped<dynamic>? overrideLink,
      Wrapped<bool?>? micMutingEnabled,
      Wrapped<bool?>? transcriptEnabled,
      Wrapped<bool?>? textInputEnabled,
      Wrapped<WidgetTextContents?>? textContents,
      Wrapped<bool?>? languageSelector,
      Wrapped<bool?>? supportsTextOnly,
      Wrapped<dynamic>? customAvatarPath,
      Wrapped<Map<String, dynamic>?>? languagePresets}) {
    return WidgetConfigInput(
        variant: (variant != null ? variant.value : this.variant),
        placement: (placement != null ? placement.value : this.placement),
        expandable: (expandable != null ? expandable.value : this.expandable),
        avatar: (avatar != null ? avatar.value : this.avatar),
        feedbackMode:
            (feedbackMode != null ? feedbackMode.value : this.feedbackMode),
        bgColor: (bgColor != null ? bgColor.value : this.bgColor),
        textColor: (textColor != null ? textColor.value : this.textColor),
        btnColor: (btnColor != null ? btnColor.value : this.btnColor),
        btnTextColor:
            (btnTextColor != null ? btnTextColor.value : this.btnTextColor),
        borderColor:
            (borderColor != null ? borderColor.value : this.borderColor),
        focusColor: (focusColor != null ? focusColor.value : this.focusColor),
        borderRadius:
            (borderRadius != null ? borderRadius.value : this.borderRadius),
        btnRadius: (btnRadius != null ? btnRadius.value : this.btnRadius),
        actionText: (actionText != null ? actionText.value : this.actionText),
        startCallText:
            (startCallText != null ? startCallText.value : this.startCallText),
        endCallText:
            (endCallText != null ? endCallText.value : this.endCallText),
        expandText: (expandText != null ? expandText.value : this.expandText),
        listeningText:
            (listeningText != null ? listeningText.value : this.listeningText),
        speakingText:
            (speakingText != null ? speakingText.value : this.speakingText),
        shareablePageText: (shareablePageText != null
            ? shareablePageText.value
            : this.shareablePageText),
        shareablePageShowTerms: (shareablePageShowTerms != null
            ? shareablePageShowTerms.value
            : this.shareablePageShowTerms),
        termsText: (termsText != null ? termsText.value : this.termsText),
        termsHtml: (termsHtml != null ? termsHtml.value : this.termsHtml),
        termsKey: (termsKey != null ? termsKey.value : this.termsKey),
        showAvatarWhenCollapsed: (showAvatarWhenCollapsed != null
            ? showAvatarWhenCollapsed.value
            : this.showAvatarWhenCollapsed),
        disableBanner:
            (disableBanner != null ? disableBanner.value : this.disableBanner),
        overrideLink:
            (overrideLink != null ? overrideLink.value : this.overrideLink),
        micMutingEnabled: (micMutingEnabled != null
            ? micMutingEnabled.value
            : this.micMutingEnabled),
        transcriptEnabled: (transcriptEnabled != null
            ? transcriptEnabled.value
            : this.transcriptEnabled),
        textInputEnabled: (textInputEnabled != null
            ? textInputEnabled.value
            : this.textInputEnabled),
        textContents:
            (textContents != null ? textContents.value : this.textContents),
        languageSelector: (languageSelector != null
            ? languageSelector.value
            : this.languageSelector),
        supportsTextOnly: (supportsTextOnly != null
            ? supportsTextOnly.value
            : this.supportsTextOnly),
        customAvatarPath: (customAvatarPath != null
            ? customAvatarPath.value
            : this.customAvatarPath),
        languagePresets: (languagePresets != null
            ? languagePresets.value
            : this.languagePresets));
  }
}

@JsonSerializable(explicitToJson: true)
class WidgetConfigOutput {
  const WidgetConfigOutput({
    this.variant,
    this.placement,
    this.expandable,
    this.avatar,
    this.feedbackMode,
    this.bgColor,
    this.textColor,
    this.btnColor,
    this.btnTextColor,
    this.borderColor,
    this.focusColor,
    this.borderRadius,
    this.btnRadius,
    this.actionText,
    this.startCallText,
    this.endCallText,
    this.expandText,
    this.listeningText,
    this.speakingText,
    this.shareablePageText,
    this.shareablePageShowTerms,
    this.termsText,
    this.termsHtml,
    this.termsKey,
    this.showAvatarWhenCollapsed,
    this.disableBanner,
    this.overrideLink,
    this.micMutingEnabled,
    this.transcriptEnabled,
    this.textInputEnabled,
    this.textContents,
    this.languageSelector,
    this.supportsTextOnly,
    this.customAvatarPath,
    this.languagePresets,
  });

  factory WidgetConfigOutput.fromJson(Map<String, dynamic> json) =>
      _$WidgetConfigOutputFromJson(json);

  static const toJsonFactory = _$WidgetConfigOutputToJson;
  Map<String, dynamic> toJson() => _$WidgetConfigOutputToJson(this);

  @JsonKey(
    name: 'variant',
    toJson: embedVariantNullableToJson,
    fromJson: embedVariantVariantNullableFromJson,
  )
  final enums.EmbedVariant? variant;
  static enums.EmbedVariant? embedVariantVariantNullableFromJson(
          Object? value) =>
      embedVariantNullableFromJson(value, enums.EmbedVariant.full);

  @JsonKey(
    name: 'placement',
    toJson: widgetPlacementNullableToJson,
    fromJson: widgetPlacementPlacementNullableFromJson,
  )
  final enums.WidgetPlacement? placement;
  static enums.WidgetPlacement? widgetPlacementPlacementNullableFromJson(
          Object? value) =>
      widgetPlacementNullableFromJson(value, enums.WidgetPlacement.bottomRight);

  @JsonKey(
    name: 'expandable',
    toJson: widgetExpandableNullableToJson,
    fromJson: widgetExpandableExpandableNullableFromJson,
  )
  final enums.WidgetExpandable? expandable;
  static enums.WidgetExpandable? widgetExpandableExpandableNullableFromJson(
          Object? value) =>
      widgetExpandableNullableFromJson(value, enums.WidgetExpandable.never);

  @JsonKey(name: 'avatar')
  final dynamic avatar;
  @JsonKey(
    name: 'feedback_mode',
    toJson: widgetFeedbackModeNullableToJson,
    fromJson: widgetFeedbackModeFeedbackModeNullableFromJson,
  )
  final enums.WidgetFeedbackMode? feedbackMode;
  static enums.WidgetFeedbackMode?
      widgetFeedbackModeFeedbackModeNullableFromJson(Object? value) =>
          widgetFeedbackModeNullableFromJson(
              value, enums.WidgetFeedbackMode.none);

  @JsonKey(name: 'bg_color')
  final String? bgColor;
  @JsonKey(name: 'text_color')
  final String? textColor;
  @JsonKey(name: 'btn_color')
  final String? btnColor;
  @JsonKey(name: 'btn_text_color')
  final String? btnTextColor;
  @JsonKey(name: 'border_color')
  final String? borderColor;
  @JsonKey(name: 'focus_color')
  final String? focusColor;
  @JsonKey(name: 'border_radius')
  final dynamic borderRadius;
  @JsonKey(name: 'btn_radius')
  final dynamic btnRadius;
  @JsonKey(name: 'action_text')
  final dynamic actionText;
  @JsonKey(name: 'start_call_text')
  final dynamic startCallText;
  @JsonKey(name: 'end_call_text')
  final dynamic endCallText;
  @JsonKey(name: 'expand_text')
  final dynamic expandText;
  @JsonKey(name: 'listening_text')
  final dynamic listeningText;
  @JsonKey(name: 'speaking_text')
  final dynamic speakingText;
  @JsonKey(name: 'shareable_page_text')
  final dynamic shareablePageText;
  @JsonKey(name: 'shareable_page_show_terms', defaultValue: true)
  final bool? shareablePageShowTerms;
  @JsonKey(name: 'terms_text')
  final dynamic termsText;
  @JsonKey(name: 'terms_html')
  final dynamic termsHtml;
  @JsonKey(name: 'terms_key')
  final dynamic termsKey;
  @JsonKey(name: 'show_avatar_when_collapsed')
  final dynamic showAvatarWhenCollapsed;
  @JsonKey(name: 'disable_banner', defaultValue: false)
  final bool? disableBanner;
  @JsonKey(name: 'override_link')
  final dynamic overrideLink;
  @JsonKey(name: 'mic_muting_enabled', defaultValue: false)
  final bool? micMutingEnabled;
  @JsonKey(name: 'transcript_enabled', defaultValue: false)
  final bool? transcriptEnabled;
  @JsonKey(name: 'text_input_enabled', defaultValue: false)
  final bool? textInputEnabled;
  @JsonKey(name: 'text_contents')
  final WidgetTextContents? textContents;
  @JsonKey(name: 'language_selector', defaultValue: false)
  final bool? languageSelector;
  @JsonKey(name: 'supports_text_only', defaultValue: false)
  final bool? supportsTextOnly;
  @JsonKey(name: 'custom_avatar_path')
  final dynamic customAvatarPath;
  @JsonKey(name: 'language_presets')
  final Map<String, dynamic>? languagePresets;
  static const fromJsonFactory = _$WidgetConfigOutputFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WidgetConfigOutput &&
            (identical(other.variant, variant) ||
                const DeepCollectionEquality()
                    .equals(other.variant, variant)) &&
            (identical(other.placement, placement) ||
                const DeepCollectionEquality()
                    .equals(other.placement, placement)) &&
            (identical(other.expandable, expandable) ||
                const DeepCollectionEquality()
                    .equals(other.expandable, expandable)) &&
            (identical(other.avatar, avatar) ||
                const DeepCollectionEquality().equals(other.avatar, avatar)) &&
            (identical(other.feedbackMode, feedbackMode) ||
                const DeepCollectionEquality()
                    .equals(other.feedbackMode, feedbackMode)) &&
            (identical(other.bgColor, bgColor) ||
                const DeepCollectionEquality()
                    .equals(other.bgColor, bgColor)) &&
            (identical(other.textColor, textColor) ||
                const DeepCollectionEquality()
                    .equals(other.textColor, textColor)) &&
            (identical(other.btnColor, btnColor) ||
                const DeepCollectionEquality()
                    .equals(other.btnColor, btnColor)) &&
            (identical(other.btnTextColor, btnTextColor) ||
                const DeepCollectionEquality()
                    .equals(other.btnTextColor, btnTextColor)) &&
            (identical(other.borderColor, borderColor) ||
                const DeepCollectionEquality()
                    .equals(other.borderColor, borderColor)) &&
            (identical(other.focusColor, focusColor) ||
                const DeepCollectionEquality()
                    .equals(other.focusColor, focusColor)) &&
            (identical(other.borderRadius, borderRadius) ||
                const DeepCollectionEquality()
                    .equals(other.borderRadius, borderRadius)) &&
            (identical(other.btnRadius, btnRadius) ||
                const DeepCollectionEquality()
                    .equals(other.btnRadius, btnRadius)) &&
            (identical(other.actionText, actionText) ||
                const DeepCollectionEquality()
                    .equals(other.actionText, actionText)) &&
            (identical(other.startCallText, startCallText) ||
                const DeepCollectionEquality()
                    .equals(other.startCallText, startCallText)) &&
            (identical(other.endCallText, endCallText) ||
                const DeepCollectionEquality()
                    .equals(other.endCallText, endCallText)) &&
            (identical(other.expandText, expandText) ||
                const DeepCollectionEquality()
                    .equals(other.expandText, expandText)) &&
            (identical(other.listeningText, listeningText) ||
                const DeepCollectionEquality()
                    .equals(other.listeningText, listeningText)) &&
            (identical(other.speakingText, speakingText) ||
                const DeepCollectionEquality()
                    .equals(other.speakingText, speakingText)) &&
            (identical(other.shareablePageText, shareablePageText) ||
                const DeepCollectionEquality()
                    .equals(other.shareablePageText, shareablePageText)) &&
            (identical(other.shareablePageShowTerms, shareablePageShowTerms) ||
                const DeepCollectionEquality().equals(
                    other.shareablePageShowTerms, shareablePageShowTerms)) &&
            (identical(other.termsText, termsText) ||
                const DeepCollectionEquality()
                    .equals(other.termsText, termsText)) &&
            (identical(other.termsHtml, termsHtml) || const DeepCollectionEquality().equals(other.termsHtml, termsHtml)) &&
            (identical(other.termsKey, termsKey) || const DeepCollectionEquality().equals(other.termsKey, termsKey)) &&
            (identical(other.showAvatarWhenCollapsed, showAvatarWhenCollapsed) || const DeepCollectionEquality().equals(other.showAvatarWhenCollapsed, showAvatarWhenCollapsed)) &&
            (identical(other.disableBanner, disableBanner) || const DeepCollectionEquality().equals(other.disableBanner, disableBanner)) &&
            (identical(other.overrideLink, overrideLink) || const DeepCollectionEquality().equals(other.overrideLink, overrideLink)) &&
            (identical(other.micMutingEnabled, micMutingEnabled) || const DeepCollectionEquality().equals(other.micMutingEnabled, micMutingEnabled)) &&
            (identical(other.transcriptEnabled, transcriptEnabled) || const DeepCollectionEquality().equals(other.transcriptEnabled, transcriptEnabled)) &&
            (identical(other.textInputEnabled, textInputEnabled) || const DeepCollectionEquality().equals(other.textInputEnabled, textInputEnabled)) &&
            (identical(other.textContents, textContents) || const DeepCollectionEquality().equals(other.textContents, textContents)) &&
            (identical(other.languageSelector, languageSelector) || const DeepCollectionEquality().equals(other.languageSelector, languageSelector)) &&
            (identical(other.supportsTextOnly, supportsTextOnly) || const DeepCollectionEquality().equals(other.supportsTextOnly, supportsTextOnly)) &&
            (identical(other.customAvatarPath, customAvatarPath) || const DeepCollectionEquality().equals(other.customAvatarPath, customAvatarPath)) &&
            (identical(other.languagePresets, languagePresets) || const DeepCollectionEquality().equals(other.languagePresets, languagePresets)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(variant) ^
      const DeepCollectionEquality().hash(placement) ^
      const DeepCollectionEquality().hash(expandable) ^
      const DeepCollectionEquality().hash(avatar) ^
      const DeepCollectionEquality().hash(feedbackMode) ^
      const DeepCollectionEquality().hash(bgColor) ^
      const DeepCollectionEquality().hash(textColor) ^
      const DeepCollectionEquality().hash(btnColor) ^
      const DeepCollectionEquality().hash(btnTextColor) ^
      const DeepCollectionEquality().hash(borderColor) ^
      const DeepCollectionEquality().hash(focusColor) ^
      const DeepCollectionEquality().hash(borderRadius) ^
      const DeepCollectionEquality().hash(btnRadius) ^
      const DeepCollectionEquality().hash(actionText) ^
      const DeepCollectionEquality().hash(startCallText) ^
      const DeepCollectionEquality().hash(endCallText) ^
      const DeepCollectionEquality().hash(expandText) ^
      const DeepCollectionEquality().hash(listeningText) ^
      const DeepCollectionEquality().hash(speakingText) ^
      const DeepCollectionEquality().hash(shareablePageText) ^
      const DeepCollectionEquality().hash(shareablePageShowTerms) ^
      const DeepCollectionEquality().hash(termsText) ^
      const DeepCollectionEquality().hash(termsHtml) ^
      const DeepCollectionEquality().hash(termsKey) ^
      const DeepCollectionEquality().hash(showAvatarWhenCollapsed) ^
      const DeepCollectionEquality().hash(disableBanner) ^
      const DeepCollectionEquality().hash(overrideLink) ^
      const DeepCollectionEquality().hash(micMutingEnabled) ^
      const DeepCollectionEquality().hash(transcriptEnabled) ^
      const DeepCollectionEquality().hash(textInputEnabled) ^
      const DeepCollectionEquality().hash(textContents) ^
      const DeepCollectionEquality().hash(languageSelector) ^
      const DeepCollectionEquality().hash(supportsTextOnly) ^
      const DeepCollectionEquality().hash(customAvatarPath) ^
      const DeepCollectionEquality().hash(languagePresets) ^
      runtimeType.hashCode;
}

extension $WidgetConfigOutputExtension on WidgetConfigOutput {
  WidgetConfigOutput copyWith(
      {enums.EmbedVariant? variant,
      enums.WidgetPlacement? placement,
      enums.WidgetExpandable? expandable,
      dynamic avatar,
      enums.WidgetFeedbackMode? feedbackMode,
      String? bgColor,
      String? textColor,
      String? btnColor,
      String? btnTextColor,
      String? borderColor,
      String? focusColor,
      dynamic borderRadius,
      dynamic btnRadius,
      dynamic actionText,
      dynamic startCallText,
      dynamic endCallText,
      dynamic expandText,
      dynamic listeningText,
      dynamic speakingText,
      dynamic shareablePageText,
      bool? shareablePageShowTerms,
      dynamic termsText,
      dynamic termsHtml,
      dynamic termsKey,
      dynamic showAvatarWhenCollapsed,
      bool? disableBanner,
      dynamic overrideLink,
      bool? micMutingEnabled,
      bool? transcriptEnabled,
      bool? textInputEnabled,
      WidgetTextContents? textContents,
      bool? languageSelector,
      bool? supportsTextOnly,
      dynamic customAvatarPath,
      Map<String, dynamic>? languagePresets}) {
    return WidgetConfigOutput(
        variant: variant ?? this.variant,
        placement: placement ?? this.placement,
        expandable: expandable ?? this.expandable,
        avatar: avatar ?? this.avatar,
        feedbackMode: feedbackMode ?? this.feedbackMode,
        bgColor: bgColor ?? this.bgColor,
        textColor: textColor ?? this.textColor,
        btnColor: btnColor ?? this.btnColor,
        btnTextColor: btnTextColor ?? this.btnTextColor,
        borderColor: borderColor ?? this.borderColor,
        focusColor: focusColor ?? this.focusColor,
        borderRadius: borderRadius ?? this.borderRadius,
        btnRadius: btnRadius ?? this.btnRadius,
        actionText: actionText ?? this.actionText,
        startCallText: startCallText ?? this.startCallText,
        endCallText: endCallText ?? this.endCallText,
        expandText: expandText ?? this.expandText,
        listeningText: listeningText ?? this.listeningText,
        speakingText: speakingText ?? this.speakingText,
        shareablePageText: shareablePageText ?? this.shareablePageText,
        shareablePageShowTerms:
            shareablePageShowTerms ?? this.shareablePageShowTerms,
        termsText: termsText ?? this.termsText,
        termsHtml: termsHtml ?? this.termsHtml,
        termsKey: termsKey ?? this.termsKey,
        showAvatarWhenCollapsed:
            showAvatarWhenCollapsed ?? this.showAvatarWhenCollapsed,
        disableBanner: disableBanner ?? this.disableBanner,
        overrideLink: overrideLink ?? this.overrideLink,
        micMutingEnabled: micMutingEnabled ?? this.micMutingEnabled,
        transcriptEnabled: transcriptEnabled ?? this.transcriptEnabled,
        textInputEnabled: textInputEnabled ?? this.textInputEnabled,
        textContents: textContents ?? this.textContents,
        languageSelector: languageSelector ?? this.languageSelector,
        supportsTextOnly: supportsTextOnly ?? this.supportsTextOnly,
        customAvatarPath: customAvatarPath ?? this.customAvatarPath,
        languagePresets: languagePresets ?? this.languagePresets);
  }

  WidgetConfigOutput copyWithWrapped(
      {Wrapped<enums.EmbedVariant?>? variant,
      Wrapped<enums.WidgetPlacement?>? placement,
      Wrapped<enums.WidgetExpandable?>? expandable,
      Wrapped<dynamic>? avatar,
      Wrapped<enums.WidgetFeedbackMode?>? feedbackMode,
      Wrapped<String?>? bgColor,
      Wrapped<String?>? textColor,
      Wrapped<String?>? btnColor,
      Wrapped<String?>? btnTextColor,
      Wrapped<String?>? borderColor,
      Wrapped<String?>? focusColor,
      Wrapped<dynamic>? borderRadius,
      Wrapped<dynamic>? btnRadius,
      Wrapped<dynamic>? actionText,
      Wrapped<dynamic>? startCallText,
      Wrapped<dynamic>? endCallText,
      Wrapped<dynamic>? expandText,
      Wrapped<dynamic>? listeningText,
      Wrapped<dynamic>? speakingText,
      Wrapped<dynamic>? shareablePageText,
      Wrapped<bool?>? shareablePageShowTerms,
      Wrapped<dynamic>? termsText,
      Wrapped<dynamic>? termsHtml,
      Wrapped<dynamic>? termsKey,
      Wrapped<dynamic>? showAvatarWhenCollapsed,
      Wrapped<bool?>? disableBanner,
      Wrapped<dynamic>? overrideLink,
      Wrapped<bool?>? micMutingEnabled,
      Wrapped<bool?>? transcriptEnabled,
      Wrapped<bool?>? textInputEnabled,
      Wrapped<WidgetTextContents?>? textContents,
      Wrapped<bool?>? languageSelector,
      Wrapped<bool?>? supportsTextOnly,
      Wrapped<dynamic>? customAvatarPath,
      Wrapped<Map<String, dynamic>?>? languagePresets}) {
    return WidgetConfigOutput(
        variant: (variant != null ? variant.value : this.variant),
        placement: (placement != null ? placement.value : this.placement),
        expandable: (expandable != null ? expandable.value : this.expandable),
        avatar: (avatar != null ? avatar.value : this.avatar),
        feedbackMode:
            (feedbackMode != null ? feedbackMode.value : this.feedbackMode),
        bgColor: (bgColor != null ? bgColor.value : this.bgColor),
        textColor: (textColor != null ? textColor.value : this.textColor),
        btnColor: (btnColor != null ? btnColor.value : this.btnColor),
        btnTextColor:
            (btnTextColor != null ? btnTextColor.value : this.btnTextColor),
        borderColor:
            (borderColor != null ? borderColor.value : this.borderColor),
        focusColor: (focusColor != null ? focusColor.value : this.focusColor),
        borderRadius:
            (borderRadius != null ? borderRadius.value : this.borderRadius),
        btnRadius: (btnRadius != null ? btnRadius.value : this.btnRadius),
        actionText: (actionText != null ? actionText.value : this.actionText),
        startCallText:
            (startCallText != null ? startCallText.value : this.startCallText),
        endCallText:
            (endCallText != null ? endCallText.value : this.endCallText),
        expandText: (expandText != null ? expandText.value : this.expandText),
        listeningText:
            (listeningText != null ? listeningText.value : this.listeningText),
        speakingText:
            (speakingText != null ? speakingText.value : this.speakingText),
        shareablePageText: (shareablePageText != null
            ? shareablePageText.value
            : this.shareablePageText),
        shareablePageShowTerms: (shareablePageShowTerms != null
            ? shareablePageShowTerms.value
            : this.shareablePageShowTerms),
        termsText: (termsText != null ? termsText.value : this.termsText),
        termsHtml: (termsHtml != null ? termsHtml.value : this.termsHtml),
        termsKey: (termsKey != null ? termsKey.value : this.termsKey),
        showAvatarWhenCollapsed: (showAvatarWhenCollapsed != null
            ? showAvatarWhenCollapsed.value
            : this.showAvatarWhenCollapsed),
        disableBanner:
            (disableBanner != null ? disableBanner.value : this.disableBanner),
        overrideLink:
            (overrideLink != null ? overrideLink.value : this.overrideLink),
        micMutingEnabled: (micMutingEnabled != null
            ? micMutingEnabled.value
            : this.micMutingEnabled),
        transcriptEnabled: (transcriptEnabled != null
            ? transcriptEnabled.value
            : this.transcriptEnabled),
        textInputEnabled: (textInputEnabled != null
            ? textInputEnabled.value
            : this.textInputEnabled),
        textContents:
            (textContents != null ? textContents.value : this.textContents),
        languageSelector: (languageSelector != null
            ? languageSelector.value
            : this.languageSelector),
        supportsTextOnly: (supportsTextOnly != null
            ? supportsTextOnly.value
            : this.supportsTextOnly),
        customAvatarPath: (customAvatarPath != null
            ? customAvatarPath.value
            : this.customAvatarPath),
        languagePresets: (languagePresets != null
            ? languagePresets.value
            : this.languagePresets));
  }
}

@JsonSerializable(explicitToJson: true)
class WidgetConfigResponseModel {
  const WidgetConfigResponseModel({
    this.variant,
    this.placement,
    this.expandable,
    this.avatar,
    this.feedbackMode,
    this.bgColor,
    this.textColor,
    this.btnColor,
    this.btnTextColor,
    this.borderColor,
    this.focusColor,
    this.borderRadius,
    this.btnRadius,
    this.actionText,
    this.startCallText,
    this.endCallText,
    this.expandText,
    this.listeningText,
    this.speakingText,
    this.shareablePageText,
    this.shareablePageShowTerms,
    this.termsText,
    this.termsHtml,
    this.termsKey,
    this.showAvatarWhenCollapsed,
    this.disableBanner,
    this.overrideLink,
    this.micMutingEnabled,
    this.transcriptEnabled,
    this.textInputEnabled,
    this.textContents,
    required this.language,
    this.supportedLanguageOverrides,
    this.languagePresets,
    this.textOnly,
    this.supportsTextOnly,
    this.firstMessage,
  });

  factory WidgetConfigResponseModel.fromJson(Map<String, dynamic> json) =>
      _$WidgetConfigResponseModelFromJson(json);

  static const toJsonFactory = _$WidgetConfigResponseModelToJson;
  Map<String, dynamic> toJson() => _$WidgetConfigResponseModelToJson(this);

  @JsonKey(
    name: 'variant',
    toJson: embedVariantNullableToJson,
    fromJson: embedVariantVariantNullableFromJson,
  )
  final enums.EmbedVariant? variant;
  static enums.EmbedVariant? embedVariantVariantNullableFromJson(
          Object? value) =>
      embedVariantNullableFromJson(value, enums.EmbedVariant.full);

  @JsonKey(
    name: 'placement',
    toJson: widgetPlacementNullableToJson,
    fromJson: widgetPlacementPlacementNullableFromJson,
  )
  final enums.WidgetPlacement? placement;
  static enums.WidgetPlacement? widgetPlacementPlacementNullableFromJson(
          Object? value) =>
      widgetPlacementNullableFromJson(value, enums.WidgetPlacement.bottomRight);

  @JsonKey(
    name: 'expandable',
    toJson: widgetExpandableNullableToJson,
    fromJson: widgetExpandableExpandableNullableFromJson,
  )
  final enums.WidgetExpandable? expandable;
  static enums.WidgetExpandable? widgetExpandableExpandableNullableFromJson(
          Object? value) =>
      widgetExpandableNullableFromJson(value, enums.WidgetExpandable.never);

  @JsonKey(name: 'avatar')
  final dynamic avatar;
  @JsonKey(
    name: 'feedback_mode',
    toJson: widgetFeedbackModeNullableToJson,
    fromJson: widgetFeedbackModeFeedbackModeNullableFromJson,
  )
  final enums.WidgetFeedbackMode? feedbackMode;
  static enums.WidgetFeedbackMode?
      widgetFeedbackModeFeedbackModeNullableFromJson(Object? value) =>
          widgetFeedbackModeNullableFromJson(
              value, enums.WidgetFeedbackMode.none);

  @JsonKey(name: 'bg_color')
  final String? bgColor;
  @JsonKey(name: 'text_color')
  final String? textColor;
  @JsonKey(name: 'btn_color')
  final String? btnColor;
  @JsonKey(name: 'btn_text_color')
  final String? btnTextColor;
  @JsonKey(name: 'border_color')
  final String? borderColor;
  @JsonKey(name: 'focus_color')
  final String? focusColor;
  @JsonKey(name: 'border_radius')
  final dynamic borderRadius;
  @JsonKey(name: 'btn_radius')
  final dynamic btnRadius;
  @JsonKey(name: 'action_text')
  final dynamic actionText;
  @JsonKey(name: 'start_call_text')
  final dynamic startCallText;
  @JsonKey(name: 'end_call_text')
  final dynamic endCallText;
  @JsonKey(name: 'expand_text')
  final dynamic expandText;
  @JsonKey(name: 'listening_text')
  final dynamic listeningText;
  @JsonKey(name: 'speaking_text')
  final dynamic speakingText;
  @JsonKey(name: 'shareable_page_text')
  final dynamic shareablePageText;
  @JsonKey(name: 'shareable_page_show_terms', defaultValue: true)
  final bool? shareablePageShowTerms;
  @JsonKey(name: 'terms_text')
  final dynamic termsText;
  @JsonKey(name: 'terms_html')
  final dynamic termsHtml;
  @JsonKey(name: 'terms_key')
  final dynamic termsKey;
  @JsonKey(name: 'show_avatar_when_collapsed')
  final dynamic showAvatarWhenCollapsed;
  @JsonKey(name: 'disable_banner', defaultValue: false)
  final bool? disableBanner;
  @JsonKey(name: 'override_link')
  final dynamic overrideLink;
  @JsonKey(name: 'mic_muting_enabled', defaultValue: false)
  final bool? micMutingEnabled;
  @JsonKey(name: 'transcript_enabled', defaultValue: false)
  final bool? transcriptEnabled;
  @JsonKey(name: 'text_input_enabled', defaultValue: false)
  final bool? textInputEnabled;
  @JsonKey(name: 'text_contents')
  final WidgetTextContents? textContents;
  @JsonKey(name: 'language')
  final String language;
  @JsonKey(name: 'supported_language_overrides')
  final dynamic supportedLanguageOverrides;
  @JsonKey(name: 'language_presets')
  final Map<String, dynamic>? languagePresets;
  @JsonKey(name: 'text_only', defaultValue: false)
  final bool? textOnly;
  @JsonKey(name: 'supports_text_only', defaultValue: false)
  final bool? supportsTextOnly;
  @JsonKey(name: 'first_message')
  final dynamic firstMessage;
  static const fromJsonFactory = _$WidgetConfigResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WidgetConfigResponseModel &&
            (identical(other.variant, variant) ||
                const DeepCollectionEquality()
                    .equals(other.variant, variant)) &&
            (identical(other.placement, placement) ||
                const DeepCollectionEquality()
                    .equals(other.placement, placement)) &&
            (identical(other.expandable, expandable) ||
                const DeepCollectionEquality()
                    .equals(other.expandable, expandable)) &&
            (identical(other.avatar, avatar) ||
                const DeepCollectionEquality().equals(other.avatar, avatar)) &&
            (identical(other.feedbackMode, feedbackMode) ||
                const DeepCollectionEquality()
                    .equals(other.feedbackMode, feedbackMode)) &&
            (identical(other.bgColor, bgColor) ||
                const DeepCollectionEquality()
                    .equals(other.bgColor, bgColor)) &&
            (identical(other.textColor, textColor) ||
                const DeepCollectionEquality()
                    .equals(other.textColor, textColor)) &&
            (identical(other.btnColor, btnColor) ||
                const DeepCollectionEquality()
                    .equals(other.btnColor, btnColor)) &&
            (identical(other.btnTextColor, btnTextColor) ||
                const DeepCollectionEquality()
                    .equals(other.btnTextColor, btnTextColor)) &&
            (identical(other.borderColor, borderColor) ||
                const DeepCollectionEquality()
                    .equals(other.borderColor, borderColor)) &&
            (identical(other.focusColor, focusColor) ||
                const DeepCollectionEquality()
                    .equals(other.focusColor, focusColor)) &&
            (identical(other.borderRadius, borderRadius) ||
                const DeepCollectionEquality()
                    .equals(other.borderRadius, borderRadius)) &&
            (identical(other.btnRadius, btnRadius) ||
                const DeepCollectionEquality()
                    .equals(other.btnRadius, btnRadius)) &&
            (identical(other.actionText, actionText) ||
                const DeepCollectionEquality()
                    .equals(other.actionText, actionText)) &&
            (identical(other.startCallText, startCallText) ||
                const DeepCollectionEquality()
                    .equals(other.startCallText, startCallText)) &&
            (identical(other.endCallText, endCallText) ||
                const DeepCollectionEquality()
                    .equals(other.endCallText, endCallText)) &&
            (identical(other.expandText, expandText) ||
                const DeepCollectionEquality()
                    .equals(other.expandText, expandText)) &&
            (identical(other.listeningText, listeningText) ||
                const DeepCollectionEquality()
                    .equals(other.listeningText, listeningText)) &&
            (identical(other.speakingText, speakingText) ||
                const DeepCollectionEquality()
                    .equals(other.speakingText, speakingText)) &&
            (identical(other.shareablePageText, shareablePageText) ||
                const DeepCollectionEquality()
                    .equals(other.shareablePageText, shareablePageText)) &&
            (identical(other.shareablePageShowTerms, shareablePageShowTerms) ||
                const DeepCollectionEquality().equals(
                    other.shareablePageShowTerms, shareablePageShowTerms)) &&
            (identical(other.termsText, termsText) ||
                const DeepCollectionEquality()
                    .equals(other.termsText, termsText)) &&
            (identical(other.termsHtml, termsHtml) || const DeepCollectionEquality().equals(other.termsHtml, termsHtml)) &&
            (identical(other.termsKey, termsKey) || const DeepCollectionEquality().equals(other.termsKey, termsKey)) &&
            (identical(other.showAvatarWhenCollapsed, showAvatarWhenCollapsed) || const DeepCollectionEquality().equals(other.showAvatarWhenCollapsed, showAvatarWhenCollapsed)) &&
            (identical(other.disableBanner, disableBanner) || const DeepCollectionEquality().equals(other.disableBanner, disableBanner)) &&
            (identical(other.overrideLink, overrideLink) || const DeepCollectionEquality().equals(other.overrideLink, overrideLink)) &&
            (identical(other.micMutingEnabled, micMutingEnabled) || const DeepCollectionEquality().equals(other.micMutingEnabled, micMutingEnabled)) &&
            (identical(other.transcriptEnabled, transcriptEnabled) || const DeepCollectionEquality().equals(other.transcriptEnabled, transcriptEnabled)) &&
            (identical(other.textInputEnabled, textInputEnabled) || const DeepCollectionEquality().equals(other.textInputEnabled, textInputEnabled)) &&
            (identical(other.textContents, textContents) || const DeepCollectionEquality().equals(other.textContents, textContents)) &&
            (identical(other.language, language) || const DeepCollectionEquality().equals(other.language, language)) &&
            (identical(other.supportedLanguageOverrides, supportedLanguageOverrides) || const DeepCollectionEquality().equals(other.supportedLanguageOverrides, supportedLanguageOverrides)) &&
            (identical(other.languagePresets, languagePresets) || const DeepCollectionEquality().equals(other.languagePresets, languagePresets)) &&
            (identical(other.textOnly, textOnly) || const DeepCollectionEquality().equals(other.textOnly, textOnly)) &&
            (identical(other.supportsTextOnly, supportsTextOnly) || const DeepCollectionEquality().equals(other.supportsTextOnly, supportsTextOnly)) &&
            (identical(other.firstMessage, firstMessage) || const DeepCollectionEquality().equals(other.firstMessage, firstMessage)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(variant) ^
      const DeepCollectionEquality().hash(placement) ^
      const DeepCollectionEquality().hash(expandable) ^
      const DeepCollectionEquality().hash(avatar) ^
      const DeepCollectionEquality().hash(feedbackMode) ^
      const DeepCollectionEquality().hash(bgColor) ^
      const DeepCollectionEquality().hash(textColor) ^
      const DeepCollectionEquality().hash(btnColor) ^
      const DeepCollectionEquality().hash(btnTextColor) ^
      const DeepCollectionEquality().hash(borderColor) ^
      const DeepCollectionEquality().hash(focusColor) ^
      const DeepCollectionEquality().hash(borderRadius) ^
      const DeepCollectionEquality().hash(btnRadius) ^
      const DeepCollectionEquality().hash(actionText) ^
      const DeepCollectionEquality().hash(startCallText) ^
      const DeepCollectionEquality().hash(endCallText) ^
      const DeepCollectionEquality().hash(expandText) ^
      const DeepCollectionEquality().hash(listeningText) ^
      const DeepCollectionEquality().hash(speakingText) ^
      const DeepCollectionEquality().hash(shareablePageText) ^
      const DeepCollectionEquality().hash(shareablePageShowTerms) ^
      const DeepCollectionEquality().hash(termsText) ^
      const DeepCollectionEquality().hash(termsHtml) ^
      const DeepCollectionEquality().hash(termsKey) ^
      const DeepCollectionEquality().hash(showAvatarWhenCollapsed) ^
      const DeepCollectionEquality().hash(disableBanner) ^
      const DeepCollectionEquality().hash(overrideLink) ^
      const DeepCollectionEquality().hash(micMutingEnabled) ^
      const DeepCollectionEquality().hash(transcriptEnabled) ^
      const DeepCollectionEquality().hash(textInputEnabled) ^
      const DeepCollectionEquality().hash(textContents) ^
      const DeepCollectionEquality().hash(language) ^
      const DeepCollectionEquality().hash(supportedLanguageOverrides) ^
      const DeepCollectionEquality().hash(languagePresets) ^
      const DeepCollectionEquality().hash(textOnly) ^
      const DeepCollectionEquality().hash(supportsTextOnly) ^
      const DeepCollectionEquality().hash(firstMessage) ^
      runtimeType.hashCode;
}

extension $WidgetConfigResponseModelExtension on WidgetConfigResponseModel {
  WidgetConfigResponseModel copyWith(
      {enums.EmbedVariant? variant,
      enums.WidgetPlacement? placement,
      enums.WidgetExpandable? expandable,
      dynamic avatar,
      enums.WidgetFeedbackMode? feedbackMode,
      String? bgColor,
      String? textColor,
      String? btnColor,
      String? btnTextColor,
      String? borderColor,
      String? focusColor,
      dynamic borderRadius,
      dynamic btnRadius,
      dynamic actionText,
      dynamic startCallText,
      dynamic endCallText,
      dynamic expandText,
      dynamic listeningText,
      dynamic speakingText,
      dynamic shareablePageText,
      bool? shareablePageShowTerms,
      dynamic termsText,
      dynamic termsHtml,
      dynamic termsKey,
      dynamic showAvatarWhenCollapsed,
      bool? disableBanner,
      dynamic overrideLink,
      bool? micMutingEnabled,
      bool? transcriptEnabled,
      bool? textInputEnabled,
      WidgetTextContents? textContents,
      String? language,
      dynamic supportedLanguageOverrides,
      Map<String, dynamic>? languagePresets,
      bool? textOnly,
      bool? supportsTextOnly,
      dynamic firstMessage}) {
    return WidgetConfigResponseModel(
        variant: variant ?? this.variant,
        placement: placement ?? this.placement,
        expandable: expandable ?? this.expandable,
        avatar: avatar ?? this.avatar,
        feedbackMode: feedbackMode ?? this.feedbackMode,
        bgColor: bgColor ?? this.bgColor,
        textColor: textColor ?? this.textColor,
        btnColor: btnColor ?? this.btnColor,
        btnTextColor: btnTextColor ?? this.btnTextColor,
        borderColor: borderColor ?? this.borderColor,
        focusColor: focusColor ?? this.focusColor,
        borderRadius: borderRadius ?? this.borderRadius,
        btnRadius: btnRadius ?? this.btnRadius,
        actionText: actionText ?? this.actionText,
        startCallText: startCallText ?? this.startCallText,
        endCallText: endCallText ?? this.endCallText,
        expandText: expandText ?? this.expandText,
        listeningText: listeningText ?? this.listeningText,
        speakingText: speakingText ?? this.speakingText,
        shareablePageText: shareablePageText ?? this.shareablePageText,
        shareablePageShowTerms:
            shareablePageShowTerms ?? this.shareablePageShowTerms,
        termsText: termsText ?? this.termsText,
        termsHtml: termsHtml ?? this.termsHtml,
        termsKey: termsKey ?? this.termsKey,
        showAvatarWhenCollapsed:
            showAvatarWhenCollapsed ?? this.showAvatarWhenCollapsed,
        disableBanner: disableBanner ?? this.disableBanner,
        overrideLink: overrideLink ?? this.overrideLink,
        micMutingEnabled: micMutingEnabled ?? this.micMutingEnabled,
        transcriptEnabled: transcriptEnabled ?? this.transcriptEnabled,
        textInputEnabled: textInputEnabled ?? this.textInputEnabled,
        textContents: textContents ?? this.textContents,
        language: language ?? this.language,
        supportedLanguageOverrides:
            supportedLanguageOverrides ?? this.supportedLanguageOverrides,
        languagePresets: languagePresets ?? this.languagePresets,
        textOnly: textOnly ?? this.textOnly,
        supportsTextOnly: supportsTextOnly ?? this.supportsTextOnly,
        firstMessage: firstMessage ?? this.firstMessage);
  }

  WidgetConfigResponseModel copyWithWrapped(
      {Wrapped<enums.EmbedVariant?>? variant,
      Wrapped<enums.WidgetPlacement?>? placement,
      Wrapped<enums.WidgetExpandable?>? expandable,
      Wrapped<dynamic>? avatar,
      Wrapped<enums.WidgetFeedbackMode?>? feedbackMode,
      Wrapped<String?>? bgColor,
      Wrapped<String?>? textColor,
      Wrapped<String?>? btnColor,
      Wrapped<String?>? btnTextColor,
      Wrapped<String?>? borderColor,
      Wrapped<String?>? focusColor,
      Wrapped<dynamic>? borderRadius,
      Wrapped<dynamic>? btnRadius,
      Wrapped<dynamic>? actionText,
      Wrapped<dynamic>? startCallText,
      Wrapped<dynamic>? endCallText,
      Wrapped<dynamic>? expandText,
      Wrapped<dynamic>? listeningText,
      Wrapped<dynamic>? speakingText,
      Wrapped<dynamic>? shareablePageText,
      Wrapped<bool?>? shareablePageShowTerms,
      Wrapped<dynamic>? termsText,
      Wrapped<dynamic>? termsHtml,
      Wrapped<dynamic>? termsKey,
      Wrapped<dynamic>? showAvatarWhenCollapsed,
      Wrapped<bool?>? disableBanner,
      Wrapped<dynamic>? overrideLink,
      Wrapped<bool?>? micMutingEnabled,
      Wrapped<bool?>? transcriptEnabled,
      Wrapped<bool?>? textInputEnabled,
      Wrapped<WidgetTextContents?>? textContents,
      Wrapped<String>? language,
      Wrapped<dynamic>? supportedLanguageOverrides,
      Wrapped<Map<String, dynamic>?>? languagePresets,
      Wrapped<bool?>? textOnly,
      Wrapped<bool?>? supportsTextOnly,
      Wrapped<dynamic>? firstMessage}) {
    return WidgetConfigResponseModel(
        variant: (variant != null ? variant.value : this.variant),
        placement: (placement != null ? placement.value : this.placement),
        expandable: (expandable != null ? expandable.value : this.expandable),
        avatar: (avatar != null ? avatar.value : this.avatar),
        feedbackMode:
            (feedbackMode != null ? feedbackMode.value : this.feedbackMode),
        bgColor: (bgColor != null ? bgColor.value : this.bgColor),
        textColor: (textColor != null ? textColor.value : this.textColor),
        btnColor: (btnColor != null ? btnColor.value : this.btnColor),
        btnTextColor:
            (btnTextColor != null ? btnTextColor.value : this.btnTextColor),
        borderColor:
            (borderColor != null ? borderColor.value : this.borderColor),
        focusColor: (focusColor != null ? focusColor.value : this.focusColor),
        borderRadius:
            (borderRadius != null ? borderRadius.value : this.borderRadius),
        btnRadius: (btnRadius != null ? btnRadius.value : this.btnRadius),
        actionText: (actionText != null ? actionText.value : this.actionText),
        startCallText:
            (startCallText != null ? startCallText.value : this.startCallText),
        endCallText:
            (endCallText != null ? endCallText.value : this.endCallText),
        expandText: (expandText != null ? expandText.value : this.expandText),
        listeningText:
            (listeningText != null ? listeningText.value : this.listeningText),
        speakingText:
            (speakingText != null ? speakingText.value : this.speakingText),
        shareablePageText: (shareablePageText != null
            ? shareablePageText.value
            : this.shareablePageText),
        shareablePageShowTerms: (shareablePageShowTerms != null
            ? shareablePageShowTerms.value
            : this.shareablePageShowTerms),
        termsText: (termsText != null ? termsText.value : this.termsText),
        termsHtml: (termsHtml != null ? termsHtml.value : this.termsHtml),
        termsKey: (termsKey != null ? termsKey.value : this.termsKey),
        showAvatarWhenCollapsed: (showAvatarWhenCollapsed != null
            ? showAvatarWhenCollapsed.value
            : this.showAvatarWhenCollapsed),
        disableBanner:
            (disableBanner != null ? disableBanner.value : this.disableBanner),
        overrideLink:
            (overrideLink != null ? overrideLink.value : this.overrideLink),
        micMutingEnabled: (micMutingEnabled != null
            ? micMutingEnabled.value
            : this.micMutingEnabled),
        transcriptEnabled: (transcriptEnabled != null
            ? transcriptEnabled.value
            : this.transcriptEnabled),
        textInputEnabled: (textInputEnabled != null
            ? textInputEnabled.value
            : this.textInputEnabled),
        textContents:
            (textContents != null ? textContents.value : this.textContents),
        language: (language != null ? language.value : this.language),
        supportedLanguageOverrides: (supportedLanguageOverrides != null
            ? supportedLanguageOverrides.value
            : this.supportedLanguageOverrides),
        languagePresets: (languagePresets != null
            ? languagePresets.value
            : this.languagePresets),
        textOnly: (textOnly != null ? textOnly.value : this.textOnly),
        supportsTextOnly: (supportsTextOnly != null
            ? supportsTextOnly.value
            : this.supportsTextOnly),
        firstMessage:
            (firstMessage != null ? firstMessage.value : this.firstMessage));
  }
}

@JsonSerializable(explicitToJson: true)
class WidgetLanguagePreset {
  const WidgetLanguagePreset({
    this.textContents,
  });

  factory WidgetLanguagePreset.fromJson(Map<String, dynamic> json) =>
      _$WidgetLanguagePresetFromJson(json);

  static const toJsonFactory = _$WidgetLanguagePresetToJson;
  Map<String, dynamic> toJson() => _$WidgetLanguagePresetToJson(this);

  @JsonKey(name: 'text_contents')
  final dynamic textContents;
  static const fromJsonFactory = _$WidgetLanguagePresetFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WidgetLanguagePreset &&
            (identical(other.textContents, textContents) ||
                const DeepCollectionEquality()
                    .equals(other.textContents, textContents)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(textContents) ^ runtimeType.hashCode;
}

extension $WidgetLanguagePresetExtension on WidgetLanguagePreset {
  WidgetLanguagePreset copyWith({dynamic textContents}) {
    return WidgetLanguagePreset(
        textContents: textContents ?? this.textContents);
  }

  WidgetLanguagePreset copyWithWrapped({Wrapped<dynamic>? textContents}) {
    return WidgetLanguagePreset(
        textContents:
            (textContents != null ? textContents.value : this.textContents));
  }
}

@JsonSerializable(explicitToJson: true)
class WidgetLanguagePresetResponse {
  const WidgetLanguagePresetResponse({
    this.firstMessage,
    this.textContents,
  });

  factory WidgetLanguagePresetResponse.fromJson(Map<String, dynamic> json) =>
      _$WidgetLanguagePresetResponseFromJson(json);

  static const toJsonFactory = _$WidgetLanguagePresetResponseToJson;
  Map<String, dynamic> toJson() => _$WidgetLanguagePresetResponseToJson(this);

  @JsonKey(name: 'first_message')
  final dynamic firstMessage;
  @JsonKey(name: 'text_contents')
  final dynamic textContents;
  static const fromJsonFactory = _$WidgetLanguagePresetResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WidgetLanguagePresetResponse &&
            (identical(other.firstMessage, firstMessage) ||
                const DeepCollectionEquality()
                    .equals(other.firstMessage, firstMessage)) &&
            (identical(other.textContents, textContents) ||
                const DeepCollectionEquality()
                    .equals(other.textContents, textContents)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(firstMessage) ^
      const DeepCollectionEquality().hash(textContents) ^
      runtimeType.hashCode;
}

extension $WidgetLanguagePresetResponseExtension
    on WidgetLanguagePresetResponse {
  WidgetLanguagePresetResponse copyWith(
      {dynamic firstMessage, dynamic textContents}) {
    return WidgetLanguagePresetResponse(
        firstMessage: firstMessage ?? this.firstMessage,
        textContents: textContents ?? this.textContents);
  }

  WidgetLanguagePresetResponse copyWithWrapped(
      {Wrapped<dynamic>? firstMessage, Wrapped<dynamic>? textContents}) {
    return WidgetLanguagePresetResponse(
        firstMessage:
            (firstMessage != null ? firstMessage.value : this.firstMessage),
        textContents:
            (textContents != null ? textContents.value : this.textContents));
  }
}

@JsonSerializable(explicitToJson: true)
class WidgetTextContents {
  const WidgetTextContents({
    this.mainLabel,
    this.startCall,
    this.newCall,
    this.endCall,
    this.muteMicrophone,
    this.changeLanguage,
    this.collapse,
    this.expand,
    this.copied,
    this.acceptTerms,
    this.dismissTerms,
    this.listeningStatus,
    this.speakingStatus,
    this.connectingStatus,
    this.inputLabel,
    this.inputPlaceholder,
    this.userEndedConversation,
    this.agentEndedConversation,
    this.conversationId,
    this.errorOccurred,
    this.copyId,
  });

  factory WidgetTextContents.fromJson(Map<String, dynamic> json) =>
      _$WidgetTextContentsFromJson(json);

  static const toJsonFactory = _$WidgetTextContentsToJson;
  Map<String, dynamic> toJson() => _$WidgetTextContentsToJson(this);

  @JsonKey(name: 'main_label')
  final dynamic mainLabel;
  @JsonKey(name: 'start_call')
  final dynamic startCall;
  @JsonKey(name: 'new_call')
  final dynamic newCall;
  @JsonKey(name: 'end_call')
  final dynamic endCall;
  @JsonKey(name: 'mute_microphone')
  final dynamic muteMicrophone;
  @JsonKey(name: 'change_language')
  final dynamic changeLanguage;
  @JsonKey(name: 'collapse')
  final dynamic collapse;
  @JsonKey(name: 'expand')
  final dynamic expand;
  @JsonKey(name: 'copied')
  final dynamic copied;
  @JsonKey(name: 'accept_terms')
  final dynamic acceptTerms;
  @JsonKey(name: 'dismiss_terms')
  final dynamic dismissTerms;
  @JsonKey(name: 'listening_status')
  final dynamic listeningStatus;
  @JsonKey(name: 'speaking_status')
  final dynamic speakingStatus;
  @JsonKey(name: 'connecting_status')
  final dynamic connectingStatus;
  @JsonKey(name: 'input_label')
  final dynamic inputLabel;
  @JsonKey(name: 'input_placeholder')
  final dynamic inputPlaceholder;
  @JsonKey(name: 'user_ended_conversation')
  final dynamic userEndedConversation;
  @JsonKey(name: 'agent_ended_conversation')
  final dynamic agentEndedConversation;
  @JsonKey(name: 'conversation_id')
  final dynamic conversationId;
  @JsonKey(name: 'error_occurred')
  final dynamic errorOccurred;
  @JsonKey(name: 'copy_id')
  final dynamic copyId;
  static const fromJsonFactory = _$WidgetTextContentsFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WidgetTextContents &&
            (identical(other.mainLabel, mainLabel) ||
                const DeepCollectionEquality()
                    .equals(other.mainLabel, mainLabel)) &&
            (identical(other.startCall, startCall) ||
                const DeepCollectionEquality()
                    .equals(other.startCall, startCall)) &&
            (identical(other.newCall, newCall) ||
                const DeepCollectionEquality()
                    .equals(other.newCall, newCall)) &&
            (identical(other.endCall, endCall) ||
                const DeepCollectionEquality()
                    .equals(other.endCall, endCall)) &&
            (identical(other.muteMicrophone, muteMicrophone) ||
                const DeepCollectionEquality()
                    .equals(other.muteMicrophone, muteMicrophone)) &&
            (identical(other.changeLanguage, changeLanguage) ||
                const DeepCollectionEquality()
                    .equals(other.changeLanguage, changeLanguage)) &&
            (identical(other.collapse, collapse) ||
                const DeepCollectionEquality()
                    .equals(other.collapse, collapse)) &&
            (identical(other.expand, expand) ||
                const DeepCollectionEquality().equals(other.expand, expand)) &&
            (identical(other.copied, copied) ||
                const DeepCollectionEquality().equals(other.copied, copied)) &&
            (identical(other.acceptTerms, acceptTerms) ||
                const DeepCollectionEquality()
                    .equals(other.acceptTerms, acceptTerms)) &&
            (identical(other.dismissTerms, dismissTerms) ||
                const DeepCollectionEquality()
                    .equals(other.dismissTerms, dismissTerms)) &&
            (identical(other.listeningStatus, listeningStatus) ||
                const DeepCollectionEquality()
                    .equals(other.listeningStatus, listeningStatus)) &&
            (identical(other.speakingStatus, speakingStatus) ||
                const DeepCollectionEquality()
                    .equals(other.speakingStatus, speakingStatus)) &&
            (identical(other.connectingStatus, connectingStatus) ||
                const DeepCollectionEquality()
                    .equals(other.connectingStatus, connectingStatus)) &&
            (identical(other.inputLabel, inputLabel) ||
                const DeepCollectionEquality()
                    .equals(other.inputLabel, inputLabel)) &&
            (identical(other.inputPlaceholder, inputPlaceholder) ||
                const DeepCollectionEquality()
                    .equals(other.inputPlaceholder, inputPlaceholder)) &&
            (identical(other.userEndedConversation, userEndedConversation) ||
                const DeepCollectionEquality().equals(
                    other.userEndedConversation, userEndedConversation)) &&
            (identical(other.agentEndedConversation, agentEndedConversation) ||
                const DeepCollectionEquality().equals(
                    other.agentEndedConversation, agentEndedConversation)) &&
            (identical(other.conversationId, conversationId) ||
                const DeepCollectionEquality()
                    .equals(other.conversationId, conversationId)) &&
            (identical(other.errorOccurred, errorOccurred) ||
                const DeepCollectionEquality()
                    .equals(other.errorOccurred, errorOccurred)) &&
            (identical(other.copyId, copyId) ||
                const DeepCollectionEquality().equals(other.copyId, copyId)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(mainLabel) ^
      const DeepCollectionEquality().hash(startCall) ^
      const DeepCollectionEquality().hash(newCall) ^
      const DeepCollectionEquality().hash(endCall) ^
      const DeepCollectionEquality().hash(muteMicrophone) ^
      const DeepCollectionEquality().hash(changeLanguage) ^
      const DeepCollectionEquality().hash(collapse) ^
      const DeepCollectionEquality().hash(expand) ^
      const DeepCollectionEquality().hash(copied) ^
      const DeepCollectionEquality().hash(acceptTerms) ^
      const DeepCollectionEquality().hash(dismissTerms) ^
      const DeepCollectionEquality().hash(listeningStatus) ^
      const DeepCollectionEquality().hash(speakingStatus) ^
      const DeepCollectionEquality().hash(connectingStatus) ^
      const DeepCollectionEquality().hash(inputLabel) ^
      const DeepCollectionEquality().hash(inputPlaceholder) ^
      const DeepCollectionEquality().hash(userEndedConversation) ^
      const DeepCollectionEquality().hash(agentEndedConversation) ^
      const DeepCollectionEquality().hash(conversationId) ^
      const DeepCollectionEquality().hash(errorOccurred) ^
      const DeepCollectionEquality().hash(copyId) ^
      runtimeType.hashCode;
}

extension $WidgetTextContentsExtension on WidgetTextContents {
  WidgetTextContents copyWith(
      {dynamic mainLabel,
      dynamic startCall,
      dynamic newCall,
      dynamic endCall,
      dynamic muteMicrophone,
      dynamic changeLanguage,
      dynamic collapse,
      dynamic expand,
      dynamic copied,
      dynamic acceptTerms,
      dynamic dismissTerms,
      dynamic listeningStatus,
      dynamic speakingStatus,
      dynamic connectingStatus,
      dynamic inputLabel,
      dynamic inputPlaceholder,
      dynamic userEndedConversation,
      dynamic agentEndedConversation,
      dynamic conversationId,
      dynamic errorOccurred,
      dynamic copyId}) {
    return WidgetTextContents(
        mainLabel: mainLabel ?? this.mainLabel,
        startCall: startCall ?? this.startCall,
        newCall: newCall ?? this.newCall,
        endCall: endCall ?? this.endCall,
        muteMicrophone: muteMicrophone ?? this.muteMicrophone,
        changeLanguage: changeLanguage ?? this.changeLanguage,
        collapse: collapse ?? this.collapse,
        expand: expand ?? this.expand,
        copied: copied ?? this.copied,
        acceptTerms: acceptTerms ?? this.acceptTerms,
        dismissTerms: dismissTerms ?? this.dismissTerms,
        listeningStatus: listeningStatus ?? this.listeningStatus,
        speakingStatus: speakingStatus ?? this.speakingStatus,
        connectingStatus: connectingStatus ?? this.connectingStatus,
        inputLabel: inputLabel ?? this.inputLabel,
        inputPlaceholder: inputPlaceholder ?? this.inputPlaceholder,
        userEndedConversation:
            userEndedConversation ?? this.userEndedConversation,
        agentEndedConversation:
            agentEndedConversation ?? this.agentEndedConversation,
        conversationId: conversationId ?? this.conversationId,
        errorOccurred: errorOccurred ?? this.errorOccurred,
        copyId: copyId ?? this.copyId);
  }

  WidgetTextContents copyWithWrapped(
      {Wrapped<dynamic>? mainLabel,
      Wrapped<dynamic>? startCall,
      Wrapped<dynamic>? newCall,
      Wrapped<dynamic>? endCall,
      Wrapped<dynamic>? muteMicrophone,
      Wrapped<dynamic>? changeLanguage,
      Wrapped<dynamic>? collapse,
      Wrapped<dynamic>? expand,
      Wrapped<dynamic>? copied,
      Wrapped<dynamic>? acceptTerms,
      Wrapped<dynamic>? dismissTerms,
      Wrapped<dynamic>? listeningStatus,
      Wrapped<dynamic>? speakingStatus,
      Wrapped<dynamic>? connectingStatus,
      Wrapped<dynamic>? inputLabel,
      Wrapped<dynamic>? inputPlaceholder,
      Wrapped<dynamic>? userEndedConversation,
      Wrapped<dynamic>? agentEndedConversation,
      Wrapped<dynamic>? conversationId,
      Wrapped<dynamic>? errorOccurred,
      Wrapped<dynamic>? copyId}) {
    return WidgetTextContents(
        mainLabel: (mainLabel != null ? mainLabel.value : this.mainLabel),
        startCall: (startCall != null ? startCall.value : this.startCall),
        newCall: (newCall != null ? newCall.value : this.newCall),
        endCall: (endCall != null ? endCall.value : this.endCall),
        muteMicrophone: (muteMicrophone != null
            ? muteMicrophone.value
            : this.muteMicrophone),
        changeLanguage: (changeLanguage != null
            ? changeLanguage.value
            : this.changeLanguage),
        collapse: (collapse != null ? collapse.value : this.collapse),
        expand: (expand != null ? expand.value : this.expand),
        copied: (copied != null ? copied.value : this.copied),
        acceptTerms:
            (acceptTerms != null ? acceptTerms.value : this.acceptTerms),
        dismissTerms:
            (dismissTerms != null ? dismissTerms.value : this.dismissTerms),
        listeningStatus: (listeningStatus != null
            ? listeningStatus.value
            : this.listeningStatus),
        speakingStatus: (speakingStatus != null
            ? speakingStatus.value
            : this.speakingStatus),
        connectingStatus: (connectingStatus != null
            ? connectingStatus.value
            : this.connectingStatus),
        inputLabel: (inputLabel != null ? inputLabel.value : this.inputLabel),
        inputPlaceholder: (inputPlaceholder != null
            ? inputPlaceholder.value
            : this.inputPlaceholder),
        userEndedConversation: (userEndedConversation != null
            ? userEndedConversation.value
            : this.userEndedConversation),
        agentEndedConversation: (agentEndedConversation != null
            ? agentEndedConversation.value
            : this.agentEndedConversation),
        conversationId: (conversationId != null
            ? conversationId.value
            : this.conversationId),
        errorOccurred:
            (errorOccurred != null ? errorOccurred.value : this.errorOccurred),
        copyId: (copyId != null ? copyId.value : this.copyId));
  }
}

@JsonSerializable(explicitToJson: true)
class WorkspaceBatchCallsResponse {
  const WorkspaceBatchCallsResponse({
    required this.batchCalls,
    this.nextDoc,
    this.hasMore,
  });

  factory WorkspaceBatchCallsResponse.fromJson(Map<String, dynamic> json) =>
      _$WorkspaceBatchCallsResponseFromJson(json);

  static const toJsonFactory = _$WorkspaceBatchCallsResponseToJson;
  Map<String, dynamic> toJson() => _$WorkspaceBatchCallsResponseToJson(this);

  @JsonKey(name: 'batch_calls', defaultValue: <BatchCallResponse>[])
  final List<BatchCallResponse> batchCalls;
  @JsonKey(name: 'next_doc')
  final dynamic nextDoc;
  @JsonKey(name: 'has_more', defaultValue: false)
  final bool? hasMore;
  static const fromJsonFactory = _$WorkspaceBatchCallsResponseFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WorkspaceBatchCallsResponse &&
            (identical(other.batchCalls, batchCalls) ||
                const DeepCollectionEquality()
                    .equals(other.batchCalls, batchCalls)) &&
            (identical(other.nextDoc, nextDoc) ||
                const DeepCollectionEquality()
                    .equals(other.nextDoc, nextDoc)) &&
            (identical(other.hasMore, hasMore) ||
                const DeepCollectionEquality().equals(other.hasMore, hasMore)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(batchCalls) ^
      const DeepCollectionEquality().hash(nextDoc) ^
      const DeepCollectionEquality().hash(hasMore) ^
      runtimeType.hashCode;
}

extension $WorkspaceBatchCallsResponseExtension on WorkspaceBatchCallsResponse {
  WorkspaceBatchCallsResponse copyWith(
      {List<BatchCallResponse>? batchCalls, dynamic nextDoc, bool? hasMore}) {
    return WorkspaceBatchCallsResponse(
        batchCalls: batchCalls ?? this.batchCalls,
        nextDoc: nextDoc ?? this.nextDoc,
        hasMore: hasMore ?? this.hasMore);
  }

  WorkspaceBatchCallsResponse copyWithWrapped(
      {Wrapped<List<BatchCallResponse>>? batchCalls,
      Wrapped<dynamic>? nextDoc,
      Wrapped<bool?>? hasMore}) {
    return WorkspaceBatchCallsResponse(
        batchCalls: (batchCalls != null ? batchCalls.value : this.batchCalls),
        nextDoc: (nextDoc != null ? nextDoc.value : this.nextDoc),
        hasMore: (hasMore != null ? hasMore.value : this.hasMore));
  }
}

@JsonSerializable(explicitToJson: true)
class WorkspaceGroupByNameResponseModel {
  const WorkspaceGroupByNameResponseModel({
    required this.name,
    required this.id,
    required this.membersEmails,
  });

  factory WorkspaceGroupByNameResponseModel.fromJson(
          Map<String, dynamic> json) =>
      _$WorkspaceGroupByNameResponseModelFromJson(json);

  static const toJsonFactory = _$WorkspaceGroupByNameResponseModelToJson;
  Map<String, dynamic> toJson() =>
      _$WorkspaceGroupByNameResponseModelToJson(this);

  @JsonKey(name: 'name')
  final String name;
  @JsonKey(name: 'id')
  final String id;
  @JsonKey(name: 'members_emails', defaultValue: <String>[])
  final List<String> membersEmails;
  static const fromJsonFactory = _$WorkspaceGroupByNameResponseModelFromJson;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other is WorkspaceGroupByNameResponseModel &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)) &&
            (identical(other.membersEmails, membersEmails) ||
                const DeepCollectionEquality()
                    .equals(other.membersEmails, membersEmails)));
  }

  @override
  String toString() => jsonEncode(this);

  @override
  int get hashCode =>
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(id) ^
      const DeepCollectionEquality().hash(membersEmails) ^
      runtimeType.hashCode;
}

extension $WorkspaceGroupByNameResponseModelExtension
    on WorkspaceGroupByNameResponseModel {
  WorkspaceGroupByNameResponseModel copyWith(
      {String? name, String? id, List<String>? membersEmails}) {
    return WorkspaceGroupByNameResponseModel(
        name: name ?? this.name,
        id: id ?? this.id,
        membersEmails: membersEmails ?? this.membersEmails);
  }

  WorkspaceGroupByNameResponseModel copyWithWrapped(
      {Wrapped<String>? name,
      Wrapped<String>? id,
      Wrapped<List<String>>? membersEmails}) {
    return WorkspaceGroupByNameResponseModel(
        name: (name != null ? name.value : this.name),
        id: (id != null ? id.value : this.id),
        membersEmails:
            (membersEmails != null ? membersEmails.value : this.membersEmails));
  }
}

String? aSRInputFormatNullableToJson(enums.ASRInputFormat? aSRInputFormat) {
  return aSRInputFormat?.value;
}

String? aSRInputFormatToJson(enums.ASRInputFormat aSRInputFormat) {
  return aSRInputFormat.value;
}

enums.ASRInputFormat aSRInputFormatFromJson(
  Object? aSRInputFormat, [
  enums.ASRInputFormat? defaultValue,
]) {
  return enums.ASRInputFormat.values
          .firstWhereOrNull((e) => e.value == aSRInputFormat) ??
      defaultValue ??
      enums.ASRInputFormat.swaggerGeneratedUnknown;
}

enums.ASRInputFormat? aSRInputFormatNullableFromJson(
  Object? aSRInputFormat, [
  enums.ASRInputFormat? defaultValue,
]) {
  if (aSRInputFormat == null) {
    return null;
  }
  return enums.ASRInputFormat.values
          .firstWhereOrNull((e) => e.value == aSRInputFormat) ??
      defaultValue;
}

String aSRInputFormatExplodedListToJson(
    List<enums.ASRInputFormat>? aSRInputFormat) {
  return aSRInputFormat?.map((e) => e.value!).join(',') ?? '';
}

List<String> aSRInputFormatListToJson(
    List<enums.ASRInputFormat>? aSRInputFormat) {
  if (aSRInputFormat == null) {
    return [];
  }

  return aSRInputFormat.map((e) => e.value!).toList();
}

List<enums.ASRInputFormat> aSRInputFormatListFromJson(
  List? aSRInputFormat, [
  List<enums.ASRInputFormat>? defaultValue,
]) {
  if (aSRInputFormat == null) {
    return defaultValue ?? [];
  }

  return aSRInputFormat
      .map((e) => aSRInputFormatFromJson(e.toString()))
      .toList();
}

List<enums.ASRInputFormat>? aSRInputFormatNullableListFromJson(
  List? aSRInputFormat, [
  List<enums.ASRInputFormat>? defaultValue,
]) {
  if (aSRInputFormat == null) {
    return defaultValue;
  }

  return aSRInputFormat
      .map((e) => aSRInputFormatFromJson(e.toString()))
      .toList();
}

String? aSRProviderNullableToJson(enums.ASRProvider? aSRProvider) {
  return aSRProvider?.value;
}

String? aSRProviderToJson(enums.ASRProvider aSRProvider) {
  return aSRProvider.value;
}

enums.ASRProvider aSRProviderFromJson(
  Object? aSRProvider, [
  enums.ASRProvider? defaultValue,
]) {
  return enums.ASRProvider.values
          .firstWhereOrNull((e) => e.value == aSRProvider) ??
      defaultValue ??
      enums.ASRProvider.swaggerGeneratedUnknown;
}

enums.ASRProvider? aSRProviderNullableFromJson(
  Object? aSRProvider, [
  enums.ASRProvider? defaultValue,
]) {
  if (aSRProvider == null) {
    return null;
  }
  return enums.ASRProvider.values
          .firstWhereOrNull((e) => e.value == aSRProvider) ??
      defaultValue;
}

String aSRProviderExplodedListToJson(List<enums.ASRProvider>? aSRProvider) {
  return aSRProvider?.map((e) => e.value!).join(',') ?? '';
}

List<String> aSRProviderListToJson(List<enums.ASRProvider>? aSRProvider) {
  if (aSRProvider == null) {
    return [];
  }

  return aSRProvider.map((e) => e.value!).toList();
}

List<enums.ASRProvider> aSRProviderListFromJson(
  List? aSRProvider, [
  List<enums.ASRProvider>? defaultValue,
]) {
  if (aSRProvider == null) {
    return defaultValue ?? [];
  }

  return aSRProvider.map((e) => aSRProviderFromJson(e.toString())).toList();
}

List<enums.ASRProvider>? aSRProviderNullableListFromJson(
  List? aSRProvider, [
  List<enums.ASRProvider>? defaultValue,
]) {
  if (aSRProvider == null) {
    return defaultValue;
  }

  return aSRProvider.map((e) => aSRProviderFromJson(e.toString())).toList();
}

String? aSRQualityNullableToJson(enums.ASRQuality? aSRQuality) {
  return aSRQuality?.value;
}

String? aSRQualityToJson(enums.ASRQuality aSRQuality) {
  return aSRQuality.value;
}

enums.ASRQuality aSRQualityFromJson(
  Object? aSRQuality, [
  enums.ASRQuality? defaultValue,
]) {
  return enums.ASRQuality.values
          .firstWhereOrNull((e) => e.value == aSRQuality) ??
      defaultValue ??
      enums.ASRQuality.swaggerGeneratedUnknown;
}

enums.ASRQuality? aSRQualityNullableFromJson(
  Object? aSRQuality, [
  enums.ASRQuality? defaultValue,
]) {
  if (aSRQuality == null) {
    return null;
  }
  return enums.ASRQuality.values
          .firstWhereOrNull((e) => e.value == aSRQuality) ??
      defaultValue;
}

String aSRQualityExplodedListToJson(List<enums.ASRQuality>? aSRQuality) {
  return aSRQuality?.map((e) => e.value!).join(',') ?? '';
}

List<String> aSRQualityListToJson(List<enums.ASRQuality>? aSRQuality) {
  if (aSRQuality == null) {
    return [];
  }

  return aSRQuality.map((e) => e.value!).toList();
}

List<enums.ASRQuality> aSRQualityListFromJson(
  List? aSRQuality, [
  List<enums.ASRQuality>? defaultValue,
]) {
  if (aSRQuality == null) {
    return defaultValue ?? [];
  }

  return aSRQuality.map((e) => aSRQualityFromJson(e.toString())).toList();
}

List<enums.ASRQuality>? aSRQualityNullableListFromJson(
  List? aSRQuality, [
  List<enums.ASRQuality>? defaultValue,
]) {
  if (aSRQuality == null) {
    return defaultValue;
  }

  return aSRQuality.map((e) => aSRQualityFromJson(e.toString())).toList();
}

String? audioNativeProjectSettingsResponseModelStatusNullableToJson(
    enums.AudioNativeProjectSettingsResponseModelStatus?
        audioNativeProjectSettingsResponseModelStatus) {
  return audioNativeProjectSettingsResponseModelStatus?.value;
}

String? audioNativeProjectSettingsResponseModelStatusToJson(
    enums.AudioNativeProjectSettingsResponseModelStatus
        audioNativeProjectSettingsResponseModelStatus) {
  return audioNativeProjectSettingsResponseModelStatus.value;
}

enums.AudioNativeProjectSettingsResponseModelStatus
    audioNativeProjectSettingsResponseModelStatusFromJson(
  Object? audioNativeProjectSettingsResponseModelStatus, [
  enums.AudioNativeProjectSettingsResponseModelStatus? defaultValue,
]) {
  return enums.AudioNativeProjectSettingsResponseModelStatus.values
          .firstWhereOrNull((e) =>
              e.value == audioNativeProjectSettingsResponseModelStatus) ??
      defaultValue ??
      enums.AudioNativeProjectSettingsResponseModelStatus
          .swaggerGeneratedUnknown;
}

enums.AudioNativeProjectSettingsResponseModelStatus?
    audioNativeProjectSettingsResponseModelStatusNullableFromJson(
  Object? audioNativeProjectSettingsResponseModelStatus, [
  enums.AudioNativeProjectSettingsResponseModelStatus? defaultValue,
]) {
  if (audioNativeProjectSettingsResponseModelStatus == null) {
    return null;
  }
  return enums.AudioNativeProjectSettingsResponseModelStatus.values
          .firstWhereOrNull((e) =>
              e.value == audioNativeProjectSettingsResponseModelStatus) ??
      defaultValue;
}

String audioNativeProjectSettingsResponseModelStatusExplodedListToJson(
    List<enums.AudioNativeProjectSettingsResponseModelStatus>?
        audioNativeProjectSettingsResponseModelStatus) {
  return audioNativeProjectSettingsResponseModelStatus
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> audioNativeProjectSettingsResponseModelStatusListToJson(
    List<enums.AudioNativeProjectSettingsResponseModelStatus>?
        audioNativeProjectSettingsResponseModelStatus) {
  if (audioNativeProjectSettingsResponseModelStatus == null) {
    return [];
  }

  return audioNativeProjectSettingsResponseModelStatus
      .map((e) => e.value!)
      .toList();
}

List<enums.AudioNativeProjectSettingsResponseModelStatus>
    audioNativeProjectSettingsResponseModelStatusListFromJson(
  List? audioNativeProjectSettingsResponseModelStatus, [
  List<enums.AudioNativeProjectSettingsResponseModelStatus>? defaultValue,
]) {
  if (audioNativeProjectSettingsResponseModelStatus == null) {
    return defaultValue ?? [];
  }

  return audioNativeProjectSettingsResponseModelStatus
      .map((e) =>
          audioNativeProjectSettingsResponseModelStatusFromJson(e.toString()))
      .toList();
}

List<enums.AudioNativeProjectSettingsResponseModelStatus>?
    audioNativeProjectSettingsResponseModelStatusNullableListFromJson(
  List? audioNativeProjectSettingsResponseModelStatus, [
  List<enums.AudioNativeProjectSettingsResponseModelStatus>? defaultValue,
]) {
  if (audioNativeProjectSettingsResponseModelStatus == null) {
    return defaultValue;
  }

  return audioNativeProjectSettingsResponseModelStatus
      .map((e) =>
          audioNativeProjectSettingsResponseModelStatusFromJson(e.toString()))
      .toList();
}

String? authorizationMethodNullableToJson(
    enums.AuthorizationMethod? authorizationMethod) {
  return authorizationMethod?.value;
}

String? authorizationMethodToJson(
    enums.AuthorizationMethod authorizationMethod) {
  return authorizationMethod.value;
}

enums.AuthorizationMethod authorizationMethodFromJson(
  Object? authorizationMethod, [
  enums.AuthorizationMethod? defaultValue,
]) {
  return enums.AuthorizationMethod.values
          .firstWhereOrNull((e) => e.value == authorizationMethod) ??
      defaultValue ??
      enums.AuthorizationMethod.swaggerGeneratedUnknown;
}

enums.AuthorizationMethod? authorizationMethodNullableFromJson(
  Object? authorizationMethod, [
  enums.AuthorizationMethod? defaultValue,
]) {
  if (authorizationMethod == null) {
    return null;
  }
  return enums.AuthorizationMethod.values
          .firstWhereOrNull((e) => e.value == authorizationMethod) ??
      defaultValue;
}

String authorizationMethodExplodedListToJson(
    List<enums.AuthorizationMethod>? authorizationMethod) {
  return authorizationMethod?.map((e) => e.value!).join(',') ?? '';
}

List<String> authorizationMethodListToJson(
    List<enums.AuthorizationMethod>? authorizationMethod) {
  if (authorizationMethod == null) {
    return [];
  }

  return authorizationMethod.map((e) => e.value!).toList();
}

List<enums.AuthorizationMethod> authorizationMethodListFromJson(
  List? authorizationMethod, [
  List<enums.AuthorizationMethod>? defaultValue,
]) {
  if (authorizationMethod == null) {
    return defaultValue ?? [];
  }

  return authorizationMethod
      .map((e) => authorizationMethodFromJson(e.toString()))
      .toList();
}

List<enums.AuthorizationMethod>? authorizationMethodNullableListFromJson(
  List? authorizationMethod, [
  List<enums.AuthorizationMethod>? defaultValue,
]) {
  if (authorizationMethod == null) {
    return defaultValue;
  }

  return authorizationMethod
      .map((e) => authorizationMethodFromJson(e.toString()))
      .toList();
}

String? banReasonTypeNullableToJson(enums.BanReasonType? banReasonType) {
  return banReasonType?.value;
}

String? banReasonTypeToJson(enums.BanReasonType banReasonType) {
  return banReasonType.value;
}

enums.BanReasonType banReasonTypeFromJson(
  Object? banReasonType, [
  enums.BanReasonType? defaultValue,
]) {
  return enums.BanReasonType.values
          .firstWhereOrNull((e) => e.value == banReasonType) ??
      defaultValue ??
      enums.BanReasonType.swaggerGeneratedUnknown;
}

enums.BanReasonType? banReasonTypeNullableFromJson(
  Object? banReasonType, [
  enums.BanReasonType? defaultValue,
]) {
  if (banReasonType == null) {
    return null;
  }
  return enums.BanReasonType.values
          .firstWhereOrNull((e) => e.value == banReasonType) ??
      defaultValue;
}

String banReasonTypeExplodedListToJson(
    List<enums.BanReasonType>? banReasonType) {
  return banReasonType?.map((e) => e.value!).join(',') ?? '';
}

List<String> banReasonTypeListToJson(List<enums.BanReasonType>? banReasonType) {
  if (banReasonType == null) {
    return [];
  }

  return banReasonType.map((e) => e.value!).toList();
}

List<enums.BanReasonType> banReasonTypeListFromJson(
  List? banReasonType, [
  List<enums.BanReasonType>? defaultValue,
]) {
  if (banReasonType == null) {
    return defaultValue ?? [];
  }

  return banReasonType.map((e) => banReasonTypeFromJson(e.toString())).toList();
}

List<enums.BanReasonType>? banReasonTypeNullableListFromJson(
  List? banReasonType, [
  List<enums.BanReasonType>? defaultValue,
]) {
  if (banReasonType == null) {
    return defaultValue;
  }

  return banReasonType.map((e) => banReasonTypeFromJson(e.toString())).toList();
}

String? batchCallRecipientStatusNullableToJson(
    enums.BatchCallRecipientStatus? batchCallRecipientStatus) {
  return batchCallRecipientStatus?.value;
}

String? batchCallRecipientStatusToJson(
    enums.BatchCallRecipientStatus batchCallRecipientStatus) {
  return batchCallRecipientStatus.value;
}

enums.BatchCallRecipientStatus batchCallRecipientStatusFromJson(
  Object? batchCallRecipientStatus, [
  enums.BatchCallRecipientStatus? defaultValue,
]) {
  return enums.BatchCallRecipientStatus.values
          .firstWhereOrNull((e) => e.value == batchCallRecipientStatus) ??
      defaultValue ??
      enums.BatchCallRecipientStatus.swaggerGeneratedUnknown;
}

enums.BatchCallRecipientStatus? batchCallRecipientStatusNullableFromJson(
  Object? batchCallRecipientStatus, [
  enums.BatchCallRecipientStatus? defaultValue,
]) {
  if (batchCallRecipientStatus == null) {
    return null;
  }
  return enums.BatchCallRecipientStatus.values
          .firstWhereOrNull((e) => e.value == batchCallRecipientStatus) ??
      defaultValue;
}

String batchCallRecipientStatusExplodedListToJson(
    List<enums.BatchCallRecipientStatus>? batchCallRecipientStatus) {
  return batchCallRecipientStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> batchCallRecipientStatusListToJson(
    List<enums.BatchCallRecipientStatus>? batchCallRecipientStatus) {
  if (batchCallRecipientStatus == null) {
    return [];
  }

  return batchCallRecipientStatus.map((e) => e.value!).toList();
}

List<enums.BatchCallRecipientStatus> batchCallRecipientStatusListFromJson(
  List? batchCallRecipientStatus, [
  List<enums.BatchCallRecipientStatus>? defaultValue,
]) {
  if (batchCallRecipientStatus == null) {
    return defaultValue ?? [];
  }

  return batchCallRecipientStatus
      .map((e) => batchCallRecipientStatusFromJson(e.toString()))
      .toList();
}

List<enums.BatchCallRecipientStatus>?
    batchCallRecipientStatusNullableListFromJson(
  List? batchCallRecipientStatus, [
  List<enums.BatchCallRecipientStatus>? defaultValue,
]) {
  if (batchCallRecipientStatus == null) {
    return defaultValue;
  }

  return batchCallRecipientStatus
      .map((e) => batchCallRecipientStatusFromJson(e.toString()))
      .toList();
}

String? batchCallStatusNullableToJson(enums.BatchCallStatus? batchCallStatus) {
  return batchCallStatus?.value;
}

String? batchCallStatusToJson(enums.BatchCallStatus batchCallStatus) {
  return batchCallStatus.value;
}

enums.BatchCallStatus batchCallStatusFromJson(
  Object? batchCallStatus, [
  enums.BatchCallStatus? defaultValue,
]) {
  return enums.BatchCallStatus.values
          .firstWhereOrNull((e) => e.value == batchCallStatus) ??
      defaultValue ??
      enums.BatchCallStatus.swaggerGeneratedUnknown;
}

enums.BatchCallStatus? batchCallStatusNullableFromJson(
  Object? batchCallStatus, [
  enums.BatchCallStatus? defaultValue,
]) {
  if (batchCallStatus == null) {
    return null;
  }
  return enums.BatchCallStatus.values
          .firstWhereOrNull((e) => e.value == batchCallStatus) ??
      defaultValue;
}

String batchCallStatusExplodedListToJson(
    List<enums.BatchCallStatus>? batchCallStatus) {
  return batchCallStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> batchCallStatusListToJson(
    List<enums.BatchCallStatus>? batchCallStatus) {
  if (batchCallStatus == null) {
    return [];
  }

  return batchCallStatus.map((e) => e.value!).toList();
}

List<enums.BatchCallStatus> batchCallStatusListFromJson(
  List? batchCallStatus, [
  List<enums.BatchCallStatus>? defaultValue,
]) {
  if (batchCallStatus == null) {
    return defaultValue ?? [];
  }

  return batchCallStatus
      .map((e) => batchCallStatusFromJson(e.toString()))
      .toList();
}

List<enums.BatchCallStatus>? batchCallStatusNullableListFromJson(
  List? batchCallStatus, [
  List<enums.BatchCallStatus>? defaultValue,
]) {
  if (batchCallStatus == null) {
    return defaultValue;
  }

  return batchCallStatus
      .map((e) => batchCallStatusFromJson(e.toString()))
      .toList();
}

String? bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPresetNullableToJson(
    enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset?
        bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset) {
  return bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset?.value;
}

String? bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPresetToJson(
    enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset
        bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset) {
  return bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset.value;
}

enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset
    bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPresetFromJson(
  Object? bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset, [
  enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset? defaultValue,
]) {
  return enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset.values
          .firstWhereOrNull((e) =>
              e.value ==
              bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset) ??
      defaultValue ??
      enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset
          .swaggerGeneratedUnknown;
}

enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset?
    bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPresetNullableFromJson(
  Object? bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset, [
  enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset? defaultValue,
]) {
  if (bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset == null) {
    return null;
  }
  return enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset.values
          .firstWhereOrNull((e) =>
              e.value ==
              bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset) ??
      defaultValue;
}

String
    bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPresetExplodedListToJson(
        List<enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset>?
            bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset) {
  return bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String>
    bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPresetListToJson(
        List<enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset>?
            bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset) {
  if (bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset == null) {
    return [];
  }

  return bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset
      .map((e) => e.value!)
      .toList();
}

List<enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset>
    bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPresetListFromJson(
  List? bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset, [
  List<enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset>?
      defaultValue,
]) {
  if (bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset == null) {
    return defaultValue ?? [];
  }

  return bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset
      .map((e) =>
          bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPresetFromJson(
              e.toString()))
      .toList();
}

List<enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset>?
    bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPresetNullableListFromJson(
  List? bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset, [
  List<enums.BodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset>?
      defaultValue,
]) {
  if (bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset == null) {
    return defaultValue;
  }

  return bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPreset
      .map((e) =>
          bodyCreatePodcastV1ProjectsPodcastCreatePostQualityPresetFromJson(
              e.toString()))
      .toList();
}

String? bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScaleNullableToJson(
    enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale?
        bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale) {
  return bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale?.value;
}

String? bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScaleToJson(
    enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale
        bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale) {
  return bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale.value;
}

enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale
    bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScaleFromJson(
  Object? bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale, [
  enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale? defaultValue,
]) {
  return enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale.values
          .firstWhereOrNull((e) =>
              e.value ==
              bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale) ??
      defaultValue ??
      enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale
          .swaggerGeneratedUnknown;
}

enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale?
    bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScaleNullableFromJson(
  Object? bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale, [
  enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale? defaultValue,
]) {
  if (bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale == null) {
    return null;
  }
  return enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale.values
          .firstWhereOrNull((e) =>
              e.value ==
              bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale) ??
      defaultValue;
}

String
    bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScaleExplodedListToJson(
        List<enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale>?
            bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale) {
  return bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String>
    bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScaleListToJson(
        List<enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale>?
            bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale) {
  if (bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale == null) {
    return [];
  }

  return bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale
      .map((e) => e.value!)
      .toList();
}

List<enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale>
    bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScaleListFromJson(
  List? bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale, [
  List<enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale>?
      defaultValue,
]) {
  if (bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale == null) {
    return defaultValue ?? [];
  }

  return bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale
      .map((e) =>
          bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScaleFromJson(
              e.toString()))
      .toList();
}

List<enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale>?
    bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScaleNullableListFromJson(
  List? bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale, [
  List<enums.BodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale>?
      defaultValue,
]) {
  if (bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale == null) {
    return defaultValue;
  }

  return bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScale
      .map((e) =>
          bodyCreatePodcastV1ProjectsPodcastCreatePostDurationScaleFromJson(
              e.toString()))
      .toList();
}

String? bodyCreatePodcastV1StudioPodcastsPostQualityPresetNullableToJson(
    enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset?
        bodyCreatePodcastV1StudioPodcastsPostQualityPreset) {
  return bodyCreatePodcastV1StudioPodcastsPostQualityPreset?.value;
}

String? bodyCreatePodcastV1StudioPodcastsPostQualityPresetToJson(
    enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset
        bodyCreatePodcastV1StudioPodcastsPostQualityPreset) {
  return bodyCreatePodcastV1StudioPodcastsPostQualityPreset.value;
}

enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset
    bodyCreatePodcastV1StudioPodcastsPostQualityPresetFromJson(
  Object? bodyCreatePodcastV1StudioPodcastsPostQualityPreset, [
  enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset? defaultValue,
]) {
  return enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset.values
          .firstWhereOrNull((e) =>
              e.value == bodyCreatePodcastV1StudioPodcastsPostQualityPreset) ??
      defaultValue ??
      enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset
          .swaggerGeneratedUnknown;
}

enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset?
    bodyCreatePodcastV1StudioPodcastsPostQualityPresetNullableFromJson(
  Object? bodyCreatePodcastV1StudioPodcastsPostQualityPreset, [
  enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset? defaultValue,
]) {
  if (bodyCreatePodcastV1StudioPodcastsPostQualityPreset == null) {
    return null;
  }
  return enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset.values
          .firstWhereOrNull((e) =>
              e.value == bodyCreatePodcastV1StudioPodcastsPostQualityPreset) ??
      defaultValue;
}

String bodyCreatePodcastV1StudioPodcastsPostQualityPresetExplodedListToJson(
    List<enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset>?
        bodyCreatePodcastV1StudioPodcastsPostQualityPreset) {
  return bodyCreatePodcastV1StudioPodcastsPostQualityPreset
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> bodyCreatePodcastV1StudioPodcastsPostQualityPresetListToJson(
    List<enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset>?
        bodyCreatePodcastV1StudioPodcastsPostQualityPreset) {
  if (bodyCreatePodcastV1StudioPodcastsPostQualityPreset == null) {
    return [];
  }

  return bodyCreatePodcastV1StudioPodcastsPostQualityPreset
      .map((e) => e.value!)
      .toList();
}

List<enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset>
    bodyCreatePodcastV1StudioPodcastsPostQualityPresetListFromJson(
  List? bodyCreatePodcastV1StudioPodcastsPostQualityPreset, [
  List<enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset>? defaultValue,
]) {
  if (bodyCreatePodcastV1StudioPodcastsPostQualityPreset == null) {
    return defaultValue ?? [];
  }

  return bodyCreatePodcastV1StudioPodcastsPostQualityPreset
      .map((e) => bodyCreatePodcastV1StudioPodcastsPostQualityPresetFromJson(
          e.toString()))
      .toList();
}

List<enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset>?
    bodyCreatePodcastV1StudioPodcastsPostQualityPresetNullableListFromJson(
  List? bodyCreatePodcastV1StudioPodcastsPostQualityPreset, [
  List<enums.BodyCreatePodcastV1StudioPodcastsPostQualityPreset>? defaultValue,
]) {
  if (bodyCreatePodcastV1StudioPodcastsPostQualityPreset == null) {
    return defaultValue;
  }

  return bodyCreatePodcastV1StudioPodcastsPostQualityPreset
      .map((e) => bodyCreatePodcastV1StudioPodcastsPostQualityPresetFromJson(
          e.toString()))
      .toList();
}

String? bodyCreatePodcastV1StudioPodcastsPostDurationScaleNullableToJson(
    enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale?
        bodyCreatePodcastV1StudioPodcastsPostDurationScale) {
  return bodyCreatePodcastV1StudioPodcastsPostDurationScale?.value;
}

String? bodyCreatePodcastV1StudioPodcastsPostDurationScaleToJson(
    enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale
        bodyCreatePodcastV1StudioPodcastsPostDurationScale) {
  return bodyCreatePodcastV1StudioPodcastsPostDurationScale.value;
}

enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale
    bodyCreatePodcastV1StudioPodcastsPostDurationScaleFromJson(
  Object? bodyCreatePodcastV1StudioPodcastsPostDurationScale, [
  enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale? defaultValue,
]) {
  return enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale.values
          .firstWhereOrNull((e) =>
              e.value == bodyCreatePodcastV1StudioPodcastsPostDurationScale) ??
      defaultValue ??
      enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale
          .swaggerGeneratedUnknown;
}

enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale?
    bodyCreatePodcastV1StudioPodcastsPostDurationScaleNullableFromJson(
  Object? bodyCreatePodcastV1StudioPodcastsPostDurationScale, [
  enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale? defaultValue,
]) {
  if (bodyCreatePodcastV1StudioPodcastsPostDurationScale == null) {
    return null;
  }
  return enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale.values
          .firstWhereOrNull((e) =>
              e.value == bodyCreatePodcastV1StudioPodcastsPostDurationScale) ??
      defaultValue;
}

String bodyCreatePodcastV1StudioPodcastsPostDurationScaleExplodedListToJson(
    List<enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale>?
        bodyCreatePodcastV1StudioPodcastsPostDurationScale) {
  return bodyCreatePodcastV1StudioPodcastsPostDurationScale
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> bodyCreatePodcastV1StudioPodcastsPostDurationScaleListToJson(
    List<enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale>?
        bodyCreatePodcastV1StudioPodcastsPostDurationScale) {
  if (bodyCreatePodcastV1StudioPodcastsPostDurationScale == null) {
    return [];
  }

  return bodyCreatePodcastV1StudioPodcastsPostDurationScale
      .map((e) => e.value!)
      .toList();
}

List<enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale>
    bodyCreatePodcastV1StudioPodcastsPostDurationScaleListFromJson(
  List? bodyCreatePodcastV1StudioPodcastsPostDurationScale, [
  List<enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale>? defaultValue,
]) {
  if (bodyCreatePodcastV1StudioPodcastsPostDurationScale == null) {
    return defaultValue ?? [];
  }

  return bodyCreatePodcastV1StudioPodcastsPostDurationScale
      .map((e) => bodyCreatePodcastV1StudioPodcastsPostDurationScaleFromJson(
          e.toString()))
      .toList();
}

List<enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale>?
    bodyCreatePodcastV1StudioPodcastsPostDurationScaleNullableListFromJson(
  List? bodyCreatePodcastV1StudioPodcastsPostDurationScale, [
  List<enums.BodyCreatePodcastV1StudioPodcastsPostDurationScale>? defaultValue,
]) {
  if (bodyCreatePodcastV1StudioPodcastsPostDurationScale == null) {
    return defaultValue;
  }

  return bodyCreatePodcastV1StudioPodcastsPostDurationScale
      .map((e) => bodyCreatePodcastV1StudioPodcastsPostDurationScaleFromJson(
          e.toString()))
      .toList();
}

String?
    bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGenderNullableToJson(
        enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender?
            bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender) {
  return bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender
      ?.value;
}

String? bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGenderToJson(
    enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender
        bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender) {
  return bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender.value;
}

enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender
    bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGenderFromJson(
  Object? bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender, [
  enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender?
      defaultValue,
]) {
  return enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender) ??
      defaultValue ??
      enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender
          .swaggerGeneratedUnknown;
}

enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender?
    bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGenderNullableFromJson(
  Object? bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender, [
  enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender?
      defaultValue,
]) {
  if (bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender ==
      null) {
    return null;
  }
  return enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender) ??
      defaultValue;
}

String bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGenderExplodedListToJson(
    List<
            enums
            .BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender>?
        bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender) {
  return bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String>
    bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGenderListToJson(
        List<
                enums
                .BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender>?
            bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender) {
  if (bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender ==
      null) {
    return [];
  }

  return bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender
      .map((e) => e.value!)
      .toList();
}

List<enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender>
    bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGenderListFromJson(
  List? bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender, [
  List<enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender>?
      defaultValue,
]) {
  if (bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender ==
      null) {
    return defaultValue ?? [];
  }

  return bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender
      .map((e) =>
          bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGenderFromJson(
              e.toString()))
      .toList();
}

List<enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender>?
    bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGenderNullableListFromJson(
  List? bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender, [
  List<enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender>?
      defaultValue,
]) {
  if (bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender ==
      null) {
    return defaultValue;
  }

  return bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGender
      .map((e) =>
          bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostGenderFromJson(
              e.toString()))
      .toList();
}

String?
    bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAgeNullableToJson(
        enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge?
            bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge) {
  return bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge?.value;
}

String? bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAgeToJson(
    enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge
        bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge) {
  return bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge.value;
}

enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge
    bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAgeFromJson(
  Object? bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge, [
  enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge?
      defaultValue,
]) {
  return enums
          .BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge.values
          .firstWhereOrNull((e) =>
              e.value ==
              bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge) ??
      defaultValue ??
      enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge
          .swaggerGeneratedUnknown;
}

enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge?
    bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAgeNullableFromJson(
  Object? bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge, [
  enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge?
      defaultValue,
]) {
  if (bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge == null) {
    return null;
  }
  return enums
          .BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge.values
          .firstWhereOrNull((e) =>
              e.value ==
              bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge) ??
      defaultValue;
}

String
    bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAgeExplodedListToJson(
        List<
                enums
                .BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge>?
            bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge) {
  return bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String>
    bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAgeListToJson(
        List<
                enums
                .BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge>?
            bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge) {
  if (bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge == null) {
    return [];
  }

  return bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge
      .map((e) => e.value!)
      .toList();
}

List<enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge>
    bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAgeListFromJson(
  List? bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge, [
  List<enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge>?
      defaultValue,
]) {
  if (bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge == null) {
    return defaultValue ?? [];
  }

  return bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge
      .map((e) =>
          bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAgeFromJson(
              e.toString()))
      .toList();
}

List<enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge>?
    bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAgeNullableListFromJson(
  List? bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge, [
  List<enums.BodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge>?
      defaultValue,
]) {
  if (bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge == null) {
    return defaultValue;
  }

  return bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAge
      .map((e) =>
          bodyGenerateARandomVoiceV1VoiceGenerationGenerateVoicePostAgeFromJson(
              e.toString()))
      .toList();
}

String? bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRoleNullableToJson(
    enums.BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole?
        bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole) {
  return bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole
      ?.value;
}

String? bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRoleToJson(
    enums.BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole
        bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole) {
  return bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole
      .value;
}

enums.BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole
    bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRoleFromJson(
  Object?
      bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole, [
  enums.BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole?
      defaultValue,
]) {
  return enums
          .BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole) ??
      defaultValue ??
      enums
          .BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole
          .swaggerGeneratedUnknown;
}

enums.BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole?
    bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRoleNullableFromJson(
  Object?
      bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole, [
  enums.BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole?
      defaultValue,
]) {
  if (bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole ==
      null) {
    return null;
  }
  return enums
          .BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole) ??
      defaultValue;
}

String bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRoleExplodedListToJson(
    List<
            enums
            .BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole>?
        bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole) {
  return bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String>
    bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRoleListToJson(
        List<
                enums
                .BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole>?
            bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole) {
  if (bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole ==
      null) {
    return [];
  }

  return bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole
      .map((e) => e.value!)
      .toList();
}

List<
        enums
        .BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole>
    bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRoleListFromJson(
  List? bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole, [
  List<
          enums
          .BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole>?
      defaultValue,
]) {
  if (bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole ==
      null) {
    return defaultValue ?? [];
  }

  return bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole
      .map((e) =>
          bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRoleFromJson(
              e.toString()))
      .toList();
}

List<
        enums
        .BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole>?
    bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRoleNullableListFromJson(
  List? bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole, [
  List<
          enums
          .BodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole>?
      defaultValue,
]) {
  if (bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole ==
      null) {
    return defaultValue;
  }

  return bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRole
      .map((e) =>
          bodyShareWorkspaceResourceV1WorkspaceResourcesResourceIdSharePostRoleFromJson(
              e.toString()))
      .toList();
}

String? bodySpeechToTextV1SpeechToTextPostTimestampsGranularityNullableToJson(
    enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity?
        bodySpeechToTextV1SpeechToTextPostTimestampsGranularity) {
  return bodySpeechToTextV1SpeechToTextPostTimestampsGranularity?.value;
}

String? bodySpeechToTextV1SpeechToTextPostTimestampsGranularityToJson(
    enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity
        bodySpeechToTextV1SpeechToTextPostTimestampsGranularity) {
  return bodySpeechToTextV1SpeechToTextPostTimestampsGranularity.value;
}

enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity
    bodySpeechToTextV1SpeechToTextPostTimestampsGranularityFromJson(
  Object? bodySpeechToTextV1SpeechToTextPostTimestampsGranularity, [
  enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity? defaultValue,
]) {
  return enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity.values
          .firstWhereOrNull((e) =>
              e.value ==
              bodySpeechToTextV1SpeechToTextPostTimestampsGranularity) ??
      defaultValue ??
      enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity
          .swaggerGeneratedUnknown;
}

enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity?
    bodySpeechToTextV1SpeechToTextPostTimestampsGranularityNullableFromJson(
  Object? bodySpeechToTextV1SpeechToTextPostTimestampsGranularity, [
  enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity? defaultValue,
]) {
  if (bodySpeechToTextV1SpeechToTextPostTimestampsGranularity == null) {
    return null;
  }
  return enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity.values
          .firstWhereOrNull((e) =>
              e.value ==
              bodySpeechToTextV1SpeechToTextPostTimestampsGranularity) ??
      defaultValue;
}

String
    bodySpeechToTextV1SpeechToTextPostTimestampsGranularityExplodedListToJson(
        List<enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity>?
            bodySpeechToTextV1SpeechToTextPostTimestampsGranularity) {
  return bodySpeechToTextV1SpeechToTextPostTimestampsGranularity
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> bodySpeechToTextV1SpeechToTextPostTimestampsGranularityListToJson(
    List<enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity>?
        bodySpeechToTextV1SpeechToTextPostTimestampsGranularity) {
  if (bodySpeechToTextV1SpeechToTextPostTimestampsGranularity == null) {
    return [];
  }

  return bodySpeechToTextV1SpeechToTextPostTimestampsGranularity
      .map((e) => e.value!)
      .toList();
}

List<enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity>
    bodySpeechToTextV1SpeechToTextPostTimestampsGranularityListFromJson(
  List? bodySpeechToTextV1SpeechToTextPostTimestampsGranularity, [
  List<enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity>?
      defaultValue,
]) {
  if (bodySpeechToTextV1SpeechToTextPostTimestampsGranularity == null) {
    return defaultValue ?? [];
  }

  return bodySpeechToTextV1SpeechToTextPostTimestampsGranularity
      .map((e) =>
          bodySpeechToTextV1SpeechToTextPostTimestampsGranularityFromJson(
              e.toString()))
      .toList();
}

List<enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity>?
    bodySpeechToTextV1SpeechToTextPostTimestampsGranularityNullableListFromJson(
  List? bodySpeechToTextV1SpeechToTextPostTimestampsGranularity, [
  List<enums.BodySpeechToTextV1SpeechToTextPostTimestampsGranularity>?
      defaultValue,
]) {
  if (bodySpeechToTextV1SpeechToTextPostTimestampsGranularity == null) {
    return defaultValue;
  }

  return bodySpeechToTextV1SpeechToTextPostTimestampsGranularity
      .map((e) =>
          bodySpeechToTextV1SpeechToTextPostTimestampsGranularityFromJson(
              e.toString()))
      .toList();
}

String? bodySpeechToTextV1SpeechToTextPostFileFormatNullableToJson(
    enums.BodySpeechToTextV1SpeechToTextPostFileFormat?
        bodySpeechToTextV1SpeechToTextPostFileFormat) {
  return bodySpeechToTextV1SpeechToTextPostFileFormat?.value;
}

String? bodySpeechToTextV1SpeechToTextPostFileFormatToJson(
    enums.BodySpeechToTextV1SpeechToTextPostFileFormat
        bodySpeechToTextV1SpeechToTextPostFileFormat) {
  return bodySpeechToTextV1SpeechToTextPostFileFormat.value;
}

enums.BodySpeechToTextV1SpeechToTextPostFileFormat
    bodySpeechToTextV1SpeechToTextPostFileFormatFromJson(
  Object? bodySpeechToTextV1SpeechToTextPostFileFormat, [
  enums.BodySpeechToTextV1SpeechToTextPostFileFormat? defaultValue,
]) {
  return enums.BodySpeechToTextV1SpeechToTextPostFileFormat.values
          .firstWhereOrNull(
              (e) => e.value == bodySpeechToTextV1SpeechToTextPostFileFormat) ??
      defaultValue ??
      enums
          .BodySpeechToTextV1SpeechToTextPostFileFormat.swaggerGeneratedUnknown;
}

enums.BodySpeechToTextV1SpeechToTextPostFileFormat?
    bodySpeechToTextV1SpeechToTextPostFileFormatNullableFromJson(
  Object? bodySpeechToTextV1SpeechToTextPostFileFormat, [
  enums.BodySpeechToTextV1SpeechToTextPostFileFormat? defaultValue,
]) {
  if (bodySpeechToTextV1SpeechToTextPostFileFormat == null) {
    return null;
  }
  return enums.BodySpeechToTextV1SpeechToTextPostFileFormat.values
          .firstWhereOrNull(
              (e) => e.value == bodySpeechToTextV1SpeechToTextPostFileFormat) ??
      defaultValue;
}

String bodySpeechToTextV1SpeechToTextPostFileFormatExplodedListToJson(
    List<enums.BodySpeechToTextV1SpeechToTextPostFileFormat>?
        bodySpeechToTextV1SpeechToTextPostFileFormat) {
  return bodySpeechToTextV1SpeechToTextPostFileFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> bodySpeechToTextV1SpeechToTextPostFileFormatListToJson(
    List<enums.BodySpeechToTextV1SpeechToTextPostFileFormat>?
        bodySpeechToTextV1SpeechToTextPostFileFormat) {
  if (bodySpeechToTextV1SpeechToTextPostFileFormat == null) {
    return [];
  }

  return bodySpeechToTextV1SpeechToTextPostFileFormat
      .map((e) => e.value!)
      .toList();
}

List<enums.BodySpeechToTextV1SpeechToTextPostFileFormat>
    bodySpeechToTextV1SpeechToTextPostFileFormatListFromJson(
  List? bodySpeechToTextV1SpeechToTextPostFileFormat, [
  List<enums.BodySpeechToTextV1SpeechToTextPostFileFormat>? defaultValue,
]) {
  if (bodySpeechToTextV1SpeechToTextPostFileFormat == null) {
    return defaultValue ?? [];
  }

  return bodySpeechToTextV1SpeechToTextPostFileFormat
      .map((e) =>
          bodySpeechToTextV1SpeechToTextPostFileFormatFromJson(e.toString()))
      .toList();
}

List<enums.BodySpeechToTextV1SpeechToTextPostFileFormat>?
    bodySpeechToTextV1SpeechToTextPostFileFormatNullableListFromJson(
  List? bodySpeechToTextV1SpeechToTextPostFileFormat, [
  List<enums.BodySpeechToTextV1SpeechToTextPostFileFormat>? defaultValue,
]) {
  if (bodySpeechToTextV1SpeechToTextPostFileFormat == null) {
    return defaultValue;
  }

  return bodySpeechToTextV1SpeechToTextPostFileFormat
      .map((e) =>
          bodySpeechToTextV1SpeechToTextPostFileFormatFromJson(e.toString()))
      .toList();
}

String? bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalizationNullableToJson(
    enums
        .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization?
        bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization) {
  return bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization
      ?.value;
}

String? bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalizationToJson(
    enums
        .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization
        bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization) {
  return bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization
      .value;
}

enums
    .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization
    bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalizationFromJson(
  Object?
      bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization, [
  enums
      .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization?
      defaultValue,
]) {
  return enums
          .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization) ??
      defaultValue ??
      enums
          .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization
          .swaggerGeneratedUnknown;
}

enums
    .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization?
    bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalizationNullableFromJson(
  Object?
      bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization, [
  enums
      .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization?
      defaultValue,
]) {
  if (bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization ==
      null) {
    return null;
  }
  return enums
          .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization) ??
      defaultValue;
}

String bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalizationExplodedListToJson(
    List<
            enums
            .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization>?
        bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization) {
  return bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String>
    bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalizationListToJson(
        List<
                enums
                .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization>?
            bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization) {
  if (bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization ==
      null) {
    return [];
  }

  return bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization
      .map((e) => e.value!)
      .toList();
}

List<
        enums
        .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization>
    bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalizationListFromJson(
  List?
      bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization, [
  List<
          enums
          .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization>?
      defaultValue,
]) {
  if (bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization ==
      null) {
    return defaultValue ?? [];
  }

  return bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization
      .map((e) =>
          bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalizationFromJson(
              e.toString()))
      .toList();
}

List<
        enums
        .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization>?
    bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalizationNullableListFromJson(
  List?
      bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization, [
  List<
          enums
          .BodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization>?
      defaultValue,
]) {
  if (bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization ==
      null) {
    return defaultValue;
  }

  return bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalization
      .map((e) =>
          bodyTextToSpeechStreamingV1TextToSpeechVoiceIdStreamPostApplyTextNormalizationFromJson(
              e.toString()))
      .toList();
}

String? bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalizationNullableToJson(
    enums
        .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization?
        bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization) {
  return bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization
      ?.value;
}

String? bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalizationToJson(
    enums
        .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization
        bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization) {
  return bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization
      .value;
}

enums
    .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization
    bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalizationFromJson(
  Object?
      bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization, [
  enums
      .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization?
      defaultValue,
]) {
  return enums
          .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization) ??
      defaultValue ??
      enums
          .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization
          .swaggerGeneratedUnknown;
}

enums
    .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization?
    bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalizationNullableFromJson(
  Object?
      bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization, [
  enums
      .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization?
      defaultValue,
]) {
  if (bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization ==
      null) {
    return null;
  }
  return enums
          .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization) ??
      defaultValue;
}

String bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalizationExplodedListToJson(
    List<
            enums
            .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization>?
        bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization) {
  return bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String>
    bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalizationListToJson(
        List<
                enums
                .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization>?
            bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization) {
  if (bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization ==
      null) {
    return [];
  }

  return bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization
      .map((e) => e.value!)
      .toList();
}

List<
        enums
        .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization>
    bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalizationListFromJson(
  List?
      bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization, [
  List<
          enums
          .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization>?
      defaultValue,
]) {
  if (bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization ==
      null) {
    return defaultValue ?? [];
  }

  return bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization
      .map((e) =>
          bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalizationFromJson(
              e.toString()))
      .toList();
}

List<
        enums
        .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization>?
    bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalizationNullableListFromJson(
  List?
      bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization, [
  List<
          enums
          .BodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization>?
      defaultValue,
]) {
  if (bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization ==
      null) {
    return defaultValue;
  }

  return bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalization
      .map((e) =>
          bodyTextToSpeechStreamingWithTimestampsV1TextToSpeechVoiceIdStreamWithTimestampsPostApplyTextNormalizationFromJson(
              e.toString()))
      .toList();
}

String?
    bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalizationNullableToJson(
        enums.BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization?
            bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization) {
  return bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization?.value;
}

String? bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalizationToJson(
    enums.BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization
        bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization) {
  return bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization.value;
}

enums.BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization
    bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalizationFromJson(
  Object? bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization, [
  enums.BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization?
      defaultValue,
]) {
  return enums.BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization) ??
      defaultValue ??
      enums.BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization
          .swaggerGeneratedUnknown;
}

enums.BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization?
    bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalizationNullableFromJson(
  Object? bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization, [
  enums.BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization?
      defaultValue,
]) {
  if (bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization == null) {
    return null;
  }
  return enums.BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization) ??
      defaultValue;
}

String
    bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalizationExplodedListToJson(
        List<
                enums
                .BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization>?
            bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization) {
  return bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String>
    bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalizationListToJson(
        List<
                enums
                .BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization>?
            bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization) {
  if (bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization == null) {
    return [];
  }

  return bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization
      .map((e) => e.value!)
      .toList();
}

List<enums.BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization>
    bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalizationListFromJson(
  List? bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization, [
  List<enums.BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization>?
      defaultValue,
]) {
  if (bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization == null) {
    return defaultValue ?? [];
  }

  return bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization
      .map((e) =>
          bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalizationFromJson(
              e.toString()))
      .toList();
}

List<enums.BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization>?
    bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalizationNullableListFromJson(
  List? bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization, [
  List<enums.BodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization>?
      defaultValue,
]) {
  if (bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization == null) {
    return defaultValue;
  }

  return bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalization
      .map((e) =>
          bodyTextToSpeechV1TextToSpeechVoiceIdPostApplyTextNormalizationFromJson(
              e.toString()))
      .toList();
}

String? bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalizationNullableToJson(
    enums
        .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization?
        bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization) {
  return bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization
      ?.value;
}

String? bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalizationToJson(
    enums
        .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization
        bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization) {
  return bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization
      .value;
}

enums
    .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization
    bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalizationFromJson(
  Object?
      bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization, [
  enums
      .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization?
      defaultValue,
]) {
  return enums
          .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization) ??
      defaultValue ??
      enums
          .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization
          .swaggerGeneratedUnknown;
}

enums
    .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization?
    bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalizationNullableFromJson(
  Object?
      bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization, [
  enums
      .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization?
      defaultValue,
]) {
  if (bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization ==
      null) {
    return null;
  }
  return enums
          .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization
          .values
          .firstWhereOrNull((e) =>
              e.value ==
              bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization) ??
      defaultValue;
}

String bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalizationExplodedListToJson(
    List<
            enums
            .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization>?
        bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization) {
  return bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String>
    bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalizationListToJson(
        List<
                enums
                .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization>?
            bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization) {
  if (bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization ==
      null) {
    return [];
  }

  return bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization
      .map((e) => e.value!)
      .toList();
}

List<
        enums
        .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization>
    bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalizationListFromJson(
  List?
      bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization, [
  List<
          enums
          .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization>?
      defaultValue,
]) {
  if (bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization ==
      null) {
    return defaultValue ?? [];
  }

  return bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization
      .map((e) =>
          bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalizationFromJson(
              e.toString()))
      .toList();
}

List<
        enums
        .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization>?
    bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalizationNullableListFromJson(
  List?
      bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization, [
  List<
          enums
          .BodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization>?
      defaultValue,
]) {
  if (bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization ==
      null) {
    return defaultValue;
  }

  return bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalization
      .map((e) =>
          bodyTextToSpeechWithTimestampsV1TextToSpeechVoiceIdWithTimestampsPostApplyTextNormalizationFromJson(
              e.toString()))
      .toList();
}

String? breakdownTypesNullableToJson(enums.BreakdownTypes? breakdownTypes) {
  return breakdownTypes?.value;
}

String? breakdownTypesToJson(enums.BreakdownTypes breakdownTypes) {
  return breakdownTypes.value;
}

enums.BreakdownTypes breakdownTypesFromJson(
  Object? breakdownTypes, [
  enums.BreakdownTypes? defaultValue,
]) {
  return enums.BreakdownTypes.values
          .firstWhereOrNull((e) => e.value == breakdownTypes) ??
      defaultValue ??
      enums.BreakdownTypes.swaggerGeneratedUnknown;
}

enums.BreakdownTypes? breakdownTypesNullableFromJson(
  Object? breakdownTypes, [
  enums.BreakdownTypes? defaultValue,
]) {
  if (breakdownTypes == null) {
    return null;
  }
  return enums.BreakdownTypes.values
          .firstWhereOrNull((e) => e.value == breakdownTypes) ??
      defaultValue;
}

String breakdownTypesExplodedListToJson(
    List<enums.BreakdownTypes>? breakdownTypes) {
  return breakdownTypes?.map((e) => e.value!).join(',') ?? '';
}

List<String> breakdownTypesListToJson(
    List<enums.BreakdownTypes>? breakdownTypes) {
  if (breakdownTypes == null) {
    return [];
  }

  return breakdownTypes.map((e) => e.value!).toList();
}

List<enums.BreakdownTypes> breakdownTypesListFromJson(
  List? breakdownTypes, [
  List<enums.BreakdownTypes>? defaultValue,
]) {
  if (breakdownTypes == null) {
    return defaultValue ?? [];
  }

  return breakdownTypes
      .map((e) => breakdownTypesFromJson(e.toString()))
      .toList();
}

List<enums.BreakdownTypes>? breakdownTypesNullableListFromJson(
  List? breakdownTypes, [
  List<enums.BreakdownTypes>? defaultValue,
]) {
  if (breakdownTypes == null) {
    return defaultValue;
  }

  return breakdownTypes
      .map((e) => breakdownTypesFromJson(e.toString()))
      .toList();
}

String? chapterResponseModelStateNullableToJson(
    enums.ChapterResponseModelState? chapterResponseModelState) {
  return chapterResponseModelState?.value;
}

String? chapterResponseModelStateToJson(
    enums.ChapterResponseModelState chapterResponseModelState) {
  return chapterResponseModelState.value;
}

enums.ChapterResponseModelState chapterResponseModelStateFromJson(
  Object? chapterResponseModelState, [
  enums.ChapterResponseModelState? defaultValue,
]) {
  return enums.ChapterResponseModelState.values
          .firstWhereOrNull((e) => e.value == chapterResponseModelState) ??
      defaultValue ??
      enums.ChapterResponseModelState.swaggerGeneratedUnknown;
}

enums.ChapterResponseModelState? chapterResponseModelStateNullableFromJson(
  Object? chapterResponseModelState, [
  enums.ChapterResponseModelState? defaultValue,
]) {
  if (chapterResponseModelState == null) {
    return null;
  }
  return enums.ChapterResponseModelState.values
          .firstWhereOrNull((e) => e.value == chapterResponseModelState) ??
      defaultValue;
}

String chapterResponseModelStateExplodedListToJson(
    List<enums.ChapterResponseModelState>? chapterResponseModelState) {
  return chapterResponseModelState?.map((e) => e.value!).join(',') ?? '';
}

List<String> chapterResponseModelStateListToJson(
    List<enums.ChapterResponseModelState>? chapterResponseModelState) {
  if (chapterResponseModelState == null) {
    return [];
  }

  return chapterResponseModelState.map((e) => e.value!).toList();
}

List<enums.ChapterResponseModelState> chapterResponseModelStateListFromJson(
  List? chapterResponseModelState, [
  List<enums.ChapterResponseModelState>? defaultValue,
]) {
  if (chapterResponseModelState == null) {
    return defaultValue ?? [];
  }

  return chapterResponseModelState
      .map((e) => chapterResponseModelStateFromJson(e.toString()))
      .toList();
}

List<enums.ChapterResponseModelState>?
    chapterResponseModelStateNullableListFromJson(
  List? chapterResponseModelState, [
  List<enums.ChapterResponseModelState>? defaultValue,
]) {
  if (chapterResponseModelState == null) {
    return defaultValue;
  }

  return chapterResponseModelState
      .map((e) => chapterResponseModelStateFromJson(e.toString()))
      .toList();
}

String? chapterWithContentResponseModelStateNullableToJson(
    enums.ChapterWithContentResponseModelState?
        chapterWithContentResponseModelState) {
  return chapterWithContentResponseModelState?.value;
}

String? chapterWithContentResponseModelStateToJson(
    enums.ChapterWithContentResponseModelState
        chapterWithContentResponseModelState) {
  return chapterWithContentResponseModelState.value;
}

enums.ChapterWithContentResponseModelState
    chapterWithContentResponseModelStateFromJson(
  Object? chapterWithContentResponseModelState, [
  enums.ChapterWithContentResponseModelState? defaultValue,
]) {
  return enums.ChapterWithContentResponseModelState.values.firstWhereOrNull(
          (e) => e.value == chapterWithContentResponseModelState) ??
      defaultValue ??
      enums.ChapterWithContentResponseModelState.swaggerGeneratedUnknown;
}

enums.ChapterWithContentResponseModelState?
    chapterWithContentResponseModelStateNullableFromJson(
  Object? chapterWithContentResponseModelState, [
  enums.ChapterWithContentResponseModelState? defaultValue,
]) {
  if (chapterWithContentResponseModelState == null) {
    return null;
  }
  return enums.ChapterWithContentResponseModelState.values.firstWhereOrNull(
          (e) => e.value == chapterWithContentResponseModelState) ??
      defaultValue;
}

String chapterWithContentResponseModelStateExplodedListToJson(
    List<enums.ChapterWithContentResponseModelState>?
        chapterWithContentResponseModelState) {
  return chapterWithContentResponseModelState?.map((e) => e.value!).join(',') ??
      '';
}

List<String> chapterWithContentResponseModelStateListToJson(
    List<enums.ChapterWithContentResponseModelState>?
        chapterWithContentResponseModelState) {
  if (chapterWithContentResponseModelState == null) {
    return [];
  }

  return chapterWithContentResponseModelState.map((e) => e.value!).toList();
}

List<enums.ChapterWithContentResponseModelState>
    chapterWithContentResponseModelStateListFromJson(
  List? chapterWithContentResponseModelState, [
  List<enums.ChapterWithContentResponseModelState>? defaultValue,
]) {
  if (chapterWithContentResponseModelState == null) {
    return defaultValue ?? [];
  }

  return chapterWithContentResponseModelState
      .map((e) => chapterWithContentResponseModelStateFromJson(e.toString()))
      .toList();
}

List<enums.ChapterWithContentResponseModelState>?
    chapterWithContentResponseModelStateNullableListFromJson(
  List? chapterWithContentResponseModelState, [
  List<enums.ChapterWithContentResponseModelState>? defaultValue,
]) {
  if (chapterWithContentResponseModelState == null) {
    return defaultValue;
  }

  return chapterWithContentResponseModelState
      .map((e) => chapterWithContentResponseModelStateFromJson(e.toString()))
      .toList();
}

String? clientEventNullableToJson(enums.ClientEvent? clientEvent) {
  return clientEvent?.value;
}

String? clientEventToJson(enums.ClientEvent clientEvent) {
  return clientEvent.value;
}

enums.ClientEvent clientEventFromJson(
  Object? clientEvent, [
  enums.ClientEvent? defaultValue,
]) {
  return enums.ClientEvent.values
          .firstWhereOrNull((e) => e.value == clientEvent) ??
      defaultValue ??
      enums.ClientEvent.swaggerGeneratedUnknown;
}

enums.ClientEvent? clientEventNullableFromJson(
  Object? clientEvent, [
  enums.ClientEvent? defaultValue,
]) {
  if (clientEvent == null) {
    return null;
  }
  return enums.ClientEvent.values
          .firstWhereOrNull((e) => e.value == clientEvent) ??
      defaultValue;
}

String clientEventExplodedListToJson(List<enums.ClientEvent>? clientEvent) {
  return clientEvent?.map((e) => e.value!).join(',') ?? '';
}

List<String> clientEventListToJson(List<enums.ClientEvent>? clientEvent) {
  if (clientEvent == null) {
    return [];
  }

  return clientEvent.map((e) => e.value!).toList();
}

List<enums.ClientEvent> clientEventListFromJson(
  List? clientEvent, [
  List<enums.ClientEvent>? defaultValue,
]) {
  if (clientEvent == null) {
    return defaultValue ?? [];
  }

  return clientEvent.map((e) => clientEventFromJson(e.toString())).toList();
}

List<enums.ClientEvent>? clientEventNullableListFromJson(
  List? clientEvent, [
  List<enums.ClientEvent>? defaultValue,
]) {
  if (clientEvent == null) {
    return defaultValue;
  }

  return clientEvent.map((e) => clientEventFromJson(e.toString())).toList();
}

String? conversationHistorySIPTrunkingPhoneCallModelDirectionNullableToJson(
    enums.ConversationHistorySIPTrunkingPhoneCallModelDirection?
        conversationHistorySIPTrunkingPhoneCallModelDirection) {
  return conversationHistorySIPTrunkingPhoneCallModelDirection?.value;
}

String? conversationHistorySIPTrunkingPhoneCallModelDirectionToJson(
    enums.ConversationHistorySIPTrunkingPhoneCallModelDirection
        conversationHistorySIPTrunkingPhoneCallModelDirection) {
  return conversationHistorySIPTrunkingPhoneCallModelDirection.value;
}

enums.ConversationHistorySIPTrunkingPhoneCallModelDirection
    conversationHistorySIPTrunkingPhoneCallModelDirectionFromJson(
  Object? conversationHistorySIPTrunkingPhoneCallModelDirection, [
  enums.ConversationHistorySIPTrunkingPhoneCallModelDirection? defaultValue,
]) {
  return enums.ConversationHistorySIPTrunkingPhoneCallModelDirection.values
          .firstWhereOrNull((e) =>
              e.value ==
              conversationHistorySIPTrunkingPhoneCallModelDirection) ??
      defaultValue ??
      enums.ConversationHistorySIPTrunkingPhoneCallModelDirection
          .swaggerGeneratedUnknown;
}

enums.ConversationHistorySIPTrunkingPhoneCallModelDirection?
    conversationHistorySIPTrunkingPhoneCallModelDirectionNullableFromJson(
  Object? conversationHistorySIPTrunkingPhoneCallModelDirection, [
  enums.ConversationHistorySIPTrunkingPhoneCallModelDirection? defaultValue,
]) {
  if (conversationHistorySIPTrunkingPhoneCallModelDirection == null) {
    return null;
  }
  return enums.ConversationHistorySIPTrunkingPhoneCallModelDirection.values
          .firstWhereOrNull((e) =>
              e.value ==
              conversationHistorySIPTrunkingPhoneCallModelDirection) ??
      defaultValue;
}

String conversationHistorySIPTrunkingPhoneCallModelDirectionExplodedListToJson(
    List<enums.ConversationHistorySIPTrunkingPhoneCallModelDirection>?
        conversationHistorySIPTrunkingPhoneCallModelDirection) {
  return conversationHistorySIPTrunkingPhoneCallModelDirection
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> conversationHistorySIPTrunkingPhoneCallModelDirectionListToJson(
    List<enums.ConversationHistorySIPTrunkingPhoneCallModelDirection>?
        conversationHistorySIPTrunkingPhoneCallModelDirection) {
  if (conversationHistorySIPTrunkingPhoneCallModelDirection == null) {
    return [];
  }

  return conversationHistorySIPTrunkingPhoneCallModelDirection
      .map((e) => e.value!)
      .toList();
}

List<enums.ConversationHistorySIPTrunkingPhoneCallModelDirection>
    conversationHistorySIPTrunkingPhoneCallModelDirectionListFromJson(
  List? conversationHistorySIPTrunkingPhoneCallModelDirection, [
  List<enums.ConversationHistorySIPTrunkingPhoneCallModelDirection>?
      defaultValue,
]) {
  if (conversationHistorySIPTrunkingPhoneCallModelDirection == null) {
    return defaultValue ?? [];
  }

  return conversationHistorySIPTrunkingPhoneCallModelDirection
      .map((e) => conversationHistorySIPTrunkingPhoneCallModelDirectionFromJson(
          e.toString()))
      .toList();
}

List<enums.ConversationHistorySIPTrunkingPhoneCallModelDirection>?
    conversationHistorySIPTrunkingPhoneCallModelDirectionNullableListFromJson(
  List? conversationHistorySIPTrunkingPhoneCallModelDirection, [
  List<enums.ConversationHistorySIPTrunkingPhoneCallModelDirection>?
      defaultValue,
]) {
  if (conversationHistorySIPTrunkingPhoneCallModelDirection == null) {
    return defaultValue;
  }

  return conversationHistorySIPTrunkingPhoneCallModelDirection
      .map((e) => conversationHistorySIPTrunkingPhoneCallModelDirectionFromJson(
          e.toString()))
      .toList();
}

String? conversationHistoryTranscriptCommonModelInputRoleNullableToJson(
    enums.ConversationHistoryTranscriptCommonModelInputRole?
        conversationHistoryTranscriptCommonModelInputRole) {
  return conversationHistoryTranscriptCommonModelInputRole?.value;
}

String? conversationHistoryTranscriptCommonModelInputRoleToJson(
    enums.ConversationHistoryTranscriptCommonModelInputRole
        conversationHistoryTranscriptCommonModelInputRole) {
  return conversationHistoryTranscriptCommonModelInputRole.value;
}

enums.ConversationHistoryTranscriptCommonModelInputRole
    conversationHistoryTranscriptCommonModelInputRoleFromJson(
  Object? conversationHistoryTranscriptCommonModelInputRole, [
  enums.ConversationHistoryTranscriptCommonModelInputRole? defaultValue,
]) {
  return enums.ConversationHistoryTranscriptCommonModelInputRole.values
          .firstWhereOrNull((e) =>
              e.value == conversationHistoryTranscriptCommonModelInputRole) ??
      defaultValue ??
      enums.ConversationHistoryTranscriptCommonModelInputRole
          .swaggerGeneratedUnknown;
}

enums.ConversationHistoryTranscriptCommonModelInputRole?
    conversationHistoryTranscriptCommonModelInputRoleNullableFromJson(
  Object? conversationHistoryTranscriptCommonModelInputRole, [
  enums.ConversationHistoryTranscriptCommonModelInputRole? defaultValue,
]) {
  if (conversationHistoryTranscriptCommonModelInputRole == null) {
    return null;
  }
  return enums.ConversationHistoryTranscriptCommonModelInputRole.values
          .firstWhereOrNull((e) =>
              e.value == conversationHistoryTranscriptCommonModelInputRole) ??
      defaultValue;
}

String conversationHistoryTranscriptCommonModelInputRoleExplodedListToJson(
    List<enums.ConversationHistoryTranscriptCommonModelInputRole>?
        conversationHistoryTranscriptCommonModelInputRole) {
  return conversationHistoryTranscriptCommonModelInputRole
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> conversationHistoryTranscriptCommonModelInputRoleListToJson(
    List<enums.ConversationHistoryTranscriptCommonModelInputRole>?
        conversationHistoryTranscriptCommonModelInputRole) {
  if (conversationHistoryTranscriptCommonModelInputRole == null) {
    return [];
  }

  return conversationHistoryTranscriptCommonModelInputRole
      .map((e) => e.value!)
      .toList();
}

List<enums.ConversationHistoryTranscriptCommonModelInputRole>
    conversationHistoryTranscriptCommonModelInputRoleListFromJson(
  List? conversationHistoryTranscriptCommonModelInputRole, [
  List<enums.ConversationHistoryTranscriptCommonModelInputRole>? defaultValue,
]) {
  if (conversationHistoryTranscriptCommonModelInputRole == null) {
    return defaultValue ?? [];
  }

  return conversationHistoryTranscriptCommonModelInputRole
      .map((e) => conversationHistoryTranscriptCommonModelInputRoleFromJson(
          e.toString()))
      .toList();
}

List<enums.ConversationHistoryTranscriptCommonModelInputRole>?
    conversationHistoryTranscriptCommonModelInputRoleNullableListFromJson(
  List? conversationHistoryTranscriptCommonModelInputRole, [
  List<enums.ConversationHistoryTranscriptCommonModelInputRole>? defaultValue,
]) {
  if (conversationHistoryTranscriptCommonModelInputRole == null) {
    return defaultValue;
  }

  return conversationHistoryTranscriptCommonModelInputRole
      .map((e) => conversationHistoryTranscriptCommonModelInputRoleFromJson(
          e.toString()))
      .toList();
}

String? conversationHistoryTranscriptCommonModelOutputRoleNullableToJson(
    enums.ConversationHistoryTranscriptCommonModelOutputRole?
        conversationHistoryTranscriptCommonModelOutputRole) {
  return conversationHistoryTranscriptCommonModelOutputRole?.value;
}

String? conversationHistoryTranscriptCommonModelOutputRoleToJson(
    enums.ConversationHistoryTranscriptCommonModelOutputRole
        conversationHistoryTranscriptCommonModelOutputRole) {
  return conversationHistoryTranscriptCommonModelOutputRole.value;
}

enums.ConversationHistoryTranscriptCommonModelOutputRole
    conversationHistoryTranscriptCommonModelOutputRoleFromJson(
  Object? conversationHistoryTranscriptCommonModelOutputRole, [
  enums.ConversationHistoryTranscriptCommonModelOutputRole? defaultValue,
]) {
  return enums.ConversationHistoryTranscriptCommonModelOutputRole.values
          .firstWhereOrNull((e) =>
              e.value == conversationHistoryTranscriptCommonModelOutputRole) ??
      defaultValue ??
      enums.ConversationHistoryTranscriptCommonModelOutputRole
          .swaggerGeneratedUnknown;
}

enums.ConversationHistoryTranscriptCommonModelOutputRole?
    conversationHistoryTranscriptCommonModelOutputRoleNullableFromJson(
  Object? conversationHistoryTranscriptCommonModelOutputRole, [
  enums.ConversationHistoryTranscriptCommonModelOutputRole? defaultValue,
]) {
  if (conversationHistoryTranscriptCommonModelOutputRole == null) {
    return null;
  }
  return enums.ConversationHistoryTranscriptCommonModelOutputRole.values
          .firstWhereOrNull((e) =>
              e.value == conversationHistoryTranscriptCommonModelOutputRole) ??
      defaultValue;
}

String conversationHistoryTranscriptCommonModelOutputRoleExplodedListToJson(
    List<enums.ConversationHistoryTranscriptCommonModelOutputRole>?
        conversationHistoryTranscriptCommonModelOutputRole) {
  return conversationHistoryTranscriptCommonModelOutputRole
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> conversationHistoryTranscriptCommonModelOutputRoleListToJson(
    List<enums.ConversationHistoryTranscriptCommonModelOutputRole>?
        conversationHistoryTranscriptCommonModelOutputRole) {
  if (conversationHistoryTranscriptCommonModelOutputRole == null) {
    return [];
  }

  return conversationHistoryTranscriptCommonModelOutputRole
      .map((e) => e.value!)
      .toList();
}

List<enums.ConversationHistoryTranscriptCommonModelOutputRole>
    conversationHistoryTranscriptCommonModelOutputRoleListFromJson(
  List? conversationHistoryTranscriptCommonModelOutputRole, [
  List<enums.ConversationHistoryTranscriptCommonModelOutputRole>? defaultValue,
]) {
  if (conversationHistoryTranscriptCommonModelOutputRole == null) {
    return defaultValue ?? [];
  }

  return conversationHistoryTranscriptCommonModelOutputRole
      .map((e) => conversationHistoryTranscriptCommonModelOutputRoleFromJson(
          e.toString()))
      .toList();
}

List<enums.ConversationHistoryTranscriptCommonModelOutputRole>?
    conversationHistoryTranscriptCommonModelOutputRoleNullableListFromJson(
  List? conversationHistoryTranscriptCommonModelOutputRole, [
  List<enums.ConversationHistoryTranscriptCommonModelOutputRole>? defaultValue,
]) {
  if (conversationHistoryTranscriptCommonModelOutputRole == null) {
    return defaultValue;
  }

  return conversationHistoryTranscriptCommonModelOutputRole
      .map((e) => conversationHistoryTranscriptCommonModelOutputRoleFromJson(
          e.toString()))
      .toList();
}

String? conversationHistoryTwilioPhoneCallModelDirectionNullableToJson(
    enums.ConversationHistoryTwilioPhoneCallModelDirection?
        conversationHistoryTwilioPhoneCallModelDirection) {
  return conversationHistoryTwilioPhoneCallModelDirection?.value;
}

String? conversationHistoryTwilioPhoneCallModelDirectionToJson(
    enums.ConversationHistoryTwilioPhoneCallModelDirection
        conversationHistoryTwilioPhoneCallModelDirection) {
  return conversationHistoryTwilioPhoneCallModelDirection.value;
}

enums.ConversationHistoryTwilioPhoneCallModelDirection
    conversationHistoryTwilioPhoneCallModelDirectionFromJson(
  Object? conversationHistoryTwilioPhoneCallModelDirection, [
  enums.ConversationHistoryTwilioPhoneCallModelDirection? defaultValue,
]) {
  return enums.ConversationHistoryTwilioPhoneCallModelDirection.values
          .firstWhereOrNull((e) =>
              e.value == conversationHistoryTwilioPhoneCallModelDirection) ??
      defaultValue ??
      enums.ConversationHistoryTwilioPhoneCallModelDirection
          .swaggerGeneratedUnknown;
}

enums.ConversationHistoryTwilioPhoneCallModelDirection?
    conversationHistoryTwilioPhoneCallModelDirectionNullableFromJson(
  Object? conversationHistoryTwilioPhoneCallModelDirection, [
  enums.ConversationHistoryTwilioPhoneCallModelDirection? defaultValue,
]) {
  if (conversationHistoryTwilioPhoneCallModelDirection == null) {
    return null;
  }
  return enums.ConversationHistoryTwilioPhoneCallModelDirection.values
          .firstWhereOrNull((e) =>
              e.value == conversationHistoryTwilioPhoneCallModelDirection) ??
      defaultValue;
}

String conversationHistoryTwilioPhoneCallModelDirectionExplodedListToJson(
    List<enums.ConversationHistoryTwilioPhoneCallModelDirection>?
        conversationHistoryTwilioPhoneCallModelDirection) {
  return conversationHistoryTwilioPhoneCallModelDirection
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> conversationHistoryTwilioPhoneCallModelDirectionListToJson(
    List<enums.ConversationHistoryTwilioPhoneCallModelDirection>?
        conversationHistoryTwilioPhoneCallModelDirection) {
  if (conversationHistoryTwilioPhoneCallModelDirection == null) {
    return [];
  }

  return conversationHistoryTwilioPhoneCallModelDirection
      .map((e) => e.value!)
      .toList();
}

List<enums.ConversationHistoryTwilioPhoneCallModelDirection>
    conversationHistoryTwilioPhoneCallModelDirectionListFromJson(
  List? conversationHistoryTwilioPhoneCallModelDirection, [
  List<enums.ConversationHistoryTwilioPhoneCallModelDirection>? defaultValue,
]) {
  if (conversationHistoryTwilioPhoneCallModelDirection == null) {
    return defaultValue ?? [];
  }

  return conversationHistoryTwilioPhoneCallModelDirection
      .map((e) => conversationHistoryTwilioPhoneCallModelDirectionFromJson(
          e.toString()))
      .toList();
}

List<enums.ConversationHistoryTwilioPhoneCallModelDirection>?
    conversationHistoryTwilioPhoneCallModelDirectionNullableListFromJson(
  List? conversationHistoryTwilioPhoneCallModelDirection, [
  List<enums.ConversationHistoryTwilioPhoneCallModelDirection>? defaultValue,
]) {
  if (conversationHistoryTwilioPhoneCallModelDirection == null) {
    return defaultValue;
  }

  return conversationHistoryTwilioPhoneCallModelDirection
      .map((e) => conversationHistoryTwilioPhoneCallModelDirectionFromJson(
          e.toString()))
      .toList();
}

String? conversationSummaryResponseModelStatusNullableToJson(
    enums.ConversationSummaryResponseModelStatus?
        conversationSummaryResponseModelStatus) {
  return conversationSummaryResponseModelStatus?.value;
}

String? conversationSummaryResponseModelStatusToJson(
    enums.ConversationSummaryResponseModelStatus
        conversationSummaryResponseModelStatus) {
  return conversationSummaryResponseModelStatus.value;
}

enums.ConversationSummaryResponseModelStatus
    conversationSummaryResponseModelStatusFromJson(
  Object? conversationSummaryResponseModelStatus, [
  enums.ConversationSummaryResponseModelStatus? defaultValue,
]) {
  return enums.ConversationSummaryResponseModelStatus.values.firstWhereOrNull(
          (e) => e.value == conversationSummaryResponseModelStatus) ??
      defaultValue ??
      enums.ConversationSummaryResponseModelStatus.swaggerGeneratedUnknown;
}

enums.ConversationSummaryResponseModelStatus?
    conversationSummaryResponseModelStatusNullableFromJson(
  Object? conversationSummaryResponseModelStatus, [
  enums.ConversationSummaryResponseModelStatus? defaultValue,
]) {
  if (conversationSummaryResponseModelStatus == null) {
    return null;
  }
  return enums.ConversationSummaryResponseModelStatus.values.firstWhereOrNull(
          (e) => e.value == conversationSummaryResponseModelStatus) ??
      defaultValue;
}

String conversationSummaryResponseModelStatusExplodedListToJson(
    List<enums.ConversationSummaryResponseModelStatus>?
        conversationSummaryResponseModelStatus) {
  return conversationSummaryResponseModelStatus
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> conversationSummaryResponseModelStatusListToJson(
    List<enums.ConversationSummaryResponseModelStatus>?
        conversationSummaryResponseModelStatus) {
  if (conversationSummaryResponseModelStatus == null) {
    return [];
  }

  return conversationSummaryResponseModelStatus.map((e) => e.value!).toList();
}

List<enums.ConversationSummaryResponseModelStatus>
    conversationSummaryResponseModelStatusListFromJson(
  List? conversationSummaryResponseModelStatus, [
  List<enums.ConversationSummaryResponseModelStatus>? defaultValue,
]) {
  if (conversationSummaryResponseModelStatus == null) {
    return defaultValue ?? [];
  }

  return conversationSummaryResponseModelStatus
      .map((e) => conversationSummaryResponseModelStatusFromJson(e.toString()))
      .toList();
}

List<enums.ConversationSummaryResponseModelStatus>?
    conversationSummaryResponseModelStatusNullableListFromJson(
  List? conversationSummaryResponseModelStatus, [
  List<enums.ConversationSummaryResponseModelStatus>? defaultValue,
]) {
  if (conversationSummaryResponseModelStatus == null) {
    return defaultValue;
  }

  return conversationSummaryResponseModelStatus
      .map((e) => conversationSummaryResponseModelStatusFromJson(e.toString()))
      .toList();
}

String? conversationTokenPurposeNullableToJson(
    enums.ConversationTokenPurpose? conversationTokenPurpose) {
  return conversationTokenPurpose?.value;
}

String? conversationTokenPurposeToJson(
    enums.ConversationTokenPurpose conversationTokenPurpose) {
  return conversationTokenPurpose.value;
}

enums.ConversationTokenPurpose conversationTokenPurposeFromJson(
  Object? conversationTokenPurpose, [
  enums.ConversationTokenPurpose? defaultValue,
]) {
  return enums.ConversationTokenPurpose.values
          .firstWhereOrNull((e) => e.value == conversationTokenPurpose) ??
      defaultValue ??
      enums.ConversationTokenPurpose.swaggerGeneratedUnknown;
}

enums.ConversationTokenPurpose? conversationTokenPurposeNullableFromJson(
  Object? conversationTokenPurpose, [
  enums.ConversationTokenPurpose? defaultValue,
]) {
  if (conversationTokenPurpose == null) {
    return null;
  }
  return enums.ConversationTokenPurpose.values
          .firstWhereOrNull((e) => e.value == conversationTokenPurpose) ??
      defaultValue;
}

String conversationTokenPurposeExplodedListToJson(
    List<enums.ConversationTokenPurpose>? conversationTokenPurpose) {
  return conversationTokenPurpose?.map((e) => e.value!).join(',') ?? '';
}

List<String> conversationTokenPurposeListToJson(
    List<enums.ConversationTokenPurpose>? conversationTokenPurpose) {
  if (conversationTokenPurpose == null) {
    return [];
  }

  return conversationTokenPurpose.map((e) => e.value!).toList();
}

List<enums.ConversationTokenPurpose> conversationTokenPurposeListFromJson(
  List? conversationTokenPurpose, [
  List<enums.ConversationTokenPurpose>? defaultValue,
]) {
  if (conversationTokenPurpose == null) {
    return defaultValue ?? [];
  }

  return conversationTokenPurpose
      .map((e) => conversationTokenPurposeFromJson(e.toString()))
      .toList();
}

List<enums.ConversationTokenPurpose>?
    conversationTokenPurposeNullableListFromJson(
  List? conversationTokenPurpose, [
  List<enums.ConversationTokenPurpose>? defaultValue,
]) {
  if (conversationTokenPurpose == null) {
    return defaultValue;
  }

  return conversationTokenPurpose
      .map((e) => conversationTokenPurposeFromJson(e.toString()))
      .toList();
}

String? dependentAvailableAgentIdentifierAccessLevelNullableToJson(
    enums.DependentAvailableAgentIdentifierAccessLevel?
        dependentAvailableAgentIdentifierAccessLevel) {
  return dependentAvailableAgentIdentifierAccessLevel?.value;
}

String? dependentAvailableAgentIdentifierAccessLevelToJson(
    enums.DependentAvailableAgentIdentifierAccessLevel
        dependentAvailableAgentIdentifierAccessLevel) {
  return dependentAvailableAgentIdentifierAccessLevel.value;
}

enums.DependentAvailableAgentIdentifierAccessLevel
    dependentAvailableAgentIdentifierAccessLevelFromJson(
  Object? dependentAvailableAgentIdentifierAccessLevel, [
  enums.DependentAvailableAgentIdentifierAccessLevel? defaultValue,
]) {
  return enums.DependentAvailableAgentIdentifierAccessLevel.values
          .firstWhereOrNull(
              (e) => e.value == dependentAvailableAgentIdentifierAccessLevel) ??
      defaultValue ??
      enums
          .DependentAvailableAgentIdentifierAccessLevel.swaggerGeneratedUnknown;
}

enums.DependentAvailableAgentIdentifierAccessLevel?
    dependentAvailableAgentIdentifierAccessLevelNullableFromJson(
  Object? dependentAvailableAgentIdentifierAccessLevel, [
  enums.DependentAvailableAgentIdentifierAccessLevel? defaultValue,
]) {
  if (dependentAvailableAgentIdentifierAccessLevel == null) {
    return null;
  }
  return enums.DependentAvailableAgentIdentifierAccessLevel.values
          .firstWhereOrNull(
              (e) => e.value == dependentAvailableAgentIdentifierAccessLevel) ??
      defaultValue;
}

String dependentAvailableAgentIdentifierAccessLevelExplodedListToJson(
    List<enums.DependentAvailableAgentIdentifierAccessLevel>?
        dependentAvailableAgentIdentifierAccessLevel) {
  return dependentAvailableAgentIdentifierAccessLevel
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> dependentAvailableAgentIdentifierAccessLevelListToJson(
    List<enums.DependentAvailableAgentIdentifierAccessLevel>?
        dependentAvailableAgentIdentifierAccessLevel) {
  if (dependentAvailableAgentIdentifierAccessLevel == null) {
    return [];
  }

  return dependentAvailableAgentIdentifierAccessLevel
      .map((e) => e.value!)
      .toList();
}

List<enums.DependentAvailableAgentIdentifierAccessLevel>
    dependentAvailableAgentIdentifierAccessLevelListFromJson(
  List? dependentAvailableAgentIdentifierAccessLevel, [
  List<enums.DependentAvailableAgentIdentifierAccessLevel>? defaultValue,
]) {
  if (dependentAvailableAgentIdentifierAccessLevel == null) {
    return defaultValue ?? [];
  }

  return dependentAvailableAgentIdentifierAccessLevel
      .map((e) =>
          dependentAvailableAgentIdentifierAccessLevelFromJson(e.toString()))
      .toList();
}

List<enums.DependentAvailableAgentIdentifierAccessLevel>?
    dependentAvailableAgentIdentifierAccessLevelNullableListFromJson(
  List? dependentAvailableAgentIdentifierAccessLevel, [
  List<enums.DependentAvailableAgentIdentifierAccessLevel>? defaultValue,
]) {
  if (dependentAvailableAgentIdentifierAccessLevel == null) {
    return defaultValue;
  }

  return dependentAvailableAgentIdentifierAccessLevel
      .map((e) =>
          dependentAvailableAgentIdentifierAccessLevelFromJson(e.toString()))
      .toList();
}

String? dependentAvailableAgentToolIdentifierAccessLevelNullableToJson(
    enums.DependentAvailableAgentToolIdentifierAccessLevel?
        dependentAvailableAgentToolIdentifierAccessLevel) {
  return dependentAvailableAgentToolIdentifierAccessLevel?.value;
}

String? dependentAvailableAgentToolIdentifierAccessLevelToJson(
    enums.DependentAvailableAgentToolIdentifierAccessLevel
        dependentAvailableAgentToolIdentifierAccessLevel) {
  return dependentAvailableAgentToolIdentifierAccessLevel.value;
}

enums.DependentAvailableAgentToolIdentifierAccessLevel
    dependentAvailableAgentToolIdentifierAccessLevelFromJson(
  Object? dependentAvailableAgentToolIdentifierAccessLevel, [
  enums.DependentAvailableAgentToolIdentifierAccessLevel? defaultValue,
]) {
  return enums.DependentAvailableAgentToolIdentifierAccessLevel.values
          .firstWhereOrNull((e) =>
              e.value == dependentAvailableAgentToolIdentifierAccessLevel) ??
      defaultValue ??
      enums.DependentAvailableAgentToolIdentifierAccessLevel
          .swaggerGeneratedUnknown;
}

enums.DependentAvailableAgentToolIdentifierAccessLevel?
    dependentAvailableAgentToolIdentifierAccessLevelNullableFromJson(
  Object? dependentAvailableAgentToolIdentifierAccessLevel, [
  enums.DependentAvailableAgentToolIdentifierAccessLevel? defaultValue,
]) {
  if (dependentAvailableAgentToolIdentifierAccessLevel == null) {
    return null;
  }
  return enums.DependentAvailableAgentToolIdentifierAccessLevel.values
          .firstWhereOrNull((e) =>
              e.value == dependentAvailableAgentToolIdentifierAccessLevel) ??
      defaultValue;
}

String dependentAvailableAgentToolIdentifierAccessLevelExplodedListToJson(
    List<enums.DependentAvailableAgentToolIdentifierAccessLevel>?
        dependentAvailableAgentToolIdentifierAccessLevel) {
  return dependentAvailableAgentToolIdentifierAccessLevel
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> dependentAvailableAgentToolIdentifierAccessLevelListToJson(
    List<enums.DependentAvailableAgentToolIdentifierAccessLevel>?
        dependentAvailableAgentToolIdentifierAccessLevel) {
  if (dependentAvailableAgentToolIdentifierAccessLevel == null) {
    return [];
  }

  return dependentAvailableAgentToolIdentifierAccessLevel
      .map((e) => e.value!)
      .toList();
}

List<enums.DependentAvailableAgentToolIdentifierAccessLevel>
    dependentAvailableAgentToolIdentifierAccessLevelListFromJson(
  List? dependentAvailableAgentToolIdentifierAccessLevel, [
  List<enums.DependentAvailableAgentToolIdentifierAccessLevel>? defaultValue,
]) {
  if (dependentAvailableAgentToolIdentifierAccessLevel == null) {
    return defaultValue ?? [];
  }

  return dependentAvailableAgentToolIdentifierAccessLevel
      .map((e) => dependentAvailableAgentToolIdentifierAccessLevelFromJson(
          e.toString()))
      .toList();
}

List<enums.DependentAvailableAgentToolIdentifierAccessLevel>?
    dependentAvailableAgentToolIdentifierAccessLevelNullableListFromJson(
  List? dependentAvailableAgentToolIdentifierAccessLevel, [
  List<enums.DependentAvailableAgentToolIdentifierAccessLevel>? defaultValue,
]) {
  if (dependentAvailableAgentToolIdentifierAccessLevel == null) {
    return defaultValue;
  }

  return dependentAvailableAgentToolIdentifierAccessLevel
      .map((e) => dependentAvailableAgentToolIdentifierAccessLevelFromJson(
          e.toString()))
      .toList();
}

String? dependentAvailableToolIdentifierAccessLevelNullableToJson(
    enums.DependentAvailableToolIdentifierAccessLevel?
        dependentAvailableToolIdentifierAccessLevel) {
  return dependentAvailableToolIdentifierAccessLevel?.value;
}

String? dependentAvailableToolIdentifierAccessLevelToJson(
    enums.DependentAvailableToolIdentifierAccessLevel
        dependentAvailableToolIdentifierAccessLevel) {
  return dependentAvailableToolIdentifierAccessLevel.value;
}

enums.DependentAvailableToolIdentifierAccessLevel
    dependentAvailableToolIdentifierAccessLevelFromJson(
  Object? dependentAvailableToolIdentifierAccessLevel, [
  enums.DependentAvailableToolIdentifierAccessLevel? defaultValue,
]) {
  return enums.DependentAvailableToolIdentifierAccessLevel.values
          .firstWhereOrNull(
              (e) => e.value == dependentAvailableToolIdentifierAccessLevel) ??
      defaultValue ??
      enums.DependentAvailableToolIdentifierAccessLevel.swaggerGeneratedUnknown;
}

enums.DependentAvailableToolIdentifierAccessLevel?
    dependentAvailableToolIdentifierAccessLevelNullableFromJson(
  Object? dependentAvailableToolIdentifierAccessLevel, [
  enums.DependentAvailableToolIdentifierAccessLevel? defaultValue,
]) {
  if (dependentAvailableToolIdentifierAccessLevel == null) {
    return null;
  }
  return enums.DependentAvailableToolIdentifierAccessLevel.values
          .firstWhereOrNull(
              (e) => e.value == dependentAvailableToolIdentifierAccessLevel) ??
      defaultValue;
}

String dependentAvailableToolIdentifierAccessLevelExplodedListToJson(
    List<enums.DependentAvailableToolIdentifierAccessLevel>?
        dependentAvailableToolIdentifierAccessLevel) {
  return dependentAvailableToolIdentifierAccessLevel
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> dependentAvailableToolIdentifierAccessLevelListToJson(
    List<enums.DependentAvailableToolIdentifierAccessLevel>?
        dependentAvailableToolIdentifierAccessLevel) {
  if (dependentAvailableToolIdentifierAccessLevel == null) {
    return [];
  }

  return dependentAvailableToolIdentifierAccessLevel
      .map((e) => e.value!)
      .toList();
}

List<enums.DependentAvailableToolIdentifierAccessLevel>
    dependentAvailableToolIdentifierAccessLevelListFromJson(
  List? dependentAvailableToolIdentifierAccessLevel, [
  List<enums.DependentAvailableToolIdentifierAccessLevel>? defaultValue,
]) {
  if (dependentAvailableToolIdentifierAccessLevel == null) {
    return defaultValue ?? [];
  }

  return dependentAvailableToolIdentifierAccessLevel
      .map((e) =>
          dependentAvailableToolIdentifierAccessLevelFromJson(e.toString()))
      .toList();
}

List<enums.DependentAvailableToolIdentifierAccessLevel>?
    dependentAvailableToolIdentifierAccessLevelNullableListFromJson(
  List? dependentAvailableToolIdentifierAccessLevel, [
  List<enums.DependentAvailableToolIdentifierAccessLevel>? defaultValue,
]) {
  if (dependentAvailableToolIdentifierAccessLevel == null) {
    return defaultValue;
  }

  return dependentAvailableToolIdentifierAccessLevel
      .map((e) =>
          dependentAvailableToolIdentifierAccessLevelFromJson(e.toString()))
      .toList();
}

String? documentUsageModeEnumNullableToJson(
    enums.DocumentUsageModeEnum? documentUsageModeEnum) {
  return documentUsageModeEnum?.value;
}

String? documentUsageModeEnumToJson(
    enums.DocumentUsageModeEnum documentUsageModeEnum) {
  return documentUsageModeEnum.value;
}

enums.DocumentUsageModeEnum documentUsageModeEnumFromJson(
  Object? documentUsageModeEnum, [
  enums.DocumentUsageModeEnum? defaultValue,
]) {
  return enums.DocumentUsageModeEnum.values
          .firstWhereOrNull((e) => e.value == documentUsageModeEnum) ??
      defaultValue ??
      enums.DocumentUsageModeEnum.swaggerGeneratedUnknown;
}

enums.DocumentUsageModeEnum? documentUsageModeEnumNullableFromJson(
  Object? documentUsageModeEnum, [
  enums.DocumentUsageModeEnum? defaultValue,
]) {
  if (documentUsageModeEnum == null) {
    return null;
  }
  return enums.DocumentUsageModeEnum.values
          .firstWhereOrNull((e) => e.value == documentUsageModeEnum) ??
      defaultValue;
}

String documentUsageModeEnumExplodedListToJson(
    List<enums.DocumentUsageModeEnum>? documentUsageModeEnum) {
  return documentUsageModeEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> documentUsageModeEnumListToJson(
    List<enums.DocumentUsageModeEnum>? documentUsageModeEnum) {
  if (documentUsageModeEnum == null) {
    return [];
  }

  return documentUsageModeEnum.map((e) => e.value!).toList();
}

List<enums.DocumentUsageModeEnum> documentUsageModeEnumListFromJson(
  List? documentUsageModeEnum, [
  List<enums.DocumentUsageModeEnum>? defaultValue,
]) {
  if (documentUsageModeEnum == null) {
    return defaultValue ?? [];
  }

  return documentUsageModeEnum
      .map((e) => documentUsageModeEnumFromJson(e.toString()))
      .toList();
}

List<enums.DocumentUsageModeEnum>? documentUsageModeEnumNullableListFromJson(
  List? documentUsageModeEnum, [
  List<enums.DocumentUsageModeEnum>? defaultValue,
]) {
  if (documentUsageModeEnum == null) {
    return defaultValue;
  }

  return documentUsageModeEnum
      .map((e) => documentUsageModeEnumFromJson(e.toString()))
      .toList();
}

String? embedVariantNullableToJson(enums.EmbedVariant? embedVariant) {
  return embedVariant?.value;
}

String? embedVariantToJson(enums.EmbedVariant embedVariant) {
  return embedVariant.value;
}

enums.EmbedVariant embedVariantFromJson(
  Object? embedVariant, [
  enums.EmbedVariant? defaultValue,
]) {
  return enums.EmbedVariant.values
          .firstWhereOrNull((e) => e.value == embedVariant) ??
      defaultValue ??
      enums.EmbedVariant.swaggerGeneratedUnknown;
}

enums.EmbedVariant? embedVariantNullableFromJson(
  Object? embedVariant, [
  enums.EmbedVariant? defaultValue,
]) {
  if (embedVariant == null) {
    return null;
  }
  return enums.EmbedVariant.values
          .firstWhereOrNull((e) => e.value == embedVariant) ??
      defaultValue;
}

String embedVariantExplodedListToJson(List<enums.EmbedVariant>? embedVariant) {
  return embedVariant?.map((e) => e.value!).join(',') ?? '';
}

List<String> embedVariantListToJson(List<enums.EmbedVariant>? embedVariant) {
  if (embedVariant == null) {
    return [];
  }

  return embedVariant.map((e) => e.value!).toList();
}

List<enums.EmbedVariant> embedVariantListFromJson(
  List? embedVariant, [
  List<enums.EmbedVariant>? defaultValue,
]) {
  if (embedVariant == null) {
    return defaultValue ?? [];
  }

  return embedVariant.map((e) => embedVariantFromJson(e.toString())).toList();
}

List<enums.EmbedVariant>? embedVariantNullableListFromJson(
  List? embedVariant, [
  List<enums.EmbedVariant>? defaultValue,
]) {
  if (embedVariant == null) {
    return defaultValue;
  }

  return embedVariant.map((e) => embedVariantFromJson(e.toString())).toList();
}

String? embeddingModelEnumNullableToJson(
    enums.EmbeddingModelEnum? embeddingModelEnum) {
  return embeddingModelEnum?.value;
}

String? embeddingModelEnumToJson(enums.EmbeddingModelEnum embeddingModelEnum) {
  return embeddingModelEnum.value;
}

enums.EmbeddingModelEnum embeddingModelEnumFromJson(
  Object? embeddingModelEnum, [
  enums.EmbeddingModelEnum? defaultValue,
]) {
  return enums.EmbeddingModelEnum.values
          .firstWhereOrNull((e) => e.value == embeddingModelEnum) ??
      defaultValue ??
      enums.EmbeddingModelEnum.swaggerGeneratedUnknown;
}

enums.EmbeddingModelEnum? embeddingModelEnumNullableFromJson(
  Object? embeddingModelEnum, [
  enums.EmbeddingModelEnum? defaultValue,
]) {
  if (embeddingModelEnum == null) {
    return null;
  }
  return enums.EmbeddingModelEnum.values
          .firstWhereOrNull((e) => e.value == embeddingModelEnum) ??
      defaultValue;
}

String embeddingModelEnumExplodedListToJson(
    List<enums.EmbeddingModelEnum>? embeddingModelEnum) {
  return embeddingModelEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> embeddingModelEnumListToJson(
    List<enums.EmbeddingModelEnum>? embeddingModelEnum) {
  if (embeddingModelEnum == null) {
    return [];
  }

  return embeddingModelEnum.map((e) => e.value!).toList();
}

List<enums.EmbeddingModelEnum> embeddingModelEnumListFromJson(
  List? embeddingModelEnum, [
  List<enums.EmbeddingModelEnum>? defaultValue,
]) {
  if (embeddingModelEnum == null) {
    return defaultValue ?? [];
  }

  return embeddingModelEnum
      .map((e) => embeddingModelEnumFromJson(e.toString()))
      .toList();
}

List<enums.EmbeddingModelEnum>? embeddingModelEnumNullableListFromJson(
  List? embeddingModelEnum, [
  List<enums.EmbeddingModelEnum>? defaultValue,
]) {
  if (embeddingModelEnum == null) {
    return defaultValue;
  }

  return embeddingModelEnum
      .map((e) => embeddingModelEnumFromJson(e.toString()))
      .toList();
}

String? evaluationSuccessResultNullableToJson(
    enums.EvaluationSuccessResult? evaluationSuccessResult) {
  return evaluationSuccessResult?.value;
}

String? evaluationSuccessResultToJson(
    enums.EvaluationSuccessResult evaluationSuccessResult) {
  return evaluationSuccessResult.value;
}

enums.EvaluationSuccessResult evaluationSuccessResultFromJson(
  Object? evaluationSuccessResult, [
  enums.EvaluationSuccessResult? defaultValue,
]) {
  return enums.EvaluationSuccessResult.values
          .firstWhereOrNull((e) => e.value == evaluationSuccessResult) ??
      defaultValue ??
      enums.EvaluationSuccessResult.swaggerGeneratedUnknown;
}

enums.EvaluationSuccessResult? evaluationSuccessResultNullableFromJson(
  Object? evaluationSuccessResult, [
  enums.EvaluationSuccessResult? defaultValue,
]) {
  if (evaluationSuccessResult == null) {
    return null;
  }
  return enums.EvaluationSuccessResult.values
          .firstWhereOrNull((e) => e.value == evaluationSuccessResult) ??
      defaultValue;
}

String evaluationSuccessResultExplodedListToJson(
    List<enums.EvaluationSuccessResult>? evaluationSuccessResult) {
  return evaluationSuccessResult?.map((e) => e.value!).join(',') ?? '';
}

List<String> evaluationSuccessResultListToJson(
    List<enums.EvaluationSuccessResult>? evaluationSuccessResult) {
  if (evaluationSuccessResult == null) {
    return [];
  }

  return evaluationSuccessResult.map((e) => e.value!).toList();
}

List<enums.EvaluationSuccessResult> evaluationSuccessResultListFromJson(
  List? evaluationSuccessResult, [
  List<enums.EvaluationSuccessResult>? defaultValue,
]) {
  if (evaluationSuccessResult == null) {
    return defaultValue ?? [];
  }

  return evaluationSuccessResult
      .map((e) => evaluationSuccessResultFromJson(e.toString()))
      .toList();
}

List<enums.EvaluationSuccessResult>?
    evaluationSuccessResultNullableListFromJson(
  List? evaluationSuccessResult, [
  List<enums.EvaluationSuccessResult>? defaultValue,
]) {
  if (evaluationSuccessResult == null) {
    return defaultValue;
  }

  return evaluationSuccessResult
      .map((e) => evaluationSuccessResultFromJson(e.toString()))
      .toList();
}

String? extendedSubscriptionResponseModelStatusNullableToJson(
    enums.ExtendedSubscriptionResponseModelStatus?
        extendedSubscriptionResponseModelStatus) {
  return extendedSubscriptionResponseModelStatus?.value;
}

String? extendedSubscriptionResponseModelStatusToJson(
    enums.ExtendedSubscriptionResponseModelStatus
        extendedSubscriptionResponseModelStatus) {
  return extendedSubscriptionResponseModelStatus.value;
}

enums.ExtendedSubscriptionResponseModelStatus
    extendedSubscriptionResponseModelStatusFromJson(
  Object? extendedSubscriptionResponseModelStatus, [
  enums.ExtendedSubscriptionResponseModelStatus? defaultValue,
]) {
  return enums.ExtendedSubscriptionResponseModelStatus.values.firstWhereOrNull(
          (e) => e.value == extendedSubscriptionResponseModelStatus) ??
      defaultValue ??
      enums.ExtendedSubscriptionResponseModelStatus.swaggerGeneratedUnknown;
}

enums.ExtendedSubscriptionResponseModelStatus?
    extendedSubscriptionResponseModelStatusNullableFromJson(
  Object? extendedSubscriptionResponseModelStatus, [
  enums.ExtendedSubscriptionResponseModelStatus? defaultValue,
]) {
  if (extendedSubscriptionResponseModelStatus == null) {
    return null;
  }
  return enums.ExtendedSubscriptionResponseModelStatus.values.firstWhereOrNull(
          (e) => e.value == extendedSubscriptionResponseModelStatus) ??
      defaultValue;
}

String extendedSubscriptionResponseModelStatusExplodedListToJson(
    List<enums.ExtendedSubscriptionResponseModelStatus>?
        extendedSubscriptionResponseModelStatus) {
  return extendedSubscriptionResponseModelStatus
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> extendedSubscriptionResponseModelStatusListToJson(
    List<enums.ExtendedSubscriptionResponseModelStatus>?
        extendedSubscriptionResponseModelStatus) {
  if (extendedSubscriptionResponseModelStatus == null) {
    return [];
  }

  return extendedSubscriptionResponseModelStatus.map((e) => e.value!).toList();
}

List<enums.ExtendedSubscriptionResponseModelStatus>
    extendedSubscriptionResponseModelStatusListFromJson(
  List? extendedSubscriptionResponseModelStatus, [
  List<enums.ExtendedSubscriptionResponseModelStatus>? defaultValue,
]) {
  if (extendedSubscriptionResponseModelStatus == null) {
    return defaultValue ?? [];
  }

  return extendedSubscriptionResponseModelStatus
      .map((e) => extendedSubscriptionResponseModelStatusFromJson(e.toString()))
      .toList();
}

List<enums.ExtendedSubscriptionResponseModelStatus>?
    extendedSubscriptionResponseModelStatusNullableListFromJson(
  List? extendedSubscriptionResponseModelStatus, [
  List<enums.ExtendedSubscriptionResponseModelStatus>? defaultValue,
]) {
  if (extendedSubscriptionResponseModelStatus == null) {
    return defaultValue;
  }

  return extendedSubscriptionResponseModelStatus
      .map((e) => extendedSubscriptionResponseModelStatusFromJson(e.toString()))
      .toList();
}

String? getConversationResponseModelStatusNullableToJson(
    enums.GetConversationResponseModelStatus?
        getConversationResponseModelStatus) {
  return getConversationResponseModelStatus?.value;
}

String? getConversationResponseModelStatusToJson(
    enums.GetConversationResponseModelStatus
        getConversationResponseModelStatus) {
  return getConversationResponseModelStatus.value;
}

enums.GetConversationResponseModelStatus
    getConversationResponseModelStatusFromJson(
  Object? getConversationResponseModelStatus, [
  enums.GetConversationResponseModelStatus? defaultValue,
]) {
  return enums.GetConversationResponseModelStatus.values.firstWhereOrNull(
          (e) => e.value == getConversationResponseModelStatus) ??
      defaultValue ??
      enums.GetConversationResponseModelStatus.swaggerGeneratedUnknown;
}

enums.GetConversationResponseModelStatus?
    getConversationResponseModelStatusNullableFromJson(
  Object? getConversationResponseModelStatus, [
  enums.GetConversationResponseModelStatus? defaultValue,
]) {
  if (getConversationResponseModelStatus == null) {
    return null;
  }
  return enums.GetConversationResponseModelStatus.values.firstWhereOrNull(
          (e) => e.value == getConversationResponseModelStatus) ??
      defaultValue;
}

String getConversationResponseModelStatusExplodedListToJson(
    List<enums.GetConversationResponseModelStatus>?
        getConversationResponseModelStatus) {
  return getConversationResponseModelStatus?.map((e) => e.value!).join(',') ??
      '';
}

List<String> getConversationResponseModelStatusListToJson(
    List<enums.GetConversationResponseModelStatus>?
        getConversationResponseModelStatus) {
  if (getConversationResponseModelStatus == null) {
    return [];
  }

  return getConversationResponseModelStatus.map((e) => e.value!).toList();
}

List<enums.GetConversationResponseModelStatus>
    getConversationResponseModelStatusListFromJson(
  List? getConversationResponseModelStatus, [
  List<enums.GetConversationResponseModelStatus>? defaultValue,
]) {
  if (getConversationResponseModelStatus == null) {
    return defaultValue ?? [];
  }

  return getConversationResponseModelStatus
      .map((e) => getConversationResponseModelStatusFromJson(e.toString()))
      .toList();
}

List<enums.GetConversationResponseModelStatus>?
    getConversationResponseModelStatusNullableListFromJson(
  List? getConversationResponseModelStatus, [
  List<enums.GetConversationResponseModelStatus>? defaultValue,
]) {
  if (getConversationResponseModelStatus == null) {
    return defaultValue;
  }

  return getConversationResponseModelStatus
      .map((e) => getConversationResponseModelStatusFromJson(e.toString()))
      .toList();
}

String? knowledgeBaseDocumentTypeNullableToJson(
    enums.KnowledgeBaseDocumentType? knowledgeBaseDocumentType) {
  return knowledgeBaseDocumentType?.value;
}

String? knowledgeBaseDocumentTypeToJson(
    enums.KnowledgeBaseDocumentType knowledgeBaseDocumentType) {
  return knowledgeBaseDocumentType.value;
}

enums.KnowledgeBaseDocumentType knowledgeBaseDocumentTypeFromJson(
  Object? knowledgeBaseDocumentType, [
  enums.KnowledgeBaseDocumentType? defaultValue,
]) {
  return enums.KnowledgeBaseDocumentType.values
          .firstWhereOrNull((e) => e.value == knowledgeBaseDocumentType) ??
      defaultValue ??
      enums.KnowledgeBaseDocumentType.swaggerGeneratedUnknown;
}

enums.KnowledgeBaseDocumentType? knowledgeBaseDocumentTypeNullableFromJson(
  Object? knowledgeBaseDocumentType, [
  enums.KnowledgeBaseDocumentType? defaultValue,
]) {
  if (knowledgeBaseDocumentType == null) {
    return null;
  }
  return enums.KnowledgeBaseDocumentType.values
          .firstWhereOrNull((e) => e.value == knowledgeBaseDocumentType) ??
      defaultValue;
}

String knowledgeBaseDocumentTypeExplodedListToJson(
    List<enums.KnowledgeBaseDocumentType>? knowledgeBaseDocumentType) {
  return knowledgeBaseDocumentType?.map((e) => e.value!).join(',') ?? '';
}

List<String> knowledgeBaseDocumentTypeListToJson(
    List<enums.KnowledgeBaseDocumentType>? knowledgeBaseDocumentType) {
  if (knowledgeBaseDocumentType == null) {
    return [];
  }

  return knowledgeBaseDocumentType.map((e) => e.value!).toList();
}

List<enums.KnowledgeBaseDocumentType> knowledgeBaseDocumentTypeListFromJson(
  List? knowledgeBaseDocumentType, [
  List<enums.KnowledgeBaseDocumentType>? defaultValue,
]) {
  if (knowledgeBaseDocumentType == null) {
    return defaultValue ?? [];
  }

  return knowledgeBaseDocumentType
      .map((e) => knowledgeBaseDocumentTypeFromJson(e.toString()))
      .toList();
}

List<enums.KnowledgeBaseDocumentType>?
    knowledgeBaseDocumentTypeNullableListFromJson(
  List? knowledgeBaseDocumentType, [
  List<enums.KnowledgeBaseDocumentType>? defaultValue,
]) {
  if (knowledgeBaseDocumentType == null) {
    return defaultValue;
  }

  return knowledgeBaseDocumentType
      .map((e) => knowledgeBaseDocumentTypeFromJson(e.toString()))
      .toList();
}

String? llmNullableToJson(enums.Llm? llm) {
  return llm?.value;
}

String? llmToJson(enums.Llm llm) {
  return llm.value;
}

enums.Llm llmFromJson(
  Object? llm, [
  enums.Llm? defaultValue,
]) {
  return enums.Llm.values.firstWhereOrNull((e) => e.value == llm) ??
      defaultValue ??
      enums.Llm.swaggerGeneratedUnknown;
}

enums.Llm? llmNullableFromJson(
  Object? llm, [
  enums.Llm? defaultValue,
]) {
  if (llm == null) {
    return null;
  }
  return enums.Llm.values.firstWhereOrNull((e) => e.value == llm) ??
      defaultValue;
}

String llmExplodedListToJson(List<enums.Llm>? llm) {
  return llm?.map((e) => e.value!).join(',') ?? '';
}

List<String> llmListToJson(List<enums.Llm>? llm) {
  if (llm == null) {
    return [];
  }

  return llm.map((e) => e.value!).toList();
}

List<enums.Llm> llmListFromJson(
  List? llm, [
  List<enums.Llm>? defaultValue,
]) {
  if (llm == null) {
    return defaultValue ?? [];
  }

  return llm.map((e) => llmFromJson(e.toString())).toList();
}

List<enums.Llm>? llmNullableListFromJson(
  List? llm, [
  List<enums.Llm>? defaultValue,
]) {
  if (llm == null) {
    return defaultValue;
  }

  return llm.map((e) => llmFromJson(e.toString())).toList();
}

String? libraryVoiceResponseModelCategoryNullableToJson(
    enums.LibraryVoiceResponseModelCategory?
        libraryVoiceResponseModelCategory) {
  return libraryVoiceResponseModelCategory?.value;
}

String? libraryVoiceResponseModelCategoryToJson(
    enums.LibraryVoiceResponseModelCategory libraryVoiceResponseModelCategory) {
  return libraryVoiceResponseModelCategory.value;
}

enums.LibraryVoiceResponseModelCategory
    libraryVoiceResponseModelCategoryFromJson(
  Object? libraryVoiceResponseModelCategory, [
  enums.LibraryVoiceResponseModelCategory? defaultValue,
]) {
  return enums.LibraryVoiceResponseModelCategory.values.firstWhereOrNull(
          (e) => e.value == libraryVoiceResponseModelCategory) ??
      defaultValue ??
      enums.LibraryVoiceResponseModelCategory.swaggerGeneratedUnknown;
}

enums.LibraryVoiceResponseModelCategory?
    libraryVoiceResponseModelCategoryNullableFromJson(
  Object? libraryVoiceResponseModelCategory, [
  enums.LibraryVoiceResponseModelCategory? defaultValue,
]) {
  if (libraryVoiceResponseModelCategory == null) {
    return null;
  }
  return enums.LibraryVoiceResponseModelCategory.values.firstWhereOrNull(
          (e) => e.value == libraryVoiceResponseModelCategory) ??
      defaultValue;
}

String libraryVoiceResponseModelCategoryExplodedListToJson(
    List<enums.LibraryVoiceResponseModelCategory>?
        libraryVoiceResponseModelCategory) {
  return libraryVoiceResponseModelCategory?.map((e) => e.value!).join(',') ??
      '';
}

List<String> libraryVoiceResponseModelCategoryListToJson(
    List<enums.LibraryVoiceResponseModelCategory>?
        libraryVoiceResponseModelCategory) {
  if (libraryVoiceResponseModelCategory == null) {
    return [];
  }

  return libraryVoiceResponseModelCategory.map((e) => e.value!).toList();
}

List<enums.LibraryVoiceResponseModelCategory>
    libraryVoiceResponseModelCategoryListFromJson(
  List? libraryVoiceResponseModelCategory, [
  List<enums.LibraryVoiceResponseModelCategory>? defaultValue,
]) {
  if (libraryVoiceResponseModelCategory == null) {
    return defaultValue ?? [];
  }

  return libraryVoiceResponseModelCategory
      .map((e) => libraryVoiceResponseModelCategoryFromJson(e.toString()))
      .toList();
}

List<enums.LibraryVoiceResponseModelCategory>?
    libraryVoiceResponseModelCategoryNullableListFromJson(
  List? libraryVoiceResponseModelCategory, [
  List<enums.LibraryVoiceResponseModelCategory>? defaultValue,
]) {
  if (libraryVoiceResponseModelCategory == null) {
    return defaultValue;
  }

  return libraryVoiceResponseModelCategory
      .map((e) => libraryVoiceResponseModelCategoryFromJson(e.toString()))
      .toList();
}

String? literalJsonSchemaPropertyTypeNullableToJson(
    enums.LiteralJsonSchemaPropertyType? literalJsonSchemaPropertyType) {
  return literalJsonSchemaPropertyType?.value;
}

String? literalJsonSchemaPropertyTypeToJson(
    enums.LiteralJsonSchemaPropertyType literalJsonSchemaPropertyType) {
  return literalJsonSchemaPropertyType.value;
}

enums.LiteralJsonSchemaPropertyType literalJsonSchemaPropertyTypeFromJson(
  Object? literalJsonSchemaPropertyType, [
  enums.LiteralJsonSchemaPropertyType? defaultValue,
]) {
  return enums.LiteralJsonSchemaPropertyType.values
          .firstWhereOrNull((e) => e.value == literalJsonSchemaPropertyType) ??
      defaultValue ??
      enums.LiteralJsonSchemaPropertyType.swaggerGeneratedUnknown;
}

enums.LiteralJsonSchemaPropertyType?
    literalJsonSchemaPropertyTypeNullableFromJson(
  Object? literalJsonSchemaPropertyType, [
  enums.LiteralJsonSchemaPropertyType? defaultValue,
]) {
  if (literalJsonSchemaPropertyType == null) {
    return null;
  }
  return enums.LiteralJsonSchemaPropertyType.values
          .firstWhereOrNull((e) => e.value == literalJsonSchemaPropertyType) ??
      defaultValue;
}

String literalJsonSchemaPropertyTypeExplodedListToJson(
    List<enums.LiteralJsonSchemaPropertyType>? literalJsonSchemaPropertyType) {
  return literalJsonSchemaPropertyType?.map((e) => e.value!).join(',') ?? '';
}

List<String> literalJsonSchemaPropertyTypeListToJson(
    List<enums.LiteralJsonSchemaPropertyType>? literalJsonSchemaPropertyType) {
  if (literalJsonSchemaPropertyType == null) {
    return [];
  }

  return literalJsonSchemaPropertyType.map((e) => e.value!).toList();
}

List<enums.LiteralJsonSchemaPropertyType>
    literalJsonSchemaPropertyTypeListFromJson(
  List? literalJsonSchemaPropertyType, [
  List<enums.LiteralJsonSchemaPropertyType>? defaultValue,
]) {
  if (literalJsonSchemaPropertyType == null) {
    return defaultValue ?? [];
  }

  return literalJsonSchemaPropertyType
      .map((e) => literalJsonSchemaPropertyTypeFromJson(e.toString()))
      .toList();
}

List<enums.LiteralJsonSchemaPropertyType>?
    literalJsonSchemaPropertyTypeNullableListFromJson(
  List? literalJsonSchemaPropertyType, [
  List<enums.LiteralJsonSchemaPropertyType>? defaultValue,
]) {
  if (literalJsonSchemaPropertyType == null) {
    return defaultValue;
  }

  return literalJsonSchemaPropertyType
      .map((e) => literalJsonSchemaPropertyTypeFromJson(e.toString()))
      .toList();
}

String? mCPApprovalRequiredModelNullableToJson(
    enums.MCPApprovalRequiredModel? mCPApprovalRequiredModel) {
  return mCPApprovalRequiredModel?.value;
}

String? mCPApprovalRequiredModelToJson(
    enums.MCPApprovalRequiredModel mCPApprovalRequiredModel) {
  return mCPApprovalRequiredModel.value;
}

enums.MCPApprovalRequiredModel mCPApprovalRequiredModelFromJson(
  Object? mCPApprovalRequiredModel, [
  enums.MCPApprovalRequiredModel? defaultValue,
]) {
  return enums.MCPApprovalRequiredModel.values
          .firstWhereOrNull((e) => e.value == mCPApprovalRequiredModel) ??
      defaultValue ??
      enums.MCPApprovalRequiredModel.swaggerGeneratedUnknown;
}

enums.MCPApprovalRequiredModel? mCPApprovalRequiredModelNullableFromJson(
  Object? mCPApprovalRequiredModel, [
  enums.MCPApprovalRequiredModel? defaultValue,
]) {
  if (mCPApprovalRequiredModel == null) {
    return null;
  }
  return enums.MCPApprovalRequiredModel.values
          .firstWhereOrNull((e) => e.value == mCPApprovalRequiredModel) ??
      defaultValue;
}

String mCPApprovalRequiredModelExplodedListToJson(
    List<enums.MCPApprovalRequiredModel>? mCPApprovalRequiredModel) {
  return mCPApprovalRequiredModel?.map((e) => e.value!).join(',') ?? '';
}

List<String> mCPApprovalRequiredModelListToJson(
    List<enums.MCPApprovalRequiredModel>? mCPApprovalRequiredModel) {
  if (mCPApprovalRequiredModel == null) {
    return [];
  }

  return mCPApprovalRequiredModel.map((e) => e.value!).toList();
}

List<enums.MCPApprovalRequiredModel> mCPApprovalRequiredModelListFromJson(
  List? mCPApprovalRequiredModel, [
  List<enums.MCPApprovalRequiredModel>? defaultValue,
]) {
  if (mCPApprovalRequiredModel == null) {
    return defaultValue ?? [];
  }

  return mCPApprovalRequiredModel
      .map((e) => mCPApprovalRequiredModelFromJson(e.toString()))
      .toList();
}

List<enums.MCPApprovalRequiredModel>?
    mCPApprovalRequiredModelNullableListFromJson(
  List? mCPApprovalRequiredModel, [
  List<enums.MCPApprovalRequiredModel>? defaultValue,
]) {
  if (mCPApprovalRequiredModel == null) {
    return defaultValue;
  }

  return mCPApprovalRequiredModel
      .map((e) => mCPApprovalRequiredModelFromJson(e.toString()))
      .toList();
}

String? metricTypeNullableToJson(enums.MetricType? metricType) {
  return metricType?.value;
}

String? metricTypeToJson(enums.MetricType metricType) {
  return metricType.value;
}

enums.MetricType metricTypeFromJson(
  Object? metricType, [
  enums.MetricType? defaultValue,
]) {
  return enums.MetricType.values
          .firstWhereOrNull((e) => e.value == metricType) ??
      defaultValue ??
      enums.MetricType.swaggerGeneratedUnknown;
}

enums.MetricType? metricTypeNullableFromJson(
  Object? metricType, [
  enums.MetricType? defaultValue,
]) {
  if (metricType == null) {
    return null;
  }
  return enums.MetricType.values
          .firstWhereOrNull((e) => e.value == metricType) ??
      defaultValue;
}

String metricTypeExplodedListToJson(List<enums.MetricType>? metricType) {
  return metricType?.map((e) => e.value!).join(',') ?? '';
}

List<String> metricTypeListToJson(List<enums.MetricType>? metricType) {
  if (metricType == null) {
    return [];
  }

  return metricType.map((e) => e.value!).toList();
}

List<enums.MetricType> metricTypeListFromJson(
  List? metricType, [
  List<enums.MetricType>? defaultValue,
]) {
  if (metricType == null) {
    return defaultValue ?? [];
  }

  return metricType.map((e) => metricTypeFromJson(e.toString())).toList();
}

List<enums.MetricType>? metricTypeNullableListFromJson(
  List? metricType, [
  List<enums.MetricType>? defaultValue,
]) {
  if (metricType == null) {
    return defaultValue;
  }

  return metricType.map((e) => metricTypeFromJson(e.toString())).toList();
}

String? modelResponseModelConcurrencyGroupNullableToJson(
    enums.ModelResponseModelConcurrencyGroup?
        modelResponseModelConcurrencyGroup) {
  return modelResponseModelConcurrencyGroup?.value;
}

String? modelResponseModelConcurrencyGroupToJson(
    enums.ModelResponseModelConcurrencyGroup
        modelResponseModelConcurrencyGroup) {
  return modelResponseModelConcurrencyGroup.value;
}

enums.ModelResponseModelConcurrencyGroup
    modelResponseModelConcurrencyGroupFromJson(
  Object? modelResponseModelConcurrencyGroup, [
  enums.ModelResponseModelConcurrencyGroup? defaultValue,
]) {
  return enums.ModelResponseModelConcurrencyGroup.values.firstWhereOrNull(
          (e) => e.value == modelResponseModelConcurrencyGroup) ??
      defaultValue ??
      enums.ModelResponseModelConcurrencyGroup.swaggerGeneratedUnknown;
}

enums.ModelResponseModelConcurrencyGroup?
    modelResponseModelConcurrencyGroupNullableFromJson(
  Object? modelResponseModelConcurrencyGroup, [
  enums.ModelResponseModelConcurrencyGroup? defaultValue,
]) {
  if (modelResponseModelConcurrencyGroup == null) {
    return null;
  }
  return enums.ModelResponseModelConcurrencyGroup.values.firstWhereOrNull(
          (e) => e.value == modelResponseModelConcurrencyGroup) ??
      defaultValue;
}

String modelResponseModelConcurrencyGroupExplodedListToJson(
    List<enums.ModelResponseModelConcurrencyGroup>?
        modelResponseModelConcurrencyGroup) {
  return modelResponseModelConcurrencyGroup?.map((e) => e.value!).join(',') ??
      '';
}

List<String> modelResponseModelConcurrencyGroupListToJson(
    List<enums.ModelResponseModelConcurrencyGroup>?
        modelResponseModelConcurrencyGroup) {
  if (modelResponseModelConcurrencyGroup == null) {
    return [];
  }

  return modelResponseModelConcurrencyGroup.map((e) => e.value!).toList();
}

List<enums.ModelResponseModelConcurrencyGroup>
    modelResponseModelConcurrencyGroupListFromJson(
  List? modelResponseModelConcurrencyGroup, [
  List<enums.ModelResponseModelConcurrencyGroup>? defaultValue,
]) {
  if (modelResponseModelConcurrencyGroup == null) {
    return defaultValue ?? [];
  }

  return modelResponseModelConcurrencyGroup
      .map((e) => modelResponseModelConcurrencyGroupFromJson(e.toString()))
      .toList();
}

List<enums.ModelResponseModelConcurrencyGroup>?
    modelResponseModelConcurrencyGroupNullableListFromJson(
  List? modelResponseModelConcurrencyGroup, [
  List<enums.ModelResponseModelConcurrencyGroup>? defaultValue,
]) {
  if (modelResponseModelConcurrencyGroup == null) {
    return defaultValue;
  }

  return modelResponseModelConcurrencyGroup
      .map((e) => modelResponseModelConcurrencyGroupFromJson(e.toString()))
      .toList();
}

String? projectCreationMetaResponseModelStatusNullableToJson(
    enums.ProjectCreationMetaResponseModelStatus?
        projectCreationMetaResponseModelStatus) {
  return projectCreationMetaResponseModelStatus?.value;
}

String? projectCreationMetaResponseModelStatusToJson(
    enums.ProjectCreationMetaResponseModelStatus
        projectCreationMetaResponseModelStatus) {
  return projectCreationMetaResponseModelStatus.value;
}

enums.ProjectCreationMetaResponseModelStatus
    projectCreationMetaResponseModelStatusFromJson(
  Object? projectCreationMetaResponseModelStatus, [
  enums.ProjectCreationMetaResponseModelStatus? defaultValue,
]) {
  return enums.ProjectCreationMetaResponseModelStatus.values.firstWhereOrNull(
          (e) => e.value == projectCreationMetaResponseModelStatus) ??
      defaultValue ??
      enums.ProjectCreationMetaResponseModelStatus.swaggerGeneratedUnknown;
}

enums.ProjectCreationMetaResponseModelStatus?
    projectCreationMetaResponseModelStatusNullableFromJson(
  Object? projectCreationMetaResponseModelStatus, [
  enums.ProjectCreationMetaResponseModelStatus? defaultValue,
]) {
  if (projectCreationMetaResponseModelStatus == null) {
    return null;
  }
  return enums.ProjectCreationMetaResponseModelStatus.values.firstWhereOrNull(
          (e) => e.value == projectCreationMetaResponseModelStatus) ??
      defaultValue;
}

String projectCreationMetaResponseModelStatusExplodedListToJson(
    List<enums.ProjectCreationMetaResponseModelStatus>?
        projectCreationMetaResponseModelStatus) {
  return projectCreationMetaResponseModelStatus
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> projectCreationMetaResponseModelStatusListToJson(
    List<enums.ProjectCreationMetaResponseModelStatus>?
        projectCreationMetaResponseModelStatus) {
  if (projectCreationMetaResponseModelStatus == null) {
    return [];
  }

  return projectCreationMetaResponseModelStatus.map((e) => e.value!).toList();
}

List<enums.ProjectCreationMetaResponseModelStatus>
    projectCreationMetaResponseModelStatusListFromJson(
  List? projectCreationMetaResponseModelStatus, [
  List<enums.ProjectCreationMetaResponseModelStatus>? defaultValue,
]) {
  if (projectCreationMetaResponseModelStatus == null) {
    return defaultValue ?? [];
  }

  return projectCreationMetaResponseModelStatus
      .map((e) => projectCreationMetaResponseModelStatusFromJson(e.toString()))
      .toList();
}

List<enums.ProjectCreationMetaResponseModelStatus>?
    projectCreationMetaResponseModelStatusNullableListFromJson(
  List? projectCreationMetaResponseModelStatus, [
  List<enums.ProjectCreationMetaResponseModelStatus>? defaultValue,
]) {
  if (projectCreationMetaResponseModelStatus == null) {
    return defaultValue;
  }

  return projectCreationMetaResponseModelStatus
      .map((e) => projectCreationMetaResponseModelStatusFromJson(e.toString()))
      .toList();
}

String? projectCreationMetaResponseModelTypeNullableToJson(
    enums.ProjectCreationMetaResponseModelType?
        projectCreationMetaResponseModelType) {
  return projectCreationMetaResponseModelType?.value;
}

String? projectCreationMetaResponseModelTypeToJson(
    enums.ProjectCreationMetaResponseModelType
        projectCreationMetaResponseModelType) {
  return projectCreationMetaResponseModelType.value;
}

enums.ProjectCreationMetaResponseModelType
    projectCreationMetaResponseModelTypeFromJson(
  Object? projectCreationMetaResponseModelType, [
  enums.ProjectCreationMetaResponseModelType? defaultValue,
]) {
  return enums.ProjectCreationMetaResponseModelType.values.firstWhereOrNull(
          (e) => e.value == projectCreationMetaResponseModelType) ??
      defaultValue ??
      enums.ProjectCreationMetaResponseModelType.swaggerGeneratedUnknown;
}

enums.ProjectCreationMetaResponseModelType?
    projectCreationMetaResponseModelTypeNullableFromJson(
  Object? projectCreationMetaResponseModelType, [
  enums.ProjectCreationMetaResponseModelType? defaultValue,
]) {
  if (projectCreationMetaResponseModelType == null) {
    return null;
  }
  return enums.ProjectCreationMetaResponseModelType.values.firstWhereOrNull(
          (e) => e.value == projectCreationMetaResponseModelType) ??
      defaultValue;
}

String projectCreationMetaResponseModelTypeExplodedListToJson(
    List<enums.ProjectCreationMetaResponseModelType>?
        projectCreationMetaResponseModelType) {
  return projectCreationMetaResponseModelType?.map((e) => e.value!).join(',') ??
      '';
}

List<String> projectCreationMetaResponseModelTypeListToJson(
    List<enums.ProjectCreationMetaResponseModelType>?
        projectCreationMetaResponseModelType) {
  if (projectCreationMetaResponseModelType == null) {
    return [];
  }

  return projectCreationMetaResponseModelType.map((e) => e.value!).toList();
}

List<enums.ProjectCreationMetaResponseModelType>
    projectCreationMetaResponseModelTypeListFromJson(
  List? projectCreationMetaResponseModelType, [
  List<enums.ProjectCreationMetaResponseModelType>? defaultValue,
]) {
  if (projectCreationMetaResponseModelType == null) {
    return defaultValue ?? [];
  }

  return projectCreationMetaResponseModelType
      .map((e) => projectCreationMetaResponseModelTypeFromJson(e.toString()))
      .toList();
}

List<enums.ProjectCreationMetaResponseModelType>?
    projectCreationMetaResponseModelTypeNullableListFromJson(
  List? projectCreationMetaResponseModelType, [
  List<enums.ProjectCreationMetaResponseModelType>? defaultValue,
]) {
  if (projectCreationMetaResponseModelType == null) {
    return defaultValue;
  }

  return projectCreationMetaResponseModelType
      .map((e) => projectCreationMetaResponseModelTypeFromJson(e.toString()))
      .toList();
}

String? projectExtendedResponseModelStateNullableToJson(
    enums.ProjectExtendedResponseModelState?
        projectExtendedResponseModelState) {
  return projectExtendedResponseModelState?.value;
}

String? projectExtendedResponseModelStateToJson(
    enums.ProjectExtendedResponseModelState projectExtendedResponseModelState) {
  return projectExtendedResponseModelState.value;
}

enums.ProjectExtendedResponseModelState
    projectExtendedResponseModelStateFromJson(
  Object? projectExtendedResponseModelState, [
  enums.ProjectExtendedResponseModelState? defaultValue,
]) {
  return enums.ProjectExtendedResponseModelState.values.firstWhereOrNull(
          (e) => e.value == projectExtendedResponseModelState) ??
      defaultValue ??
      enums.ProjectExtendedResponseModelState.swaggerGeneratedUnknown;
}

enums.ProjectExtendedResponseModelState?
    projectExtendedResponseModelStateNullableFromJson(
  Object? projectExtendedResponseModelState, [
  enums.ProjectExtendedResponseModelState? defaultValue,
]) {
  if (projectExtendedResponseModelState == null) {
    return null;
  }
  return enums.ProjectExtendedResponseModelState.values.firstWhereOrNull(
          (e) => e.value == projectExtendedResponseModelState) ??
      defaultValue;
}

String projectExtendedResponseModelStateExplodedListToJson(
    List<enums.ProjectExtendedResponseModelState>?
        projectExtendedResponseModelState) {
  return projectExtendedResponseModelState?.map((e) => e.value!).join(',') ??
      '';
}

List<String> projectExtendedResponseModelStateListToJson(
    List<enums.ProjectExtendedResponseModelState>?
        projectExtendedResponseModelState) {
  if (projectExtendedResponseModelState == null) {
    return [];
  }

  return projectExtendedResponseModelState.map((e) => e.value!).toList();
}

List<enums.ProjectExtendedResponseModelState>
    projectExtendedResponseModelStateListFromJson(
  List? projectExtendedResponseModelState, [
  List<enums.ProjectExtendedResponseModelState>? defaultValue,
]) {
  if (projectExtendedResponseModelState == null) {
    return defaultValue ?? [];
  }

  return projectExtendedResponseModelState
      .map((e) => projectExtendedResponseModelStateFromJson(e.toString()))
      .toList();
}

List<enums.ProjectExtendedResponseModelState>?
    projectExtendedResponseModelStateNullableListFromJson(
  List? projectExtendedResponseModelState, [
  List<enums.ProjectExtendedResponseModelState>? defaultValue,
]) {
  if (projectExtendedResponseModelState == null) {
    return defaultValue;
  }

  return projectExtendedResponseModelState
      .map((e) => projectExtendedResponseModelStateFromJson(e.toString()))
      .toList();
}

String? projectExtendedResponseModelAccessLevelNullableToJson(
    enums.ProjectExtendedResponseModelAccessLevel?
        projectExtendedResponseModelAccessLevel) {
  return projectExtendedResponseModelAccessLevel?.value;
}

String? projectExtendedResponseModelAccessLevelToJson(
    enums.ProjectExtendedResponseModelAccessLevel
        projectExtendedResponseModelAccessLevel) {
  return projectExtendedResponseModelAccessLevel.value;
}

enums.ProjectExtendedResponseModelAccessLevel
    projectExtendedResponseModelAccessLevelFromJson(
  Object? projectExtendedResponseModelAccessLevel, [
  enums.ProjectExtendedResponseModelAccessLevel? defaultValue,
]) {
  return enums.ProjectExtendedResponseModelAccessLevel.values.firstWhereOrNull(
          (e) => e.value == projectExtendedResponseModelAccessLevel) ??
      defaultValue ??
      enums.ProjectExtendedResponseModelAccessLevel.swaggerGeneratedUnknown;
}

enums.ProjectExtendedResponseModelAccessLevel?
    projectExtendedResponseModelAccessLevelNullableFromJson(
  Object? projectExtendedResponseModelAccessLevel, [
  enums.ProjectExtendedResponseModelAccessLevel? defaultValue,
]) {
  if (projectExtendedResponseModelAccessLevel == null) {
    return null;
  }
  return enums.ProjectExtendedResponseModelAccessLevel.values.firstWhereOrNull(
          (e) => e.value == projectExtendedResponseModelAccessLevel) ??
      defaultValue;
}

String projectExtendedResponseModelAccessLevelExplodedListToJson(
    List<enums.ProjectExtendedResponseModelAccessLevel>?
        projectExtendedResponseModelAccessLevel) {
  return projectExtendedResponseModelAccessLevel
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> projectExtendedResponseModelAccessLevelListToJson(
    List<enums.ProjectExtendedResponseModelAccessLevel>?
        projectExtendedResponseModelAccessLevel) {
  if (projectExtendedResponseModelAccessLevel == null) {
    return [];
  }

  return projectExtendedResponseModelAccessLevel.map((e) => e.value!).toList();
}

List<enums.ProjectExtendedResponseModelAccessLevel>
    projectExtendedResponseModelAccessLevelListFromJson(
  List? projectExtendedResponseModelAccessLevel, [
  List<enums.ProjectExtendedResponseModelAccessLevel>? defaultValue,
]) {
  if (projectExtendedResponseModelAccessLevel == null) {
    return defaultValue ?? [];
  }

  return projectExtendedResponseModelAccessLevel
      .map((e) => projectExtendedResponseModelAccessLevelFromJson(e.toString()))
      .toList();
}

List<enums.ProjectExtendedResponseModelAccessLevel>?
    projectExtendedResponseModelAccessLevelNullableListFromJson(
  List? projectExtendedResponseModelAccessLevel, [
  List<enums.ProjectExtendedResponseModelAccessLevel>? defaultValue,
]) {
  if (projectExtendedResponseModelAccessLevel == null) {
    return defaultValue;
  }

  return projectExtendedResponseModelAccessLevel
      .map((e) => projectExtendedResponseModelAccessLevelFromJson(e.toString()))
      .toList();
}

String? projectExtendedResponseModelQualityPresetNullableToJson(
    enums.ProjectExtendedResponseModelQualityPreset?
        projectExtendedResponseModelQualityPreset) {
  return projectExtendedResponseModelQualityPreset?.value;
}

String? projectExtendedResponseModelQualityPresetToJson(
    enums.ProjectExtendedResponseModelQualityPreset
        projectExtendedResponseModelQualityPreset) {
  return projectExtendedResponseModelQualityPreset.value;
}

enums.ProjectExtendedResponseModelQualityPreset
    projectExtendedResponseModelQualityPresetFromJson(
  Object? projectExtendedResponseModelQualityPreset, [
  enums.ProjectExtendedResponseModelQualityPreset? defaultValue,
]) {
  return enums.ProjectExtendedResponseModelQualityPreset.values
          .firstWhereOrNull(
              (e) => e.value == projectExtendedResponseModelQualityPreset) ??
      defaultValue ??
      enums.ProjectExtendedResponseModelQualityPreset.swaggerGeneratedUnknown;
}

enums.ProjectExtendedResponseModelQualityPreset?
    projectExtendedResponseModelQualityPresetNullableFromJson(
  Object? projectExtendedResponseModelQualityPreset, [
  enums.ProjectExtendedResponseModelQualityPreset? defaultValue,
]) {
  if (projectExtendedResponseModelQualityPreset == null) {
    return null;
  }
  return enums.ProjectExtendedResponseModelQualityPreset.values
          .firstWhereOrNull(
              (e) => e.value == projectExtendedResponseModelQualityPreset) ??
      defaultValue;
}

String projectExtendedResponseModelQualityPresetExplodedListToJson(
    List<enums.ProjectExtendedResponseModelQualityPreset>?
        projectExtendedResponseModelQualityPreset) {
  return projectExtendedResponseModelQualityPreset
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> projectExtendedResponseModelQualityPresetListToJson(
    List<enums.ProjectExtendedResponseModelQualityPreset>?
        projectExtendedResponseModelQualityPreset) {
  if (projectExtendedResponseModelQualityPreset == null) {
    return [];
  }

  return projectExtendedResponseModelQualityPreset
      .map((e) => e.value!)
      .toList();
}

List<enums.ProjectExtendedResponseModelQualityPreset>
    projectExtendedResponseModelQualityPresetListFromJson(
  List? projectExtendedResponseModelQualityPreset, [
  List<enums.ProjectExtendedResponseModelQualityPreset>? defaultValue,
]) {
  if (projectExtendedResponseModelQualityPreset == null) {
    return defaultValue ?? [];
  }

  return projectExtendedResponseModelQualityPreset
      .map((e) =>
          projectExtendedResponseModelQualityPresetFromJson(e.toString()))
      .toList();
}

List<enums.ProjectExtendedResponseModelQualityPreset>?
    projectExtendedResponseModelQualityPresetNullableListFromJson(
  List? projectExtendedResponseModelQualityPreset, [
  List<enums.ProjectExtendedResponseModelQualityPreset>? defaultValue,
]) {
  if (projectExtendedResponseModelQualityPreset == null) {
    return defaultValue;
  }

  return projectExtendedResponseModelQualityPreset
      .map((e) =>
          projectExtendedResponseModelQualityPresetFromJson(e.toString()))
      .toList();
}

String? projectExtendedResponseModelApplyTextNormalizationNullableToJson(
    enums.ProjectExtendedResponseModelApplyTextNormalization?
        projectExtendedResponseModelApplyTextNormalization) {
  return projectExtendedResponseModelApplyTextNormalization?.value;
}

String? projectExtendedResponseModelApplyTextNormalizationToJson(
    enums.ProjectExtendedResponseModelApplyTextNormalization
        projectExtendedResponseModelApplyTextNormalization) {
  return projectExtendedResponseModelApplyTextNormalization.value;
}

enums.ProjectExtendedResponseModelApplyTextNormalization
    projectExtendedResponseModelApplyTextNormalizationFromJson(
  Object? projectExtendedResponseModelApplyTextNormalization, [
  enums.ProjectExtendedResponseModelApplyTextNormalization? defaultValue,
]) {
  return enums.ProjectExtendedResponseModelApplyTextNormalization.values
          .firstWhereOrNull((e) =>
              e.value == projectExtendedResponseModelApplyTextNormalization) ??
      defaultValue ??
      enums.ProjectExtendedResponseModelApplyTextNormalization
          .swaggerGeneratedUnknown;
}

enums.ProjectExtendedResponseModelApplyTextNormalization?
    projectExtendedResponseModelApplyTextNormalizationNullableFromJson(
  Object? projectExtendedResponseModelApplyTextNormalization, [
  enums.ProjectExtendedResponseModelApplyTextNormalization? defaultValue,
]) {
  if (projectExtendedResponseModelApplyTextNormalization == null) {
    return null;
  }
  return enums.ProjectExtendedResponseModelApplyTextNormalization.values
          .firstWhereOrNull((e) =>
              e.value == projectExtendedResponseModelApplyTextNormalization) ??
      defaultValue;
}

String projectExtendedResponseModelApplyTextNormalizationExplodedListToJson(
    List<enums.ProjectExtendedResponseModelApplyTextNormalization>?
        projectExtendedResponseModelApplyTextNormalization) {
  return projectExtendedResponseModelApplyTextNormalization
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> projectExtendedResponseModelApplyTextNormalizationListToJson(
    List<enums.ProjectExtendedResponseModelApplyTextNormalization>?
        projectExtendedResponseModelApplyTextNormalization) {
  if (projectExtendedResponseModelApplyTextNormalization == null) {
    return [];
  }

  return projectExtendedResponseModelApplyTextNormalization
      .map((e) => e.value!)
      .toList();
}

List<enums.ProjectExtendedResponseModelApplyTextNormalization>
    projectExtendedResponseModelApplyTextNormalizationListFromJson(
  List? projectExtendedResponseModelApplyTextNormalization, [
  List<enums.ProjectExtendedResponseModelApplyTextNormalization>? defaultValue,
]) {
  if (projectExtendedResponseModelApplyTextNormalization == null) {
    return defaultValue ?? [];
  }

  return projectExtendedResponseModelApplyTextNormalization
      .map((e) => projectExtendedResponseModelApplyTextNormalizationFromJson(
          e.toString()))
      .toList();
}

List<enums.ProjectExtendedResponseModelApplyTextNormalization>?
    projectExtendedResponseModelApplyTextNormalizationNullableListFromJson(
  List? projectExtendedResponseModelApplyTextNormalization, [
  List<enums.ProjectExtendedResponseModelApplyTextNormalization>? defaultValue,
]) {
  if (projectExtendedResponseModelApplyTextNormalization == null) {
    return defaultValue;
  }

  return projectExtendedResponseModelApplyTextNormalization
      .map((e) => projectExtendedResponseModelApplyTextNormalizationFromJson(
          e.toString()))
      .toList();
}

String? projectResponseModelStateNullableToJson(
    enums.ProjectResponseModelState? projectResponseModelState) {
  return projectResponseModelState?.value;
}

String? projectResponseModelStateToJson(
    enums.ProjectResponseModelState projectResponseModelState) {
  return projectResponseModelState.value;
}

enums.ProjectResponseModelState projectResponseModelStateFromJson(
  Object? projectResponseModelState, [
  enums.ProjectResponseModelState? defaultValue,
]) {
  return enums.ProjectResponseModelState.values
          .firstWhereOrNull((e) => e.value == projectResponseModelState) ??
      defaultValue ??
      enums.ProjectResponseModelState.swaggerGeneratedUnknown;
}

enums.ProjectResponseModelState? projectResponseModelStateNullableFromJson(
  Object? projectResponseModelState, [
  enums.ProjectResponseModelState? defaultValue,
]) {
  if (projectResponseModelState == null) {
    return null;
  }
  return enums.ProjectResponseModelState.values
          .firstWhereOrNull((e) => e.value == projectResponseModelState) ??
      defaultValue;
}

String projectResponseModelStateExplodedListToJson(
    List<enums.ProjectResponseModelState>? projectResponseModelState) {
  return projectResponseModelState?.map((e) => e.value!).join(',') ?? '';
}

List<String> projectResponseModelStateListToJson(
    List<enums.ProjectResponseModelState>? projectResponseModelState) {
  if (projectResponseModelState == null) {
    return [];
  }

  return projectResponseModelState.map((e) => e.value!).toList();
}

List<enums.ProjectResponseModelState> projectResponseModelStateListFromJson(
  List? projectResponseModelState, [
  List<enums.ProjectResponseModelState>? defaultValue,
]) {
  if (projectResponseModelState == null) {
    return defaultValue ?? [];
  }

  return projectResponseModelState
      .map((e) => projectResponseModelStateFromJson(e.toString()))
      .toList();
}

List<enums.ProjectResponseModelState>?
    projectResponseModelStateNullableListFromJson(
  List? projectResponseModelState, [
  List<enums.ProjectResponseModelState>? defaultValue,
]) {
  if (projectResponseModelState == null) {
    return defaultValue;
  }

  return projectResponseModelState
      .map((e) => projectResponseModelStateFromJson(e.toString()))
      .toList();
}

String? projectResponseModelAccessLevelNullableToJson(
    enums.ProjectResponseModelAccessLevel? projectResponseModelAccessLevel) {
  return projectResponseModelAccessLevel?.value;
}

String? projectResponseModelAccessLevelToJson(
    enums.ProjectResponseModelAccessLevel projectResponseModelAccessLevel) {
  return projectResponseModelAccessLevel.value;
}

enums.ProjectResponseModelAccessLevel projectResponseModelAccessLevelFromJson(
  Object? projectResponseModelAccessLevel, [
  enums.ProjectResponseModelAccessLevel? defaultValue,
]) {
  return enums.ProjectResponseModelAccessLevel.values.firstWhereOrNull(
          (e) => e.value == projectResponseModelAccessLevel) ??
      defaultValue ??
      enums.ProjectResponseModelAccessLevel.swaggerGeneratedUnknown;
}

enums.ProjectResponseModelAccessLevel?
    projectResponseModelAccessLevelNullableFromJson(
  Object? projectResponseModelAccessLevel, [
  enums.ProjectResponseModelAccessLevel? defaultValue,
]) {
  if (projectResponseModelAccessLevel == null) {
    return null;
  }
  return enums.ProjectResponseModelAccessLevel.values.firstWhereOrNull(
          (e) => e.value == projectResponseModelAccessLevel) ??
      defaultValue;
}

String projectResponseModelAccessLevelExplodedListToJson(
    List<enums.ProjectResponseModelAccessLevel>?
        projectResponseModelAccessLevel) {
  return projectResponseModelAccessLevel?.map((e) => e.value!).join(',') ?? '';
}

List<String> projectResponseModelAccessLevelListToJson(
    List<enums.ProjectResponseModelAccessLevel>?
        projectResponseModelAccessLevel) {
  if (projectResponseModelAccessLevel == null) {
    return [];
  }

  return projectResponseModelAccessLevel.map((e) => e.value!).toList();
}

List<enums.ProjectResponseModelAccessLevel>
    projectResponseModelAccessLevelListFromJson(
  List? projectResponseModelAccessLevel, [
  List<enums.ProjectResponseModelAccessLevel>? defaultValue,
]) {
  if (projectResponseModelAccessLevel == null) {
    return defaultValue ?? [];
  }

  return projectResponseModelAccessLevel
      .map((e) => projectResponseModelAccessLevelFromJson(e.toString()))
      .toList();
}

List<enums.ProjectResponseModelAccessLevel>?
    projectResponseModelAccessLevelNullableListFromJson(
  List? projectResponseModelAccessLevel, [
  List<enums.ProjectResponseModelAccessLevel>? defaultValue,
]) {
  if (projectResponseModelAccessLevel == null) {
    return defaultValue;
  }

  return projectResponseModelAccessLevel
      .map((e) => projectResponseModelAccessLevelFromJson(e.toString()))
      .toList();
}

String? rAGIndexStatusNullableToJson(enums.RAGIndexStatus? rAGIndexStatus) {
  return rAGIndexStatus?.value;
}

String? rAGIndexStatusToJson(enums.RAGIndexStatus rAGIndexStatus) {
  return rAGIndexStatus.value;
}

enums.RAGIndexStatus rAGIndexStatusFromJson(
  Object? rAGIndexStatus, [
  enums.RAGIndexStatus? defaultValue,
]) {
  return enums.RAGIndexStatus.values
          .firstWhereOrNull((e) => e.value == rAGIndexStatus) ??
      defaultValue ??
      enums.RAGIndexStatus.swaggerGeneratedUnknown;
}

enums.RAGIndexStatus? rAGIndexStatusNullableFromJson(
  Object? rAGIndexStatus, [
  enums.RAGIndexStatus? defaultValue,
]) {
  if (rAGIndexStatus == null) {
    return null;
  }
  return enums.RAGIndexStatus.values
          .firstWhereOrNull((e) => e.value == rAGIndexStatus) ??
      defaultValue;
}

String rAGIndexStatusExplodedListToJson(
    List<enums.RAGIndexStatus>? rAGIndexStatus) {
  return rAGIndexStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> rAGIndexStatusListToJson(
    List<enums.RAGIndexStatus>? rAGIndexStatus) {
  if (rAGIndexStatus == null) {
    return [];
  }

  return rAGIndexStatus.map((e) => e.value!).toList();
}

List<enums.RAGIndexStatus> rAGIndexStatusListFromJson(
  List? rAGIndexStatus, [
  List<enums.RAGIndexStatus>? defaultValue,
]) {
  if (rAGIndexStatus == null) {
    return defaultValue ?? [];
  }

  return rAGIndexStatus
      .map((e) => rAGIndexStatusFromJson(e.toString()))
      .toList();
}

List<enums.RAGIndexStatus>? rAGIndexStatusNullableListFromJson(
  List? rAGIndexStatus, [
  List<enums.RAGIndexStatus>? defaultValue,
]) {
  if (rAGIndexStatus == null) {
    return defaultValue;
  }

  return rAGIndexStatus
      .map((e) => rAGIndexStatusFromJson(e.toString()))
      .toList();
}

String? readerResourceResponseModelResourceTypeNullableToJson(
    enums.ReaderResourceResponseModelResourceType?
        readerResourceResponseModelResourceType) {
  return readerResourceResponseModelResourceType?.value;
}

String? readerResourceResponseModelResourceTypeToJson(
    enums.ReaderResourceResponseModelResourceType
        readerResourceResponseModelResourceType) {
  return readerResourceResponseModelResourceType.value;
}

enums.ReaderResourceResponseModelResourceType
    readerResourceResponseModelResourceTypeFromJson(
  Object? readerResourceResponseModelResourceType, [
  enums.ReaderResourceResponseModelResourceType? defaultValue,
]) {
  return enums.ReaderResourceResponseModelResourceType.values.firstWhereOrNull(
          (e) => e.value == readerResourceResponseModelResourceType) ??
      defaultValue ??
      enums.ReaderResourceResponseModelResourceType.swaggerGeneratedUnknown;
}

enums.ReaderResourceResponseModelResourceType?
    readerResourceResponseModelResourceTypeNullableFromJson(
  Object? readerResourceResponseModelResourceType, [
  enums.ReaderResourceResponseModelResourceType? defaultValue,
]) {
  if (readerResourceResponseModelResourceType == null) {
    return null;
  }
  return enums.ReaderResourceResponseModelResourceType.values.firstWhereOrNull(
          (e) => e.value == readerResourceResponseModelResourceType) ??
      defaultValue;
}

String readerResourceResponseModelResourceTypeExplodedListToJson(
    List<enums.ReaderResourceResponseModelResourceType>?
        readerResourceResponseModelResourceType) {
  return readerResourceResponseModelResourceType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> readerResourceResponseModelResourceTypeListToJson(
    List<enums.ReaderResourceResponseModelResourceType>?
        readerResourceResponseModelResourceType) {
  if (readerResourceResponseModelResourceType == null) {
    return [];
  }

  return readerResourceResponseModelResourceType.map((e) => e.value!).toList();
}

List<enums.ReaderResourceResponseModelResourceType>
    readerResourceResponseModelResourceTypeListFromJson(
  List? readerResourceResponseModelResourceType, [
  List<enums.ReaderResourceResponseModelResourceType>? defaultValue,
]) {
  if (readerResourceResponseModelResourceType == null) {
    return defaultValue ?? [];
  }

  return readerResourceResponseModelResourceType
      .map((e) => readerResourceResponseModelResourceTypeFromJson(e.toString()))
      .toList();
}

List<enums.ReaderResourceResponseModelResourceType>?
    readerResourceResponseModelResourceTypeNullableListFromJson(
  List? readerResourceResponseModelResourceType, [
  List<enums.ReaderResourceResponseModelResourceType>? defaultValue,
]) {
  if (readerResourceResponseModelResourceType == null) {
    return defaultValue;
  }

  return readerResourceResponseModelResourceType
      .map((e) => readerResourceResponseModelResourceTypeFromJson(e.toString()))
      .toList();
}

String? renderStatusNullableToJson(enums.RenderStatus? renderStatus) {
  return renderStatus?.value;
}

String? renderStatusToJson(enums.RenderStatus renderStatus) {
  return renderStatus.value;
}

enums.RenderStatus renderStatusFromJson(
  Object? renderStatus, [
  enums.RenderStatus? defaultValue,
]) {
  return enums.RenderStatus.values
          .firstWhereOrNull((e) => e.value == renderStatus) ??
      defaultValue ??
      enums.RenderStatus.swaggerGeneratedUnknown;
}

enums.RenderStatus? renderStatusNullableFromJson(
  Object? renderStatus, [
  enums.RenderStatus? defaultValue,
]) {
  if (renderStatus == null) {
    return null;
  }
  return enums.RenderStatus.values
          .firstWhereOrNull((e) => e.value == renderStatus) ??
      defaultValue;
}

String renderStatusExplodedListToJson(List<enums.RenderStatus>? renderStatus) {
  return renderStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> renderStatusListToJson(List<enums.RenderStatus>? renderStatus) {
  if (renderStatus == null) {
    return [];
  }

  return renderStatus.map((e) => e.value!).toList();
}

List<enums.RenderStatus> renderStatusListFromJson(
  List? renderStatus, [
  List<enums.RenderStatus>? defaultValue,
]) {
  if (renderStatus == null) {
    return defaultValue ?? [];
  }

  return renderStatus.map((e) => renderStatusFromJson(e.toString())).toList();
}

List<enums.RenderStatus>? renderStatusNullableListFromJson(
  List? renderStatus, [
  List<enums.RenderStatus>? defaultValue,
]) {
  if (renderStatus == null) {
    return defaultValue;
  }

  return renderStatus.map((e) => renderStatusFromJson(e.toString())).toList();
}

String? renderTypeNullableToJson(enums.RenderType? renderType) {
  return renderType?.value;
}

String? renderTypeToJson(enums.RenderType renderType) {
  return renderType.value;
}

enums.RenderType renderTypeFromJson(
  Object? renderType, [
  enums.RenderType? defaultValue,
]) {
  return enums.RenderType.values
          .firstWhereOrNull((e) => e.value == renderType) ??
      defaultValue ??
      enums.RenderType.swaggerGeneratedUnknown;
}

enums.RenderType? renderTypeNullableFromJson(
  Object? renderType, [
  enums.RenderType? defaultValue,
]) {
  if (renderType == null) {
    return null;
  }
  return enums.RenderType.values
          .firstWhereOrNull((e) => e.value == renderType) ??
      defaultValue;
}

String renderTypeExplodedListToJson(List<enums.RenderType>? renderType) {
  return renderType?.map((e) => e.value!).join(',') ?? '';
}

List<String> renderTypeListToJson(List<enums.RenderType>? renderType) {
  if (renderType == null) {
    return [];
  }

  return renderType.map((e) => e.value!).toList();
}

List<enums.RenderType> renderTypeListFromJson(
  List? renderType, [
  List<enums.RenderType>? defaultValue,
]) {
  if (renderType == null) {
    return defaultValue ?? [];
  }

  return renderType.map((e) => renderTypeFromJson(e.toString())).toList();
}

List<enums.RenderType>? renderTypeNullableListFromJson(
  List? renderType, [
  List<enums.RenderType>? defaultValue,
]) {
  if (renderType == null) {
    return defaultValue;
  }

  return renderType.map((e) => renderTypeFromJson(e.toString())).toList();
}

String? resourceAccessInfoRoleNullableToJson(
    enums.ResourceAccessInfoRole? resourceAccessInfoRole) {
  return resourceAccessInfoRole?.value;
}

String? resourceAccessInfoRoleToJson(
    enums.ResourceAccessInfoRole resourceAccessInfoRole) {
  return resourceAccessInfoRole.value;
}

enums.ResourceAccessInfoRole resourceAccessInfoRoleFromJson(
  Object? resourceAccessInfoRole, [
  enums.ResourceAccessInfoRole? defaultValue,
]) {
  return enums.ResourceAccessInfoRole.values
          .firstWhereOrNull((e) => e.value == resourceAccessInfoRole) ??
      defaultValue ??
      enums.ResourceAccessInfoRole.swaggerGeneratedUnknown;
}

enums.ResourceAccessInfoRole? resourceAccessInfoRoleNullableFromJson(
  Object? resourceAccessInfoRole, [
  enums.ResourceAccessInfoRole? defaultValue,
]) {
  if (resourceAccessInfoRole == null) {
    return null;
  }
  return enums.ResourceAccessInfoRole.values
          .firstWhereOrNull((e) => e.value == resourceAccessInfoRole) ??
      defaultValue;
}

String resourceAccessInfoRoleExplodedListToJson(
    List<enums.ResourceAccessInfoRole>? resourceAccessInfoRole) {
  return resourceAccessInfoRole?.map((e) => e.value!).join(',') ?? '';
}

List<String> resourceAccessInfoRoleListToJson(
    List<enums.ResourceAccessInfoRole>? resourceAccessInfoRole) {
  if (resourceAccessInfoRole == null) {
    return [];
  }

  return resourceAccessInfoRole.map((e) => e.value!).toList();
}

List<enums.ResourceAccessInfoRole> resourceAccessInfoRoleListFromJson(
  List? resourceAccessInfoRole, [
  List<enums.ResourceAccessInfoRole>? defaultValue,
]) {
  if (resourceAccessInfoRole == null) {
    return defaultValue ?? [];
  }

  return resourceAccessInfoRole
      .map((e) => resourceAccessInfoRoleFromJson(e.toString()))
      .toList();
}

List<enums.ResourceAccessInfoRole>? resourceAccessInfoRoleNullableListFromJson(
  List? resourceAccessInfoRole, [
  List<enums.ResourceAccessInfoRole>? defaultValue,
]) {
  if (resourceAccessInfoRole == null) {
    return defaultValue;
  }

  return resourceAccessInfoRole
      .map((e) => resourceAccessInfoRoleFromJson(e.toString()))
      .toList();
}

String? sIPMediaEncryptionEnumNullableToJson(
    enums.SIPMediaEncryptionEnum? sIPMediaEncryptionEnum) {
  return sIPMediaEncryptionEnum?.value;
}

String? sIPMediaEncryptionEnumToJson(
    enums.SIPMediaEncryptionEnum sIPMediaEncryptionEnum) {
  return sIPMediaEncryptionEnum.value;
}

enums.SIPMediaEncryptionEnum sIPMediaEncryptionEnumFromJson(
  Object? sIPMediaEncryptionEnum, [
  enums.SIPMediaEncryptionEnum? defaultValue,
]) {
  return enums.SIPMediaEncryptionEnum.values
          .firstWhereOrNull((e) => e.value == sIPMediaEncryptionEnum) ??
      defaultValue ??
      enums.SIPMediaEncryptionEnum.swaggerGeneratedUnknown;
}

enums.SIPMediaEncryptionEnum? sIPMediaEncryptionEnumNullableFromJson(
  Object? sIPMediaEncryptionEnum, [
  enums.SIPMediaEncryptionEnum? defaultValue,
]) {
  if (sIPMediaEncryptionEnum == null) {
    return null;
  }
  return enums.SIPMediaEncryptionEnum.values
          .firstWhereOrNull((e) => e.value == sIPMediaEncryptionEnum) ??
      defaultValue;
}

String sIPMediaEncryptionEnumExplodedListToJson(
    List<enums.SIPMediaEncryptionEnum>? sIPMediaEncryptionEnum) {
  return sIPMediaEncryptionEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> sIPMediaEncryptionEnumListToJson(
    List<enums.SIPMediaEncryptionEnum>? sIPMediaEncryptionEnum) {
  if (sIPMediaEncryptionEnum == null) {
    return [];
  }

  return sIPMediaEncryptionEnum.map((e) => e.value!).toList();
}

List<enums.SIPMediaEncryptionEnum> sIPMediaEncryptionEnumListFromJson(
  List? sIPMediaEncryptionEnum, [
  List<enums.SIPMediaEncryptionEnum>? defaultValue,
]) {
  if (sIPMediaEncryptionEnum == null) {
    return defaultValue ?? [];
  }

  return sIPMediaEncryptionEnum
      .map((e) => sIPMediaEncryptionEnumFromJson(e.toString()))
      .toList();
}

List<enums.SIPMediaEncryptionEnum>? sIPMediaEncryptionEnumNullableListFromJson(
  List? sIPMediaEncryptionEnum, [
  List<enums.SIPMediaEncryptionEnum>? defaultValue,
]) {
  if (sIPMediaEncryptionEnum == null) {
    return defaultValue;
  }

  return sIPMediaEncryptionEnum
      .map((e) => sIPMediaEncryptionEnumFromJson(e.toString()))
      .toList();
}

String? sIPTrunkTransportEnumNullableToJson(
    enums.SIPTrunkTransportEnum? sIPTrunkTransportEnum) {
  return sIPTrunkTransportEnum?.value;
}

String? sIPTrunkTransportEnumToJson(
    enums.SIPTrunkTransportEnum sIPTrunkTransportEnum) {
  return sIPTrunkTransportEnum.value;
}

enums.SIPTrunkTransportEnum sIPTrunkTransportEnumFromJson(
  Object? sIPTrunkTransportEnum, [
  enums.SIPTrunkTransportEnum? defaultValue,
]) {
  return enums.SIPTrunkTransportEnum.values
          .firstWhereOrNull((e) => e.value == sIPTrunkTransportEnum) ??
      defaultValue ??
      enums.SIPTrunkTransportEnum.swaggerGeneratedUnknown;
}

enums.SIPTrunkTransportEnum? sIPTrunkTransportEnumNullableFromJson(
  Object? sIPTrunkTransportEnum, [
  enums.SIPTrunkTransportEnum? defaultValue,
]) {
  if (sIPTrunkTransportEnum == null) {
    return null;
  }
  return enums.SIPTrunkTransportEnum.values
          .firstWhereOrNull((e) => e.value == sIPTrunkTransportEnum) ??
      defaultValue;
}

String sIPTrunkTransportEnumExplodedListToJson(
    List<enums.SIPTrunkTransportEnum>? sIPTrunkTransportEnum) {
  return sIPTrunkTransportEnum?.map((e) => e.value!).join(',') ?? '';
}

List<String> sIPTrunkTransportEnumListToJson(
    List<enums.SIPTrunkTransportEnum>? sIPTrunkTransportEnum) {
  if (sIPTrunkTransportEnum == null) {
    return [];
  }

  return sIPTrunkTransportEnum.map((e) => e.value!).toList();
}

List<enums.SIPTrunkTransportEnum> sIPTrunkTransportEnumListFromJson(
  List? sIPTrunkTransportEnum, [
  List<enums.SIPTrunkTransportEnum>? defaultValue,
]) {
  if (sIPTrunkTransportEnum == null) {
    return defaultValue ?? [];
  }

  return sIPTrunkTransportEnum
      .map((e) => sIPTrunkTransportEnumFromJson(e.toString()))
      .toList();
}

List<enums.SIPTrunkTransportEnum>? sIPTrunkTransportEnumNullableListFromJson(
  List? sIPTrunkTransportEnum, [
  List<enums.SIPTrunkTransportEnum>? defaultValue,
]) {
  if (sIPTrunkTransportEnum == null) {
    return defaultValue;
  }

  return sIPTrunkTransportEnum
      .map((e) => sIPTrunkTransportEnumFromJson(e.toString()))
      .toList();
}

String? safetyRuleNullableToJson(enums.SafetyRule? safetyRule) {
  return safetyRule?.value;
}

String? safetyRuleToJson(enums.SafetyRule safetyRule) {
  return safetyRule.value;
}

enums.SafetyRule safetyRuleFromJson(
  Object? safetyRule, [
  enums.SafetyRule? defaultValue,
]) {
  return enums.SafetyRule.values
          .firstWhereOrNull((e) => e.value == safetyRule) ??
      defaultValue ??
      enums.SafetyRule.swaggerGeneratedUnknown;
}

enums.SafetyRule? safetyRuleNullableFromJson(
  Object? safetyRule, [
  enums.SafetyRule? defaultValue,
]) {
  if (safetyRule == null) {
    return null;
  }
  return enums.SafetyRule.values
          .firstWhereOrNull((e) => e.value == safetyRule) ??
      defaultValue;
}

String safetyRuleExplodedListToJson(List<enums.SafetyRule>? safetyRule) {
  return safetyRule?.map((e) => e.value!).join(',') ?? '';
}

List<String> safetyRuleListToJson(List<enums.SafetyRule>? safetyRule) {
  if (safetyRule == null) {
    return [];
  }

  return safetyRule.map((e) => e.value!).toList();
}

List<enums.SafetyRule> safetyRuleListFromJson(
  List? safetyRule, [
  List<enums.SafetyRule>? defaultValue,
]) {
  if (safetyRule == null) {
    return defaultValue ?? [];
  }

  return safetyRule.map((e) => safetyRuleFromJson(e.toString())).toList();
}

List<enums.SafetyRule>? safetyRuleNullableListFromJson(
  List? safetyRule, [
  List<enums.SafetyRule>? defaultValue,
]) {
  if (safetyRule == null) {
    return defaultValue;
  }

  return safetyRule.map((e) => safetyRuleFromJson(e.toString())).toList();
}

String? secretDependencyTypeNullableToJson(
    enums.SecretDependencyType? secretDependencyType) {
  return secretDependencyType?.value;
}

String? secretDependencyTypeToJson(
    enums.SecretDependencyType secretDependencyType) {
  return secretDependencyType.value;
}

enums.SecretDependencyType secretDependencyTypeFromJson(
  Object? secretDependencyType, [
  enums.SecretDependencyType? defaultValue,
]) {
  return enums.SecretDependencyType.values
          .firstWhereOrNull((e) => e.value == secretDependencyType) ??
      defaultValue ??
      enums.SecretDependencyType.swaggerGeneratedUnknown;
}

enums.SecretDependencyType? secretDependencyTypeNullableFromJson(
  Object? secretDependencyType, [
  enums.SecretDependencyType? defaultValue,
]) {
  if (secretDependencyType == null) {
    return null;
  }
  return enums.SecretDependencyType.values
          .firstWhereOrNull((e) => e.value == secretDependencyType) ??
      defaultValue;
}

String secretDependencyTypeExplodedListToJson(
    List<enums.SecretDependencyType>? secretDependencyType) {
  return secretDependencyType?.map((e) => e.value!).join(',') ?? '';
}

List<String> secretDependencyTypeListToJson(
    List<enums.SecretDependencyType>? secretDependencyType) {
  if (secretDependencyType == null) {
    return [];
  }

  return secretDependencyType.map((e) => e.value!).toList();
}

List<enums.SecretDependencyType> secretDependencyTypeListFromJson(
  List? secretDependencyType, [
  List<enums.SecretDependencyType>? defaultValue,
]) {
  if (secretDependencyType == null) {
    return defaultValue ?? [];
  }

  return secretDependencyType
      .map((e) => secretDependencyTypeFromJson(e.toString()))
      .toList();
}

List<enums.SecretDependencyType>? secretDependencyTypeNullableListFromJson(
  List? secretDependencyType, [
  List<enums.SecretDependencyType>? defaultValue,
]) {
  if (secretDependencyType == null) {
    return defaultValue;
  }

  return secretDependencyType
      .map((e) => secretDependencyTypeFromJson(e.toString()))
      .toList();
}

String? shareOptionResponseModelTypeNullableToJson(
    enums.ShareOptionResponseModelType? shareOptionResponseModelType) {
  return shareOptionResponseModelType?.value;
}

String? shareOptionResponseModelTypeToJson(
    enums.ShareOptionResponseModelType shareOptionResponseModelType) {
  return shareOptionResponseModelType.value;
}

enums.ShareOptionResponseModelType shareOptionResponseModelTypeFromJson(
  Object? shareOptionResponseModelType, [
  enums.ShareOptionResponseModelType? defaultValue,
]) {
  return enums.ShareOptionResponseModelType.values
          .firstWhereOrNull((e) => e.value == shareOptionResponseModelType) ??
      defaultValue ??
      enums.ShareOptionResponseModelType.swaggerGeneratedUnknown;
}

enums.ShareOptionResponseModelType?
    shareOptionResponseModelTypeNullableFromJson(
  Object? shareOptionResponseModelType, [
  enums.ShareOptionResponseModelType? defaultValue,
]) {
  if (shareOptionResponseModelType == null) {
    return null;
  }
  return enums.ShareOptionResponseModelType.values
          .firstWhereOrNull((e) => e.value == shareOptionResponseModelType) ??
      defaultValue;
}

String shareOptionResponseModelTypeExplodedListToJson(
    List<enums.ShareOptionResponseModelType>? shareOptionResponseModelType) {
  return shareOptionResponseModelType?.map((e) => e.value!).join(',') ?? '';
}

List<String> shareOptionResponseModelTypeListToJson(
    List<enums.ShareOptionResponseModelType>? shareOptionResponseModelType) {
  if (shareOptionResponseModelType == null) {
    return [];
  }

  return shareOptionResponseModelType.map((e) => e.value!).toList();
}

List<enums.ShareOptionResponseModelType>
    shareOptionResponseModelTypeListFromJson(
  List? shareOptionResponseModelType, [
  List<enums.ShareOptionResponseModelType>? defaultValue,
]) {
  if (shareOptionResponseModelType == null) {
    return defaultValue ?? [];
  }

  return shareOptionResponseModelType
      .map((e) => shareOptionResponseModelTypeFromJson(e.toString()))
      .toList();
}

List<enums.ShareOptionResponseModelType>?
    shareOptionResponseModelTypeNullableListFromJson(
  List? shareOptionResponseModelType, [
  List<enums.ShareOptionResponseModelType>? defaultValue,
]) {
  if (shareOptionResponseModelType == null) {
    return defaultValue;
  }

  return shareOptionResponseModelType
      .map((e) => shareOptionResponseModelTypeFromJson(e.toString()))
      .toList();
}

String? similarVoiceCategoryNullableToJson(
    enums.SimilarVoiceCategory? similarVoiceCategory) {
  return similarVoiceCategory?.value;
}

String? similarVoiceCategoryToJson(
    enums.SimilarVoiceCategory similarVoiceCategory) {
  return similarVoiceCategory.value;
}

enums.SimilarVoiceCategory similarVoiceCategoryFromJson(
  Object? similarVoiceCategory, [
  enums.SimilarVoiceCategory? defaultValue,
]) {
  return enums.SimilarVoiceCategory.values
          .firstWhereOrNull((e) => e.value == similarVoiceCategory) ??
      defaultValue ??
      enums.SimilarVoiceCategory.swaggerGeneratedUnknown;
}

enums.SimilarVoiceCategory? similarVoiceCategoryNullableFromJson(
  Object? similarVoiceCategory, [
  enums.SimilarVoiceCategory? defaultValue,
]) {
  if (similarVoiceCategory == null) {
    return null;
  }
  return enums.SimilarVoiceCategory.values
          .firstWhereOrNull((e) => e.value == similarVoiceCategory) ??
      defaultValue;
}

String similarVoiceCategoryExplodedListToJson(
    List<enums.SimilarVoiceCategory>? similarVoiceCategory) {
  return similarVoiceCategory?.map((e) => e.value!).join(',') ?? '';
}

List<String> similarVoiceCategoryListToJson(
    List<enums.SimilarVoiceCategory>? similarVoiceCategory) {
  if (similarVoiceCategory == null) {
    return [];
  }

  return similarVoiceCategory.map((e) => e.value!).toList();
}

List<enums.SimilarVoiceCategory> similarVoiceCategoryListFromJson(
  List? similarVoiceCategory, [
  List<enums.SimilarVoiceCategory>? defaultValue,
]) {
  if (similarVoiceCategory == null) {
    return defaultValue ?? [];
  }

  return similarVoiceCategory
      .map((e) => similarVoiceCategoryFromJson(e.toString()))
      .toList();
}

List<enums.SimilarVoiceCategory>? similarVoiceCategoryNullableListFromJson(
  List? similarVoiceCategory, [
  List<enums.SimilarVoiceCategory>? defaultValue,
]) {
  if (similarVoiceCategory == null) {
    return defaultValue;
  }

  return similarVoiceCategory
      .map((e) => similarVoiceCategoryFromJson(e.toString()))
      .toList();
}

String? speakerSeparationResponseModelStatusNullableToJson(
    enums.SpeakerSeparationResponseModelStatus?
        speakerSeparationResponseModelStatus) {
  return speakerSeparationResponseModelStatus?.value;
}

String? speakerSeparationResponseModelStatusToJson(
    enums.SpeakerSeparationResponseModelStatus
        speakerSeparationResponseModelStatus) {
  return speakerSeparationResponseModelStatus.value;
}

enums.SpeakerSeparationResponseModelStatus
    speakerSeparationResponseModelStatusFromJson(
  Object? speakerSeparationResponseModelStatus, [
  enums.SpeakerSeparationResponseModelStatus? defaultValue,
]) {
  return enums.SpeakerSeparationResponseModelStatus.values.firstWhereOrNull(
          (e) => e.value == speakerSeparationResponseModelStatus) ??
      defaultValue ??
      enums.SpeakerSeparationResponseModelStatus.swaggerGeneratedUnknown;
}

enums.SpeakerSeparationResponseModelStatus?
    speakerSeparationResponseModelStatusNullableFromJson(
  Object? speakerSeparationResponseModelStatus, [
  enums.SpeakerSeparationResponseModelStatus? defaultValue,
]) {
  if (speakerSeparationResponseModelStatus == null) {
    return null;
  }
  return enums.SpeakerSeparationResponseModelStatus.values.firstWhereOrNull(
          (e) => e.value == speakerSeparationResponseModelStatus) ??
      defaultValue;
}

String speakerSeparationResponseModelStatusExplodedListToJson(
    List<enums.SpeakerSeparationResponseModelStatus>?
        speakerSeparationResponseModelStatus) {
  return speakerSeparationResponseModelStatus?.map((e) => e.value!).join(',') ??
      '';
}

List<String> speakerSeparationResponseModelStatusListToJson(
    List<enums.SpeakerSeparationResponseModelStatus>?
        speakerSeparationResponseModelStatus) {
  if (speakerSeparationResponseModelStatus == null) {
    return [];
  }

  return speakerSeparationResponseModelStatus.map((e) => e.value!).toList();
}

List<enums.SpeakerSeparationResponseModelStatus>
    speakerSeparationResponseModelStatusListFromJson(
  List? speakerSeparationResponseModelStatus, [
  List<enums.SpeakerSeparationResponseModelStatus>? defaultValue,
]) {
  if (speakerSeparationResponseModelStatus == null) {
    return defaultValue ?? [];
  }

  return speakerSeparationResponseModelStatus
      .map((e) => speakerSeparationResponseModelStatusFromJson(e.toString()))
      .toList();
}

List<enums.SpeakerSeparationResponseModelStatus>?
    speakerSeparationResponseModelStatusNullableListFromJson(
  List? speakerSeparationResponseModelStatus, [
  List<enums.SpeakerSeparationResponseModelStatus>? defaultValue,
]) {
  if (speakerSeparationResponseModelStatus == null) {
    return defaultValue;
  }

  return speakerSeparationResponseModelStatus
      .map((e) => speakerSeparationResponseModelStatusFromJson(e.toString()))
      .toList();
}

String? speechHistoryItemResponseModelStateNullableToJson(
    enums.SpeechHistoryItemResponseModelState?
        speechHistoryItemResponseModelState) {
  return speechHistoryItemResponseModelState?.value;
}

String? speechHistoryItemResponseModelStateToJson(
    enums.SpeechHistoryItemResponseModelState
        speechHistoryItemResponseModelState) {
  return speechHistoryItemResponseModelState.value;
}

enums.SpeechHistoryItemResponseModelState
    speechHistoryItemResponseModelStateFromJson(
  Object? speechHistoryItemResponseModelState, [
  enums.SpeechHistoryItemResponseModelState? defaultValue,
]) {
  return enums.SpeechHistoryItemResponseModelState.values.firstWhereOrNull(
          (e) => e.value == speechHistoryItemResponseModelState) ??
      defaultValue ??
      enums.SpeechHistoryItemResponseModelState.swaggerGeneratedUnknown;
}

enums.SpeechHistoryItemResponseModelState?
    speechHistoryItemResponseModelStateNullableFromJson(
  Object? speechHistoryItemResponseModelState, [
  enums.SpeechHistoryItemResponseModelState? defaultValue,
]) {
  if (speechHistoryItemResponseModelState == null) {
    return null;
  }
  return enums.SpeechHistoryItemResponseModelState.values.firstWhereOrNull(
          (e) => e.value == speechHistoryItemResponseModelState) ??
      defaultValue;
}

String speechHistoryItemResponseModelStateExplodedListToJson(
    List<enums.SpeechHistoryItemResponseModelState>?
        speechHistoryItemResponseModelState) {
  return speechHistoryItemResponseModelState?.map((e) => e.value!).join(',') ??
      '';
}

List<String> speechHistoryItemResponseModelStateListToJson(
    List<enums.SpeechHistoryItemResponseModelState>?
        speechHistoryItemResponseModelState) {
  if (speechHistoryItemResponseModelState == null) {
    return [];
  }

  return speechHistoryItemResponseModelState.map((e) => e.value!).toList();
}

List<enums.SpeechHistoryItemResponseModelState>
    speechHistoryItemResponseModelStateListFromJson(
  List? speechHistoryItemResponseModelState, [
  List<enums.SpeechHistoryItemResponseModelState>? defaultValue,
]) {
  if (speechHistoryItemResponseModelState == null) {
    return defaultValue ?? [];
  }

  return speechHistoryItemResponseModelState
      .map((e) => speechHistoryItemResponseModelStateFromJson(e.toString()))
      .toList();
}

List<enums.SpeechHistoryItemResponseModelState>?
    speechHistoryItemResponseModelStateNullableListFromJson(
  List? speechHistoryItemResponseModelState, [
  List<enums.SpeechHistoryItemResponseModelState>? defaultValue,
]) {
  if (speechHistoryItemResponseModelState == null) {
    return defaultValue;
  }

  return speechHistoryItemResponseModelState
      .map((e) => speechHistoryItemResponseModelStateFromJson(e.toString()))
      .toList();
}

String? speechToTextWordResponseModelTypeNullableToJson(
    enums.SpeechToTextWordResponseModelType?
        speechToTextWordResponseModelType) {
  return speechToTextWordResponseModelType?.value;
}

String? speechToTextWordResponseModelTypeToJson(
    enums.SpeechToTextWordResponseModelType speechToTextWordResponseModelType) {
  return speechToTextWordResponseModelType.value;
}

enums.SpeechToTextWordResponseModelType
    speechToTextWordResponseModelTypeFromJson(
  Object? speechToTextWordResponseModelType, [
  enums.SpeechToTextWordResponseModelType? defaultValue,
]) {
  return enums.SpeechToTextWordResponseModelType.values.firstWhereOrNull(
          (e) => e.value == speechToTextWordResponseModelType) ??
      defaultValue ??
      enums.SpeechToTextWordResponseModelType.swaggerGeneratedUnknown;
}

enums.SpeechToTextWordResponseModelType?
    speechToTextWordResponseModelTypeNullableFromJson(
  Object? speechToTextWordResponseModelType, [
  enums.SpeechToTextWordResponseModelType? defaultValue,
]) {
  if (speechToTextWordResponseModelType == null) {
    return null;
  }
  return enums.SpeechToTextWordResponseModelType.values.firstWhereOrNull(
          (e) => e.value == speechToTextWordResponseModelType) ??
      defaultValue;
}

String speechToTextWordResponseModelTypeExplodedListToJson(
    List<enums.SpeechToTextWordResponseModelType>?
        speechToTextWordResponseModelType) {
  return speechToTextWordResponseModelType?.map((e) => e.value!).join(',') ??
      '';
}

List<String> speechToTextWordResponseModelTypeListToJson(
    List<enums.SpeechToTextWordResponseModelType>?
        speechToTextWordResponseModelType) {
  if (speechToTextWordResponseModelType == null) {
    return [];
  }

  return speechToTextWordResponseModelType.map((e) => e.value!).toList();
}

List<enums.SpeechToTextWordResponseModelType>
    speechToTextWordResponseModelTypeListFromJson(
  List? speechToTextWordResponseModelType, [
  List<enums.SpeechToTextWordResponseModelType>? defaultValue,
]) {
  if (speechToTextWordResponseModelType == null) {
    return defaultValue ?? [];
  }

  return speechToTextWordResponseModelType
      .map((e) => speechToTextWordResponseModelTypeFromJson(e.toString()))
      .toList();
}

List<enums.SpeechToTextWordResponseModelType>?
    speechToTextWordResponseModelTypeNullableListFromJson(
  List? speechToTextWordResponseModelType, [
  List<enums.SpeechToTextWordResponseModelType>? defaultValue,
]) {
  if (speechToTextWordResponseModelType == null) {
    return defaultValue;
  }

  return speechToTextWordResponseModelType
      .map((e) => speechToTextWordResponseModelTypeFromJson(e.toString()))
      .toList();
}

String? subscriptionResponseModelStatusNullableToJson(
    enums.SubscriptionResponseModelStatus? subscriptionResponseModelStatus) {
  return subscriptionResponseModelStatus?.value;
}

String? subscriptionResponseModelStatusToJson(
    enums.SubscriptionResponseModelStatus subscriptionResponseModelStatus) {
  return subscriptionResponseModelStatus.value;
}

enums.SubscriptionResponseModelStatus subscriptionResponseModelStatusFromJson(
  Object? subscriptionResponseModelStatus, [
  enums.SubscriptionResponseModelStatus? defaultValue,
]) {
  return enums.SubscriptionResponseModelStatus.values.firstWhereOrNull(
          (e) => e.value == subscriptionResponseModelStatus) ??
      defaultValue ??
      enums.SubscriptionResponseModelStatus.swaggerGeneratedUnknown;
}

enums.SubscriptionResponseModelStatus?
    subscriptionResponseModelStatusNullableFromJson(
  Object? subscriptionResponseModelStatus, [
  enums.SubscriptionResponseModelStatus? defaultValue,
]) {
  if (subscriptionResponseModelStatus == null) {
    return null;
  }
  return enums.SubscriptionResponseModelStatus.values.firstWhereOrNull(
          (e) => e.value == subscriptionResponseModelStatus) ??
      defaultValue;
}

String subscriptionResponseModelStatusExplodedListToJson(
    List<enums.SubscriptionResponseModelStatus>?
        subscriptionResponseModelStatus) {
  return subscriptionResponseModelStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> subscriptionResponseModelStatusListToJson(
    List<enums.SubscriptionResponseModelStatus>?
        subscriptionResponseModelStatus) {
  if (subscriptionResponseModelStatus == null) {
    return [];
  }

  return subscriptionResponseModelStatus.map((e) => e.value!).toList();
}

List<enums.SubscriptionResponseModelStatus>
    subscriptionResponseModelStatusListFromJson(
  List? subscriptionResponseModelStatus, [
  List<enums.SubscriptionResponseModelStatus>? defaultValue,
]) {
  if (subscriptionResponseModelStatus == null) {
    return defaultValue ?? [];
  }

  return subscriptionResponseModelStatus
      .map((e) => subscriptionResponseModelStatusFromJson(e.toString()))
      .toList();
}

List<enums.SubscriptionResponseModelStatus>?
    subscriptionResponseModelStatusNullableListFromJson(
  List? subscriptionResponseModelStatus, [
  List<enums.SubscriptionResponseModelStatus>? defaultValue,
]) {
  if (subscriptionResponseModelStatus == null) {
    return defaultValue;
  }

  return subscriptionResponseModelStatus
      .map((e) => subscriptionResponseModelStatusFromJson(e.toString()))
      .toList();
}

String? tTSConversationalModelNullableToJson(
    enums.TTSConversationalModel? tTSConversationalModel) {
  return tTSConversationalModel?.value;
}

String? tTSConversationalModelToJson(
    enums.TTSConversationalModel tTSConversationalModel) {
  return tTSConversationalModel.value;
}

enums.TTSConversationalModel tTSConversationalModelFromJson(
  Object? tTSConversationalModel, [
  enums.TTSConversationalModel? defaultValue,
]) {
  return enums.TTSConversationalModel.values
          .firstWhereOrNull((e) => e.value == tTSConversationalModel) ??
      defaultValue ??
      enums.TTSConversationalModel.swaggerGeneratedUnknown;
}

enums.TTSConversationalModel? tTSConversationalModelNullableFromJson(
  Object? tTSConversationalModel, [
  enums.TTSConversationalModel? defaultValue,
]) {
  if (tTSConversationalModel == null) {
    return null;
  }
  return enums.TTSConversationalModel.values
          .firstWhereOrNull((e) => e.value == tTSConversationalModel) ??
      defaultValue;
}

String tTSConversationalModelExplodedListToJson(
    List<enums.TTSConversationalModel>? tTSConversationalModel) {
  return tTSConversationalModel?.map((e) => e.value!).join(',') ?? '';
}

List<String> tTSConversationalModelListToJson(
    List<enums.TTSConversationalModel>? tTSConversationalModel) {
  if (tTSConversationalModel == null) {
    return [];
  }

  return tTSConversationalModel.map((e) => e.value!).toList();
}

List<enums.TTSConversationalModel> tTSConversationalModelListFromJson(
  List? tTSConversationalModel, [
  List<enums.TTSConversationalModel>? defaultValue,
]) {
  if (tTSConversationalModel == null) {
    return defaultValue ?? [];
  }

  return tTSConversationalModel
      .map((e) => tTSConversationalModelFromJson(e.toString()))
      .toList();
}

List<enums.TTSConversationalModel>? tTSConversationalModelNullableListFromJson(
  List? tTSConversationalModel, [
  List<enums.TTSConversationalModel>? defaultValue,
]) {
  if (tTSConversationalModel == null) {
    return defaultValue;
  }

  return tTSConversationalModel
      .map((e) => tTSConversationalModelFromJson(e.toString()))
      .toList();
}

int? tTSOptimizeStreamingLatencyNullableToJson(
    enums.TTSOptimizeStreamingLatency? tTSOptimizeStreamingLatency) {
  return tTSOptimizeStreamingLatency?.value;
}

int? tTSOptimizeStreamingLatencyToJson(
    enums.TTSOptimizeStreamingLatency tTSOptimizeStreamingLatency) {
  return tTSOptimizeStreamingLatency.value;
}

enums.TTSOptimizeStreamingLatency tTSOptimizeStreamingLatencyFromJson(
  Object? tTSOptimizeStreamingLatency, [
  enums.TTSOptimizeStreamingLatency? defaultValue,
]) {
  return enums.TTSOptimizeStreamingLatency.values
          .firstWhereOrNull((e) => e.value == tTSOptimizeStreamingLatency) ??
      defaultValue ??
      enums.TTSOptimizeStreamingLatency.swaggerGeneratedUnknown;
}

enums.TTSOptimizeStreamingLatency? tTSOptimizeStreamingLatencyNullableFromJson(
  Object? tTSOptimizeStreamingLatency, [
  enums.TTSOptimizeStreamingLatency? defaultValue,
]) {
  if (tTSOptimizeStreamingLatency == null) {
    return null;
  }
  return enums.TTSOptimizeStreamingLatency.values
          .firstWhereOrNull((e) => e.value == tTSOptimizeStreamingLatency) ??
      defaultValue;
}

String tTSOptimizeStreamingLatencyExplodedListToJson(
    List<enums.TTSOptimizeStreamingLatency>? tTSOptimizeStreamingLatency) {
  return tTSOptimizeStreamingLatency?.map((e) => e.value!).join(',') ?? '';
}

List<int> tTSOptimizeStreamingLatencyListToJson(
    List<enums.TTSOptimizeStreamingLatency>? tTSOptimizeStreamingLatency) {
  if (tTSOptimizeStreamingLatency == null) {
    return [];
  }

  return tTSOptimizeStreamingLatency.map((e) => e.value!).toList();
}

List<enums.TTSOptimizeStreamingLatency> tTSOptimizeStreamingLatencyListFromJson(
  List? tTSOptimizeStreamingLatency, [
  List<enums.TTSOptimizeStreamingLatency>? defaultValue,
]) {
  if (tTSOptimizeStreamingLatency == null) {
    return defaultValue ?? [];
  }

  return tTSOptimizeStreamingLatency
      .map((e) => tTSOptimizeStreamingLatencyFromJson(e.toString()))
      .toList();
}

List<enums.TTSOptimizeStreamingLatency>?
    tTSOptimizeStreamingLatencyNullableListFromJson(
  List? tTSOptimizeStreamingLatency, [
  List<enums.TTSOptimizeStreamingLatency>? defaultValue,
]) {
  if (tTSOptimizeStreamingLatency == null) {
    return defaultValue;
  }

  return tTSOptimizeStreamingLatency
      .map((e) => tTSOptimizeStreamingLatencyFromJson(e.toString()))
      .toList();
}

String? tTSOutputFormatNullableToJson(enums.TTSOutputFormat? tTSOutputFormat) {
  return tTSOutputFormat?.value;
}

String? tTSOutputFormatToJson(enums.TTSOutputFormat tTSOutputFormat) {
  return tTSOutputFormat.value;
}

enums.TTSOutputFormat tTSOutputFormatFromJson(
  Object? tTSOutputFormat, [
  enums.TTSOutputFormat? defaultValue,
]) {
  return enums.TTSOutputFormat.values
          .firstWhereOrNull((e) => e.value == tTSOutputFormat) ??
      defaultValue ??
      enums.TTSOutputFormat.swaggerGeneratedUnknown;
}

enums.TTSOutputFormat? tTSOutputFormatNullableFromJson(
  Object? tTSOutputFormat, [
  enums.TTSOutputFormat? defaultValue,
]) {
  if (tTSOutputFormat == null) {
    return null;
  }
  return enums.TTSOutputFormat.values
          .firstWhereOrNull((e) => e.value == tTSOutputFormat) ??
      defaultValue;
}

String tTSOutputFormatExplodedListToJson(
    List<enums.TTSOutputFormat>? tTSOutputFormat) {
  return tTSOutputFormat?.map((e) => e.value!).join(',') ?? '';
}

List<String> tTSOutputFormatListToJson(
    List<enums.TTSOutputFormat>? tTSOutputFormat) {
  if (tTSOutputFormat == null) {
    return [];
  }

  return tTSOutputFormat.map((e) => e.value!).toList();
}

List<enums.TTSOutputFormat> tTSOutputFormatListFromJson(
  List? tTSOutputFormat, [
  List<enums.TTSOutputFormat>? defaultValue,
]) {
  if (tTSOutputFormat == null) {
    return defaultValue ?? [];
  }

  return tTSOutputFormat
      .map((e) => tTSOutputFormatFromJson(e.toString()))
      .toList();
}

List<enums.TTSOutputFormat>? tTSOutputFormatNullableListFromJson(
  List? tTSOutputFormat, [
  List<enums.TTSOutputFormat>? defaultValue,
]) {
  if (tTSOutputFormat == null) {
    return defaultValue;
  }

  return tTSOutputFormat
      .map((e) => tTSOutputFormatFromJson(e.toString()))
      .toList();
}

String? telephonyProviderNullableToJson(
    enums.TelephonyProvider? telephonyProvider) {
  return telephonyProvider?.value;
}

String? telephonyProviderToJson(enums.TelephonyProvider telephonyProvider) {
  return telephonyProvider.value;
}

enums.TelephonyProvider telephonyProviderFromJson(
  Object? telephonyProvider, [
  enums.TelephonyProvider? defaultValue,
]) {
  return enums.TelephonyProvider.values
          .firstWhereOrNull((e) => e.value == telephonyProvider) ??
      defaultValue ??
      enums.TelephonyProvider.swaggerGeneratedUnknown;
}

enums.TelephonyProvider? telephonyProviderNullableFromJson(
  Object? telephonyProvider, [
  enums.TelephonyProvider? defaultValue,
]) {
  if (telephonyProvider == null) {
    return null;
  }
  return enums.TelephonyProvider.values
          .firstWhereOrNull((e) => e.value == telephonyProvider) ??
      defaultValue;
}

String telephonyProviderExplodedListToJson(
    List<enums.TelephonyProvider>? telephonyProvider) {
  return telephonyProvider?.map((e) => e.value!).join(',') ?? '';
}

List<String> telephonyProviderListToJson(
    List<enums.TelephonyProvider>? telephonyProvider) {
  if (telephonyProvider == null) {
    return [];
  }

  return telephonyProvider.map((e) => e.value!).toList();
}

List<enums.TelephonyProvider> telephonyProviderListFromJson(
  List? telephonyProvider, [
  List<enums.TelephonyProvider>? defaultValue,
]) {
  if (telephonyProvider == null) {
    return defaultValue ?? [];
  }

  return telephonyProvider
      .map((e) => telephonyProviderFromJson(e.toString()))
      .toList();
}

List<enums.TelephonyProvider>? telephonyProviderNullableListFromJson(
  List? telephonyProvider, [
  List<enums.TelephonyProvider>? defaultValue,
]) {
  if (telephonyProvider == null) {
    return defaultValue;
  }

  return telephonyProvider
      .map((e) => telephonyProviderFromJson(e.toString()))
      .toList();
}

String? turnModeNullableToJson(enums.TurnMode? turnMode) {
  return turnMode?.value;
}

String? turnModeToJson(enums.TurnMode turnMode) {
  return turnMode.value;
}

enums.TurnMode turnModeFromJson(
  Object? turnMode, [
  enums.TurnMode? defaultValue,
]) {
  return enums.TurnMode.values.firstWhereOrNull((e) => e.value == turnMode) ??
      defaultValue ??
      enums.TurnMode.swaggerGeneratedUnknown;
}

enums.TurnMode? turnModeNullableFromJson(
  Object? turnMode, [
  enums.TurnMode? defaultValue,
]) {
  if (turnMode == null) {
    return null;
  }
  return enums.TurnMode.values.firstWhereOrNull((e) => e.value == turnMode) ??
      defaultValue;
}

String turnModeExplodedListToJson(List<enums.TurnMode>? turnMode) {
  return turnMode?.map((e) => e.value!).join(',') ?? '';
}

List<String> turnModeListToJson(List<enums.TurnMode>? turnMode) {
  if (turnMode == null) {
    return [];
  }

  return turnMode.map((e) => e.value!).toList();
}

List<enums.TurnMode> turnModeListFromJson(
  List? turnMode, [
  List<enums.TurnMode>? defaultValue,
]) {
  if (turnMode == null) {
    return defaultValue ?? [];
  }

  return turnMode.map((e) => turnModeFromJson(e.toString())).toList();
}

List<enums.TurnMode>? turnModeNullableListFromJson(
  List? turnMode, [
  List<enums.TurnMode>? defaultValue,
]) {
  if (turnMode == null) {
    return defaultValue;
  }

  return turnMode.map((e) => turnModeFromJson(e.toString())).toList();
}

String? usageAggregationIntervalNullableToJson(
    enums.UsageAggregationInterval? usageAggregationInterval) {
  return usageAggregationInterval?.value;
}

String? usageAggregationIntervalToJson(
    enums.UsageAggregationInterval usageAggregationInterval) {
  return usageAggregationInterval.value;
}

enums.UsageAggregationInterval usageAggregationIntervalFromJson(
  Object? usageAggregationInterval, [
  enums.UsageAggregationInterval? defaultValue,
]) {
  return enums.UsageAggregationInterval.values
          .firstWhereOrNull((e) => e.value == usageAggregationInterval) ??
      defaultValue ??
      enums.UsageAggregationInterval.swaggerGeneratedUnknown;
}

enums.UsageAggregationInterval? usageAggregationIntervalNullableFromJson(
  Object? usageAggregationInterval, [
  enums.UsageAggregationInterval? defaultValue,
]) {
  if (usageAggregationInterval == null) {
    return null;
  }
  return enums.UsageAggregationInterval.values
          .firstWhereOrNull((e) => e.value == usageAggregationInterval) ??
      defaultValue;
}

String usageAggregationIntervalExplodedListToJson(
    List<enums.UsageAggregationInterval>? usageAggregationInterval) {
  return usageAggregationInterval?.map((e) => e.value!).join(',') ?? '';
}

List<String> usageAggregationIntervalListToJson(
    List<enums.UsageAggregationInterval>? usageAggregationInterval) {
  if (usageAggregationInterval == null) {
    return [];
  }

  return usageAggregationInterval.map((e) => e.value!).toList();
}

List<enums.UsageAggregationInterval> usageAggregationIntervalListFromJson(
  List? usageAggregationInterval, [
  List<enums.UsageAggregationInterval>? defaultValue,
]) {
  if (usageAggregationInterval == null) {
    return defaultValue ?? [];
  }

  return usageAggregationInterval
      .map((e) => usageAggregationIntervalFromJson(e.toString()))
      .toList();
}

List<enums.UsageAggregationInterval>?
    usageAggregationIntervalNullableListFromJson(
  List? usageAggregationInterval, [
  List<enums.UsageAggregationInterval>? defaultValue,
]) {
  if (usageAggregationInterval == null) {
    return defaultValue;
  }

  return usageAggregationInterval
      .map((e) => usageAggregationIntervalFromJson(e.toString()))
      .toList();
}

String? userFeedbackScoreNullableToJson(
    enums.UserFeedbackScore? userFeedbackScore) {
  return userFeedbackScore?.value;
}

String? userFeedbackScoreToJson(enums.UserFeedbackScore userFeedbackScore) {
  return userFeedbackScore.value;
}

enums.UserFeedbackScore userFeedbackScoreFromJson(
  Object? userFeedbackScore, [
  enums.UserFeedbackScore? defaultValue,
]) {
  return enums.UserFeedbackScore.values
          .firstWhereOrNull((e) => e.value == userFeedbackScore) ??
      defaultValue ??
      enums.UserFeedbackScore.swaggerGeneratedUnknown;
}

enums.UserFeedbackScore? userFeedbackScoreNullableFromJson(
  Object? userFeedbackScore, [
  enums.UserFeedbackScore? defaultValue,
]) {
  if (userFeedbackScore == null) {
    return null;
  }
  return enums.UserFeedbackScore.values
          .firstWhereOrNull((e) => e.value == userFeedbackScore) ??
      defaultValue;
}

String userFeedbackScoreExplodedListToJson(
    List<enums.UserFeedbackScore>? userFeedbackScore) {
  return userFeedbackScore?.map((e) => e.value!).join(',') ?? '';
}

List<String> userFeedbackScoreListToJson(
    List<enums.UserFeedbackScore>? userFeedbackScore) {
  if (userFeedbackScore == null) {
    return [];
  }

  return userFeedbackScore.map((e) => e.value!).toList();
}

List<enums.UserFeedbackScore> userFeedbackScoreListFromJson(
  List? userFeedbackScore, [
  List<enums.UserFeedbackScore>? defaultValue,
]) {
  if (userFeedbackScore == null) {
    return defaultValue ?? [];
  }

  return userFeedbackScore
      .map((e) => userFeedbackScoreFromJson(e.toString()))
      .toList();
}

List<enums.UserFeedbackScore>? userFeedbackScoreNullableListFromJson(
  List? userFeedbackScore, [
  List<enums.UserFeedbackScore>? defaultValue,
]) {
  if (userFeedbackScore == null) {
    return defaultValue;
  }

  return userFeedbackScore
      .map((e) => userFeedbackScoreFromJson(e.toString()))
      .toList();
}

String? voiceResponseModelCategoryNullableToJson(
    enums.VoiceResponseModelCategory? voiceResponseModelCategory) {
  return voiceResponseModelCategory?.value;
}

String? voiceResponseModelCategoryToJson(
    enums.VoiceResponseModelCategory voiceResponseModelCategory) {
  return voiceResponseModelCategory.value;
}

enums.VoiceResponseModelCategory voiceResponseModelCategoryFromJson(
  Object? voiceResponseModelCategory, [
  enums.VoiceResponseModelCategory? defaultValue,
]) {
  return enums.VoiceResponseModelCategory.values
          .firstWhereOrNull((e) => e.value == voiceResponseModelCategory) ??
      defaultValue ??
      enums.VoiceResponseModelCategory.swaggerGeneratedUnknown;
}

enums.VoiceResponseModelCategory? voiceResponseModelCategoryNullableFromJson(
  Object? voiceResponseModelCategory, [
  enums.VoiceResponseModelCategory? defaultValue,
]) {
  if (voiceResponseModelCategory == null) {
    return null;
  }
  return enums.VoiceResponseModelCategory.values
          .firstWhereOrNull((e) => e.value == voiceResponseModelCategory) ??
      defaultValue;
}

String voiceResponseModelCategoryExplodedListToJson(
    List<enums.VoiceResponseModelCategory>? voiceResponseModelCategory) {
  return voiceResponseModelCategory?.map((e) => e.value!).join(',') ?? '';
}

List<String> voiceResponseModelCategoryListToJson(
    List<enums.VoiceResponseModelCategory>? voiceResponseModelCategory) {
  if (voiceResponseModelCategory == null) {
    return [];
  }

  return voiceResponseModelCategory.map((e) => e.value!).toList();
}

List<enums.VoiceResponseModelCategory> voiceResponseModelCategoryListFromJson(
  List? voiceResponseModelCategory, [
  List<enums.VoiceResponseModelCategory>? defaultValue,
]) {
  if (voiceResponseModelCategory == null) {
    return defaultValue ?? [];
  }

  return voiceResponseModelCategory
      .map((e) => voiceResponseModelCategoryFromJson(e.toString()))
      .toList();
}

List<enums.VoiceResponseModelCategory>?
    voiceResponseModelCategoryNullableListFromJson(
  List? voiceResponseModelCategory, [
  List<enums.VoiceResponseModelCategory>? defaultValue,
]) {
  if (voiceResponseModelCategory == null) {
    return defaultValue;
  }

  return voiceResponseModelCategory
      .map((e) => voiceResponseModelCategoryFromJson(e.toString()))
      .toList();
}

String? voiceSharingResponseModelStatusNullableToJson(
    enums.VoiceSharingResponseModelStatus? voiceSharingResponseModelStatus) {
  return voiceSharingResponseModelStatus?.value;
}

String? voiceSharingResponseModelStatusToJson(
    enums.VoiceSharingResponseModelStatus voiceSharingResponseModelStatus) {
  return voiceSharingResponseModelStatus.value;
}

enums.VoiceSharingResponseModelStatus voiceSharingResponseModelStatusFromJson(
  Object? voiceSharingResponseModelStatus, [
  enums.VoiceSharingResponseModelStatus? defaultValue,
]) {
  return enums.VoiceSharingResponseModelStatus.values.firstWhereOrNull(
          (e) => e.value == voiceSharingResponseModelStatus) ??
      defaultValue ??
      enums.VoiceSharingResponseModelStatus.swaggerGeneratedUnknown;
}

enums.VoiceSharingResponseModelStatus?
    voiceSharingResponseModelStatusNullableFromJson(
  Object? voiceSharingResponseModelStatus, [
  enums.VoiceSharingResponseModelStatus? defaultValue,
]) {
  if (voiceSharingResponseModelStatus == null) {
    return null;
  }
  return enums.VoiceSharingResponseModelStatus.values.firstWhereOrNull(
          (e) => e.value == voiceSharingResponseModelStatus) ??
      defaultValue;
}

String voiceSharingResponseModelStatusExplodedListToJson(
    List<enums.VoiceSharingResponseModelStatus>?
        voiceSharingResponseModelStatus) {
  return voiceSharingResponseModelStatus?.map((e) => e.value!).join(',') ?? '';
}

List<String> voiceSharingResponseModelStatusListToJson(
    List<enums.VoiceSharingResponseModelStatus>?
        voiceSharingResponseModelStatus) {
  if (voiceSharingResponseModelStatus == null) {
    return [];
  }

  return voiceSharingResponseModelStatus.map((e) => e.value!).toList();
}

List<enums.VoiceSharingResponseModelStatus>
    voiceSharingResponseModelStatusListFromJson(
  List? voiceSharingResponseModelStatus, [
  List<enums.VoiceSharingResponseModelStatus>? defaultValue,
]) {
  if (voiceSharingResponseModelStatus == null) {
    return defaultValue ?? [];
  }

  return voiceSharingResponseModelStatus
      .map((e) => voiceSharingResponseModelStatusFromJson(e.toString()))
      .toList();
}

List<enums.VoiceSharingResponseModelStatus>?
    voiceSharingResponseModelStatusNullableListFromJson(
  List? voiceSharingResponseModelStatus, [
  List<enums.VoiceSharingResponseModelStatus>? defaultValue,
]) {
  if (voiceSharingResponseModelStatus == null) {
    return defaultValue;
  }

  return voiceSharingResponseModelStatus
      .map((e) => voiceSharingResponseModelStatusFromJson(e.toString()))
      .toList();
}

String? voiceSharingResponseModelCategoryNullableToJson(
    enums.VoiceSharingResponseModelCategory?
        voiceSharingResponseModelCategory) {
  return voiceSharingResponseModelCategory?.value;
}

String? voiceSharingResponseModelCategoryToJson(
    enums.VoiceSharingResponseModelCategory voiceSharingResponseModelCategory) {
  return voiceSharingResponseModelCategory.value;
}

enums.VoiceSharingResponseModelCategory
    voiceSharingResponseModelCategoryFromJson(
  Object? voiceSharingResponseModelCategory, [
  enums.VoiceSharingResponseModelCategory? defaultValue,
]) {
  return enums.VoiceSharingResponseModelCategory.values.firstWhereOrNull(
          (e) => e.value == voiceSharingResponseModelCategory) ??
      defaultValue ??
      enums.VoiceSharingResponseModelCategory.swaggerGeneratedUnknown;
}

enums.VoiceSharingResponseModelCategory?
    voiceSharingResponseModelCategoryNullableFromJson(
  Object? voiceSharingResponseModelCategory, [
  enums.VoiceSharingResponseModelCategory? defaultValue,
]) {
  if (voiceSharingResponseModelCategory == null) {
    return null;
  }
  return enums.VoiceSharingResponseModelCategory.values.firstWhereOrNull(
          (e) => e.value == voiceSharingResponseModelCategory) ??
      defaultValue;
}

String voiceSharingResponseModelCategoryExplodedListToJson(
    List<enums.VoiceSharingResponseModelCategory>?
        voiceSharingResponseModelCategory) {
  return voiceSharingResponseModelCategory?.map((e) => e.value!).join(',') ??
      '';
}

List<String> voiceSharingResponseModelCategoryListToJson(
    List<enums.VoiceSharingResponseModelCategory>?
        voiceSharingResponseModelCategory) {
  if (voiceSharingResponseModelCategory == null) {
    return [];
  }

  return voiceSharingResponseModelCategory.map((e) => e.value!).toList();
}

List<enums.VoiceSharingResponseModelCategory>
    voiceSharingResponseModelCategoryListFromJson(
  List? voiceSharingResponseModelCategory, [
  List<enums.VoiceSharingResponseModelCategory>? defaultValue,
]) {
  if (voiceSharingResponseModelCategory == null) {
    return defaultValue ?? [];
  }

  return voiceSharingResponseModelCategory
      .map((e) => voiceSharingResponseModelCategoryFromJson(e.toString()))
      .toList();
}

List<enums.VoiceSharingResponseModelCategory>?
    voiceSharingResponseModelCategoryNullableListFromJson(
  List? voiceSharingResponseModelCategory, [
  List<enums.VoiceSharingResponseModelCategory>? defaultValue,
]) {
  if (voiceSharingResponseModelCategory == null) {
    return defaultValue;
  }

  return voiceSharingResponseModelCategory
      .map((e) => voiceSharingResponseModelCategoryFromJson(e.toString()))
      .toList();
}

String? voiceSharingResponseModelReviewStatusNullableToJson(
    enums.VoiceSharingResponseModelReviewStatus?
        voiceSharingResponseModelReviewStatus) {
  return voiceSharingResponseModelReviewStatus?.value;
}

String? voiceSharingResponseModelReviewStatusToJson(
    enums.VoiceSharingResponseModelReviewStatus
        voiceSharingResponseModelReviewStatus) {
  return voiceSharingResponseModelReviewStatus.value;
}

enums.VoiceSharingResponseModelReviewStatus
    voiceSharingResponseModelReviewStatusFromJson(
  Object? voiceSharingResponseModelReviewStatus, [
  enums.VoiceSharingResponseModelReviewStatus? defaultValue,
]) {
  return enums.VoiceSharingResponseModelReviewStatus.values.firstWhereOrNull(
          (e) => e.value == voiceSharingResponseModelReviewStatus) ??
      defaultValue ??
      enums.VoiceSharingResponseModelReviewStatus.swaggerGeneratedUnknown;
}

enums.VoiceSharingResponseModelReviewStatus?
    voiceSharingResponseModelReviewStatusNullableFromJson(
  Object? voiceSharingResponseModelReviewStatus, [
  enums.VoiceSharingResponseModelReviewStatus? defaultValue,
]) {
  if (voiceSharingResponseModelReviewStatus == null) {
    return null;
  }
  return enums.VoiceSharingResponseModelReviewStatus.values.firstWhereOrNull(
          (e) => e.value == voiceSharingResponseModelReviewStatus) ??
      defaultValue;
}

String voiceSharingResponseModelReviewStatusExplodedListToJson(
    List<enums.VoiceSharingResponseModelReviewStatus>?
        voiceSharingResponseModelReviewStatus) {
  return voiceSharingResponseModelReviewStatus
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> voiceSharingResponseModelReviewStatusListToJson(
    List<enums.VoiceSharingResponseModelReviewStatus>?
        voiceSharingResponseModelReviewStatus) {
  if (voiceSharingResponseModelReviewStatus == null) {
    return [];
  }

  return voiceSharingResponseModelReviewStatus.map((e) => e.value!).toList();
}

List<enums.VoiceSharingResponseModelReviewStatus>
    voiceSharingResponseModelReviewStatusListFromJson(
  List? voiceSharingResponseModelReviewStatus, [
  List<enums.VoiceSharingResponseModelReviewStatus>? defaultValue,
]) {
  if (voiceSharingResponseModelReviewStatus == null) {
    return defaultValue ?? [];
  }

  return voiceSharingResponseModelReviewStatus
      .map((e) => voiceSharingResponseModelReviewStatusFromJson(e.toString()))
      .toList();
}

List<enums.VoiceSharingResponseModelReviewStatus>?
    voiceSharingResponseModelReviewStatusNullableListFromJson(
  List? voiceSharingResponseModelReviewStatus, [
  List<enums.VoiceSharingResponseModelReviewStatus>? defaultValue,
]) {
  if (voiceSharingResponseModelReviewStatus == null) {
    return defaultValue;
  }

  return voiceSharingResponseModelReviewStatus
      .map((e) => voiceSharingResponseModelReviewStatusFromJson(e.toString()))
      .toList();
}

String? webhookToolApiSchemaConfigInputMethodNullableToJson(
    enums.WebhookToolApiSchemaConfigInputMethod?
        webhookToolApiSchemaConfigInputMethod) {
  return webhookToolApiSchemaConfigInputMethod?.value;
}

String? webhookToolApiSchemaConfigInputMethodToJson(
    enums.WebhookToolApiSchemaConfigInputMethod
        webhookToolApiSchemaConfigInputMethod) {
  return webhookToolApiSchemaConfigInputMethod.value;
}

enums.WebhookToolApiSchemaConfigInputMethod
    webhookToolApiSchemaConfigInputMethodFromJson(
  Object? webhookToolApiSchemaConfigInputMethod, [
  enums.WebhookToolApiSchemaConfigInputMethod? defaultValue,
]) {
  return enums.WebhookToolApiSchemaConfigInputMethod.values.firstWhereOrNull(
          (e) => e.value == webhookToolApiSchemaConfigInputMethod) ??
      defaultValue ??
      enums.WebhookToolApiSchemaConfigInputMethod.swaggerGeneratedUnknown;
}

enums.WebhookToolApiSchemaConfigInputMethod?
    webhookToolApiSchemaConfigInputMethodNullableFromJson(
  Object? webhookToolApiSchemaConfigInputMethod, [
  enums.WebhookToolApiSchemaConfigInputMethod? defaultValue,
]) {
  if (webhookToolApiSchemaConfigInputMethod == null) {
    return null;
  }
  return enums.WebhookToolApiSchemaConfigInputMethod.values.firstWhereOrNull(
          (e) => e.value == webhookToolApiSchemaConfigInputMethod) ??
      defaultValue;
}

String webhookToolApiSchemaConfigInputMethodExplodedListToJson(
    List<enums.WebhookToolApiSchemaConfigInputMethod>?
        webhookToolApiSchemaConfigInputMethod) {
  return webhookToolApiSchemaConfigInputMethod
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> webhookToolApiSchemaConfigInputMethodListToJson(
    List<enums.WebhookToolApiSchemaConfigInputMethod>?
        webhookToolApiSchemaConfigInputMethod) {
  if (webhookToolApiSchemaConfigInputMethod == null) {
    return [];
  }

  return webhookToolApiSchemaConfigInputMethod.map((e) => e.value!).toList();
}

List<enums.WebhookToolApiSchemaConfigInputMethod>
    webhookToolApiSchemaConfigInputMethodListFromJson(
  List? webhookToolApiSchemaConfigInputMethod, [
  List<enums.WebhookToolApiSchemaConfigInputMethod>? defaultValue,
]) {
  if (webhookToolApiSchemaConfigInputMethod == null) {
    return defaultValue ?? [];
  }

  return webhookToolApiSchemaConfigInputMethod
      .map((e) => webhookToolApiSchemaConfigInputMethodFromJson(e.toString()))
      .toList();
}

List<enums.WebhookToolApiSchemaConfigInputMethod>?
    webhookToolApiSchemaConfigInputMethodNullableListFromJson(
  List? webhookToolApiSchemaConfigInputMethod, [
  List<enums.WebhookToolApiSchemaConfigInputMethod>? defaultValue,
]) {
  if (webhookToolApiSchemaConfigInputMethod == null) {
    return defaultValue;
  }

  return webhookToolApiSchemaConfigInputMethod
      .map((e) => webhookToolApiSchemaConfigInputMethodFromJson(e.toString()))
      .toList();
}

String? webhookToolApiSchemaConfigOutputMethodNullableToJson(
    enums.WebhookToolApiSchemaConfigOutputMethod?
        webhookToolApiSchemaConfigOutputMethod) {
  return webhookToolApiSchemaConfigOutputMethod?.value;
}

String? webhookToolApiSchemaConfigOutputMethodToJson(
    enums.WebhookToolApiSchemaConfigOutputMethod
        webhookToolApiSchemaConfigOutputMethod) {
  return webhookToolApiSchemaConfigOutputMethod.value;
}

enums.WebhookToolApiSchemaConfigOutputMethod
    webhookToolApiSchemaConfigOutputMethodFromJson(
  Object? webhookToolApiSchemaConfigOutputMethod, [
  enums.WebhookToolApiSchemaConfigOutputMethod? defaultValue,
]) {
  return enums.WebhookToolApiSchemaConfigOutputMethod.values.firstWhereOrNull(
          (e) => e.value == webhookToolApiSchemaConfigOutputMethod) ??
      defaultValue ??
      enums.WebhookToolApiSchemaConfigOutputMethod.swaggerGeneratedUnknown;
}

enums.WebhookToolApiSchemaConfigOutputMethod?
    webhookToolApiSchemaConfigOutputMethodNullableFromJson(
  Object? webhookToolApiSchemaConfigOutputMethod, [
  enums.WebhookToolApiSchemaConfigOutputMethod? defaultValue,
]) {
  if (webhookToolApiSchemaConfigOutputMethod == null) {
    return null;
  }
  return enums.WebhookToolApiSchemaConfigOutputMethod.values.firstWhereOrNull(
          (e) => e.value == webhookToolApiSchemaConfigOutputMethod) ??
      defaultValue;
}

String webhookToolApiSchemaConfigOutputMethodExplodedListToJson(
    List<enums.WebhookToolApiSchemaConfigOutputMethod>?
        webhookToolApiSchemaConfigOutputMethod) {
  return webhookToolApiSchemaConfigOutputMethod
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> webhookToolApiSchemaConfigOutputMethodListToJson(
    List<enums.WebhookToolApiSchemaConfigOutputMethod>?
        webhookToolApiSchemaConfigOutputMethod) {
  if (webhookToolApiSchemaConfigOutputMethod == null) {
    return [];
  }

  return webhookToolApiSchemaConfigOutputMethod.map((e) => e.value!).toList();
}

List<enums.WebhookToolApiSchemaConfigOutputMethod>
    webhookToolApiSchemaConfigOutputMethodListFromJson(
  List? webhookToolApiSchemaConfigOutputMethod, [
  List<enums.WebhookToolApiSchemaConfigOutputMethod>? defaultValue,
]) {
  if (webhookToolApiSchemaConfigOutputMethod == null) {
    return defaultValue ?? [];
  }

  return webhookToolApiSchemaConfigOutputMethod
      .map((e) => webhookToolApiSchemaConfigOutputMethodFromJson(e.toString()))
      .toList();
}

List<enums.WebhookToolApiSchemaConfigOutputMethod>?
    webhookToolApiSchemaConfigOutputMethodNullableListFromJson(
  List? webhookToolApiSchemaConfigOutputMethod, [
  List<enums.WebhookToolApiSchemaConfigOutputMethod>? defaultValue,
]) {
  if (webhookToolApiSchemaConfigOutputMethod == null) {
    return defaultValue;
  }

  return webhookToolApiSchemaConfigOutputMethod
      .map((e) => webhookToolApiSchemaConfigOutputMethodFromJson(e.toString()))
      .toList();
}

String? widgetExpandableNullableToJson(
    enums.WidgetExpandable? widgetExpandable) {
  return widgetExpandable?.value;
}

String? widgetExpandableToJson(enums.WidgetExpandable widgetExpandable) {
  return widgetExpandable.value;
}

enums.WidgetExpandable widgetExpandableFromJson(
  Object? widgetExpandable, [
  enums.WidgetExpandable? defaultValue,
]) {
  return enums.WidgetExpandable.values
          .firstWhereOrNull((e) => e.value == widgetExpandable) ??
      defaultValue ??
      enums.WidgetExpandable.swaggerGeneratedUnknown;
}

enums.WidgetExpandable? widgetExpandableNullableFromJson(
  Object? widgetExpandable, [
  enums.WidgetExpandable? defaultValue,
]) {
  if (widgetExpandable == null) {
    return null;
  }
  return enums.WidgetExpandable.values
          .firstWhereOrNull((e) => e.value == widgetExpandable) ??
      defaultValue;
}

String widgetExpandableExplodedListToJson(
    List<enums.WidgetExpandable>? widgetExpandable) {
  return widgetExpandable?.map((e) => e.value!).join(',') ?? '';
}

List<String> widgetExpandableListToJson(
    List<enums.WidgetExpandable>? widgetExpandable) {
  if (widgetExpandable == null) {
    return [];
  }

  return widgetExpandable.map((e) => e.value!).toList();
}

List<enums.WidgetExpandable> widgetExpandableListFromJson(
  List? widgetExpandable, [
  List<enums.WidgetExpandable>? defaultValue,
]) {
  if (widgetExpandable == null) {
    return defaultValue ?? [];
  }

  return widgetExpandable
      .map((e) => widgetExpandableFromJson(e.toString()))
      .toList();
}

List<enums.WidgetExpandable>? widgetExpandableNullableListFromJson(
  List? widgetExpandable, [
  List<enums.WidgetExpandable>? defaultValue,
]) {
  if (widgetExpandable == null) {
    return defaultValue;
  }

  return widgetExpandable
      .map((e) => widgetExpandableFromJson(e.toString()))
      .toList();
}

String? widgetFeedbackModeNullableToJson(
    enums.WidgetFeedbackMode? widgetFeedbackMode) {
  return widgetFeedbackMode?.value;
}

String? widgetFeedbackModeToJson(enums.WidgetFeedbackMode widgetFeedbackMode) {
  return widgetFeedbackMode.value;
}

enums.WidgetFeedbackMode widgetFeedbackModeFromJson(
  Object? widgetFeedbackMode, [
  enums.WidgetFeedbackMode? defaultValue,
]) {
  return enums.WidgetFeedbackMode.values
          .firstWhereOrNull((e) => e.value == widgetFeedbackMode) ??
      defaultValue ??
      enums.WidgetFeedbackMode.swaggerGeneratedUnknown;
}

enums.WidgetFeedbackMode? widgetFeedbackModeNullableFromJson(
  Object? widgetFeedbackMode, [
  enums.WidgetFeedbackMode? defaultValue,
]) {
  if (widgetFeedbackMode == null) {
    return null;
  }
  return enums.WidgetFeedbackMode.values
          .firstWhereOrNull((e) => e.value == widgetFeedbackMode) ??
      defaultValue;
}

String widgetFeedbackModeExplodedListToJson(
    List<enums.WidgetFeedbackMode>? widgetFeedbackMode) {
  return widgetFeedbackMode?.map((e) => e.value!).join(',') ?? '';
}

List<String> widgetFeedbackModeListToJson(
    List<enums.WidgetFeedbackMode>? widgetFeedbackMode) {
  if (widgetFeedbackMode == null) {
    return [];
  }

  return widgetFeedbackMode.map((e) => e.value!).toList();
}

List<enums.WidgetFeedbackMode> widgetFeedbackModeListFromJson(
  List? widgetFeedbackMode, [
  List<enums.WidgetFeedbackMode>? defaultValue,
]) {
  if (widgetFeedbackMode == null) {
    return defaultValue ?? [];
  }

  return widgetFeedbackMode
      .map((e) => widgetFeedbackModeFromJson(e.toString()))
      .toList();
}

List<enums.WidgetFeedbackMode>? widgetFeedbackModeNullableListFromJson(
  List? widgetFeedbackMode, [
  List<enums.WidgetFeedbackMode>? defaultValue,
]) {
  if (widgetFeedbackMode == null) {
    return defaultValue;
  }

  return widgetFeedbackMode
      .map((e) => widgetFeedbackModeFromJson(e.toString()))
      .toList();
}

String? widgetPlacementNullableToJson(enums.WidgetPlacement? widgetPlacement) {
  return widgetPlacement?.value;
}

String? widgetPlacementToJson(enums.WidgetPlacement widgetPlacement) {
  return widgetPlacement.value;
}

enums.WidgetPlacement widgetPlacementFromJson(
  Object? widgetPlacement, [
  enums.WidgetPlacement? defaultValue,
]) {
  return enums.WidgetPlacement.values
          .firstWhereOrNull((e) => e.value == widgetPlacement) ??
      defaultValue ??
      enums.WidgetPlacement.swaggerGeneratedUnknown;
}

enums.WidgetPlacement? widgetPlacementNullableFromJson(
  Object? widgetPlacement, [
  enums.WidgetPlacement? defaultValue,
]) {
  if (widgetPlacement == null) {
    return null;
  }
  return enums.WidgetPlacement.values
          .firstWhereOrNull((e) => e.value == widgetPlacement) ??
      defaultValue;
}

String widgetPlacementExplodedListToJson(
    List<enums.WidgetPlacement>? widgetPlacement) {
  return widgetPlacement?.map((e) => e.value!).join(',') ?? '';
}

List<String> widgetPlacementListToJson(
    List<enums.WidgetPlacement>? widgetPlacement) {
  if (widgetPlacement == null) {
    return [];
  }

  return widgetPlacement.map((e) => e.value!).toList();
}

List<enums.WidgetPlacement> widgetPlacementListFromJson(
  List? widgetPlacement, [
  List<enums.WidgetPlacement>? defaultValue,
]) {
  if (widgetPlacement == null) {
    return defaultValue ?? [];
  }

  return widgetPlacement
      .map((e) => widgetPlacementFromJson(e.toString()))
      .toList();
}

List<enums.WidgetPlacement>? widgetPlacementNullableListFromJson(
  List? widgetPlacement, [
  List<enums.WidgetPlacement>? defaultValue,
]) {
  if (widgetPlacement == null) {
    return defaultValue;
  }

  return widgetPlacement
      .map((e) => widgetPlacementFromJson(e.toString()))
      .toList();
}

String? workspaceResourceTypeNullableToJson(
    enums.WorkspaceResourceType? workspaceResourceType) {
  return workspaceResourceType?.value;
}

String? workspaceResourceTypeToJson(
    enums.WorkspaceResourceType workspaceResourceType) {
  return workspaceResourceType.value;
}

enums.WorkspaceResourceType workspaceResourceTypeFromJson(
  Object? workspaceResourceType, [
  enums.WorkspaceResourceType? defaultValue,
]) {
  return enums.WorkspaceResourceType.values
          .firstWhereOrNull((e) => e.value == workspaceResourceType) ??
      defaultValue ??
      enums.WorkspaceResourceType.swaggerGeneratedUnknown;
}

enums.WorkspaceResourceType? workspaceResourceTypeNullableFromJson(
  Object? workspaceResourceType, [
  enums.WorkspaceResourceType? defaultValue,
]) {
  if (workspaceResourceType == null) {
    return null;
  }
  return enums.WorkspaceResourceType.values
          .firstWhereOrNull((e) => e.value == workspaceResourceType) ??
      defaultValue;
}

String workspaceResourceTypeExplodedListToJson(
    List<enums.WorkspaceResourceType>? workspaceResourceType) {
  return workspaceResourceType?.map((e) => e.value!).join(',') ?? '';
}

List<String> workspaceResourceTypeListToJson(
    List<enums.WorkspaceResourceType>? workspaceResourceType) {
  if (workspaceResourceType == null) {
    return [];
  }

  return workspaceResourceType.map((e) => e.value!).toList();
}

List<enums.WorkspaceResourceType> workspaceResourceTypeListFromJson(
  List? workspaceResourceType, [
  List<enums.WorkspaceResourceType>? defaultValue,
]) {
  if (workspaceResourceType == null) {
    return defaultValue ?? [];
  }

  return workspaceResourceType
      .map((e) => workspaceResourceTypeFromJson(e.toString()))
      .toList();
}

List<enums.WorkspaceResourceType>? workspaceResourceTypeNullableListFromJson(
  List? workspaceResourceType, [
  List<enums.WorkspaceResourceType>? defaultValue,
]) {
  if (workspaceResourceType == null) {
    return defaultValue;
  }

  return workspaceResourceType
      .map((e) => workspaceResourceTypeFromJson(e.toString()))
      .toList();
}

String? v1SoundGenerationPostOutputFormatNullableToJson(
    enums.V1SoundGenerationPostOutputFormat?
        v1SoundGenerationPostOutputFormat) {
  return v1SoundGenerationPostOutputFormat?.value;
}

String? v1SoundGenerationPostOutputFormatToJson(
    enums.V1SoundGenerationPostOutputFormat v1SoundGenerationPostOutputFormat) {
  return v1SoundGenerationPostOutputFormat.value;
}

enums.V1SoundGenerationPostOutputFormat
    v1SoundGenerationPostOutputFormatFromJson(
  Object? v1SoundGenerationPostOutputFormat, [
  enums.V1SoundGenerationPostOutputFormat? defaultValue,
]) {
  return enums.V1SoundGenerationPostOutputFormat.values.firstWhereOrNull(
          (e) => e.value == v1SoundGenerationPostOutputFormat) ??
      defaultValue ??
      enums.V1SoundGenerationPostOutputFormat.swaggerGeneratedUnknown;
}

enums.V1SoundGenerationPostOutputFormat?
    v1SoundGenerationPostOutputFormatNullableFromJson(
  Object? v1SoundGenerationPostOutputFormat, [
  enums.V1SoundGenerationPostOutputFormat? defaultValue,
]) {
  if (v1SoundGenerationPostOutputFormat == null) {
    return null;
  }
  return enums.V1SoundGenerationPostOutputFormat.values.firstWhereOrNull(
          (e) => e.value == v1SoundGenerationPostOutputFormat) ??
      defaultValue;
}

String v1SoundGenerationPostOutputFormatExplodedListToJson(
    List<enums.V1SoundGenerationPostOutputFormat>?
        v1SoundGenerationPostOutputFormat) {
  return v1SoundGenerationPostOutputFormat?.map((e) => e.value!).join(',') ??
      '';
}

List<String> v1SoundGenerationPostOutputFormatListToJson(
    List<enums.V1SoundGenerationPostOutputFormat>?
        v1SoundGenerationPostOutputFormat) {
  if (v1SoundGenerationPostOutputFormat == null) {
    return [];
  }

  return v1SoundGenerationPostOutputFormat.map((e) => e.value!).toList();
}

List<enums.V1SoundGenerationPostOutputFormat>
    v1SoundGenerationPostOutputFormatListFromJson(
  List? v1SoundGenerationPostOutputFormat, [
  List<enums.V1SoundGenerationPostOutputFormat>? defaultValue,
]) {
  if (v1SoundGenerationPostOutputFormat == null) {
    return defaultValue ?? [];
  }

  return v1SoundGenerationPostOutputFormat
      .map((e) => v1SoundGenerationPostOutputFormatFromJson(e.toString()))
      .toList();
}

List<enums.V1SoundGenerationPostOutputFormat>?
    v1SoundGenerationPostOutputFormatNullableListFromJson(
  List? v1SoundGenerationPostOutputFormat, [
  List<enums.V1SoundGenerationPostOutputFormat>? defaultValue,
]) {
  if (v1SoundGenerationPostOutputFormat == null) {
    return defaultValue;
  }

  return v1SoundGenerationPostOutputFormat
      .map((e) => v1SoundGenerationPostOutputFormatFromJson(e.toString()))
      .toList();
}

String? v1TextToSpeechVoiceIdPostOutputFormatNullableToJson(
    enums.V1TextToSpeechVoiceIdPostOutputFormat?
        v1TextToSpeechVoiceIdPostOutputFormat) {
  return v1TextToSpeechVoiceIdPostOutputFormat?.value;
}

String? v1TextToSpeechVoiceIdPostOutputFormatToJson(
    enums.V1TextToSpeechVoiceIdPostOutputFormat
        v1TextToSpeechVoiceIdPostOutputFormat) {
  return v1TextToSpeechVoiceIdPostOutputFormat.value;
}

enums.V1TextToSpeechVoiceIdPostOutputFormat
    v1TextToSpeechVoiceIdPostOutputFormatFromJson(
  Object? v1TextToSpeechVoiceIdPostOutputFormat, [
  enums.V1TextToSpeechVoiceIdPostOutputFormat? defaultValue,
]) {
  return enums.V1TextToSpeechVoiceIdPostOutputFormat.values.firstWhereOrNull(
          (e) => e.value == v1TextToSpeechVoiceIdPostOutputFormat) ??
      defaultValue ??
      enums.V1TextToSpeechVoiceIdPostOutputFormat.swaggerGeneratedUnknown;
}

enums.V1TextToSpeechVoiceIdPostOutputFormat?
    v1TextToSpeechVoiceIdPostOutputFormatNullableFromJson(
  Object? v1TextToSpeechVoiceIdPostOutputFormat, [
  enums.V1TextToSpeechVoiceIdPostOutputFormat? defaultValue,
]) {
  if (v1TextToSpeechVoiceIdPostOutputFormat == null) {
    return null;
  }
  return enums.V1TextToSpeechVoiceIdPostOutputFormat.values.firstWhereOrNull(
          (e) => e.value == v1TextToSpeechVoiceIdPostOutputFormat) ??
      defaultValue;
}

String v1TextToSpeechVoiceIdPostOutputFormatExplodedListToJson(
    List<enums.V1TextToSpeechVoiceIdPostOutputFormat>?
        v1TextToSpeechVoiceIdPostOutputFormat) {
  return v1TextToSpeechVoiceIdPostOutputFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> v1TextToSpeechVoiceIdPostOutputFormatListToJson(
    List<enums.V1TextToSpeechVoiceIdPostOutputFormat>?
        v1TextToSpeechVoiceIdPostOutputFormat) {
  if (v1TextToSpeechVoiceIdPostOutputFormat == null) {
    return [];
  }

  return v1TextToSpeechVoiceIdPostOutputFormat.map((e) => e.value!).toList();
}

List<enums.V1TextToSpeechVoiceIdPostOutputFormat>
    v1TextToSpeechVoiceIdPostOutputFormatListFromJson(
  List? v1TextToSpeechVoiceIdPostOutputFormat, [
  List<enums.V1TextToSpeechVoiceIdPostOutputFormat>? defaultValue,
]) {
  if (v1TextToSpeechVoiceIdPostOutputFormat == null) {
    return defaultValue ?? [];
  }

  return v1TextToSpeechVoiceIdPostOutputFormat
      .map((e) => v1TextToSpeechVoiceIdPostOutputFormatFromJson(e.toString()))
      .toList();
}

List<enums.V1TextToSpeechVoiceIdPostOutputFormat>?
    v1TextToSpeechVoiceIdPostOutputFormatNullableListFromJson(
  List? v1TextToSpeechVoiceIdPostOutputFormat, [
  List<enums.V1TextToSpeechVoiceIdPostOutputFormat>? defaultValue,
]) {
  if (v1TextToSpeechVoiceIdPostOutputFormat == null) {
    return defaultValue;
  }

  return v1TextToSpeechVoiceIdPostOutputFormat
      .map((e) => v1TextToSpeechVoiceIdPostOutputFormatFromJson(e.toString()))
      .toList();
}

String? v1TextToSpeechVoiceIdWithTimestampsPostOutputFormatNullableToJson(
    enums.V1TextToSpeechVoiceIdWithTimestampsPostOutputFormat?
        v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat) {
  return v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat?.value;
}

String? v1TextToSpeechVoiceIdWithTimestampsPostOutputFormatToJson(
    enums.V1TextToSpeechVoiceIdWithTimestampsPostOutputFormat
        v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat) {
  return v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat.value;
}

enums.V1TextToSpeechVoiceIdWithTimestampsPostOutputFormat
    v1TextToSpeechVoiceIdWithTimestampsPostOutputFormatFromJson(
  Object? v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat, [
  enums.V1TextToSpeechVoiceIdWithTimestampsPostOutputFormat? defaultValue,
]) {
  return enums.V1TextToSpeechVoiceIdWithTimestampsPostOutputFormat.values
          .firstWhereOrNull((e) =>
              e.value == v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat) ??
      defaultValue ??
      enums.V1TextToSpeechVoiceIdWithTimestampsPostOutputFormat
          .swaggerGeneratedUnknown;
}

enums.V1TextToSpeechVoiceIdWithTimestampsPostOutputFormat?
    v1TextToSpeechVoiceIdWithTimestampsPostOutputFormatNullableFromJson(
  Object? v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat, [
  enums.V1TextToSpeechVoiceIdWithTimestampsPostOutputFormat? defaultValue,
]) {
  if (v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat == null) {
    return null;
  }
  return enums.V1TextToSpeechVoiceIdWithTimestampsPostOutputFormat.values
          .firstWhereOrNull((e) =>
              e.value == v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat) ??
      defaultValue;
}

String v1TextToSpeechVoiceIdWithTimestampsPostOutputFormatExplodedListToJson(
    List<enums.V1TextToSpeechVoiceIdWithTimestampsPostOutputFormat>?
        v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat) {
  return v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> v1TextToSpeechVoiceIdWithTimestampsPostOutputFormatListToJson(
    List<enums.V1TextToSpeechVoiceIdWithTimestampsPostOutputFormat>?
        v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat) {
  if (v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat == null) {
    return [];
  }

  return v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat
      .map((e) => e.value!)
      .toList();
}

List<enums.V1TextToSpeechVoiceIdWithTimestampsPostOutputFormat>
    v1TextToSpeechVoiceIdWithTimestampsPostOutputFormatListFromJson(
  List? v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat, [
  List<enums.V1TextToSpeechVoiceIdWithTimestampsPostOutputFormat>? defaultValue,
]) {
  if (v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat == null) {
    return defaultValue ?? [];
  }

  return v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat
      .map((e) => v1TextToSpeechVoiceIdWithTimestampsPostOutputFormatFromJson(
          e.toString()))
      .toList();
}

List<enums.V1TextToSpeechVoiceIdWithTimestampsPostOutputFormat>?
    v1TextToSpeechVoiceIdWithTimestampsPostOutputFormatNullableListFromJson(
  List? v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat, [
  List<enums.V1TextToSpeechVoiceIdWithTimestampsPostOutputFormat>? defaultValue,
]) {
  if (v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat == null) {
    return defaultValue;
  }

  return v1TextToSpeechVoiceIdWithTimestampsPostOutputFormat
      .map((e) => v1TextToSpeechVoiceIdWithTimestampsPostOutputFormatFromJson(
          e.toString()))
      .toList();
}

String? v1TextToSpeechVoiceIdStreamPostOutputFormatNullableToJson(
    enums.V1TextToSpeechVoiceIdStreamPostOutputFormat?
        v1TextToSpeechVoiceIdStreamPostOutputFormat) {
  return v1TextToSpeechVoiceIdStreamPostOutputFormat?.value;
}

String? v1TextToSpeechVoiceIdStreamPostOutputFormatToJson(
    enums.V1TextToSpeechVoiceIdStreamPostOutputFormat
        v1TextToSpeechVoiceIdStreamPostOutputFormat) {
  return v1TextToSpeechVoiceIdStreamPostOutputFormat.value;
}

enums.V1TextToSpeechVoiceIdStreamPostOutputFormat
    v1TextToSpeechVoiceIdStreamPostOutputFormatFromJson(
  Object? v1TextToSpeechVoiceIdStreamPostOutputFormat, [
  enums.V1TextToSpeechVoiceIdStreamPostOutputFormat? defaultValue,
]) {
  return enums.V1TextToSpeechVoiceIdStreamPostOutputFormat.values
          .firstWhereOrNull(
              (e) => e.value == v1TextToSpeechVoiceIdStreamPostOutputFormat) ??
      defaultValue ??
      enums.V1TextToSpeechVoiceIdStreamPostOutputFormat.swaggerGeneratedUnknown;
}

enums.V1TextToSpeechVoiceIdStreamPostOutputFormat?
    v1TextToSpeechVoiceIdStreamPostOutputFormatNullableFromJson(
  Object? v1TextToSpeechVoiceIdStreamPostOutputFormat, [
  enums.V1TextToSpeechVoiceIdStreamPostOutputFormat? defaultValue,
]) {
  if (v1TextToSpeechVoiceIdStreamPostOutputFormat == null) {
    return null;
  }
  return enums.V1TextToSpeechVoiceIdStreamPostOutputFormat.values
          .firstWhereOrNull(
              (e) => e.value == v1TextToSpeechVoiceIdStreamPostOutputFormat) ??
      defaultValue;
}

String v1TextToSpeechVoiceIdStreamPostOutputFormatExplodedListToJson(
    List<enums.V1TextToSpeechVoiceIdStreamPostOutputFormat>?
        v1TextToSpeechVoiceIdStreamPostOutputFormat) {
  return v1TextToSpeechVoiceIdStreamPostOutputFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> v1TextToSpeechVoiceIdStreamPostOutputFormatListToJson(
    List<enums.V1TextToSpeechVoiceIdStreamPostOutputFormat>?
        v1TextToSpeechVoiceIdStreamPostOutputFormat) {
  if (v1TextToSpeechVoiceIdStreamPostOutputFormat == null) {
    return [];
  }

  return v1TextToSpeechVoiceIdStreamPostOutputFormat
      .map((e) => e.value!)
      .toList();
}

List<enums.V1TextToSpeechVoiceIdStreamPostOutputFormat>
    v1TextToSpeechVoiceIdStreamPostOutputFormatListFromJson(
  List? v1TextToSpeechVoiceIdStreamPostOutputFormat, [
  List<enums.V1TextToSpeechVoiceIdStreamPostOutputFormat>? defaultValue,
]) {
  if (v1TextToSpeechVoiceIdStreamPostOutputFormat == null) {
    return defaultValue ?? [];
  }

  return v1TextToSpeechVoiceIdStreamPostOutputFormat
      .map((e) =>
          v1TextToSpeechVoiceIdStreamPostOutputFormatFromJson(e.toString()))
      .toList();
}

List<enums.V1TextToSpeechVoiceIdStreamPostOutputFormat>?
    v1TextToSpeechVoiceIdStreamPostOutputFormatNullableListFromJson(
  List? v1TextToSpeechVoiceIdStreamPostOutputFormat, [
  List<enums.V1TextToSpeechVoiceIdStreamPostOutputFormat>? defaultValue,
]) {
  if (v1TextToSpeechVoiceIdStreamPostOutputFormat == null) {
    return defaultValue;
  }

  return v1TextToSpeechVoiceIdStreamPostOutputFormat
      .map((e) =>
          v1TextToSpeechVoiceIdStreamPostOutputFormatFromJson(e.toString()))
      .toList();
}

String? v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormatNullableToJson(
    enums.V1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat?
        v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat) {
  return v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat?.value;
}

String? v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormatToJson(
    enums.V1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat
        v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat) {
  return v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat.value;
}

enums.V1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat
    v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormatFromJson(
  Object? v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat, [
  enums.V1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat? defaultValue,
]) {
  return enums.V1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat.values
          .firstWhereOrNull((e) =>
              e.value ==
              v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat) ??
      defaultValue ??
      enums.V1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat
          .swaggerGeneratedUnknown;
}

enums.V1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat?
    v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormatNullableFromJson(
  Object? v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat, [
  enums.V1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat? defaultValue,
]) {
  if (v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat == null) {
    return null;
  }
  return enums.V1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat.values
          .firstWhereOrNull((e) =>
              e.value ==
              v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat) ??
      defaultValue;
}

String
    v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormatExplodedListToJson(
        List<enums.V1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat>?
            v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat) {
  return v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String>
    v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormatListToJson(
        List<enums.V1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat>?
            v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat) {
  if (v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat == null) {
    return [];
  }

  return v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat
      .map((e) => e.value!)
      .toList();
}

List<enums.V1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat>
    v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormatListFromJson(
  List? v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat, [
  List<enums.V1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat>?
      defaultValue,
]) {
  if (v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat == null) {
    return defaultValue ?? [];
  }

  return v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat
      .map((e) =>
          v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormatFromJson(
              e.toString()))
      .toList();
}

List<enums.V1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat>?
    v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormatNullableListFromJson(
  List? v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat, [
  List<enums.V1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat>?
      defaultValue,
]) {
  if (v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat == null) {
    return defaultValue;
  }

  return v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormat
      .map((e) =>
          v1TextToSpeechVoiceIdStreamWithTimestampsPostOutputFormatFromJson(
              e.toString()))
      .toList();
}

String? v1SpeechToSpeechVoiceIdPostOutputFormatNullableToJson(
    enums.V1SpeechToSpeechVoiceIdPostOutputFormat?
        v1SpeechToSpeechVoiceIdPostOutputFormat) {
  return v1SpeechToSpeechVoiceIdPostOutputFormat?.value;
}

String? v1SpeechToSpeechVoiceIdPostOutputFormatToJson(
    enums.V1SpeechToSpeechVoiceIdPostOutputFormat
        v1SpeechToSpeechVoiceIdPostOutputFormat) {
  return v1SpeechToSpeechVoiceIdPostOutputFormat.value;
}

enums.V1SpeechToSpeechVoiceIdPostOutputFormat
    v1SpeechToSpeechVoiceIdPostOutputFormatFromJson(
  Object? v1SpeechToSpeechVoiceIdPostOutputFormat, [
  enums.V1SpeechToSpeechVoiceIdPostOutputFormat? defaultValue,
]) {
  return enums.V1SpeechToSpeechVoiceIdPostOutputFormat.values.firstWhereOrNull(
          (e) => e.value == v1SpeechToSpeechVoiceIdPostOutputFormat) ??
      defaultValue ??
      enums.V1SpeechToSpeechVoiceIdPostOutputFormat.swaggerGeneratedUnknown;
}

enums.V1SpeechToSpeechVoiceIdPostOutputFormat?
    v1SpeechToSpeechVoiceIdPostOutputFormatNullableFromJson(
  Object? v1SpeechToSpeechVoiceIdPostOutputFormat, [
  enums.V1SpeechToSpeechVoiceIdPostOutputFormat? defaultValue,
]) {
  if (v1SpeechToSpeechVoiceIdPostOutputFormat == null) {
    return null;
  }
  return enums.V1SpeechToSpeechVoiceIdPostOutputFormat.values.firstWhereOrNull(
          (e) => e.value == v1SpeechToSpeechVoiceIdPostOutputFormat) ??
      defaultValue;
}

String v1SpeechToSpeechVoiceIdPostOutputFormatExplodedListToJson(
    List<enums.V1SpeechToSpeechVoiceIdPostOutputFormat>?
        v1SpeechToSpeechVoiceIdPostOutputFormat) {
  return v1SpeechToSpeechVoiceIdPostOutputFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> v1SpeechToSpeechVoiceIdPostOutputFormatListToJson(
    List<enums.V1SpeechToSpeechVoiceIdPostOutputFormat>?
        v1SpeechToSpeechVoiceIdPostOutputFormat) {
  if (v1SpeechToSpeechVoiceIdPostOutputFormat == null) {
    return [];
  }

  return v1SpeechToSpeechVoiceIdPostOutputFormat.map((e) => e.value!).toList();
}

List<enums.V1SpeechToSpeechVoiceIdPostOutputFormat>
    v1SpeechToSpeechVoiceIdPostOutputFormatListFromJson(
  List? v1SpeechToSpeechVoiceIdPostOutputFormat, [
  List<enums.V1SpeechToSpeechVoiceIdPostOutputFormat>? defaultValue,
]) {
  if (v1SpeechToSpeechVoiceIdPostOutputFormat == null) {
    return defaultValue ?? [];
  }

  return v1SpeechToSpeechVoiceIdPostOutputFormat
      .map((e) => v1SpeechToSpeechVoiceIdPostOutputFormatFromJson(e.toString()))
      .toList();
}

List<enums.V1SpeechToSpeechVoiceIdPostOutputFormat>?
    v1SpeechToSpeechVoiceIdPostOutputFormatNullableListFromJson(
  List? v1SpeechToSpeechVoiceIdPostOutputFormat, [
  List<enums.V1SpeechToSpeechVoiceIdPostOutputFormat>? defaultValue,
]) {
  if (v1SpeechToSpeechVoiceIdPostOutputFormat == null) {
    return defaultValue;
  }

  return v1SpeechToSpeechVoiceIdPostOutputFormat
      .map((e) => v1SpeechToSpeechVoiceIdPostOutputFormatFromJson(e.toString()))
      .toList();
}

String? v1SpeechToSpeechVoiceIdStreamPostOutputFormatNullableToJson(
    enums.V1SpeechToSpeechVoiceIdStreamPostOutputFormat?
        v1SpeechToSpeechVoiceIdStreamPostOutputFormat) {
  return v1SpeechToSpeechVoiceIdStreamPostOutputFormat?.value;
}

String? v1SpeechToSpeechVoiceIdStreamPostOutputFormatToJson(
    enums.V1SpeechToSpeechVoiceIdStreamPostOutputFormat
        v1SpeechToSpeechVoiceIdStreamPostOutputFormat) {
  return v1SpeechToSpeechVoiceIdStreamPostOutputFormat.value;
}

enums.V1SpeechToSpeechVoiceIdStreamPostOutputFormat
    v1SpeechToSpeechVoiceIdStreamPostOutputFormatFromJson(
  Object? v1SpeechToSpeechVoiceIdStreamPostOutputFormat, [
  enums.V1SpeechToSpeechVoiceIdStreamPostOutputFormat? defaultValue,
]) {
  return enums.V1SpeechToSpeechVoiceIdStreamPostOutputFormat.values
          .firstWhereOrNull((e) =>
              e.value == v1SpeechToSpeechVoiceIdStreamPostOutputFormat) ??
      defaultValue ??
      enums.V1SpeechToSpeechVoiceIdStreamPostOutputFormat
          .swaggerGeneratedUnknown;
}

enums.V1SpeechToSpeechVoiceIdStreamPostOutputFormat?
    v1SpeechToSpeechVoiceIdStreamPostOutputFormatNullableFromJson(
  Object? v1SpeechToSpeechVoiceIdStreamPostOutputFormat, [
  enums.V1SpeechToSpeechVoiceIdStreamPostOutputFormat? defaultValue,
]) {
  if (v1SpeechToSpeechVoiceIdStreamPostOutputFormat == null) {
    return null;
  }
  return enums.V1SpeechToSpeechVoiceIdStreamPostOutputFormat.values
          .firstWhereOrNull((e) =>
              e.value == v1SpeechToSpeechVoiceIdStreamPostOutputFormat) ??
      defaultValue;
}

String v1SpeechToSpeechVoiceIdStreamPostOutputFormatExplodedListToJson(
    List<enums.V1SpeechToSpeechVoiceIdStreamPostOutputFormat>?
        v1SpeechToSpeechVoiceIdStreamPostOutputFormat) {
  return v1SpeechToSpeechVoiceIdStreamPostOutputFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> v1SpeechToSpeechVoiceIdStreamPostOutputFormatListToJson(
    List<enums.V1SpeechToSpeechVoiceIdStreamPostOutputFormat>?
        v1SpeechToSpeechVoiceIdStreamPostOutputFormat) {
  if (v1SpeechToSpeechVoiceIdStreamPostOutputFormat == null) {
    return [];
  }

  return v1SpeechToSpeechVoiceIdStreamPostOutputFormat
      .map((e) => e.value!)
      .toList();
}

List<enums.V1SpeechToSpeechVoiceIdStreamPostOutputFormat>
    v1SpeechToSpeechVoiceIdStreamPostOutputFormatListFromJson(
  List? v1SpeechToSpeechVoiceIdStreamPostOutputFormat, [
  List<enums.V1SpeechToSpeechVoiceIdStreamPostOutputFormat>? defaultValue,
]) {
  if (v1SpeechToSpeechVoiceIdStreamPostOutputFormat == null) {
    return defaultValue ?? [];
  }

  return v1SpeechToSpeechVoiceIdStreamPostOutputFormat
      .map((e) =>
          v1SpeechToSpeechVoiceIdStreamPostOutputFormatFromJson(e.toString()))
      .toList();
}

List<enums.V1SpeechToSpeechVoiceIdStreamPostOutputFormat>?
    v1SpeechToSpeechVoiceIdStreamPostOutputFormatNullableListFromJson(
  List? v1SpeechToSpeechVoiceIdStreamPostOutputFormat, [
  List<enums.V1SpeechToSpeechVoiceIdStreamPostOutputFormat>? defaultValue,
]) {
  if (v1SpeechToSpeechVoiceIdStreamPostOutputFormat == null) {
    return defaultValue;
  }

  return v1SpeechToSpeechVoiceIdStreamPostOutputFormat
      .map((e) =>
          v1SpeechToSpeechVoiceIdStreamPostOutputFormatFromJson(e.toString()))
      .toList();
}

String? v1TextToVoiceCreatePreviewsPostOutputFormatNullableToJson(
    enums.V1TextToVoiceCreatePreviewsPostOutputFormat?
        v1TextToVoiceCreatePreviewsPostOutputFormat) {
  return v1TextToVoiceCreatePreviewsPostOutputFormat?.value;
}

String? v1TextToVoiceCreatePreviewsPostOutputFormatToJson(
    enums.V1TextToVoiceCreatePreviewsPostOutputFormat
        v1TextToVoiceCreatePreviewsPostOutputFormat) {
  return v1TextToVoiceCreatePreviewsPostOutputFormat.value;
}

enums.V1TextToVoiceCreatePreviewsPostOutputFormat
    v1TextToVoiceCreatePreviewsPostOutputFormatFromJson(
  Object? v1TextToVoiceCreatePreviewsPostOutputFormat, [
  enums.V1TextToVoiceCreatePreviewsPostOutputFormat? defaultValue,
]) {
  return enums.V1TextToVoiceCreatePreviewsPostOutputFormat.values
          .firstWhereOrNull(
              (e) => e.value == v1TextToVoiceCreatePreviewsPostOutputFormat) ??
      defaultValue ??
      enums.V1TextToVoiceCreatePreviewsPostOutputFormat.swaggerGeneratedUnknown;
}

enums.V1TextToVoiceCreatePreviewsPostOutputFormat?
    v1TextToVoiceCreatePreviewsPostOutputFormatNullableFromJson(
  Object? v1TextToVoiceCreatePreviewsPostOutputFormat, [
  enums.V1TextToVoiceCreatePreviewsPostOutputFormat? defaultValue,
]) {
  if (v1TextToVoiceCreatePreviewsPostOutputFormat == null) {
    return null;
  }
  return enums.V1TextToVoiceCreatePreviewsPostOutputFormat.values
          .firstWhereOrNull(
              (e) => e.value == v1TextToVoiceCreatePreviewsPostOutputFormat) ??
      defaultValue;
}

String v1TextToVoiceCreatePreviewsPostOutputFormatExplodedListToJson(
    List<enums.V1TextToVoiceCreatePreviewsPostOutputFormat>?
        v1TextToVoiceCreatePreviewsPostOutputFormat) {
  return v1TextToVoiceCreatePreviewsPostOutputFormat
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> v1TextToVoiceCreatePreviewsPostOutputFormatListToJson(
    List<enums.V1TextToVoiceCreatePreviewsPostOutputFormat>?
        v1TextToVoiceCreatePreviewsPostOutputFormat) {
  if (v1TextToVoiceCreatePreviewsPostOutputFormat == null) {
    return [];
  }

  return v1TextToVoiceCreatePreviewsPostOutputFormat
      .map((e) => e.value!)
      .toList();
}

List<enums.V1TextToVoiceCreatePreviewsPostOutputFormat>
    v1TextToVoiceCreatePreviewsPostOutputFormatListFromJson(
  List? v1TextToVoiceCreatePreviewsPostOutputFormat, [
  List<enums.V1TextToVoiceCreatePreviewsPostOutputFormat>? defaultValue,
]) {
  if (v1TextToVoiceCreatePreviewsPostOutputFormat == null) {
    return defaultValue ?? [];
  }

  return v1TextToVoiceCreatePreviewsPostOutputFormat
      .map((e) =>
          v1TextToVoiceCreatePreviewsPostOutputFormatFromJson(e.toString()))
      .toList();
}

List<enums.V1TextToVoiceCreatePreviewsPostOutputFormat>?
    v1TextToVoiceCreatePreviewsPostOutputFormatNullableListFromJson(
  List? v1TextToVoiceCreatePreviewsPostOutputFormat, [
  List<enums.V1TextToVoiceCreatePreviewsPostOutputFormat>? defaultValue,
]) {
  if (v1TextToVoiceCreatePreviewsPostOutputFormat == null) {
    return defaultValue;
  }

  return v1TextToVoiceCreatePreviewsPostOutputFormat
      .map((e) =>
          v1TextToVoiceCreatePreviewsPostOutputFormatFromJson(e.toString()))
      .toList();
}

String? v1DubbingDubbingIdTranscriptLanguageCodeGetFormatTypeNullableToJson(
    enums.V1DubbingDubbingIdTranscriptLanguageCodeGetFormatType?
        v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType) {
  return v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType?.value;
}

String? v1DubbingDubbingIdTranscriptLanguageCodeGetFormatTypeToJson(
    enums.V1DubbingDubbingIdTranscriptLanguageCodeGetFormatType
        v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType) {
  return v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType.value;
}

enums.V1DubbingDubbingIdTranscriptLanguageCodeGetFormatType
    v1DubbingDubbingIdTranscriptLanguageCodeGetFormatTypeFromJson(
  Object? v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType, [
  enums.V1DubbingDubbingIdTranscriptLanguageCodeGetFormatType? defaultValue,
]) {
  return enums.V1DubbingDubbingIdTranscriptLanguageCodeGetFormatType.values
          .firstWhereOrNull((e) =>
              e.value ==
              v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType) ??
      defaultValue ??
      enums.V1DubbingDubbingIdTranscriptLanguageCodeGetFormatType
          .swaggerGeneratedUnknown;
}

enums.V1DubbingDubbingIdTranscriptLanguageCodeGetFormatType?
    v1DubbingDubbingIdTranscriptLanguageCodeGetFormatTypeNullableFromJson(
  Object? v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType, [
  enums.V1DubbingDubbingIdTranscriptLanguageCodeGetFormatType? defaultValue,
]) {
  if (v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType == null) {
    return null;
  }
  return enums.V1DubbingDubbingIdTranscriptLanguageCodeGetFormatType.values
          .firstWhereOrNull((e) =>
              e.value ==
              v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType) ??
      defaultValue;
}

String v1DubbingDubbingIdTranscriptLanguageCodeGetFormatTypeExplodedListToJson(
    List<enums.V1DubbingDubbingIdTranscriptLanguageCodeGetFormatType>?
        v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType) {
  return v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType
          ?.map((e) => e.value!)
          .join(',') ??
      '';
}

List<String> v1DubbingDubbingIdTranscriptLanguageCodeGetFormatTypeListToJson(
    List<enums.V1DubbingDubbingIdTranscriptLanguageCodeGetFormatType>?
        v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType) {
  if (v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType == null) {
    return [];
  }

  return v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType
      .map((e) => e.value!)
      .toList();
}

List<enums.V1DubbingDubbingIdTranscriptLanguageCodeGetFormatType>
    v1DubbingDubbingIdTranscriptLanguageCodeGetFormatTypeListFromJson(
  List? v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType, [
  List<enums.V1DubbingDubbingIdTranscriptLanguageCodeGetFormatType>?
      defaultValue,
]) {
  if (v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType == null) {
    return defaultValue ?? [];
  }

  return v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType
      .map((e) => v1DubbingDubbingIdTranscriptLanguageCodeGetFormatTypeFromJson(
          e.toString()))
      .toList();
}

List<enums.V1DubbingDubbingIdTranscriptLanguageCodeGetFormatType>?
    v1DubbingDubbingIdTranscriptLanguageCodeGetFormatTypeNullableListFromJson(
  List? v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType, [
  List<enums.V1DubbingDubbingIdTranscriptLanguageCodeGetFormatType>?
      defaultValue,
]) {
  if (v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType == null) {
    return defaultValue;
  }

  return v1DubbingDubbingIdTranscriptLanguageCodeGetFormatType
      .map((e) => v1DubbingDubbingIdTranscriptLanguageCodeGetFormatTypeFromJson(
          e.toString()))
      .toList();
}

String? v1SharedVoicesGetCategoryNullableToJson(
    enums.V1SharedVoicesGetCategory? v1SharedVoicesGetCategory) {
  return v1SharedVoicesGetCategory?.value;
}

String? v1SharedVoicesGetCategoryToJson(
    enums.V1SharedVoicesGetCategory v1SharedVoicesGetCategory) {
  return v1SharedVoicesGetCategory.value;
}

enums.V1SharedVoicesGetCategory v1SharedVoicesGetCategoryFromJson(
  Object? v1SharedVoicesGetCategory, [
  enums.V1SharedVoicesGetCategory? defaultValue,
]) {
  return enums.V1SharedVoicesGetCategory.values
          .firstWhereOrNull((e) => e.value == v1SharedVoicesGetCategory) ??
      defaultValue ??
      enums.V1SharedVoicesGetCategory.swaggerGeneratedUnknown;
}

enums.V1SharedVoicesGetCategory? v1SharedVoicesGetCategoryNullableFromJson(
  Object? v1SharedVoicesGetCategory, [
  enums.V1SharedVoicesGetCategory? defaultValue,
]) {
  if (v1SharedVoicesGetCategory == null) {
    return null;
  }
  return enums.V1SharedVoicesGetCategory.values
          .firstWhereOrNull((e) => e.value == v1SharedVoicesGetCategory) ??
      defaultValue;
}

String v1SharedVoicesGetCategoryExplodedListToJson(
    List<enums.V1SharedVoicesGetCategory>? v1SharedVoicesGetCategory) {
  return v1SharedVoicesGetCategory?.map((e) => e.value!).join(',') ?? '';
}

List<String> v1SharedVoicesGetCategoryListToJson(
    List<enums.V1SharedVoicesGetCategory>? v1SharedVoicesGetCategory) {
  if (v1SharedVoicesGetCategory == null) {
    return [];
  }

  return v1SharedVoicesGetCategory.map((e) => e.value!).toList();
}

List<enums.V1SharedVoicesGetCategory> v1SharedVoicesGetCategoryListFromJson(
  List? v1SharedVoicesGetCategory, [
  List<enums.V1SharedVoicesGetCategory>? defaultValue,
]) {
  if (v1SharedVoicesGetCategory == null) {
    return defaultValue ?? [];
  }

  return v1SharedVoicesGetCategory
      .map((e) => v1SharedVoicesGetCategoryFromJson(e.toString()))
      .toList();
}

List<enums.V1SharedVoicesGetCategory>?
    v1SharedVoicesGetCategoryNullableListFromJson(
  List? v1SharedVoicesGetCategory, [
  List<enums.V1SharedVoicesGetCategory>? defaultValue,
]) {
  if (v1SharedVoicesGetCategory == null) {
    return defaultValue;
  }

  return v1SharedVoicesGetCategory
      .map((e) => v1SharedVoicesGetCategoryFromJson(e.toString()))
      .toList();
}

// ignore: unused_element
String? _dateToJson(DateTime? date) {
  if (date == null) {
    return null;
  }

  final year = date.year.toString();
  final month = date.month < 10 ? '0${date.month}' : date.month.toString();
  final day = date.day < 10 ? '0${date.day}' : date.day.toString();

  return '$year-$month-$day';
}

class Wrapped<T> {
  final T value;
  const Wrapped.value(this.value);
}
